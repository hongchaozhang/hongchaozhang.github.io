<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Zhang Hongchao]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2015-10-09T10:51:17+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[经典算法智力题]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/09/14/brainteasers-and-puzzles/"/>
    <updated>2015-09-14T20:46:22+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/09/14/brainteasers-and-puzzles</id>
    <content type="html"><![CDATA[<ol>
<li><a href="#1">海盗分金子</a></li>
<li><a href="#2">飞机加油问题</a></li>
<li><a href="#3">蚂蚁爬杆</a></li>
<li><a href="#4">平面上N个点，每两个点都确定一条直线，求出斜率最大的那条直线所通过的两个点（斜率不存在的情况不考虑）。时间效率越高越好。</a></li>
<li><a href="#5">Find the closest pair from a sorted array</a></li>
<li><a href="#6">Building Bridge</a></li>
<li><a href="#7">打印n分之一的前k位小数</a></li>
<li><a href="#8">Marketing Size</a></li>
<li><a href="#9">赛马问题</a></li>
<li><a href="#10">火车运煤问题</a></li>
</ol>


<!-- more -->


<h3><a name="1"></a>海盗分金子</h3>

<p>参考<a href="http://lucky-harry.blog.163.com/blog/static/201270702007101634121760/">海盗分金子的游戏</a></p>

<p>数学的逻辑有时会导致看来十分怪异的结论。一般的规则是，如果逻辑推理没有漏洞，那么结论就必定站得住脚，即使它与你的直觉矛盾。</p>

<h4>题目</h4>

<p>10名海盗抢得了窖藏的100块金子，并打算瓜分这些战利品。这是一些讲民主的海盗（当然是他们自己特有的民主），他们的习惯是按下面的方式进行分配：最厉害的一名海盗提出分配方案，然后所有的海盗（包括提出方案者本人）就此方案进行表决。如果50%或更多的海盗赞同此方案，此方案就获得通过并据此分配战利品。否则提出方案的海盗将被扔到海里，然后下提名最厉害的海盗又重复上述过程。（所有的海盗都乐于看到他们的一位同伙被扔进海里，不过，如果让他们选择的话，他们还是宁可得一笔现金。他们当然也不愿意自己被扔到海里。所有的海盗都是有理性的，而且知道其他的海盗也是有理性的。此外，没有两名海盗是同等厉害的——这些海盗按照完全由上到下的等级排好了座次，并且每个人都清楚自己和其他所有人的等级。这些金块不能再分，也不允许几名海盗共有金块，因为任何海盗都不相信他的同伙会遵守关于共享金块的安排。这是一伙每人都只为自己打算的海盗。）最凶的一名海盗应当提出什么样的分配方案才能使他获得最多的金子呢？</p>

<h4>分析</h4>

<p>为方便起见，我们按照这些海盗的怯懦程度来给他们编号。最怯懦的海盗为1号海盗，次怯懦的海盗为2号海盗，如此类推。这样最厉害的海盗就应当得到最大的编号，而方案的提出就将倒过来从上至下地进行。</p>

<p>分析所有这类策略游戏的奥妙就在于应当从结尾出发倒推回去。游戏结束时，你容易知道何种决策有利而何种决策不利。确定了这一点后，你就可以把它用到倒数第2次决策上，如此类推。如果从游戏的开头出发进行分析，那是走不了多远的。其原因在于，所有的战略决策都是要确定：“如果我这样做，那么下一个人会怎样做？”</p>

<p>因此在你以下海盗所做的决定对你来说是重要的，而在你之前的海盗所做的决定并不重要，因为你反正对这些决定也无能为力了。</p>

<p>记住了这一点，就可以知道我们的出发点应当是游戏进行到只剩两名海盗——即1号和2号——的时候。这时最厉害的海盗是2号，而他的最佳分配方案是一目了然的：100块金子全归他一人所有，1号海盗什么也得不到。由于他自己肯定为这个方案投赞成票，这样就占了总数的50%，因此方案获得通过。</p>

<p>现在加上3号海盗。1号海盗知道，如果3号的方案被否决，那么最后将只剩2个海盗，而1号将肯定一无所获——此外，3号也明白1号了解这一形势。因此，只要3号的分配方案给1号一点甜头使他不至于空手而归，那么不论3号提出什么样的分配方案，1号都将投赞成票。因此3号需要分出尽可能少的一点金子来贿赂1号海盗，这样就有了下面的分配方案： 3号海盗分得99块金子，2号海盗一无所获，1号海盗得1块金子。</p>

<p>4号海盗的策略也差不多。他需要有50%的支持票，因此同3号一样也需再找一人做同党。他可以给同党的最低贿赂是1块金子，而他可以用这块金子来收买2号海盗。因为如果4号被否决而3号得以通过，则2号将一文不名。因此，4号的分配方案应是：99块金子归自己，3号一块也得不到，2号得1块金子，1号也是一块也得不到。</p>

<p>5号海盗的策略稍有不同。他需要收买另两名海盗，因此至少得用2块金子来贿赂，才能使自己的方案得到采纳。他的分配方案应该是：98块金子归自己，1块金子给3号，1块金子给1号。</p>

<p>这一分析过程可以照着上述思路继续进行下去。每个分配方案都是唯一确定的，它可以使提出该方案的海盗获得尽可能多的金子，同时又保证该方案肯定能通过。照这一模式进行下去，10号海盗提出的方案将是96块金子归他所有，其他编号为偶数的海盗各得1块金子，而编号为奇数的海盗则什么也得不到。这就解决了10名海盗的分配难题。</p>

<p>分配方案用表格表示如下：</p>

<table>
<thead>
<tr>
<th>被分配人</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>分配人</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>100</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>100</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>0</td>
<td>99</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>99</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>98</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>98</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>97</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>97</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>96</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>96</td>
</tr>
</tbody>
</table>


<h4>延伸</h4>

<p>Omohundro的贡献是他把这一问题扩大到有500名海盗的情形，即500名海盗瓜分100块金子。显然，类似的规律依然成立——至少是在一定范围内成立。事实上，前面所述的规律直到第200号海盗都成立。 200号海盗的方案将是：从1到199号的所有奇数号的海盗都将一无所获，而从2到198号的所有偶数号海盗将各得1块金子，剩下的1块金子归200号海盗自己所有。</p>

<p>乍看起来，这一论证方法到200号之后将不再适用了，因为201号拿不出更多的金子来收买其他海盗。但是即使分不到金子，201号至少还希望自己不会被扔进海里，因此他可以这样分配：给1到199号的所有奇数号海盗每人1块金子，自己一块也不要。</p>

<p>202号海盗同样别无选择，只能一块金子都不要了——他必须把这100块金子全部用来收买100名海盗，而且这100名海盗还必须是那些按照201号方案将一无所获的人。由于这样的海盗有101名，因此202号的方案将不再是唯一的——贿赂方案有101种。</p>

<blockquote><p>202号海盗是第一个有多种最优方案的人。</p></blockquote>

<p>203号海盗必须获得102张赞成票，但他显然没有足够的金子去收买101名同伙。因此，无论提出什么样的分配方案，他都注定会被扔到海里去喂鱼。不过，尽管203号命中注定死路一条，但并不是说他在游戏进程中不起任何作用。相反，204号现在知道，203号为了能保住性命，就必须避免由他自己来提出分配方案这么一种局面，所以无论204号海盗提出什么样的方案，203号都一定会投赞成票。这样204号海盗总算侥幸拣到一条命：他可以得到他自己的1票、203号的1票、以及另外100名收买的海盗的赞成票，刚好达到保命所需的50%。获得金子的海盗，必属于根据202号方案肯定将一无所获的那101名海盗之列。</p>

<p>205号海盗的命运又如何呢？他可没有这样走运了。他不能指望203号和204号支持他的方案，因为如果他们投票反对205号方案，就可以幸灾乐祸地看到205号被扔到海里去喂鱼，而他们自己的性命却仍然能够保全。这样，无论205号海盗提出什么方案都必死无疑。206号海盗也是如此——他肯定可以得到205号的支持，但这不足以救他一命。类似地，207号海盗需要104张赞成票——除了他收买的100张赞成票以及他自己的1张赞成票之外，他还需3张赞成票才能免于一死。他可以获得205号和206号的支持，但还差一张票却是无论如何也弄不到了，因此207号海盗的命运也是下海喂鱼。</p>

<p>208号又时来运转了。他需要104张赞成票，而205、206、207号都会支持他，加上他自己一票及收买的100票，他得以过关保命。获得他贿赂的必属于那些根据204号方案肯定将一无所获的人（候选人包括2到200号中所有偶数号的海盗、以及201、203、204号）。</p>

<p>现在可以看出一条新的、此后将一直有效的规律：那些方案能过关的海盗（他们的分配方案全都是把金子用来收买100名同伙而自己一点都得不到）相隔的距离越来越远，而在他们之间的海盗则无论提什么样的方案都会被扔进海里——因此为了保命，他们必会投票支持比他们厉害的海盗提出的任何分配方案。得以避免葬身鱼腹的海盗包括201、202、204、208、216、232、264、328、456号，即其号码等于200加2的某一方幂的海盗。</p>

<blockquote><p>对于大于200号的海盗，均无法获得任何黄金，而且只有200加2的整数次幂的海盗可以分金子并且免于一死。</p></blockquote>

<p>现在我们来看看哪些海盗是获得贿赂的幸运儿。分配贿赂的方法是不唯一的，其中一种方法是让201号海盗把贿赂分给1到199号的所有奇数编号的海盗，让202号分给2到200号的所有偶数编号的海盗，然后是让204号贿赂奇数编号的海盗，208号贿赂偶数编号的海盗，如此类推，也就是轮流贿赂奇数编号和偶数编号的海盗。</p>

<h4>结论</h4>

<p>当500名海盗运用最优策略来瓜分金子时，头44名海盗必死无疑，而456号海盗则给从1到199号中所有奇数编号的海盗每人分1块金子，问题就解决了。由于这些海盗所实行的那种民主制度，他们的事情就搞成了最厉害的一批海盗多半都是下海喂鱼，不过有时他们也会觉得自己很幸运——虽然分不到抢来的金子，但总可以免于一死。只有最怯懦的200名海盗有可能分得一份脏物，而他们之中又只有一半的人能真正得到一块金子，的确是<strong>怯懦者继承财富</strong>。</p>

<h3><a name="2"></a>飞机加油问题</h3>

<p>参考<a href="http://blog.csdn.net/athenaer/article/details/8612536">飞机加油智力题</a></p>

<h4>Question</h4>

<p>On Bagshot Island, there is an airport. The airport is the home base of an unlimited number of identical airplanes. Each airplane has a fuel capacity to allow it to fly exactly &frac12; way around the world, along a great circle. The planes have the ability to refuel in flight without loss of speed or spillage of fuel. Though the fuel is unlimited, the island is the only source of fuel.
What is the fewest number of aircraft necessary to get one plane all the way around the world assuming that all of the aircraft must return safely to the airport? How did you get to your answer?</p>

<p>Notes:</p>

<ol>
<li>Each airplane must depart and return to the same airport, and that is the only airport they can land and refuel on ground.</li>
<li>Each airplane must have enough fuel to return to airport.</li>
<li>The time and fuel consumption of refueling can be ignored. (so we can also assume that one airplane can refuel more than one airplanes in air at the same time.)</li>
<li>The amount of fuel airplanes carrying can be zero as long as the other airplane is refueling these airplanes. What is the fewest number of airplanes and number of tanks of fuel needed to accomplish this work? (we only need airplane to go around the world)</li>
</ol>


<h4>Answer</h4>

<p>The fewest number of aircraft is 3, and the times of taking off is 5!
Imagine 3 aircraft (A, B and C). A is going to fly round the world. All three aircraft start at the same time in the same direction. After 1/8 of the circumference, B passes &frac14; of its fuel to C, &frac14; of its fuel to A, and returns home. C continues to fly alongside A until they are &frac14; of the distance around the world. At this point C completely fills the tank of A with &frac14; of its full fuel, which is now able to fly to a point &frac34; of the way around the world. C has now only &frac12; of its full fuel capacity left, exactly enough to get back to the home base.</p>

<p>When C gets to the base, gets fully refueled and takes off in the other direction. C will meet A in &frac34; of the distance. Now A has no fuel while C has half of its full fuel. Let C fill the tank of A with &frac14; of its full fuel, and B takes off from base with full fuel. B will meet A and C in 7/8 of the distance. Currently, A and C has no fuel, while B has &frac34; of its full fuel. Let B fill A with its &frac14; of its full fuel and fills C with &frac14; of its full fuel. And all the three planes can get back safely to the base.</p>

<h4>问题</h4>

<p>每个飞机只有一个油箱，飞机之间可以相互加油，注意是相互，没有加油机，一箱油可供一架飞机绕地球飞半圈。    <br/>
为使至少一架飞机绕地球一圈回到起飞时的飞机场，至少需要出动几架飞机？<br/>
A:所有飞机从同一机场起飞，而且必须安全返回机场，不允许中途降落，中间没有飞机场
B:所有飞机从同一机场,同一方向起飞，而且必须安全返回机场，不允许中途降落，中间没有飞机场</p>

<h4>答案</h4>

<p>三架飞机，五架次。</p>

<blockquote><p>提示：刚开始三架同时飞，另一方向一架一架次去接。</p></blockquote>

<h3><a name="3"></a>蚂蚁爬杆</h3>

<h4>问题</h4>

<p>有一根30厘米的细木杆，在第3厘米、7厘米、11厘米、17厘米、23厘米这五个位置上各有一只蚂蚁。木杆很细，同时只能通过一只蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。求所有蚂蚁都离开木杆的最小时间和最大时间。</p>

<blockquote><p>提示：问题等价于蚂蚁之间是透明的，可以相互穿过不阻挡。</p></blockquote>

<h3><a name="4"></a>平面上N个点，每两个点都确定一条直线，求出斜率最大的那条直线所通过的两个点（斜率不存在的情况不考虑）。时间效率越高越好。</h3>

<p>按照一般的方法，逐个求斜率比较，O(n<sup>2</sup>)可完成。有没有更快的方法？有。</p>

<p>对所有的点按x坐标排序，然后只比较相邻两点的斜率即可。复杂度O(nlgn)。</p>

<h3><a name="5"></a>Given a sorted array and a number x, find the pair in array whose sum is closest to x</h3>

<p>reference <a href="http://geeksquiz.com/given-sorted-array-number-x-find-pair-array-whose-sum-closest-x/">Given a sorted array and a number x, find the pair in array whose sum is closest to x</a></p>

<p>A similar question is <a href="http://www.geeksforgeeks.org/given-two-sorted-arrays-number-x-find-pair-whose-sum-closest-x/">Find the closest pair from two sorted arrays</a>.</p>

<h4>Question</h4>

<p>Given a sorted array and a number x, find a pair in array whose sum is closest to x.
Examples:
<div class="highlight"><pre><code class="language-text" data-lang="text">Input: arr[] = {10, 22, 28, 29, 30, 40}, x = 54
Output: 22 and 30&lt;/p&gt;

&lt;p&gt;Input: arr[] = {1, 3, 4, 7, 10}, x = 15
Output: 4 and 10</code></pre></div></p>

<h4>Answer</h4>

<p>An efficient solution can find the pair in <code>O(n)</code> time. Following is detailed algorithm.</p>

<ol>
<li>Initialize a variable <code>diff</code> as infinite (<code>diff</code> is used to store the
difference between pair and <code>x</code>).  We need to find the minimum <code>diff</code>.</li>
<li>Initialize two index variables <code>l</code> and <code>r</code> in the given sorted array.

<ol>
<li>Initialize first to the leftmost index:  <code>l = 0</code></li>
<li>Initialize second  the rightmost index:  <code>r = n-1</code></li>
</ol>
</li>
<li>Loop while <code>l &lt; r</code>.

<ol>
<li>If  <code>abs(arr[l] + arr[r] - sum) &lt; diff</code>  then update diff and result</li>
<li>Else if(<code>arr[l] + arr[r] &lt;  sum</code> )  then <code>l++</code></li>
<li>Else <code>r--</code></li>
</ol>
</li>
</ol>


<blockquote><p>Similar question: 给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数。时间复杂度O(n),空间复杂度O(1)。</p></blockquote>

<h3><a name="6"></a>Building Bridge</h3>

<p>A and B live in different sides of a straight river, whose width is <code>w</code>. A and B want to build a bridge over the river, so that they can visit each other. <strong>Question:</strong> where to build the bridge so that the walking distance is the shortest between A and B?
<strong>Note:</strong> The bridge must be perpendicular (vertical) to the river.</p>

<h3><a name="7"></a>打印n分之一的前k位小数</h3>

<h4>Question</h4>

<p>Given a positive integer n, print first k digits after point in value of 1/n. Your program should avoid overflow and floating point arithmetic.</p>

<p>Examples:</p>

<p><div class="highlight"><pre><code class="language-text" data-lang="text">Input:   n = 3, k = 3
Output:  333
Input:   n = 50, k = 4
Output:  0200</code></pre></div></p>

<h4>Answer</h4>

<p><div class="highlight"><pre><code class="language-java" data-lang="java"><span class="lineno"> 1</span> <span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Function to print first k digits after dot in value</span>
<span class="lineno"> 4</span> <span class="c1">// of 1/n. n is assumed to be a positive integer.</span>
<span class="lineno"> 5</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span>
<span class="lineno"> 6</span> <span class="o">{</span>
<span class="lineno"> 7</span>     <span class="kt">int</span> <span class="n">rem</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// Initialize remainder&lt;/p&gt;</span>
<span class="lineno"> 8</span> 
<span class="lineno"> 9</span> <span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// Run a loop k times to print k digits</span>
<span class="lineno">10</span> <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">k</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
<span class="lineno">11</span> <span class="o">{</span>
<span class="lineno">12</span>     <span class="c1">// The next digit can always be obtained as</span>
<span class="lineno">13</span>     <span class="c1">// doing (10*rem)/10</span>
<span class="lineno">14</span>     <span class="n">cout</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="o">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">rem</span><span class="o">)</span> <span class="o">/</span> <span class="n">n</span><span class="o">;</span>
<span class="lineno">15</span> 
<span class="lineno">16</span>     <span class="c1">// Update remainder</span>
<span class="lineno">17</span>     <span class="n">rem</span> <span class="o">=</span> <span class="o">(</span><span class="mi">10</span><span class="o">*</span><span class="n">rem</span><span class="o">)</span> <span class="o">%</span> <span class="n">n</span><span class="o">;</span>
<span class="lineno">18</span> <span class="o">}</span>
<span class="lineno">19</span> <span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
<span class="lineno">20</span> 
<span class="lineno">21</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">22</span> 
<span class="lineno">23</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<h2><a name="8"></a>Marketing Size</h2>

<p>请估算：</p>

<ul>
<li>某城市市目前的出租车数量（TX某年面试题）；</li>
<li>上周在某城市有多少个煎饼被吃掉?</li>
<li>某城市的酒店的数量？</li>
<li>波音747能装下多少个乒乓球?</li>
<li>中国人一年用多少草本洗发水?</li>
</ul>


<blockquote><p>Manily, we have two kinds of methods: <strong>up-to-down</strong> and <strong>bottome-to-up</strong>.</p></blockquote>

<h2><a name="9"></a>赛马问题</h2>

<p><a href="http://blog.csdn.net/tianmohust/article/details/6839524">关于选牛和选马的问题</a></p>

<h2><a name="10"></a>火车运煤问题</h2>

<p><a href="http://www.cnblogs.com/liuzhi/p/3922311.html">火车运煤问题</a></p>

<p><strong>Question:</strong></p>

<p>你是山西的一个煤老板，你在矿区开采了有3000吨煤需要运送到市场上去卖，从你的矿区到市场有1000公里，你手里有一列烧煤的火车，这个火车最多只能装1000吨煤，且其能耗比较大——每一公里需要耗一吨煤。请问，</p>

<ul>
<li>作为一个懂编程的煤老板的你，你会怎么运送才能运最多的煤到集市？</li>
<li>假设矿区共有1000n（n是正整数）吨煤，是否可能运送多于1000吨的煤到达目的地？如果不可以，说明理由，如果可以，试求最小的n值。</li>
</ul>


<p><strong>Analytics：</strong></p>

<p>最优运送方案如下：</p>

<ul>
<li>将1000n吨煤运送到全程的1/(2n-1)处，此时还有1000(n-1)吨煤。</li>
<li>将1000(n-1)吨煤再往前运送全程的1/(2n-3)，即全程的1/(2n-1)+1/(2n-3)处，此时还剩1000(n-2)吨煤。</li>
<li>&hellip;</li>
<li>将2000吨煤再往前运送全程的1/3，即全程的1/(2n-1)+1/(2n-3)+&hellip;+1/3处，此时还剩1000吨煤。</li>
<li>将1000吨煤运送到目的地，此时还剩1000{1-[1/(2n-1)+1/(2n-3)+&hellip;+1/3]}吨煤。</li>
</ul>


<p>Note：</p>

<ul>
<li>当n=7时，1/3+1/5+1/7+&hellip;+1/13 = 0.96;</li>
<li>当n=8时，1/3+1/5+1/7+&hellip;+1/13+1/15 = 1.02;</li>
</ul>


<p>所以，当n=8时，可以将多于1000吨的煤运送到目的地。火车可以将2000吨煤运送到1000[1/5+1/7+&hellip;+1/13+1/15]公里处，即688公里处，最终能将2000-(1000-688)*3吨煤，即1065吨煤，运送到目的地。</p>
]]></content>
  </entry>
  
</feed>
