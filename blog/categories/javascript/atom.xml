<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2018-01-30T18:08:12+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Javascript Interview Questions]]></title>
    <link href="http://hongchaozhang.github.io/blog/2018/01/30/javascript-interview-questions/"/>
    <updated>2018-01-30T17:58:11+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2018/01/30/javascript-interview-questions</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>use strict</h2>

<p>What are the benefits of including 'use strict' at the beginning of a JavaScript source file?
在严格模式(&lsquo;use strict&rsquo;)下进行 JavaScript 开发有神马好处？</p>

<ol>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ol>


<h2>请指出以下代码的区别：function Person(){}、var person = Person()、var person = new Person()？</h2>

<h2>解释 function foo() {} 与 var foo = function() {} 用法的区别</h2>

<p>Refer to <a href="https://libuchao.com/2012/06/25/function-declaration-vs-function-expression">函数声明 VS 函数表达式</a>.</p>

<pre><code class="javascript">// 方法一：函数声明
function foo() {}

// 方法二：函数表达式
var foo = function () {};
</code></pre>

<p>方法一和方法二都创建了一个函数，且命名为 foo，但是二者还是有区别的。JavaScript 解释器中存在一种变量声明被<strong>提升</strong>（hoisting）的机制，也就是说变量（函数）的声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被<strong>提升</strong>至最前面。</p>

<p>例如以下代码段：</p>

<pre><code class="javascript">alert(foo); // function foo() {}
alert(bar); // undefined
function foo() {}
var bar = function bar_fn() {};
alert(foo); // function foo() {}
alert(bar); // function bar_fn() {}
</code></pre>

<p>JavaScript引擎执行以上代码的顺序可能是这样的：</p>

<ol>
<li>创建变量 foo 和 bar，并将它们都赋值为 undefined。</li>
<li>创建函数 foo 的函数体，并将其赋值给变量 foo。</li>
<li>执行前面的两个 alert。</li>
<li>创建函数 bar_fn，并将其赋值给 bar。</li>
<li>执行后面的两个 alert。</li>
</ol>


<h2>setTimeout() and  closure</h2>

<p>Refer to <a href="http://web.jobbole.com/90954/">80% 应聘者都不及格的 JS 面试题</a>.</p>

<ol>
<li>基本问题：</li>
</ol>


<p>下面程序的输出是什么？</p>

<pre><code class="javascript">for (var i = 0; i &lt; 5; i++) {
    setTimeout(function() {
        console.log(i);
    }, 1000);
}
 
console.log(i);
</code></pre>

<p>答案：5 -> 5,5,5,5,5，即第1个5直接输出，1秒之后，输出5个5；</p>

<ol>
<li>拓展</li>
</ol>


<p>如果期望代码的输出变成：5 -> 0,1,2,3,4，该怎么改造代码？请用闭包实现。</p>

<pre><code class="javascript">for (var i = 0; i &lt; 5; i++) {
    (function(j) {  // j = i
        setTimeout(function() {
            console.log(j);
        }, 1000);
    })(i);
}
 
console.log(i);
</code></pre>

<h2>reflow(回流) and repaint(重绘)</h2>

<p>引起reflow的原因，如何避免reflow？Refer to <a href="http://harttle.land/2015/08/11/reflow-repaint.html">减少页面回流与重绘（Reflow &amp; Repaint）</a>.</p>

<p>offsetWidth引起reflow</p>

<h2>NaN</h2>

<p><strong>问题</strong></p>

<p>神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?</p>

<p><strong>答案</strong></p>

<p>NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，其类型是 <code>Number</code>，可以通过 <code>isNaN(param)</code> 来判断一个值是否是 NaN：</p>

<pre><code class="javascript">console.log(isNaN(NaN)); //true
console.log(isNaN(23)); //false
console.log(isNaN('ds')); //true
console.log(isNaN('32131sdasd')); //true
console.log(NaN === NaN); //false
console.log(NaN === undefined); //false
console.log(undefined === undefined); //false
console.log(typeof NaN); //number
console.log(Object.prototype.toString.call(NaN)); //[object Number]
</code></pre>

<h2>Hybrid Mobile性能问题，交互问题</h2>

<h2>数组的插入</h2>

<p>对数组进行下面两个操作，时间和空间复杂度分别是多少？
- inset(at index: Int) 时间复杂度O(n)
- append(element) 时间复杂度O(1)</p>

<p>参考Swift关于Array.append方法效率的说明<a href="https://developer.apple.com/documentation/swift/array">Growing the Size of an Array</a></p>

<p>Every array reserves a specific amount of memory to hold its contents. When you add elements to an array and that array begins to exceed its reserved capacity, the array allocates a larger region of memory and copies its elements into the new storage. The new storage is a multiple of the old storage’s size. This exponential growth strategy means that appending an element happens in constant time, averaging the performance of many append operations. Append operations that trigger reallocation have a performance cost, but they occur less and less often as the array grows larger.</p>

<p>If you know approximately how many elements you will need to store, use the reserveCapacity(_:) method before appending to the array to avoid intermediate reallocations. Use the capacity and count properties to determine how many more elements the array can store without allocating larger storage.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Caution Javascript Closure in Loop]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/05/09/caution-javascript-closure-in-loop/"/>
    <updated>2015-05-09T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/05/09/caution-javascript-closure-in-loop</id>
    <content type="html"><![CDATA[<h3>Object</h3>

<p>Define a function <span style="background-color:yellow;"><em>addTimer</em></span>, to log executed time for all function-type property of an object</p>

<h3>Definition 1</h3>

<!-- more -->


<h4>Code:</h4>

<pre><code class="javascript">var addTimer = function (widget) {
    var prop;
    for (prop in widget) {
        if (typeof widget[prop] === 'function') {
            var backupFunc = widget[prop];
            // the same problem with the following code
            //backupFunc = (function () {
            //    return widget[prop];
            //})();

            // try a deep copy here to make bakcupFunc not changed with prop
            widget[prop] = function () {
                console.time("from timer " + prop);
                backupFunc.apply(this, arguments);
                console.timeEnd("from timer " + prop);
            };
            // the same problem with the following code
            //widget[prop] = (function () {
            //    return function () {
            //        console.time(prop);
            //        backupFunc.apply(this, arguments);
            //        console.timeEnd(prop);
            //    };
            //})();
        }
    }
}
</code></pre>

<h4>Problem</h4>

<p>All function type property in widget will call the last function type property</p>

<h3>Definition 2</h3>

<p>Since there is no block scope in JavaScript - only <strong>function scope</strong> - by wrapping the function creation in a new function, you ensure that the value of <code>prop</code> remains as you intended.</p>

<h4>Code:</h4>

<pre><code class="javascript">var addTimer = function (widget) {
    var prop;
    var getFuncWithTimer = function (prop) {
        return function () {
            console.time("from timer " + prop);
            widget[prop].apply(this, arguments);
            console.timeEnd("from timer " + prop);
        };
    };
    for (prop in widget) {
        if (typeof widget[prop] === 'function') {
            widget[prop] = getFuncWithTimer(prop);
        }
    }
};
</code></pre>

<h4>Problem</h4>

<p>exceed maximum call stack</p>

<h3>Definition 3</h3>

<h4>Code:</h4>

<pre><code class="javascript">var addTimer = function (widget) {
    var prop;
    var getFuncWithTimer = function (prop) {
        var backupFunc = widget[prop];
        return function () {
            console.time("from timer " + prop);
            backupFunc.apply(this, arguments);
            console.timeEnd("from timer " + prop);
        };
    };
    for (prop in widget) {
        if (typeof widget[prop] === 'function') {
            widget[prop] = getFuncWithTimer(prop);
        }
    }
};
</code></pre>

<h4>Problem</h4>

<p>All function with returned value can not work</p>

<h3>Final Definition</h3>

<h4>Code:</h4>

<pre><code class="javascript">var addTimer = function (widget) {
    var prop;
    var getFuncWithTimer = function (prop) {
        var backupFunc = widget[prop];
        return function () {
            console.time("from timer " + prop);
            var ret = backupFunc.apply(this, arguments);
            console.timeEnd("from timer " + prop);
            return ret;
        };
    };
    for (prop in widget) {
        if (typeof widget[prop] === 'function') {
            widget[prop] = getFuncWithTimer(prop);
        }
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Add a Clone Function to Function?]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/05/09/How-to-Add-a-Clone-function-to-Function/"/>
    <updated>2015-05-09T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/05/09/How-to-Add-a-Clone-function-to-Function</id>
    <content type="html"><![CDATA[<pre><code class="javascript">Function.prototype.clone = function() {
    var that = this;
    var temp = function temporary() { return that.apply(this, arguments); };
    for( key in this ) {
        temp[key] = this[key];
    }
    return temp;
};
</code></pre>
]]></content>
  </entry>
  
</feed>
