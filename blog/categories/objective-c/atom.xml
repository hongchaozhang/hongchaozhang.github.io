<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-c | Zhang Hongchao]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2015-10-09T10:51:17+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Singleton]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/09/07/Singleton/"/>
    <updated>2015-09-07T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/09/07/Singleton</id>
    <content type="html"><![CDATA[<h2>Singleton implementation</h2>

<p><a href="http://cocoa.venj.me/blog/singleton-in-objc/">Objective-C中单例模式的实现</a></p>

<p><a href="http://www.makebetterthings.com/iphone/singleton-design-pattern-for-objective-c/">Singleton Design Pattern for Objective-C</a></p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">sharedInstance</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">once</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">id</span> <span class="n">sharedInstance</span><span class="p">;</span>
    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">once</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">sharedInstance</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="n">sharedInstance</span><span class="p">;</span>
<span class="p">}</span></code></pre></div></p>

<h2>Avoid abusing singleton</h2>

<p><a href="http://objccn.io/issue-13-2/">避免滥用单例</a></p>

<p>Singleton introduces globla variable, which may lead to coupling of far-away components.</p>

<p>Note the life circle of an object, to see if it confirm to &ldquo;will always has one instance&rdquo;. If NO, we can not use Singleton here.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC and GC]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/08/14/ARC-and-Memory-Leak/"/>
    <updated>2015-08-14T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/08/14/ARC-and-Memory-Leak</id>
    <content type="html"><![CDATA[<p>The following post mainly comes from <a href="http://docs.elementscompiler.com/Concepts/ARCvsGC/">ARC vs GC</a> and <a href="http://lists.apple.com/archives/objc-language/2011/Jun/msg00013.html">Re: ARC replacing GC? from Chris Lattner&rsquo;s mail list</a>.</p>

<p>Also reference some posts on memory leak, including <a href="http://stackoverflow.com/questions/6260256/what-kind-of-leaks-does-automatic-reference-counting-in-objective-c-not-prevent/6388601#6388601">What kind of leaks does automatic reference counting in Objective-C not prevent or minimize?</a> and <a href="http://www.reigndesign.com/blog/debugging-retain-cycles-in-objective-c-four-likely-culprits/">Debugging retain cycles in Objective-C: four likely culprits</a>.</p>

<!-- more -->


<h2>Garbage Collection</h2>

<p>Garbage Collection (or GC for short) is the technique used for life cycle management on the .NET and Java platforms. The way GC works i/Users/hongchaozhang/Develop/octopress/source/_posts/2015-07-09-Basic-Git-Commands.mds that the runtime (either the Common Language Runtime for .NET or the Java Runtime) has infrastructure in place that detects unused objects and object graphs in the background.</p>

<blockquote><p>Unfortunately, garbage collection does have a down side. Garbage collection is only available on MacOS X Version 10.5 or above. It is not available, currently (not sure if it is still true today), on iPhone, iPad, or any of the less common platforms, such as Linux or Windows.</p></blockquote>

<p>This happens at indeterminate intervals (either after a certain amount of time has passed, or when the runtime sees available memory getting low), so objects are not necessarily released at the exact moment they are no longer used.</p>

<h3>Advantages of Garbage Collection</h3>

<p>GC can clean up entire object graphs, including retain cycles.
GC happens in the background, so less memory management work is done as part of the regular application flow.</p>

<h3>Disadvantages of Garbage Collection</h3>

<p>Because GC happens in the background, the exact time frame for object releases is undetermined.
When a GC happens, other threads in the application may be temporarily put on hold.</p>

<h2>Automatic Reference Counting</h2>

<p>Automatic Reference Counting (ARC for short) as used on Cocoa takes a different approach. Rather than having the runtime look for and dispose of unused objects in the background, the compiler will inject code into the executable that keeps track of object reference counts and will release objects as necessary, automatically. In essence, if you were to disassemble an executable compiled with ARC, it would look (conceptually) as if the developer spent a lot of time meticulously keeping track of object life cycles when writing the code — except that all that hard work was done by the compiler.</p>

<h3>Advantages of Automatic Reference Counting</h3>

<p>Real-time, deterministic destruction of objects as they become unused.
No background processing, which makes it more efficient on lower-power systems, such as mobile devices.</p>

<h3>Disadvantages of Automatic Reference Counting</h3>

<p>Cannot cope with retain cycles.</p>

<blockquote><p><strong>Note:</strong> Another couple of significant memory-related concerns are the handling of <strong>Core Foundation objects</strong> and <strong>memory allocated using malloc()</strong> for types like char*.</p>

<blockquote><p>ARC does only manages Objective-C objects, so you&rsquo;ll still need to deal with <code>malloc()</code> related objects by yourself.</p>

<p>(<strong>Not very clear about this</strong>)Core Foundation types can be particularly tricky, because sometimes they need to be bridged across to matching Objective-C objects, and vice versa. This means that control needs to be transferred back and forth from ARC when bridging between CF types and Objective-C.</p></blockquote></blockquote>

<h2>Retain Cycle</h2>

<p>A so-called retain cycle happens when two (or more) objects reference each other, essentially keeping each other alive even after all external references to the objects have gone out of scope.</p>

<p>The <strong>Garbage Collection</strong> works by looking at &ldquo;reachable&rdquo; objects, it can handle retain cycles fine, and will discard entire object graphs that reference each other, if it detects no outside references exist.</p>

<p>Because <strong>Automatic Reference Counting</strong> works on a lower level and manages life cycles based on reference counts, it cannot handle retain cycles automatically, and a retain cycle will cause objects to stay in memory, essentially causing the application to &ldquo;leak&rdquo; memory.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding KVC and KVO in Objective-C]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/08/13/Understanding-KVC-and-KVO/"/>
    <updated>2015-08-13T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/08/13/Understanding-KVC-and-KVO</id>
    <content type="html"><![CDATA[<p>Contents:</p>

<ul>
<li><a href="#description">Description</a></li>
<li><a href="#kvc">KVC</a></li>
<li><a href="#kvo">KVO</a></li>
<li><a href="#remove_observers">Remove Observers</a></li>
</ul>


<h2><a name="description"></a>Description</h2>

<p>In Cocoa, the Model-View-Controller pattern, a controller’s responsibility is to keep the view and the model synchronized. There are two parts to this: when the model object changes, the views have to be updated to reflect this change, and when the user interacts with controls, the model has to be updated accordingly.</p>

<p>Key-Value Observing helps us update the views to reflect changes to model objects. The controller can observe changes to those property values that the views depend on.</p>

<p>For more details, refer <a href="http://www.objc.io/issues/7-foundation/key-value-coding-and-observing/">Key-Value Coding and Observing</a> from <a href="objc.io">objc.io</a>;</p>

<!-- more -->


<h2><a name="kvc"></a>KVC</h2>

<h3>Description</h3>

<p>KVC, which means <em>NSKeyValueCoding</em>, is a protoco, and supplies accessors (getter and setter) for getting and setting property value. Only by using the KVC setter method to set the property value, can the sender send a message to the observer.</p>

<p>KVC has the following two getter methods: <code>valueForKey:</code> and <code>valueForKeyPath:</code>, two setter methods: <code>setValue:forKey:</code> and <code>setValue:forKeyPath:</code>.</p>

<h3>Sample code</h3>

<p>Assume that <code>Person</code> class has two simple properties: <code>name</code> and <code>address</code> and a <code>Person</code> type property <code>spouse</code>. We have the following two pieces of code explaining the <em>Key</em> and <em>KeyPath</em>:</p>

<p>For <em>Key</em>:</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="kt">void</span> <span class="nf">changeName</span><span class="p">(</span><span class="n">Person</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">p</span><span class="p">,</span> <span class="bp">NSString</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">newName</span><span class="p">)</span>
<span class="lineno"> 2</span> <span class="p">{</span>
<span class="lineno"> 3</span>     <span class="c1">// using the KVC accessor (getter) method</span>
<span class="lineno"> 4</span>     <span class="bp">NSString</span> <span class="o">*</span><span class="n">originalName</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="nl">valueForKey</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">name</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 5</span> 
<span class="lineno"> 6</span> <span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// using the KVC  accessor (setter) method.</span>
<span class="lineno"> 7</span> <span class="p">[</span><span class="n">p</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">newName</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;name&quot;</span><span class="p">];</span>
<span class="lineno"> 8</span> 
<span class="lineno"> 9</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Changed %@&#39;s name to: %@&quot;</span><span class="p">,</span> <span class="n">originalName</span><span class="p">,</span> <span class="n">newName</span><span class="p">);</span>
<span class="lineno">10</span> <span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
<span class="lineno">11</span> 
<span class="lineno">12</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span></code></pre></div></p>

<p>For <em>KeyPath</em>:</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="kt">void</span> <span class="nf">logMarriage</span><span class="p">(</span><span class="n">Person</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">p</span><span class="p">)</span>
<span class="lineno"> 2</span> <span class="p">{</span>
<span class="lineno"> 3</span>     <span class="c1">// just using the accessor again, same as example above</span>
<span class="lineno"> 4</span>     <span class="bp">NSString</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">personsName</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="nl">valueForKey</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">name</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 5</span> 
<span class="lineno"> 6</span> <span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// this line is different, because it is using</span>
<span class="lineno"> 7</span> <span class="c1">// a &quot;key path&quot; instead of a normal &quot;key&quot;</span>
<span class="lineno"> 8</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">spousesName</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="nl">valueForKeyPath</span><span class="p">:</span><span class="s">@&quot;spouse.name&quot;</span><span class="p">];</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@ is happily married to %@&quot;</span><span class="p">,</span> <span class="n">personsName</span><span class="p">,</span> <span class="n">spousesName</span><span class="p">);</span>
<span class="lineno">11</span> <span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
<span class="lineno">12</span> 
<span class="lineno">13</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span></code></pre></div></p>

<p>Actually, <code>[p valueForKeyPath:@"spouse.name"];</code> equals to <code>[[p valueForKey:@"spouse"] valueForKey:@"name"];</code>.</p>

<h2><a name="kvo"></a>KVO</h2>

<h3>Description</h3>

<p><em>Key Value Observer (KVO)</em> is based on KVC, and can observe the change of a property of another object.</p>

<p>KVO allows you to register as an observer of a given object and receive notification when specific properties on that object are changed. It’s an incredibly powerful capability, and it is built into Objective-C at its very core.</p>

<h3>Sample code</h3>

<p>Implement <code>PersonWatcher</code> for observing a <code>Person</code> instance.</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="k">@implementation</span> <span class="nc">PersonWatcher</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">static</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">KVO_CONTEXT_ADDRESS_CHANGED</span> <span class="o">=</span> <span class="p">@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">KVO_CONTEXT_ADDRESS_CHANGED</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 4</span> 
<span class="lineno"> 5</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="n">init</span><span class="p">;</span>
<span class="lineno"> 6</span> <span class="p">{</span>
<span class="lineno"> 7</span>     <span class="k">if</span><span class="p">(</span><span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">]){</span>
<span class="lineno"> 8</span>         <span class="nb">self</span><span class="p">.</span><span class="n">m_observedPeople</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
<span class="lineno"> 9</span>     <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">10</span> 
<span class="lineno">11</span> <span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="lineno">12</span> <span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
<span class="lineno">13</span> 
<span class="lineno">14</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">15</span> 
<span class="lineno">16</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// watch a person</span>
<span class="lineno">17</span> <span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nl">watchPersonForChangeOfAddress</span><span class="p">:(</span><span class="n">Person</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span>
<span class="lineno">18</span> <span class="p">{</span>
<span class="lineno">19</span>     <span class="c1">// this begins the observing</span>
<span class="lineno">20</span>     <span class="p">[</span><span class="n">p</span> <span class="nl">addObserver</span><span class="p">:</span><span class="nb">self</span>
<span class="lineno">21</span>         <span class="nl">forKeyPath</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">address</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
<span class="lineno">22</span>            <span class="nl">options</span><span class="p">:</span><span class="mi">0</span>
<span class="lineno">23</span>            <span class="nl">context</span><span class="p">:</span><span class="n">CFBridgingRetain</span><span class="p">(</span><span class="n">KVO_CONTEXT_ADDRESS_CHANGED</span><span class="p">)];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">24</span> 
<span class="lineno">25</span> <span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// keep a record of all the people being observed,</span>
<span class="lineno">26</span> <span class="c1">// because we need to stop observing them in dealloc</span>
<span class="lineno">27</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">m_observedPeople</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">p</span><span class="p">];</span>
<span class="lineno">28</span> <span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
<span class="lineno">29</span> 
<span class="lineno">30</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">31</span> 
<span class="lineno">32</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// whenever an observed key path changes, this method will be called</span>
<span class="lineno">33</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">observeValueForKeyPath</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">keyPath</span>
<span class="lineno">34</span>                       <span class="nl">ofObject</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">object</span>
<span class="lineno">35</span>                         <span class="nl">change</span><span class="p">:(</span><span class="bp">NSDictionary</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">change</span>
<span class="lineno">36</span>                        <span class="nl">context</span><span class="p">:(</span><span class="kt">void</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">context</span>
<span class="lineno">37</span> <span class="p">{</span>
<span class="lineno">38</span>     <span class="c1">// use the context to make sure this is a change in the address,</span>
<span class="lineno">39</span>     <span class="c1">// because we may also be observing other things</span>
<span class="lineno">40</span>     <span class="k">if</span><span class="p">(</span><span class="n">context</span> <span class="o">==</span> <span class="n">CFBridgingRetain</span><span class="p">(</span><span class="n">KVO_CONTEXT_ADDRESS_CHANGED</span><span class="p">))</span> <span class="p">{</span>
<span class="lineno">41</span>         <span class="bp">NSString</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="p">[</span><span class="n">object</span> <span class="nl">valueForKey</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">name</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span>
<span class="lineno">42</span>         <span class="bp">NSString</span> <span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="p">[</span><span class="n">object</span> <span class="nl">valueForKey</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">address</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span>
<span class="lineno">43</span>         <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">%</span><span class="p">@</span> <span class="n">has</span> <span class="n">a</span> <span class="n">new</span> <span class="nl">address</span><span class="p">:</span> <span class="o">%</span><span class="p">@</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="n">name</span><span class="p">,</span> <span class="n">address</span><span class="p">);</span>
<span class="lineno">44</span>     <span class="p">}</span>
<span class="lineno">45</span> <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">46</span> 
<span class="lineno">47</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">dealloc</span><span class="p">;</span>
<span class="lineno">48</span> <span class="p">{</span>
<span class="lineno">49</span>     <span class="c1">// must stop observing everything before this object is</span>
<span class="lineno">50</span>     <span class="c1">// deallocated, otherwise it will cause crashes</span>
<span class="lineno">51</span>     <span class="k">for</span><span class="p">(</span><span class="n">Person</span> <span class="o">*</span><span class="n">p</span> <span class="k">in</span> <span class="nb">self</span><span class="p">.</span><span class="n">m_observedPeople</span><span class="p">){</span>
<span class="lineno">52</span>         <span class="p">[</span><span class="n">p</span> <span class="nl">removeObserver</span><span class="p">:</span><span class="nb">self</span> <span class="nl">forKeyPath</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">address</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span>
<span class="lineno">53</span>     <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">54</span> 
<span class="lineno">55</span> <span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nb">self</span><span class="p">.</span><span class="n">m_observedPeople</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="lineno">56</span> <span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
<span class="lineno">57</span> 
<span class="lineno">58</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span></code></pre></div></p>

<h2><a name="remove_observers"></a>Remove observer</h2>

<p>Refer <a href="http://stackoverflow.com/questions/6959896/kvo-and-arc-how-to-removeobserver">here</a></p>

<p>You should stop observing the sender when observer is dealloced. If you fail to do this and then allow the observer to be deallocated, then future notifications to the observer may cause your application to crash.</p>

<p>So, remember to remove observers</p>

<ol>
<li>before observer is dealloced</li>
<li>before the sender is dealloced</li>
</ol>


<p>For <code>#1</code>, just send <code>removeObserver:forKeyPath</code> message to the sender in the <code>-dealloc</code> function of the observer.
<code>-dealloc</code> function is called even in ARC mode. In <code>-dealloc</code>, just free non-object resources, or clean up tasks like removing observers. In <code>-dealloc</code> under ARC mode, you can not call <code>[super dealloc]</code>, as the compiller did it for you and this why there is an error if you call this manually.</p>

<blockquote><p><strong>Note:</strong> <code>-dealloc</code> is not called in <em>garbage collection</em> mode.</p></blockquote>

<p>For <code>#2</code>, the observer must know the life circle of the sender, and before the sender is freed, the observer must remove the observation from the sender.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Property and Its Attributes in Objective-C]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/07/27/Property-and-its-Attributes-in-Objective-C/"/>
    <updated>2015-07-27T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/07/27/Property-and-its-Attributes-in-Objective-C</id>
    <content type="html"><![CDATA[<p>All the attributes of a property defines how the compiler generate the <code>getter</code> and <code>setter</code> accessors.</p>

<ul>
<li><p>atomic / nonatomic</p></li>
<li><p>strong / weak: used for ARC.</p></li>
<li><p>assign / retain / copy: go to <a href="http://blog.csdn.net/jiarusun000/article/details/6991249">here</a> for reference. These properties define how the compiler generate the <code>setter</code> accessor.</p></li>
<li><p>readonly / readwrite: if a property is declared as <code>readonly</code>, the compiler will only declare the getter accessor, so that you can not call setter accessor. This is called <code>readonly</code>.</p></li>
</ul>


<!-- more -->


<p>Apart from above, <code>@synthesize</code> define the instance variable used for accessors. <code>@synthesize</code> can only be used to property, not iVar. For more info, see <a href="http://hongchaozhang.github.io/code/2015/07/22/Property-vs-Instance-Variable(iVar">Property vs Instance Variable (iVar) in objective-c</a>-in-Objective-C.html).</p>

<p><a href="http://www.cnblogs.com/andyque/archive/2011/08/03/2125728.html">Here</a> has a detail description. And the useful part:</p>

<ul>
<li>什么时候用assign、什么时候用retain和copy呢？推荐做法是NSString用copy,delegate用assign（且一定要用assign，不要问为什么，只管去用就是了，以后你会明白的），非objc数据类型，比如int，float等基本数据类型用assign（默认就是assign），而其它objc类型，比如NSArray，NSDate用retain。</li>
<li>当别人使用@property来做内存管理的时候就会有问题了。总结一下，如果你自己实现了getter和setter的话，atomic/nonatomic/retain/assign/copy这些只是给编译的建议，编译会首先会到你的代码里面去找，如果你定义了相应的getter和setter的话，那么好，用你的。如果没有，编译器就会根据atomic/nonatomic/retain/assign/copy这其中你指定的某几个规则去生成相应的getter和setter。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Property vs Instance Variable (iVar) in Objective-c]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/07/22/Property-vs-Instance-Variable(iVar)-in-Objective-C/"/>
    <updated>2015-07-22T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/07/22/Property-vs-Instance-Variable(iVar)-in-Objective-C</id>
    <content type="html"><![CDATA[<h2>Description</h2>

<p>To declare a variable in a objective-c class, we have the following two ways:</p>

<ul>
<li>Property
<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="k">@interface</span> <span class="nc">Photo</span> : <span class="bp">NSObject</span>
<span class="lineno">2</span> <span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">photographer</span><span class="p">;</span>
<span class="lineno">3</span> <span class="k">@end</span></code></pre></div></li>
<li>Instance Variable (iVar)
<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="k">@interface</span> <span class="nc">Photo</span> : <span class="bp">NSObject</span> <span class="p">{</span>
<span class="lineno">2</span>   <span class="bp">NSString</span> <span class="o">*</span><span class="n">photographer</span><span class="p">;</span>
<span class="lineno">3</span> <span class="p">}</span>
<span class="lineno">4</span> <span class="k">@end</span></code></pre></div><br/>
Then, what&rsquo;s the difference?</li>
</ul>


<!-- more -->


<h2>Differences</h2>

<h3>private vs public</h3>

<p>For a private/protected variable, use iVar; for a public variable, use property. If you want to use the benifit of property attributes, like retain, nonatomic etc., declare the property in the implementation file as a private property.</p>

<p>For an iVar, you can use <code>@private</code>, <code>@protected</code> and <code>@public</code>. But these attributes only influence the access of its subclass, and has nothing to do with the access ability of its instances. Go to <a href="http://www.cnblogs.com/andyque/archive/2011/08/03/2125728.html">here</a> for reference.</p>

<h3>usage</h3>

<p>Directly use an iVar inside the class, for example, <code>photographer</code>. But use <code>self.</code> for a property, for example, <code>self.photographer</code>.</p>

<h3>performance</h3>

<p>iVar is faster than property, as property will call the <code>getter</code> or <code>setter</code> functions. When you declare a property, the compiler will add <code>getter</code> and <code>setter</code> functions for the property.</p>

<h3>@synthesize for property</h3>

<p><strong>UPDATE：Just read this paragraph, omit the paragraphs behind.</strong> <code>@synthesize</code> is only for property, not iVar. It will help the property to generate the getter and setter accessors. For every property, complier will automatically synthesize it using <code>_propertyName</code>. The auto synthesize is the same as you add <code>@synthesize propertyName = _propertyName</code>. If you only add <code>@synthesize propertyName</code>, it is the same with <code>@synthesize propertyName = propertyName</code>, and if you define an iVar with the name <code>propertyName</code>, they will be synthesized. That is to say, in the accessors of <strong>property</strong> <code>propertyName</code>, it will use <strong>iVar</strong> <code>propertyName</code>.</p>

<blockquote><p><strong>Note for property inheritance:</strong> If the super class has a property declared as public, the subclass can inherit the property. But the auto synthesize mechnism will not sythesize the property automatically, and you can only use the getter and setter accessors of the superclass by using dot operation. If you want to synthesize manually, <strong>Be Carefull!</strong> You should avoid using the same iVar as them in the superclass. This will lead to an error message <em>&ldquo;property &lsquo;propertyName&rsquo; atemping to use instance variable &lsquo;InstanceVariableName&rsquo; declared in super class &lsquo;SuperClassName&rsquo;&rdquo;</em>.</p>

<p>If you inherit a property from a <strong>protocol</strong>, you mush synthesize it, as the protocol only declares it, not synthesize it.</p></blockquote>

<p><strong>Omit the following paragraphs in this section</strong></p>

<p>If you add <code>@synthesize photographer</code> in the implementation, compiler will automatically add an iVar <code>photographer</code> <del>and <code>_photographer</code></del> to the class. You can directly use <code>photographer</code> <del>or <code>_photographer</code></del> instead of <code>self.photographer</code> to get or set the value. The iVar method is faster, but keep in mind that it will not call the <code>getter</code> or <code>setter</code> method.</p>

<p>If you declare the class like this and don&rsquo;t <code>@synthesize photographer</code>:
<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="k">@interface</span> <span class="nc">Photo</span> : <span class="bp">NSObject</span> <span class="p">{</span>
<span class="lineno">2</span>     <span class="bp">NSString</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">photographer</span><span class="p">;</span>
<span class="lineno">3</span> <span class="p">}</span>
<span class="lineno">4</span> <span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">photographer</span><span class="p">;</span>
<span class="lineno">5</span> <span class="k">@end</span></code></pre></div>
There are actually two <code>photographer</code> variables in the class: when you use <code>photographer</code> directly, you are using the iVar, and when you use <code>self.photographer</code>, you are using the property.</p>

<p>However, when you use <code>@synthesize photographer</code> in the implementation file, the compoler will add <code>photographer</code> variable for the property. That is to say, <code>photographer</code> will be the property, and the iVar will not be usable.</p>

<h2>References</h2>

<p>A more detailed description is <a href="http://stackoverflow.com/questions/9086736/why-would-you-use-an-ivar">here</a>.</p>

<p><a href="http://stackoverflow.com/questions/2032826/property-synthesize">reference</a>, answer by <em>Rachel Henderson</em></p>

<p><del><em>Property</em> session of the </del><a href="http://www.cocoadevcentral.com/d/learn_objectivec/"><del>reference</del></a>. <del>This post is old fashioned</del>.</p>

<p><a href="http://blog.csdn.net/likendsl/article/details/7345485">Here</a> has a good explaination.</p>
]]></content>
  </entry>
  
</feed>
