<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2024-03-20T00:41:33+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SightReading(è§†å¥)åº”ç”¨å¼€å‘çŸ¥è¯†ç‚¹æ€»ç»“]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/03/01/summarize-of-sight-reading-app-developping/"/>
    <updated>2021-03-01T14:39:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/03/01/summarize-of-sight-reading-app-developping</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96">æ•°æ®æŒä¹…åŒ–</a>

<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%9D%E5%AD%98%E5%92%8C%E8%AF%BB%E5%8F%96">æ–‡ä»¶çš„ä¿å­˜å’Œè¯»å–</a></li>
<li><a href="#nsdefault%E4%BF%9D%E5%AD%98%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF">NSDefaultï¼šä¿å­˜æ ‡ç­¾ä¿¡æ¯</a></li>
<li><a href="#%E5%8F%82%E8%80%83">å‚è€ƒ</a></li>
</ul>
</li>
<li><a href="#%E6%92%AD%E6%94%BE%E8%8A%82%E6%8B%8D%E5%99%A8%E5%A3%B0%E9%9F%B3">æ’­æ”¾èŠ‚æ‹å™¨å£°éŸ³</a>

<ul>
<li><a href="#%E9%80%9A%E8%BF%87avfoundation%E6%92%AD%E6%94%BE%E5%A3%B0%E9%9F%B3">é€šè¿‡AVFoundationæ’­æ”¾å£°éŸ³</a></li>
<li><a href="#%E8%8A%82%E6%8B%8D%E5%99%A8%E9%9F%B3%E9%87%8F%E8%B0%83%E8%8A%82">èŠ‚æ‹å™¨éŸ³é‡è°ƒèŠ‚</a></li>
</ul>
</li>
<li><a href="#navigationcontroller%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E9%80%92">navigationControllerçš„ä½¿ç”¨å’Œæ•°æ®çš„ä¼ é€’</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">å‚è€ƒ</a></li>
</ul>
</li>
<li><a href="#photokit%E7%9A%84%E4%BD%BF%E7%94%A8">PhotoKitçš„ä½¿ç”¨</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">å‚è€ƒ</a></li>
</ul>
</li>
<li><a href="#alert-view">Alert View</a></li>
<li><a href="#uiimage">UIImage</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">å‚è€ƒ</a></li>
</ul>
</li>
<li><a href="#%E5%8F%AF%E7%BC%96%E8%BE%91%E7%9A%84uitableview">å¯ç¼–è¾‘çš„UITableView</a></li>
<li><a href="#calayer--cashapelayer--core-graphics">CALayer &amp; CAShapeLayer &amp; Core Graphics</a></li>
<li><a href="#%E9%9F%B3%E4%B9%90%E6%9C%AF%E8%AF%AD%E8%8B%B1%E8%AF%AD">éŸ³ä¹æœ¯è¯­è‹±è¯­</a></li>
<li><a href="#swift%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95designatedconvenience">swiftä¸­æ„é€ æ–¹æ³•designatedï¼Œconvenience</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">å‚è€ƒ</a></li>
</ul>
</li>
<li><a href="#%E7%AC%94%E8%AE%B0%E7%BB%98%E5%88%B6%E5%8A%9F%E8%83%BD">ç¬”è®°ç»˜åˆ¶åŠŸèƒ½</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-æ•°æ®æŒä¹…åŒ–" name="æ•°æ®æŒä¹…åŒ–"></a></p>

<h2>æ•°æ®æŒä¹…åŒ–</h2>

<p><a id="markdown-æ–‡ä»¶çš„ä¿å­˜å’Œè¯»å–" name="æ–‡ä»¶çš„ä¿å­˜å’Œè¯»å–"></a></p>

<h3>æ–‡ä»¶çš„ä¿å­˜å’Œè¯»å–</h3>

<ul>
<li>Jsonæ–‡ä»¶ï¼šæ¯ä¸ªä¹è°±é¡µå¯¹åº”ä¸€ä¸ªJsonæ–‡ä»¶ã€‚æ–‡ä»¶ä¿å­˜ä¹è°±æ¯å°èŠ‚çš„å¤§å°å’Œä½ç½®ä¿¡æ¯ï¼Œä»¥åŠä¹è°±çš„åŸºæœ¬ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ¯å°èŠ‚èŠ‚æ‹æ•°å’Œç”¨æˆ·è®¾ç½®çš„é€Ÿåº¦å’ŒMaskåç§»é‡ã€‚</li>
<li>pngæ–‡ä»¶ï¼šæ¯ä¸ªä¹è°±éƒ½æœ‰ä¸€ä¸ªä¹è°±å›¾ç‰‡ï¼Œå¦‚æœç”¨æˆ·åšäº†ç¬”è®°ï¼Œè¿˜æœ‰ä¸€ä¸ªç¬”è®°å›¾ç‰‡ã€‚</li>
</ul>


<p>ä¿å­˜æ–‡ä»¶çš„ä»£ç å¦‚ä¸‹ï¼š
```
func getRootPath() -> String? {
    return NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first
}</p>

<p>func saveImageFile() {
    if let rootPath = Utility.getRootPath(),
        let imageName = getFileName() {
        let imagePath = &ldquo;(rootPath)/(imageName).png&rdquo;
        print(&ldquo;image path: (imagePath)&rdquo;)
        if let image = imageView.image, let imageData = image.pngData() {
            FileManager.default.createFile(atPath: imagePath, contents: imageData, attributes: nil)
        }
    }
}</p>

<p>func saveJsonFile() {
    if let rootPath = Utility.getRootPath(),
        let jsonFileName = getFileName() {
        let jsonPath = &ldquo;(rootPath)/(jsonFileName).json&rdquo;
        print(&ldquo;image path: (jsonPath)&rdquo;)
        let jsonDic: [String: Any] = [basicInfoKey: <a href="">String: String</a>, barFramesKey: barFrames]
        if let jsonData = try? NSKeyedArchiver.archivedData(withRootObject: jsonDic, requiringSecureCoding: false) {
            FileManager.default.createFile(atPath: jsonPath, contents: jsonData, attributes: nil)
        }
    }
}
```</p>

<p>è¯»å–æ–‡ä»¶çš„ä»£ç å¦‚ä¸‹ï¼š
```
func loadJsonFile() {
    if let rootPath = Utility.getRootPath(),
        let jsonName = navigationItem.title,
        let jsonData = FileManager.default.contents(atPath: &ldquo;(rootPath)/(jsonName).json&rdquo;),
        let jsonObjectAny = NSKeyedUnarchiver.unarchiveObject(with: jsonData),
        let jsonObject = jsonObjectAny as? [String: Any] {
        if let sheetBasicInfo = jsonObject[basicInfoKey] as? [String: String] {
            self.sheetBasicInfo = sheetBasicInfo
        }
        if let barFrames = jsonObject[barFramesKey] as? [Int: CGRect] {
            self.barFrames =  barFrames
        }
    }
}</p>

<p>func loadSheetImage(with imageName: String) {
    if let rootPath = Utility.getRootPath(),
        let sheetImage = UIImage(contentsOfFile: &ldquo;(rootPath)/(imageName).png&rdquo;) {
        sheetImageView.image = sheetImage
        noteImageView.image = UIImage(contentsOfFile: &ldquo;(rootPath)/(imageName)(noteImageSubfix).png&rdquo;)
        layoutImageView()
    }
}
```</p>

<p><a id="markdown-nsdefaultä¿å­˜æ ‡ç­¾ä¿¡æ¯" name="nsdefaultä¿å­˜æ ‡ç­¾ä¿¡æ¯"></a></p>

<h3>NSDefaultï¼šä¿å­˜æ ‡ç­¾ä¿¡æ¯</h3>

<pre><code>UserDefaults.standard.setValue(allTags, forKey: allTagsKey)
let allTags = UserDefaults.standard.value(forKey: allTagsKey)
</code></pre>

<p><a id="markdown-å‚è€ƒ" name="å‚è€ƒ"></a></p>

<h3>å‚è€ƒ</h3>

<ul>
<li><a href="https://www.jianshu.com/p/d1c621631f7e">iOSæ•°æ®æœ¬åœ°æŒä¹…åŒ–æ–¹æ³•æ€»ç»“</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1129341">iOSåº”ç”¨æ•°æ®å­˜å‚¨ï¼ˆæ•°æ®æŒä¹…åŒ–ï¼‰çš„å¸¸ç”¨æ–¹å¼</a></li>
<li><a href="https://www.jianshu.com/p/fad66bae5484">iOS å°†å¯¹è±¡åºåˆ—åŒ–æˆjsonï¼Œå†™å…¥æœ¬åœ°æ–‡ä»¶</a></li>
</ul>


<p><a id="markdown-æ’­æ”¾èŠ‚æ‹å™¨å£°éŸ³" name="æ’­æ”¾èŠ‚æ‹å™¨å£°éŸ³"></a></p>

<h2>æ’­æ”¾èŠ‚æ‹å™¨å£°éŸ³</h2>

<p><a id="markdown-é€šè¿‡avfoundationæ’­æ”¾å£°éŸ³" name="é€šè¿‡avfoundationæ’­æ”¾å£°éŸ³"></a></p>

<h3>é€šè¿‡AVFoundationæ’­æ”¾å£°éŸ³</h3>

<pre><code>if let audioUrl = Bundle.main.url(forResource: "FirstMeter", withExtension: "wav", subdirectory: "Resource.bundle")  {
    AudioServicesCreateSystemSoundID(audioUrl as CFURL, &amp;firstMeterId)
}
AudioServicesPlaySystemSound(self.firstMeterId)
</code></pre>

<p><a id="markdown-èŠ‚æ‹å™¨éŸ³é‡è°ƒèŠ‚" name="èŠ‚æ‹å™¨éŸ³é‡è°ƒèŠ‚"></a></p>

<h3>èŠ‚æ‹å™¨éŸ³é‡è°ƒèŠ‚</h3>

<p>åœ¨è®¾ç½®ä¸­ï¼Œå¦‚æœâ€œå£°éŸ³->é“ƒå£°å’Œè­¦æŠ¥â€ä¸‹é¢çš„â€œè·ŸéšæŒ‰é’®â€æ²¡æœ‰æ‰“å¼€ï¼Œé‚£ä¹ˆé€šè¿‡<code>AudioServicesPlaySystemSound()</code>æ’­æ”¾çš„å£°éŸ³å°±ä¼šå§‹ç»ˆç”¨ä¸€ä¸ªå›ºå®šçš„éŸ³é‡æ’­æ”¾ï¼Œå…¶å®ƒå£°éŸ³APIæ’­æ”¾çš„å£°éŸ³ï¼ˆæ¯”å¦‚<code>AVAudioPlayer</code>ï¼‰ä¼šè·Ÿéšç³»ç»ŸéŸ³é‡å˜åŒ–éŸ³é‡å¤§å°ã€‚</p>

<blockquote><p>In Settings app, Sounds->RINGER AND ALERTS, if &lsquo;Change with Buttons&rsquo; is set to Off, then sounds using AudioServicesPlaySystemSound() will always be played at a fixed volume (yet other sound API&rsquo;s such as AVAudioPlayer will respect the volume of the device).</p></blockquote>

<p><a id="markdown-navigationcontrollerçš„ä½¿ç”¨å’Œæ•°æ®çš„ä¼ é€’" name="navigationcontrollerçš„ä½¿ç”¨å’Œæ•°æ®çš„ä¼ é€’"></a></p>

<h2>navigationControllerçš„ä½¿ç”¨å’Œæ•°æ®çš„ä¼ é€’</h2>

<p>é€šè¿‡ä¸‹é¢ä¸¤ç§æ–¹æ³•è¿›è¡ŒViewControllerçš„å¼¹å‡º
<code>
let playVC = storyBoard.instantiateViewController(identifier: "Play")
playVC.navigationItem.title = filtedFileNames[indexPath.row]
navigationController?.pushViewController(playVC, animated: true)
</code>
æˆ–è€…
<code>
let colorPickerVC = UIColorPickerViewController()
colorPickerVC.selectedColor = brushColorButton.selectedColor
colorPickerVC.delegate = self
present(colorPickerVC, animated: true, completion: nil)
</code>
é€šè¿‡delegateè¿›è¡Œç›®æ ‡ViewControlleråˆ°æºViewControllerçš„æ–¹æ³•è°ƒç”¨å’Œæ•°æ®ä¼ é€’ï¼ŒæºViewControlerå¯ä»¥ç›´æ¥è®¾ç½®ç›®æ ‡ViewControllerçš„å±æ€§è¿›è¡Œæ•°æ®ä¼ é€’ã€‚</p>

<p><a id="markdown-å‚è€ƒ" name="å‚è€ƒ"></a></p>

<h3>å‚è€ƒ</h3>

<ul>
<li><a href="https://stackoverflow.com/questions/30618172/how-to-send-data-back-by-popviewcontrolleranimated-for-swift">How to send data back by popViewControllerAnimated for Swift?</a></li>
<li><a href="https://www.jianshu.com/p/319cbc53f0ba">iOSå¯¼èˆªæ§åˆ¶å™¨â€”â€”UINavigationControllerä½¿ç”¨è¯¦è§£</a></li>
<li><a href="https://blog.csdn.net/liuyinghui523/article/details/62036465">ä¸€ç¯‡è¾ƒä¸ºè¯¦ç»†çš„ Storyboardä½¿ç”¨æ–¹æ³• æ€»ç»“</a></li>
</ul>


<p><a id="markdown-photokitçš„ä½¿ç”¨" name="photokitçš„ä½¿ç”¨"></a></p>

<h2>PhotoKitçš„ä½¿ç”¨</h2>

<p>éœ€è¦åœ¨info.plisté‡Œé¢è®¾ç½®<code>NSPhotoLibraryUsageDescription</code>å±æ€§ï¼Œè®¾ç½®åœ¨è·å–æƒé™çš„æ—¶å€™æ˜¾ç¤ºç»™ç”¨æˆ·çš„å¼¹çª—ä¸­æ˜¾ç¤ºçš„å†…å®¹ã€‚</p>

<p>æ£€æŸ¥æƒé™çŠ¶æ€ï¼š
<code>
private func requestPrivilegeAndLoadPhotos() {
    let status = PHPhotoLibrary.authorizationStatus()
    if status == .authorized {
        loadPhotos()
    } else {
        PHPhotoLibrary.requestAuthorization { (status) in
            if status == .authorized {
                self.loadPhotos()
                DispatchQueue.main.async {
                    self.collection.reloadData()
                }
            } else {
                // use not grant the privilege
            }
        }
    }
}
</code></p>

<p>å¦‚æœç”¨æˆ·ç»™äº†è®¿é—®ç›¸å†Œçš„æƒé™ï¼Œé€šè¿‡ä¸‹é¢çš„æ–¹æ³•åŠ è½½æ‰€æœ‰å›¾ç‰‡ä¿¡æ¯ï¼š
<code>
private func loadPhotos() {
    let allPhotosOptions = PHFetchOptions()
    allPhotosOptions.sortDescriptors = [NSSortDescriptor(key: "creationDate", ascending: true)]
    allPhotos = PHAsset.fetchAssets(with: .image, options: allPhotosOptions)
}
</code></p>

<p>é€šè¿‡ä¸‹é¢æ–¹æ³•å°†æ‰€æœ‰å›¾ç‰‡ä¿¡æ¯æ˜¾ç¤ºåœ¨collectionåˆ—è¡¨ä¸­ï¼š
```
func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
    return allPhotos.count
}</p>

<p>func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
    if let cell = collection.dequeueReusableCell(withReuseIdentifier: cellIdentifier, for: indexPath) as? PhotoCollectionCell {
        let assert = allPhotos.object(at: indexPath.item)
        PHImageManager.default().requestImage(for: assert, targetSize: CGSize(width: photoCollectionWH, height: photoCollectionWH), contentMode: .aspectFill, options: .none) { (image, dic) in
            if let image = image {
                cell.imageView.image = image
            }
        }</p>

<pre><code>    return cell
} else {
    return collection.dequeueReusableCell(withReuseIdentifier: cellIdentifier, for: indexPath)
}
</code></pre>

<p>}
```</p>

<p>é€šè¿‡ä¸‹é¢æ–¹æ³•ï¼Œå°†ç”¨æˆ·é€‰æ‹©çš„å›¾ç‰‡ä¼ ç»™delegateå¤„ç†ï¼ˆdelegateå¯ä»¥æ˜¯æºViewControllerï¼‰ï¼š
<code>
func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
    print("item: \(indexPath.item)")
    let assert = allPhotos.object(at: indexPath.item)
    PHImageManager.default().requestImage(for: assert, targetSize: CGSize(width: assert.pixelWidth, height: assert.pixelHeight), contentMode: .aspectFill, options: .none) { (image, dic) in
        if let image = image {
            self.delegate?.set(image: image, and: nil)
        }
    }
}
</code>
<a id="markdown-å‚è€ƒ" name="å‚è€ƒ"></a></p>

<h3>å‚è€ƒ</h3>

<ul>
<li><a href="https://developer.apple.com/documentation/photokit">å®˜æ–¹æ–‡æ¡£ï¼šPhotoKit</a></li>
<li><a href="https://www.raywenderlich.com/11764166-getting-started-with-photokit">Getting Started with PhotoKit</a></li>
</ul>


<p><a id="markdown-alert-view" name="alert-view"></a></p>

<h2>Alert View</h2>

<p><a href="https://learnappmaking.com/uialertcontroller-alerts-swift-how-to/">Displaying Alerts with UIAlertController in Swift</a></p>

<p><a id="markdown-uiimage" name="uiimage"></a></p>

<h2>UIImage</h2>

<p>ä¸‹é¢ä¸¤ä¸ªå›¾ç‰‡åŠ è½½æ–¹æ³•å¯¹cacheçš„è¿ç”¨æ˜¯ä¸ä¸€æ ·çš„ï¼š
<code>
+ (UIImage *)imageNamed:(NSString *)name: use cached images
+ (UIImage *)imageWithContentsOfFile:(NSString *)path: skip cached images and read data directly from file
</code></p>

<p><a id="markdown-å‚è€ƒ" name="å‚è€ƒ"></a></p>

<h3>å‚è€ƒ</h3>

<p><a href="https://medium.com/@maximbilan/ios-uiimage-cache-92563c3ae3c2">iOS UIImage Cache</a></p>

<p><a id="markdown-å¯ç¼–è¾‘çš„uitableview" name="å¯ç¼–è¾‘çš„uitableview"></a></p>

<h2>å¯ç¼–è¾‘çš„UITableView</h2>

<p>é€šè¿‡å®ç°ä¸‹é¢æ–¹æ³•ä¿è¯æ¯ä¸ªcellæ”¯æŒå·¦æ»‘æ“ä½œï¼š
<code>
func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool {
    return true
}
</code></p>

<p>é€šè¿‡å®ç°ä¸‹é¢çš„æ–¹æ³•ï¼Œå·¦æ»‘ä¹‹åæ˜¾ç¤ºä¸¤ä¸ªæŒ‰é’®: Edit Tagså’ŒDelete
```
func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {
    let deleteAction = UITableViewRowAction(style: .destructive, title: &ldquo;Delete&rdquo;) { (action, indexPath) in
        self.deleteItem(at: indexPath)
    }
    let editAction = UITableViewRowAction(style: .default, title: &ldquo;Edit Tags&rdquo;) { (action, indexPath) in
        self.editTags(for: indexPath)
    }
    editAction.backgroundColor = UIColor(displayP3Red: 60/255, green: 148/255, blue: 1.0, alpha: 1.0)
    deleteAction.backgroundColor = .red</p>

<pre><code>return [deleteAction, editAction]
</code></pre>

<p>}
```</p>

<p><a id="markdown-calayer--cashapelayer--core-graphics" name="calayer--cashapelayer--core-graphics"></a></p>

<h2>CALayer &amp; CAShapeLayer &amp; Core Graphics</h2>

<p>è¿™ä¸€å—çš„å†…å®¹å¤ªå¤šï¼Œå¸Œæœ›æœ‰æ—¶é—´å¯ä»¥å•ç‹¬æ€»ç»“ä¸€ä¸‹ã€‚</p>

<p><a id="markdown-éŸ³ä¹æœ¯è¯­è‹±è¯­" name="éŸ³ä¹æœ¯è¯­è‹±è¯­"></a></p>

<h2>éŸ³ä¹æœ¯è¯­è‹±è¯­</h2>

<p><a href="https://zhuanlan.zhihu.com/p/35999407">éŸ³ä¹æœ¯è¯­è‹±æ–‡åç§°æ±‡æ€»</a></p>

<p><a id="markdown-swiftä¸­æ„é€ æ–¹æ³•designatedconvenience" name="swiftä¸­æ„é€ æ–¹æ³•designatedconvenience"></a></p>

<h2>swiftä¸­æ„é€ æ–¹æ³•designatedï¼Œconvenience</h2>

<p>å®˜æ–¹æ–‡æ¡£ä¸­æœ‰å¦‚ä¸‹æè¿°ï¼š</p>

<ol>
<li>å­ç±»designatedæ„é€ æ–¹æ³•ä¸­å¿…é¡»è°ƒç”¨çˆ¶ç±»çš„designatedæ„é€ æ–¹æ³•ã€‚</li>
<li>convenienceæ„é€ æ–¹æ³•ä¸­å¿…é¡»è°ƒç”¨å½“å‰ç±»çš„æ„é€ æ–¹æ³•ã€‚</li>
<li>convenienceæ„é€ æ–¹æ³•å½’æ ¹ç»“åº•è¦è°ƒç”¨åˆ°designatedæ„é€ æ–¹æ³•ã€‚</li>
</ol>


<p><img src="/images/swift_init_method.webp" alt="swift init methods" /></p>

<p><a id="markdown-å‚è€ƒ" name="å‚è€ƒ"></a></p>

<h3>å‚è€ƒ</h3>

<ul>
<li><a href="https://www.jianshu.com/p/e2cce123a5af">Swiftä¹‹initæ„é€ æ–¹æ³•</a></li>
</ul>


<p><a id="markdown-ç¬”è®°ç»˜åˆ¶åŠŸèƒ½" name="ç¬”è®°ç»˜åˆ¶åŠŸèƒ½"></a></p>

<h2>ç¬”è®°ç»˜åˆ¶åŠŸèƒ½</h2>

<p>é€šè¿‡ç¬¬ä¸‰æ–¹åº“<a href="https://github.com/e7711bbear/ATSketchKit">STSketchKit</a>å®ç°ç¬”è®°åŠŸèƒ½æ”¯æŒUndo/Redoæ“ä½œã€‚å®˜æ–¹ä»‹ç»å¦‚ä¸‹ï¼š</p>

<blockquote><p>ATSketchKit is a drawing / sketching framework for iOS written in Swift.</p>

<p>It can be used as the foundation for an artistic app, a simple signature feature or more inteligent graph designing app.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Closure]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/06/04/on-swift-closure/"/>
    <updated>2019-06-04T17:24:47+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/06/04/on-swift-closure</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#function%E4%B8%8Eclosure%E7%9A%84%E5%85%B3%E7%B3%BB">Functionä¸Closureçš„å…³ç³»ï¼š</a></li>
<li><a href="#%E7%94%A8closure%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F">ç”¨Closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡</a></li>
<li><a href="#closure%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">Closureçš„è¯­æ³•ç³–ï¼š</a></li>
<li><a href="#closure%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">Closureä¸å†…å­˜ç®¡ç†ã€å†…å­˜æ³„æ¼</a>

<ul>
<li><a href="#capture-list%E7%9A%84%E5%AE%9A%E4%B9%89">Capture Listçš„å®šä¹‰</a></li>
<li><a href="#weak-and-unowned-references">Weak and Unowned References</a></li>
</ul>
</li>
<li><a href="#closure%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F">Closureæ•è·å˜é‡</a></li>
</ul>


<p><a href="https://medium.com/@abhimuralidharan/functional-swift-all-about-closures-310bc8af31dd">Functional swift: All about Closures</a></p>

<p>è¿™ç¯‡å…¨é¢è¯¦ç»†æ˜“æ‡‚åœ°ä»‹ç»äº†Swiftçš„Closureï¼ŒåŒ…æ‹¬</p>

<ul>
<li>Closureçš„è¯­æ³•ï¼ŒåŒ…æ‹¬ä¸€äº›ç®€åŒ–å†™æ³•ï¼Œå¦‚Trailing Closures</li>
<li>Closureä¸Functionçš„åŒºåˆ«</li>
<li>Closureä¸å†…å­˜ç®¡ç†ã€å†…å­˜æ³„æ¼ï¼Œå¦‚capture listçš„ä½¿ç”¨ï¼Œweakä¸unownedçš„åŒºåˆ«</li>
<li>Functionså’Œclosureséƒ½æ˜¯å¼•ç”¨ç±»å‹ï¼Œä¸æ˜¯å€¼ç±»å‹</li>
</ul>


<p>ä¹Ÿå¯ä»¥çœ‹<a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">å®˜æ–¹æ–‡æ¡£Closures</a>ï¼Œä½†æ˜¯å®˜æ–¹æ–‡æ¡£æ²¡æœ‰ä¸Šé¢çš„æ–‡ç« è¯¦ç»†ã€‚</p>

<p>ä¸‹é¢æœ‰é€‰æ‹©åœ°è®°å½•ä¸€ä¸‹ã€‚</p>

<p><a id="markdown-functionä¸closureçš„å…³ç³»" name="functionä¸closureçš„å…³ç³»"></a></p>

<h2>Functionä¸Closureçš„å…³ç³»ï¼š</h2>

<p>å‚è€ƒ<a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">å®˜æ–¹æ–‡æ¡£Closures</a>é‡Œé¢çš„ä¸‰å¥è¯ç†è§£ä¸€ä¸‹ï¼š</p>

<blockquote><ul>
<li>Global functions are closures that have a name and do not capture any values.</li>
<li>Nested functions are closures that have a name and can capture values from their enclosing function.</li>
<li>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</li>
</ul>
</blockquote>

<p>è¿˜æœ‰ä¸€ç‚¹å¾ˆé‡è¦ï¼š<strong>Closures and functions are first class types in swift</strong>ã€‚</p>

<blockquote><p>Functions and closures are first-class citizens in Swift because you can treat then like a normal value. For example, you canï¼š</p>

<ul>
<li>assign a function/closure to a local variable .</li>
<li>pass a function/closure as an argument .</li>
<li>return a function/closure .</li>
</ul>
</blockquote>

<p><a id="markdown-ç”¨closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡" name="ç”¨closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡"></a></p>

<h2>ç”¨Closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡</h2>

<pre><code>let setupViewUsingClosure: UIView = {
    let view = UIView()
    view.backgroundColor = .green
    return view
}() //IMPORTANT!!! I have added () at the end.
</code></pre>

<p><a id="markdown-closureçš„è¯­æ³•ç³–" name="closureçš„è¯­æ³•ç³–"></a></p>

<h2>Closureçš„è¯­æ³•ç³–ï¼š</h2>

<p><a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">å®˜æ–¹æ–‡æ¡£Closures</a>æœ‰ä¸ªæ€»çš„è¯´æ˜ï¼š</p>

<blockquote><p>Swiftâ€™s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios. These optimizations include:</p>

<ul>
<li>Inferring parameter and return value types from context</li>
<li>Implicit returns from single-expression closures</li>
<li>Shorthand argument names</li>
<li>Trailing closure syntax</li>
</ul>
</blockquote>

<p>å½“ä½ ç¬¬ä¸€æ¬¡çœ‹åˆ°è¿™ä¸ªå†™æ³•çš„æ—¶å€™è‚¯å®šå¾ˆç–‘æƒ‘ï¼šå‚æ•°ã€ç±»å‹ã€å‡½æ•°è°ƒç”¨æ—¶çš„æ‹¬å·éƒ½è·‘å“ªå»äº†ï¼Ÿ</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<p>ç†è§£äº†ä¸Šé¢å‡ ç‚¹ï¼Œå°±å¯ä»¥æ˜ç™½ä¸ºä»€ä¹ˆå¯ä»¥è¿™ä¹ˆå†™ï¼Œä¸‹é¢è®©æˆ‘ä»¬ä¸€æ­¥æ­¥çœ‹æ¸…æ¥šã€‚</p>

<p>Closureçš„å®šä¹‰å¦‚ä¸‹ï¼š</p>

<blockquote><p>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</p>

<pre><code>{ (params) -&gt; returnType in
    statements
}
</code></pre></blockquote>

<p>ä¸¾ä¸ªå…·ä½“çš„ä¾‹å­ï¼š</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<p>å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Inferring parameter and return value types from context</strong></li>
</ul>


<p>Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns.</p></blockquote>

<p>æ‰€ä»¥ï¼Œä¸Šé¢çš„ä»£ç å¯ä»¥å†™ä¸ºï¼š</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )
</code></pre>

<p>å†å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Implicit returns from single-expression closures</strong></li>
</ul>


<p>Single-expression closures can implicitly return the result of their single expression by omitting the return keyword from their declaration.</p></blockquote>

<p>æ‰€ä»¥ï¼Œä»£ç ç»§ç»­æ”¹ä¸ºï¼š</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
</code></pre>

<p>å†å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Shorthand argument names</strong></li>
</ul>


<p>Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closureâ€™s arguments by the names $0, $1, $2, and so on.</p></blockquote>

<p>ä»£ç ç»§ç»­æ”¹ä¸ºï¼š</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted(by: { $0 &gt; $1 } )
</code></pre>

<p>å†å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Trailing closure syntax</strong></li>
</ul>


<p>If you need to pass a closure expression to a function as the functionâ€™s final argument and the closure expression is long, it can be useful to write it as a trailing closure instead. A trailing closure is written after the function callâ€™s parentheses, even though it is still an argument to the function. When you use the trailing closure syntax, you donâ€™t write the argument label for the closure as part of the function call.</p></blockquote>

<p>ä»£ç å°±å¯ä»¥å†™æˆï¼š</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<p><a id="markdown-closureä¸å†…å­˜ç®¡ç†å†…å­˜æ³„æ¼" name="closureä¸å†…å­˜ç®¡ç†å†…å­˜æ³„æ¼"></a></p>

<h2>Closureä¸å†…å­˜ç®¡ç†ã€å†…å­˜æ³„æ¼</h2>

<p>Closureå¸¦æ¥çš„å¾ªç¯å¼•ç”¨å’Œå†…å­˜æ³„æ¼ï¼Œä¸»è¦é€šè¿‡Capture Listæ¥è§£å†³ï¼š</p>

<blockquote><p>You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closureâ€™s definition. A capture list defines the rules to use when capturing one or more reference types within the closureâ€™s body.</p></blockquote>

<p>è¯¦ç»†å†…å®¹å‚è€ƒ<a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID56">Resolving Strong Reference Cycles for Closures</a>ã€‚ä¸‹é¢æ‘˜è¦ä¸€ä¸‹ã€‚</p>

<p><a id="markdown-capture-listçš„å®šä¹‰" name="capture-listçš„å®šä¹‰"></a></p>

<h3>Capture Listçš„å®šä¹‰</h3>

<blockquote><p>Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self) or a variable initialized with some value (such as delegate = self.delegate!). These pairings are written within a pair of square braces, separated by commas.</p></blockquote>

<p>Place the capture list before a closureâ€™s parameter list and return type if they are provided:</p>

<pre><code>lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
    // closure body goes here
}
</code></pre>

<p><a id="markdown-weak-and-unowned-references" name="weak-and-unowned-references"></a></p>

<h3>Weak and Unowned References</h3>

<blockquote><p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p>

<p>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future. Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated. This enables you to check for their existence within the closureâ€™s body.</p>

<p>NOTE: If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.</p></blockquote>

<p>å…³äºunownedçš„å¦ä¸€ä¸ªè§£é‡Šæ›´æ¸…æ¥šï¼š</p>

<blockquote><p>Like a weak reference, an unowned reference does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime.</p></blockquote>

<p><a id="markdown-closureæ•è·å˜é‡" name="closureæ•è·å˜é‡"></a></p>

<h2>Closureæ•è·å˜é‡</h2>

<blockquote><p>Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as closing over those constants and variables.</p></blockquote>

<p>æ¯”å¦‚ï¼š</p>

<pre><code>// capturing values
var i = 0
var closureArray = [()-&gt;()]()
for _ in 1...5 {
    closureArray.append {
        print(i)
    }
    i += 1
}
// here i will be 5
closureArray[0]() // prints 5
closureArray[1]() // prints 5
closureArray[2]() // prints 5
closureArray[3]() // prints 5
closureArray[4]() // prints 5
</code></pre>

<p>The closure captures the current address of <code>i</code> and every time we access <code>i</code> , it . returns the current value.</p>

<p>If we want to prevent this behavior (capturing values) and print the value of i even if the properties change after their capturing inside the closure, we can explicitly capture the variable with a capture list like this:</p>

<pre><code>var closureArray2 = [()-&gt;()]()
var j = 0
for _ in 1...5 {
    closureArray2.append { [j] in
        print(j)
    }
    j += 1
}
// here i will be 5
closureArray2[0]() // prints 0
closureArray2[1]() // prints 1
closureArray2[2]() // prints 2
closureArray2[3]() // prints 3
closureArray2[4]() // prints 4
</code></pre>

<p>In this way, we keep an immutable copy of the variable <code>j</code>. Thanks to this copy, further changes to <code>j</code>, outside the closure, will not affect the closure. <code>j</code> is a let constant here. It is not mutable.</p>

<p>We can add multiple values to the capture list :</p>

<pre><code>closure.append { [j,k,l] in
    print("\(j) \(k) \(l)")
}
</code></pre>

<p>also, you can have alias names for the values captured.</p>

<pre><code>closure.append { [a = j, b = k, c = l] in
    print("\(a) \(b) \(c)")
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sequece and Collection in Swift]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/06/03/sequece-and-collection-in-swift/"/>
    <updated>2019-06-03T16:22:33+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/06/03/sequece-and-collection-in-swift</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#array-out-of-range-crash"><code>Array</code> out of Range Crash</a></li>
<li><a href="#homemade-collection">Homemade collection</a></li>
<li><a href="#sequences">Sequences</a>

<ul>
<li><a href="#how-to-conform-to-sequence-protocol">How to Conform to <code>Sequence</code> Protocol</a></li>
<li><a href="#make-our-section-conform-to-sequence-protocol">Make our <code>Section</code> Conform to <code>Sequence</code> Protocol</a></li>
<li><a href="#gifts">Gifts</a></li>
</ul>
</li>
<li><a href="#collections">Collections</a>

<ul>
<li><a href="#how-to-conform-to-collection-protocol">How to Conform to <code>Collection</code> Protocol</a></li>
<li><a href="#make-our-section-conform-to-collection-protocol">Make our <code>Section</code> Conform to <code>Collection</code> Protocol</a></li>
</ul>
</li>
<li><a href="#difference-between-array-and-collection">Difference between <code>Array</code> and <code>Collection</code></a></li>
<li><a href="#reference">Reference</a></li>
</ul>


<p>The content comes from the following posts:</p>

<ol>
<li><a href="https://medium.com/swift-programming/swift-sequences-ce22d76f120c">Swift Sequences</a></li>
<li><a href="https://medium.com/swift-programming/swift-collections-e5fff3cd6759">Swift Collections</a></li>
</ol>


<p>But some of the code inside is old and can&rsquo;t be compiled with swift 5.0. So rewritten the code using swift 5.0.</p>

<p><a id="markdown-array-out-of-range-crash" name="array-out-of-range-crash"></a></p>

<h2><code>Array</code> out of Range Crash</h2>

<p>Before diving into Swift Sequences, letâ€™s see a strange behavior.</p>

<pre><code>let array = [1, 2, 3]
array[7] ğŸ˜­

let dic = ["a": 1, "b": 2]
dic["z"] ğŸ˜

ğŸ¤”
</code></pre>

<p>In other words, when requesting an element that doesnâ€™t exist, why arrays crash whereas dictionaries donâ€™t?</p>

<p>Arrays and dictionaries are two base collections provided by the Swift standard library. We can access those collections elements through the [] notation, also known as subscript. Letâ€™s see how those subscripts are defined.</p>

<pre><code>struct Array&lt;Element&gt; {
    subscript(index: Int) -&gt; Element
}

struct Dictionary&lt;Key: Hashable, Value&gt; {
    subscript(key: Key) -&gt; Value?
}
</code></pre>

<p>Whatâ€™s interesting is that arrays have a non optional return type. Subscript canâ€™t throw errors so there are no alternatives other than a fatalError if we request an index that doesnâ€™t exist.</p>

<p>For dictionaries, on the other hand, an optional Value is returned, which allows to gracefully return nil if the index doesnâ€™t exist.</p>

<p>We can adopt dictionaries safer approach by overloading the arrays subscriptâ€Šâ€”â€Šwe canâ€™t override them. Adding an external name to the parameter is enough.</p>

<pre><code>extension Array {
    subscript(safe index: Int) -&gt; Element? {
        return index &gt;= 0 &amp;&amp; index &lt; count ? self[index] : nil
    }
}
</code></pre>

<p>We saw how we can create a new accessor to the elements of an array, but can we do the same with a homemade collection?</p>

<p><a id="markdown-homemade-collection" name="homemade-collection"></a></p>

<h2>Homemade collection</h2>

<pre><code>struct Section&lt;T&gt; {
    let title: String
    let elements: [T]
}
</code></pre>

<p>Internally, this â€˜collectionâ€™ is based on an array. This is an implementation detail for the simplicity of the example. We could have used a linked list as in this <a href="http://austinzheng.com/2015/01/24/swift-seq/">excellent article</a> by <a href="https://twitter.com/austinzheng">Austin Zheng</a>.</p>

<p>Creating a subscript on our collection is very easy, we can even reuse the arrayâ€™s extension we made earlier.</p>

<pre><code>struct Section&lt;T&gt; {
    let title: String
    let elements: [T]

    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }
}
</code></pre>

<p>An example in practice :</p>

<pre><code>let cars = ["911", "Cayman", "Cayenne"]
let section = Section(title: "Porsche", elements: cars)

section[1]
// Optional("Cayman")
</code></pre>

<p>Great! But does that make our type a collection, as Swift defines it?</p>

<p><a id="markdown-sequences" name="sequences"></a></p>

<h2>Sequences</h2>

<p>When it comes to manipulating sets, the most abstract notion given by the standard library is the Sequence, defined as</p>

<blockquote><p>A type that can be iterated with a <code>forâ€¦in</code> loop.</p></blockquote>

<p><a id="markdown-how-to-conform-to-sequence-protocol" name="how-to-conform-to-sequence-protocol"></a></p>

<h3>How to Conform to <code>Sequence</code> Protocol</h3>

<p>This section is from <a href="https://developer.apple.com/documentation/swift/sequence">Sequece official site</a>.</p>

<p>Making your own custom types conform to Sequence enables many useful operations, like for-in looping and the contains method, without much effort. To add Sequence conformance to your own custom type, add a makeIterator() method that returns an iterator.</p>

<p>Alternatively, if your type can act as its own iterator, implementing the requirements of the IteratorProtocol protocol and declaring conformance to both Sequence and IteratorProtocol are sufficient.</p>

<p>Hereâ€™s a definition of a Countdown sequence that serves as its own iterator. The makeIterator() method is provided as a default implementation.</p>

<pre><code>struct Countdown: Sequence, IteratorProtocol {
    var count: Int

    mutating func next() -&gt; Int? {
        if count == 0 {
            return nil
        } else {
            defer { count -= 1 }
            return count
        }
    }
}

let threeToGo = Countdown(count: 3)
for i in threeToGo {
    print(i)
}
// Prints "3"
// Prints "2"
// Prints "1"
</code></pre>

<p><a id="markdown-make-our-section-conform-to-sequence-protocol" name="make-our-section-conform-to-sequence-protocol"></a></p>

<h3>Make our <code>Section</code> Conform to <code>Sequence</code> Protocol</h3>

<p>The <code>Section</code> struct can&rsquo;t act as its own iterator, we need to define an iterator for it, and then return an instance of the defined iterator inside <code>func makeIterator() -&gt; Section&lt;T&gt;.Iterator</code> method.</p>

<pre><code>struct Section&lt;T&gt;: Sequence {
    let title: String
    let elements: [T]

    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }

    struct Iterator: IteratorProtocol {
        let array: [T]
        var currentIndex = 0

        init (_ array: [T]) {
            self.array = array
        }

        mutating func next() -&gt; T? {
            let tempIndex = currentIndex
            currentIndex += 1
            return array[safe: tempIndex]

        }
    }

    func makeIterator() -&gt; Section&lt;T&gt;.Iterator {
        return Iterator(elements)
    }
}
</code></pre>

<p><a id="markdown-gifts" name="gifts"></a></p>

<h3>Gifts</h3>

<p>Is that all? No! By conforming to SequenceType we also get methods for free, here is some of them.</p>

<pre><code>section.min()
// 911
section.max()
// Cayman
section.sorted()
// ["911", "Cayenne", "Cayman"]
section.contains("911")
// true
</code></pre>

<p>We get the min, max &amp; sort methods because the elements of our sequence, String in our case, are Comparable. Contains is available thanks to our elements being Equatable.</p>

<pre><code>section.filter { $0.count &gt; 3 }
// ["Cayman", "Cayenne"]
section.map { $0.count }
// [3, 6, 7]
section.reduce(0) { $0 + $1.count }
// 16
</code></pre>

<p>And for functional programming fans, filter, map and reduce are also given.</p>

<p><a id="markdown-collections" name="collections"></a></p>

<h2>Collections</h2>

<p>Sequence is the most basic set notion given by the Swift standard library. There is a more evolved one.</p>

<p>A collection is defined as follow :</p>

<blockquote><p>A multi-pass <em>sequence</em> with addressable positions</p></blockquote>

<p>As we saw previously, a sequence is a type that can be iterated with a <code>forâ€¦in</code> loop. It doesnâ€™t need that the elements might be iterated over several times. And it doesnâ€™t need that we give a way to access directly an element.</p>

<p>Collections require those last two points. As a side effect, it no longer allows us to have an infinite number of elements.</p>

<p>To be a collection, a type must conform to the <code>Collection</code> protocol.</p>

<p><a id="markdown-how-to-conform-to-collection-protocol" name="how-to-conform-to-collection-protocol"></a></p>

<h3>How to Conform to <code>Collection</code> Protocol</h3>

<p>This section comes from <a href="https://developer.apple.com/documentation/swift/collection">Collection official site</a>.</p>

<p>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the Collection protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add Collection conformance to your type, you must declare at least the following requirements:</p>

<ol>
<li>The <code>startIndex</code> and <code>endIndex</code> properties</li>
<li>A subscript that provides at least read-only access to your typeâ€™s elements</li>
<li>The <code>index(after:)</code> method for advancing an index into your collection</li>
<li>Conform to <code>Sequece</code> Protocol, as <code>Collection</code> is inherited from <code>Sequence</code></li>
</ol>


<p><a id="markdown-make-our-section-conform-to-collection-protocol" name="make-our-section-conform-to-collection-protocol"></a></p>

<h3>Make our <code>Section</code> Conform to <code>Collection</code> Protocol</h3>

<pre><code>struct Section&lt;T&gt;: Collection {
    let title: String
    let elements: [T]

    // begin: required for Collection
    var startIndex: Int { return 0 }
    var endIndex: Int { return elements.count }

    func index(after i: Int) -&gt; Int {
        return i + 1
    }

    subscript(index: Int) -&gt; T {
        return elements[index]
    }
    // end: required for Collection


    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }


    // begin: required for Sequence
    struct Iterator: IteratorProtocol {
        let array: [T]
        var currentIndex = 0

        init (_ array: [T]) {
            self.array = array
        }

        mutating func next() -&gt; T? {
            let tempIndex = currentIndex
            currentIndex += 1
            return array[safe: tempIndex]

        }
    }

    func makeIterator() -&gt; Section&lt;T&gt;.Iterator {
        return Iterator(elements)
    }
    // end: required for Sequence
}
</code></pre>

<p>The <code>endIndex</code> has to be after the last element. It allows to define an empty collection with <code>startIndex</code> = <code>endIndex</code>.</p>

<p>Like conforming to <code>Sequence</code>, we get some methods / properties for free:</p>

<pre><code>section.count
// 3
section.first
// 911
section.isEmpty
// false
section.index(of: "911")
// 0
</code></pre>

<p>We get indexOf thanks to our Elements being Equatable.</p>

<p><a id="markdown-difference-between-array-and-collection" name="difference-between-array-and-collection"></a></p>

<h2>Difference between <code>Array</code> and <code>Collection</code></h2>

<p>We created our own collection, which is great, but what about that difference of behavior between Arrays and Dictionaries we talked about at the beginning of the post? We saw that Arrayâ€™s dangerous subscript was coming from the Indexable protocol, but what about Dictionaries?</p>

<p>Dictionaries, like Arrays, are a collection, as Swift defines it. They both conform to CollectionType. So Dictionaries are also required to provide an â€˜unsafeâ€™ subscript that takes an Index and returns a non optional Element. The one weâ€™re used to is just a convenience subscript.</p>

<p>A simple example shows that it is also really easy to get a crash with Dictionaries.</p>

<pre><code>let dic = ["a": "bmw", "b": "audi", "c": "citroen"]

var index = dic.startIndex
dic[index]
// (key: "c", value: "citroen")

index = dic.index(after: index)
print(dic[index])
// (key: "b", value: "audi")

index = dic.index(after: index)
index = dic.index(after: index)
dic[index]
// Fatal error
</code></pre>

<p><strong>The last question that remains is why <code>Collection</code> requires a subscript that may crash? Simply for performance reason, it costs too much to check the validity of the given index. Crashing is faster :)</strong></p>

<p><a id="markdown-reference" name="reference"></a></p>

<h2>Reference</h2>

<ol>
<li><a href="https://medium.com/swift-programming/swift-sequences-ce22d76f120c">Swift Sequences</a></li>
<li><a href="https://medium.com/swift-programming/swift-collections-e5fff3cd6759">Swift Collections</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[åœ¨swiftå’ŒObjcä¹‹é—´è½¬æ¢çš„ä¸€äº›æƒ³æ³•]]></title>
    <link href="http://hongchaozhang.github.io/blog/2018/11/13/some-ideas-on-converting-between-objc-and-swift/"/>
    <updated>2018-11-13T10:50:18+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2018/11/13/some-ideas-on-converting-between-objc-and-swift</id>
    <content type="html"><![CDATA[<!-- more -->


<p>åœ¨å·¥ä½œä¸­æˆ‘ä»¬æœ‰æ—¶å€™éœ€è¦åœ¨swiftå’Œobjcä¹‹é—´è¿›è¡Œè½¬æ¢ï¼Œè¿™æ—¶å€™æœ‰æ²¡æœ‰ä¸€äº›å·¥å…·å¯ä»¥å¸®åŠ©æˆ‘ä»¬å‘¢ï¼Ÿ</p>

<blockquote><p>å½“ç„¶ï¼Œå¤§éƒ¨åˆ†æ—¶å€™ï¼Œæˆ‘ä»¬ä¸éœ€è¦è½¬æ¢ï¼Œå› ä¸ºswiftå’Œobjcçš„ç±»å’Œæ–¹æ³•å¯ä»¥äº’ç›¸æš´éœ²ç»™å¯¹æ–¹ã€‚</p></blockquote>

<h2>objcè½¬æ¢æˆswfit</h2>

<p>æœç´¢äº†ä¸€ä¸‹ï¼Œæ‰¾åˆ°äº†ä¸¤ä¸ªå·¥å…·å¯ä»¥åšè¿™ä¸ªäº‹æƒ…ï¼š</p>

<h3><a href="https://github.com/yahoojapan/objc2swift">objc2swift</a></h3>

<p>objc2swiftæ˜¯é›…è™æ—¥æœ¬çš„ä¸€ä¸ªå·¥å…·ï¼Œæ”¯æŒåœ¨çº¿è½¬æ¢ã€‚<a href="https://github.com/dzenbot/XCSwiftr/blob/master/README.md">XCSwiftr</a>å°±æ˜¯ä¸€ä¸ªåŸºäºobjc2swiftçš„xcodeæ’ä»¶ï¼Œé€šè¿‡<a href="https://github.com/alcatraz/Alcatraz">Alcatraz</a>è¿›è¡Œç®¡ç†å®‰è£…ï¼Œå¯ä»¥åœ¨Xcodeé‡Œé¢è¿›è¡Œobjcåˆ°swiftçš„è½¬æ¢ã€‚ä½†æ˜¯xcodeè‡ªä»8.0å¼€å§‹å°±ä¸æ”¯æŒæ’ä»¶äº†ã€‚</p>

<blockquote><p>æ’ä»¶(plugin)åªåœ¨xcode 8.0ä¹‹å‰çš„ç‰ˆæœ¬æ‰æ”¯æŒã€‚ä»8.0å¼€å§‹ï¼Œæ’ä»¶å°±ä¸å†æ”¯æŒï¼Œä½†æ˜¯å¼•å…¥äº†æ‰©å±•(extension)ã€‚æ‰©å±•å’Œæ’ä»¶ä¸åŒçš„ä¸€ç‚¹æ˜¯ï¼šæ‰©å±•åœ¨ç‹¬ç«‹çš„è¿›ç¨‹é‡Œé¢è¿è¡Œï¼Œæ‰€ä»¥æ‰©å±•çš„å´©æºƒä¸ä¼šå½±å“åˆ°xcodeï¼Œä½†æ˜¯æ’ä»¶çš„å´©æºƒï¼Œåˆ™ä¼šå¯¼è‡´xcodeä¹Ÿå´©æºƒã€‚ä¼°è®¡æ’ä»¶å´©æºƒå¯¼è‡´çš„xcodeå´©æºƒçš„é”…éƒ½æ˜¯Appleæ¥èƒŒï¼ŒAppleå¾ˆä¸çˆ½ï¼Œå°±è®©xcodeè·Ÿæ’ä»¶åˆ†å¼€åœ¨ä¸åŒçš„è¿›ç¨‹ä¸­è¿è¡Œã€‚</p></blockquote>

<p>objc2swiftçš„è½¬æ¢æ•ˆæœå¾ˆä¸€èˆ¬ã€‚</p>

<p>objcæºä»£ç ï¼š</p>

<pre><code>@interface MyClass: NSObject

- (void)sayHelloTo:(NSString*)person;

@end

@implementation MyClass

- (void)sayHelloTo:(NSString*)person {
    NSLog([NSString stringWithFormat:@"Hello, %@.", person]);
    [self performSelector:@selector(test)];

}

- (void)test {
}

@end
</code></pre>

<p>è½¬æ¢ä¹‹åï¼š</p>

<pre><code>class MyClass: NSObject {
    func sayHelloTo(person: String) {
        print("Hello, \(person).")
        self.performSelector("test")
    }

    func test() {

    }
}
</code></pre>

<p>å‡ ä¸ªé—®é¢˜ï¼š</p>

<ol>
<li>æ–¹æ³•åç§°æ²¡æœ‰æŒ‰ç…§swiftçš„ä¹ æƒ¯æ”¹å†™ï¼šåº”è¯¥ä¸º<code>sayHello(to person: String)</code>ï¼Œè€Œä¸æ˜¯<code>sayHelloTo(person: String)</code>ã€‚</li>
<li><code>performSelector:</code>æ–¹æ³•å®Œå…¨è½¬æ¢é”™è¯¯ï¼šæ–¹æ³•åç§°é”™è¯¯ï¼Œåº”è¯¥ä¸º<code>perform(_ aSelector: Selector!)</code>ï¼Œè€Œä¸”å‚æ•°ä¹Ÿé”™è¯¯ï¼Œä¸åº”è¯¥ä¸º<code>String</code>ç±»å‹ï¼Œåº”è¯¥ä¸º<code>Selector</code>ç±»å‹ã€‚</li>
<li><code>test</code>æ–¹æ³•å‰é¢æ²¡æœ‰åŠ ä¸Š<code>@objc</code>ï¼Œæ‰€ä»¥ä¸èƒ½ä½œä¸º<code>#selector</code>çš„å‚æ•°ã€‚</li>
</ol>


<h3><a href="https://objectivec2swift.com/#/home">Swiftify</a></h3>

<p>swiftifyä¹Ÿæ”¯æŒåœ¨çº¿è½¬æ¢ï¼Œè€Œä¸”è½¬æ¢æ•ˆæœæ˜æ˜¾å¥½äºobjc2swiftã€‚å¦‚æœæ„¿æ„èŠ±é’±ï¼Œswiftifyè¿˜å¯ä»¥æ”¯æŒå¾ˆå¤šåŠŸèƒ½ï¼ŒåŒ…æ‹¬xcodeæ‰©å±•ï¼ˆæ³¨æ„ï¼Œè¿™é‡Œæ˜¯â€œæ‰©å±•extensionâ€ï¼Œä¸æ˜¯â€œæ’ä»¶pluginâ€ï¼‰ã€finderæ‰©å±•ã€æ•´ä¸ªå·¥ç¨‹çš„è½¬æ¢ã€ç¦»çº¿è½¬æ¢ç­‰ã€‚</p>

<p><img src="/images/swiftify.webp" alt="swiftify.webp" /></p>

<p>åŒæ ·ç”¨ä¸Šè¿°objcæºä»£ç ï¼Œè½¬æ¢ä¹‹åä¸ºï¼š</p>

<pre><code>class MyClass: NSObject {
    func sayHello(to person: String?) {
        print("Hello Swift, Goodbye Obj-C!")
        perform(#selector(MyClass.test))
    }

    @objc func test() {
    }
}
</code></pre>

<h2>swiftè½¬æ¢æˆobjc</h2>

<p><a href="https://objectivec2swift.com/#/home">Swiftify</a>çš„ä½œè€…å†™äº†ä¸€ç¯‡åšå®¢<a href="https://www.quora.com/How-can-you-convert-Swift-to-Objective-C">How can you convert Swift to Objective-C?</a>ï¼Œè¯´æ˜äº†è¿™ä¸ªé—®é¢˜ï¼š</p>

<p>åŸæ–‡æ˜¯ï¼š</p>

<blockquote><p>When speaking about idiomatic Swift, converting method implementations from Swift to Objective-C is the task that cannot be solved for all cases. As you might imagine, many â€œmodernâ€ Swift features do not have any counterparts in Objective-C and thus cannot be converted without a human brain :)</p></blockquote>

<p>ç»“è®ºå°±æ˜¯ï¼šç”±äºswiftæœ‰å¾ˆå¤šobjcæ²¡æœ‰çš„è¯­è¨€ç‰¹æ€§ï¼Œæ‰€ä»¥swiftåˆ°objcæ— æ³•å®Œæˆè‡ªåŠ¨è½¬æ¢ã€‚</p>

<p>ä½†æ˜¯è½¬æ¢ä¹‹åçš„objcçš„å¤´æ–‡ä»¶å¯ä»¥ä»build in â€œGenerated Interfaceâ€ ([ProjectName]-Swift.h)é‡Œé¢æ‰¾åˆ°ï¼Œæ‹·è´å‡ºæ¥ï¼Œç¨ä½œä¿®æ”¹å³å¯ã€‚ä½†æ˜¯ä»…é™äºswiftæš´æ¼ç»™objcçš„æ¥å£å’Œå±æ€§ã€‚é‚£äº›æ²¡æœ‰æš´æ¼ç»™objcçš„æ¥å£å’Œå±æ€§ï¼Œå°±éœ€è¦æ‰‹åŠ¨å»è½¬æ¢å•¦ã€‚</p>

<blockquote><p>[ProjectName]-Swift.hå¦‚æœä¸èƒ½é€šè¿‡cmd+shift+Oæ‰¾åˆ°ï¼Œå¯ä»¥ä»å¼•ç”¨è¿™ä¸ªå¤´æ–‡ä»¶çš„objcæ–‡ä»¶ä¸­é€šè¿‡â€œgo to declaration"æ‰¾åˆ°ã€‚</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Coding Conventions]]></title>
    <link href="http://hongchaozhang.github.io/blog/2018/01/26/swift-coding-convention/"/>
    <updated>2018-01-26T11:37:05+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2018/01/26/swift-coding-convention</id>
    <content type="html"><![CDATA[<p>Collection of some Swift coding conventions, which will make Swift code more maintainable, more readable.</p>

<!-- more -->


<p>The following is conventions I like or I will likely misuse. For a complete version, go to:</p>

<ol>
<li><a href="https://github.com/raywenderlich/swift-style-guide/">The Official raywenderlich.com Swift Style Guide.</a></li>
<li>Swift <a href="https://swift.org/documentation/api-design-guidelines/">API Design Guidelines</a></li>
</ol>


<!-- TOC -->


<ul>
<li><a href="#naming">Naming</a>

<ul>
<li><a href="#try-to-form-grammatical-english-phrases">Try to Form Grammatical English Phrases</a></li>
<li><a href="#mutatingnonmutating-methods-naming">Mutating/Nonmutating Methods Naming</a></li>
<li><a href="#boolean-methods-naming">Boolean Methods Naming</a></li>
<li><a href="#protocol-naming">Protocol Naming</a></li>
<li><a href="#avoid-abbreviations">Avoid Abbreviations</a></li>
<li><a href="#delegates">Delegates</a></li>
</ul>
</li>
<li><a href="#code-organization">Code Organization</a>

<ul>
<li><a href="#protocol-conformance">Protocol Conformance</a></li>
</ul>
</li>
<li><a href="#classes-and-structures">Classes and Structures</a>

<ul>
<li><a href="#use-of-self">Use of Self</a></li>
<li><a href="#constants">Constants</a></li>
</ul>
</li>
<li><a href="#control-flow">Control Flow</a>

<ul>
<li><a href="#golden-path">Golden Path</a>

<ul>
<li><a href="#failing-guards">Failing Guards</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#argument-labels">Argument Labels</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-naming" name="naming"></a></p>

<h2>Naming</h2>

<p>Descriptive and consistent naming makes software easier to read and understand. Use the Swift naming conventions described in the <a href="https://swift.org/documentation/api-design-guidelines/">API Design Guidelines</a>. Some key principles include:</p>

<ol>
<li>prioritizing clarity over brevity</li>
<li>striving for fluent usage</li>
<li>using uppercase for types (and protocols), lowercase for everything else</li>
<li>boolean types should read like assertions</li>
<li>choosing good parameter names that serve as documentation</li>
<li>generally avoiding abbreviations</li>
<li>taking advantage of default parameters</li>
<li>labeling closure and tuple parameters</li>
<li>verb methods follow the -ed, -ing rule for the non-mutating version</li>
<li>noun methods follow the formX rule for the mutating version</li>
<li>protocols that describe what something is should read as nouns</li>
<li>protocols that describe a capability should end in -able or -ible</li>
<li>striving for clarity at the call site</li>
</ol>


<p><a id="markdown-try-to-form-grammatical-english-phrases" name="try-to-form-grammatical-english-phrases"></a></p>

<h3>Try to Form Grammatical English Phrases</h3>

<p><strong>Preferred:</strong></p>

<pre><code>x.insert(y, at: z)          // â€œx, insert y at zâ€
x.subViews(havingColor: y)  // â€œx's subviews having color yâ€
x.capitalizingNouns()       // â€œx, capitalizing nounsâ€
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code>x.insert(y, position: z)
x.subViews(color: y)
x.nounCapitalize()
</code></pre>

<p><a id="markdown-mutatingnonmutating-methods-naming" name="mutatingnonmutating-methods-naming"></a></p>

<h3>Mutating/Nonmutating Methods Naming</h3>

<p>When the operation is naturally described by a verb, use the verbâ€™s imperative for the mutating method and apply the â€œedâ€ or â€œingâ€ suffix to name its nonmutating counterpart.</p>

<table>
<thead>
<tr>
<th> Mutating  </th>
<th> Nonmutating </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>x.sort()</code>    </td>
<td> <code>z = x.sorted()</code> </td>
</tr>
<tr>
<td> <code>x.append(y)</code> </td>
<td> <code>z = x.appending(y)</code> </td>
</tr>
</tbody>
</table>


<p><br>
When the operation is naturally described by a noun, use the noun for the nonmutating method and apply the â€œformâ€ prefix to name its mutating counterpart.</p>

<table>
<thead>
<tr>
<th> Nonmutating   </th>
<th> Mutating </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>x = y.union(z)</code>  </td>
<td> <code>y.formUnion(z)</code> </td>
</tr>
<tr>
<td> <code>j = c.successor(i)</code>  </td>
<td> <code>c.formSuccessor(&amp;i)</code> </td>
</tr>
</tbody>
</table>


<p><a id="markdown-boolean-methods-naming" name="boolean-methods-naming"></a></p>

<h3>Boolean Methods Naming</h3>

<p>Uses of Boolean methods and properties should read as assertions about the receiver when the use is nonmutating, e.g. <code>x.isEmpty</code>, <code>line1.intersects(line2)</code>.</p>

<p><a id="markdown-protocol-naming" name="protocol-naming"></a></p>

<h3>Protocol Naming</h3>

<p>Protocols that describe what something is should read as nouns (e.g. <code>Collection</code>).</p>

<p>Protocols that describe a capability should be named using the suffixes -able, -ible, or -ing (e.g. <code>Equatable</code>, <code>ProgressReporting</code>).</p>

<p><a id="markdown-avoid-abbreviations" name="avoid-abbreviations"></a></p>

<h3>Avoid Abbreviations</h3>

<blockquote><p>The intended meaning for any abbreviation you use should be easily found by a <strong>web search</strong>.</p></blockquote>

<p><a id="markdown-delegates" name="delegates"></a></p>

<h3>Delegates</h3>

<p>When creating custom delegate methods, an unnamed first parameter should be the delegate source. (UIKit contains numerous examples of this.)</p>

<p><strong>Preferred:</strong></p>

<pre><code>func namePickerView(_ namePickerView: NamePickerView, didSelectName name: String)
func namePickerViewShouldReload(_ namePickerView: NamePickerView) -&gt; Bool
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code>func didSelectName(namePicker: NamePickerViewController, name: String)
func namePickerShouldReload() -&gt; Bool
</code></pre>

<p><a id="markdown-code-organization" name="code-organization"></a></p>

<h2>Code Organization</h2>

<p>Use extensions to organize your code into logical blocks of functionality. Each extension should be set off with a <code>// MARK: - comment</code> to keep things well-organized.</p>

<p><a id="markdown-protocol-conformance" name="protocol-conformance"></a></p>

<h3>Protocol Conformance</h3>

<p>In particular, when adding protocol conformance to a model, prefer adding a separate extension for the protocol methods. This keeps the related methods grouped together with the protocol and can simplify instructions to add a protocol to a class with its associated methods.</p>

<p><strong>Preferred:</strong></p>

<pre><code>class MyViewController: UIViewController {
  // class stuff here
}

// MARK: - UITableViewDataSource
extension MyViewController: UITableViewDataSource {
  // table view data source methods
}

// MARK: - UIScrollViewDelegate
extension MyViewController: UIScrollViewDelegate {
  // scroll view delegate methods
}
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code>class MyViewController: UIViewController, UITableViewDataSource, UIScrollViewDelegate {
  // all methods
}
</code></pre>

<p>For UIKit view controllers, consider grouping lifecycle, custom accessors, and IBAction in separate class extensions.</p>

<p><a id="markdown-classes-and-structures" name="classes-and-structures"></a></p>

<h2>Classes and Structures</h2>

<p><a id="markdown-use-of-self" name="use-of-self"></a></p>

<h3>Use of Self</h3>

<p>For conciseness, avoid using <code>self</code> since Swift does not require it to access an object&rsquo;s properties or invoke its methods.</p>

<p>Use <code>self</code> only when required by the compiler (in <code>@escaping</code> closures, or in initializers to disambiguate properties from arguments). In other words, if it compiles without <code>self</code> then omit it.</p>

<p><a id="markdown-constants" name="constants"></a></p>

<h3>Constants</h3>

<p>Constants are defined using the <code>let</code> keyword, and variables with the <code>var</code> keyword. Always use <code>let</code> instead of <code>var</code> if the value of the variable will not change.</p>

<blockquote><p>Tip: A good technique is to define everything using <code>let</code> and only change it to <code>var</code> if the compiler complains!</p></blockquote>

<p>You can define constants on a type rather than on an instance of that type using type properties. To declare a type property as a constant simply use <code>static let</code>. Type properties declared in this way are generally preferred over global constants because they are easier to distinguish from instance properties.</p>

<p><strong>Preferred:</strong></p>

<pre><code>enum Math {
  static let e = 2.718281828459045235360287
  static let root2 = 1.41421356237309504880168872
}

let hypotenuse = side * Math.root2
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code>let e = 2.718281828459045235360287  // pollutes global namespace
let root2 = 1.41421356237309504880168872

let hypotenuse = side * root2 // what is root2?
</code></pre>

<p><a id="markdown-control-flow" name="control-flow"></a></p>

<h2>Control Flow</h2>

<p><a id="markdown-golden-path" name="golden-path"></a></p>

<h3>Golden Path</h3>

<p>When coding with conditionals, the left-hand margin of the code should be the &ldquo;golden&rdquo; or &ldquo;happy&rdquo; path. That is, don&rsquo;t nest <code>if</code> statements. Multiple return statements are OK. The <code>guard</code> statement is built for this.</p>

<p><strong>Preferred:</strong></p>

<pre><code>func computeFFT(context: Context?, inputData: InputData?) throws -&gt; Frequencies {

  guard let context = context else {
    throw FFTError.noContext
  }
  guard let inputData = inputData else {
    throw FFTError.noInputData
  }

  // use context and input to compute the frequencies
  return frequencies
}
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code>func computeFFT(context: Context?, inputData: InputData?) throws -&gt; Frequencies {

  if let context = context {
    if let inputData = inputData {
      // use context and input to compute the frequencies

      return frequencies
    } else {
      throw FFTError.noInputData
    }
  } else {
    throw FFTError.noContext
  }
}
</code></pre>

<p>When multiple optionals are unwrapped either with <code>guard</code> or <code>if let</code>, minimize nesting by using the compound version when possible. Example:</p>

<p><strong>Preferred:</strong></p>

<pre><code>guard let number1 = number1,
      let number2 = number2,
      let number3 = number3 else {
  fatalError("impossible")
}
// do something with numbers
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code>if let number1 = number1 {
  if let number2 = number2 {
    if let number3 = number3 {
      // do something with numbers
    } else {
      fatalError("impossible")
    }
  } else {
    fatalError("impossible")
  }
} else {
  fatalError("impossible")
}
</code></pre>

<p><a id="markdown-failing-guards" name="failing-guards"></a></p>

<h4>Failing Guards</h4>

<p><code>guard</code> statements are required to exit in some way. Generally, this should be simple one line statement such as <code>return</code>, <code>throw</code>, <code>break</code>, <code>continue</code>, and <code>fatalError()</code>. Large code blocks should be avoided. If cleanup code is required for multiple exit points, consider using a <code>defer</code> block to avoid cleanup code duplication.</p>

<p><a id="markdown-argument-labels" name="argument-labels"></a></p>

<h2>Argument Labels</h2>

<ol>
<li>Good practice</li>
</ol>


<pre><code>func move(from start: Point, to end: Point)
x.move(from: x, to: y) 
</code></pre>

<ol>
<li><p>Omit all labels when arguments canâ€™t be usefully distinguished, e.g. <code>min(number1, number2)</code>, <code>zip(sequence1, sequence2)</code>.</p></li>
<li><p>When the first argument forms part of a prepositional phrase, give it an argument label. The argument label should normally begin at the preposition, e.g. <code>x.removeBoxes(havingLength: 12)</code>.</p>

<ul>
<li>An exception for the principle above arises when the first two arguments represent parts of a single abstraction. In such cases, begin the argument label after the preposition, to keep the abstraction clear.</li>
</ul>
</li>
</ol>


<p><strong>Preferred:</strong></p>

<pre><code>a.moveTo(x: b, y: c)
a.fadeFrom(red: b, green: c, blue: d)
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code>a.move(toX: b, y: c)
a.fade(fromRed: b, green: c, blue: d)
</code></pre>
]]></content>
  </entry>
  
</feed>
