<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2020-11-16T21:39:18+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift Closure]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/06/04/on-swift-closure/"/>
    <updated>2019-06-04T17:24:47+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/06/04/on-swift-closure</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#function%E4%B8%8Eclosure%E7%9A%84%E5%85%B3%E7%B3%BB">Function与Closure的关系：</a></li>
<li><a href="#%E7%94%A8closure%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F">用Closure初始化一个变量</a></li>
<li><a href="#closure%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">Closure的语法糖：</a></li>
<li><a href="#closure%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">Closure与内存管理、内存泄漏</a>

<ul>
<li><a href="#capture-list%E7%9A%84%E5%AE%9A%E4%B9%89">Capture List的定义</a></li>
<li><a href="#weak-and-unowned-references">Weak and Unowned References</a></li>
</ul>
</li>
<li><a href="#closure%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F">Closure捕获变量</a></li>
</ul>


<p><a href="https://medium.com/@abhimuralidharan/functional-swift-all-about-closures-310bc8af31dd">Functional swift: All about Closures</a></p>

<p>这篇全面详细易懂地介绍了Swift的Closure，包括</p>

<ul>
<li>Closure的语法，包括一些简化写法，如Trailing Closures</li>
<li>Closure与Function的区别</li>
<li>Closure与内存管理、内存泄漏，如capture list的使用，weak与unowned的区别</li>
<li>Functions和closures都是引用类型，不是值类型</li>
</ul>


<p>也可以看<a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">官方文档Closures</a>，但是官方文档没有上面的文章详细。</p>

<p>下面有选择地记录一下。</p>

<p><a id="markdown-function与closure的关系" name="function与closure的关系"></a></p>

<h2>Function与Closure的关系：</h2>

<p>参考<a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">官方文档Closures</a>里面的三句话理解一下：</p>

<blockquote><ul>
<li>Global functions are closures that have a name and do not capture any values.</li>
<li>Nested functions are closures that have a name and can capture values from their enclosing function.</li>
<li>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</li>
</ul>
</blockquote>

<p>还有一点很重要：<strong>Closures and functions are first class types in swift</strong>。</p>

<blockquote><p>Functions and closures are first-class citizens in Swift because you can treat then like a normal value. For example, you can：</p>

<ul>
<li>assign a function/closure to a local variable .</li>
<li>pass a function/closure as an argument .</li>
<li>return a function/closure .</li>
</ul>
</blockquote>

<p><a id="markdown-用closure初始化一个变量" name="用closure初始化一个变量"></a></p>

<h2>用Closure初始化一个变量</h2>

<pre><code class="swift">let setupViewUsingClosure: UIView = {
    let view = UIView()
    view.backgroundColor = .green
    return view
}() //IMPORTANT!!! I have added () at the end.
</code></pre>

<p><a id="markdown-closure的语法糖" name="closure的语法糖"></a></p>

<h2>Closure的语法糖：</h2>

<p><a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">官方文档Closures</a>有个总的说明：</p>

<blockquote><p>Swift’s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios. These optimizations include:</p>

<ul>
<li>Inferring parameter and return value types from context</li>
<li>Implicit returns from single-expression closures</li>
<li>Shorthand argument names</li>
<li>Trailing closure syntax</li>
</ul>
</blockquote>

<p>当你第一次看到这个写法的时候肯定很疑惑：参数、类型、函数调用时的括号都跑哪去了？</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<p>理解了上面几点，就可以明白为什么可以这么写，下面让我们一步步看清楚。</p>

<p>Closure的定义如下：</p>

<blockquote><p>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</p>

<pre><code class="swift">{ (params) -&gt; returnType in
    statements
}
</code></pre></blockquote>

<p>举个具体的例子：</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<p>因为：</p>

<blockquote><ul>
<li><strong>Inferring parameter and return value types from context</strong></li>
</ul>


<p>Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns.</p></blockquote>

<p>所以，上面的代码可以写为：</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )
</code></pre>

<p>再因为：</p>

<blockquote><ul>
<li><strong>Implicit returns from single-expression closures</strong></li>
</ul>


<p>Single-expression closures can implicitly return the result of their single expression by omitting the return keyword from their declaration.</p></blockquote>

<p>所以，代码继续改为：</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
</code></pre>

<p>再因为：</p>

<blockquote><ul>
<li><strong>Shorthand argument names</strong></li>
</ul>


<p>Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names $0, $1, $2, and so on.</p></blockquote>

<p>代码继续改为：</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted(by: { $0 &gt; $1 } )
</code></pre>

<p>再因为：</p>

<blockquote><ul>
<li><strong>Trailing closure syntax</strong></li>
</ul>


<p>If you need to pass a closure expression to a function as the function’s final argument and the closure expression is long, it can be useful to write it as a trailing closure instead. A trailing closure is written after the function call’s parentheses, even though it is still an argument to the function. When you use the trailing closure syntax, you don’t write the argument label for the closure as part of the function call.</p></blockquote>

<p>代码就可以写成：</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<p><a id="markdown-closure与内存管理内存泄漏" name="closure与内存管理内存泄漏"></a></p>

<h2>Closure与内存管理、内存泄漏</h2>

<p>Closure带来的循环引用和内存泄漏，主要通过Capture List来解决：</p>

<blockquote><p>You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closure’s definition. A capture list defines the rules to use when capturing one or more reference types within the closure’s body.</p></blockquote>

<p>详细内容参考<a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID56">Resolving Strong Reference Cycles for Closures</a>。下面摘要一下。</p>

<p><a id="markdown-capture-list的定义" name="capture-list的定义"></a></p>

<h3>Capture List的定义</h3>

<blockquote><p>Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self) or a variable initialized with some value (such as delegate = self.delegate!). These pairings are written within a pair of square braces, separated by commas.</p></blockquote>

<p>Place the capture list before a closure’s parameter list and return type if they are provided:</p>

<pre><code class="swift">lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
    // closure body goes here
}
</code></pre>

<p><a id="markdown-weak-and-unowned-references" name="weak-and-unowned-references"></a></p>

<h3>Weak and Unowned References</h3>

<blockquote><p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p>

<p>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future. Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.</p>

<p>NOTE: If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.</p></blockquote>

<p>关于unowned的另一个解释更清楚：</p>

<blockquote><p>Like a weak reference, an unowned reference does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime.</p></blockquote>

<p><a id="markdown-closure捕获变量" name="closure捕获变量"></a></p>

<h2>Closure捕获变量</h2>

<blockquote><p>Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as closing over those constants and variables.</p></blockquote>

<p>比如：</p>

<pre><code class="swift">// capturing values
var i = 0
var closureArray = [()-&gt;()]()
for _ in 1...5 {
    closureArray.append {
        print(i)
    }
    i += 1
}
// here i will be 5
closureArray[0]() // prints 5
closureArray[1]() // prints 5
closureArray[2]() // prints 5
closureArray[3]() // prints 5
closureArray[4]() // prints 5
</code></pre>

<p>The closure captures the current address of <code>i</code> and every time we access <code>i</code> , it . returns the current value.</p>

<p>If we want to prevent this behavior (capturing values) and print the value of i even if the properties change after their capturing inside the closure, we can explicitly capture the variable with a capture list like this:</p>

<pre><code class="swift">var closureArray2 = [()-&gt;()]()
var j = 0
for _ in 1...5 {
    closureArray2.append { [j] in
        print(j)
    }
    j += 1
}
// here i will be 5
closureArray2[0]() // prints 0
closureArray2[1]() // prints 1
closureArray2[2]() // prints 2
closureArray2[3]() // prints 3
closureArray2[4]() // prints 4
</code></pre>

<p>In this way, we keep an immutable copy of the variable <code>j</code>. Thanks to this copy, further changes to <code>j</code>, outside the closure, will not affect the closure. <code>j</code> is a let constant here. It is not mutable.</p>

<p>We can add multiple values to the capture list :</p>

<pre><code class="swift">closure.append { [j,k,l] in
    print("\(j) \(k) \(l)")
}
</code></pre>

<p>also, you can have alias names for the values captured.</p>

<pre><code class="swift">closure.append { [a = j, b = k, c = l] in
    print("\(a) \(b) \(c)")
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sequece and Collection in Swift]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/06/03/sequece-and-collection-in-swift/"/>
    <updated>2019-06-03T16:22:33+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/06/03/sequece-and-collection-in-swift</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#array-out-of-range-crash"><code>Array</code> out of Range Crash</a></li>
<li><a href="#homemade-collection">Homemade collection</a></li>
<li><a href="#sequences">Sequences</a>

<ul>
<li><a href="#how-to-conform-to-sequence-protocol">How to Conform to <code>Sequence</code> Protocol</a></li>
<li><a href="#make-our-section-conform-to-sequence-protocol">Make our <code>Section</code> Conform to <code>Sequence</code> Protocol</a></li>
<li><a href="#gifts">Gifts</a></li>
</ul>
</li>
<li><a href="#collections">Collections</a>

<ul>
<li><a href="#how-to-conform-to-collection-protocol">How to Conform to <code>Collection</code> Protocol</a></li>
<li><a href="#make-our-section-conform-to-collection-protocol">Make our <code>Section</code> Conform to <code>Collection</code> Protocol</a></li>
</ul>
</li>
<li><a href="#difference-between-array-and-collection">Difference between <code>Array</code> and <code>Collection</code></a></li>
<li><a href="#reference">Reference</a></li>
</ul>


<p>The content comes from the following posts:</p>

<ol>
<li><a href="https://medium.com/swift-programming/swift-sequences-ce22d76f120c">Swift Sequences</a></li>
<li><a href="https://medium.com/swift-programming/swift-collections-e5fff3cd6759">Swift Collections</a></li>
</ol>


<p>But some of the code inside is old and can&rsquo;t be compiled with swift 5.0. So rewritten the code using swift 5.0.</p>

<p><a id="markdown-array-out-of-range-crash" name="array-out-of-range-crash"></a></p>

<h2><code>Array</code> out of Range Crash</h2>

<p>Before diving into Swift Sequences, let’s see a strange behavior.</p>

<pre><code class="swift">let array = [1, 2, 3]
array[7] 😭

let dic = ["a": 1, "b": 2]
dic["z"] 😎

🤔
</code></pre>

<p>In other words, when requesting an element that doesn’t exist, why arrays crash whereas dictionaries don’t?</p>

<p>Arrays and dictionaries are two base collections provided by the Swift standard library. We can access those collections elements through the [] notation, also known as subscript. Let’s see how those subscripts are defined.</p>

<pre><code class="swift">struct Array&lt;Element&gt; {
    subscript(index: Int) -&gt; Element
}

struct Dictionary&lt;Key: Hashable, Value&gt; {
    subscript(key: Key) -&gt; Value?
}
</code></pre>

<p>What’s interesting is that arrays have a non optional return type. Subscript can’t throw errors so there are no alternatives other than a fatalError if we request an index that doesn’t exist.</p>

<p>For dictionaries, on the other hand, an optional Value is returned, which allows to gracefully return nil if the index doesn’t exist.</p>

<p>We can adopt dictionaries safer approach by overloading the arrays subscript — we can’t override them. Adding an external name to the parameter is enough.</p>

<pre><code class="swift">extension Array {
    subscript(safe index: Int) -&gt; Element? {
        return index &gt;= 0 &amp;&amp; index &lt; count ? self[index] : nil
    }
}
</code></pre>

<p>We saw how we can create a new accessor to the elements of an array, but can we do the same with a homemade collection?</p>

<p><a id="markdown-homemade-collection" name="homemade-collection"></a></p>

<h2>Homemade collection</h2>

<pre><code class="swift">struct Section&lt;T&gt; {
    let title: String
    let elements: [T]
}
</code></pre>

<p>Internally, this ‘collection’ is based on an array. This is an implementation detail for the simplicity of the example. We could have used a linked list as in this <a href="http://austinzheng.com/2015/01/24/swift-seq/">excellent article</a> by <a href="https://twitter.com/austinzheng">Austin Zheng</a>.</p>

<p>Creating a subscript on our collection is very easy, we can even reuse the array’s extension we made earlier.</p>

<pre><code class="swift">struct Section&lt;T&gt; {
    let title: String
    let elements: [T]

    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }
}
</code></pre>

<p>An example in practice :</p>

<pre><code class="swift">let cars = ["911", "Cayman", "Cayenne"]
let section = Section(title: "Porsche", elements: cars)

section[1]
// Optional("Cayman")
</code></pre>

<p>Great! But does that make our type a collection, as Swift defines it?</p>

<p><a id="markdown-sequences" name="sequences"></a></p>

<h2>Sequences</h2>

<p>When it comes to manipulating sets, the most abstract notion given by the standard library is the Sequence, defined as</p>

<blockquote><p>A type that can be iterated with a <code>for…in</code> loop.</p></blockquote>

<p><a id="markdown-how-to-conform-to-sequence-protocol" name="how-to-conform-to-sequence-protocol"></a></p>

<h3>How to Conform to <code>Sequence</code> Protocol</h3>

<p>This section is from <a href="https://developer.apple.com/documentation/swift/sequence">Sequece official site</a>.</p>

<p>Making your own custom types conform to Sequence enables many useful operations, like for-in looping and the contains method, without much effort. To add Sequence conformance to your own custom type, add a makeIterator() method that returns an iterator.</p>

<p>Alternatively, if your type can act as its own iterator, implementing the requirements of the IteratorProtocol protocol and declaring conformance to both Sequence and IteratorProtocol are sufficient.</p>

<p>Here’s a definition of a Countdown sequence that serves as its own iterator. The makeIterator() method is provided as a default implementation.</p>

<pre><code class="swift">struct Countdown: Sequence, IteratorProtocol {
    var count: Int

    mutating func next() -&gt; Int? {
        if count == 0 {
            return nil
        } else {
            defer { count -= 1 }
            return count
        }
    }
}

let threeToGo = Countdown(count: 3)
for i in threeToGo {
    print(i)
}
// Prints "3"
// Prints "2"
// Prints "1"
</code></pre>

<p><a id="markdown-make-our-section-conform-to-sequence-protocol" name="make-our-section-conform-to-sequence-protocol"></a></p>

<h3>Make our <code>Section</code> Conform to <code>Sequence</code> Protocol</h3>

<p>The <code>Section</code> struct can&rsquo;t act as its own iterator, we need to define an iterator for it, and then return an instance of the defined iterator inside <code>func makeIterator() -&gt; Section&lt;T&gt;.Iterator</code> method.</p>

<pre><code class="swift">struct Section&lt;T&gt;: Sequence {
    let title: String
    let elements: [T]

    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }

    struct Iterator: IteratorProtocol {
        let array: [T]
        var currentIndex = 0

        init (_ array: [T]) {
            self.array = array
        }

        mutating func next() -&gt; T? {
            let tempIndex = currentIndex
            currentIndex += 1
            return array[safe: tempIndex]

        }
    }

    func makeIterator() -&gt; Section&lt;T&gt;.Iterator {
        return Iterator(elements)
    }
}
</code></pre>

<p><a id="markdown-gifts" name="gifts"></a></p>

<h3>Gifts</h3>

<p>Is that all? No! By conforming to SequenceType we also get methods for free, here is some of them.</p>

<pre><code class="swift">section.min()
// 911
section.max()
// Cayman
section.sorted()
// ["911", "Cayenne", "Cayman"]
section.contains("911")
// true
</code></pre>

<p>We get the min, max &amp; sort methods because the elements of our sequence, String in our case, are Comparable. Contains is available thanks to our elements being Equatable.</p>

<pre><code class="swift">section.filter { $0.count &gt; 3 }
// ["Cayman", "Cayenne"]
section.map { $0.count }
// [3, 6, 7]
section.reduce(0) { $0 + $1.count }
// 16
</code></pre>

<p>And for functional programming fans, filter, map and reduce are also given.</p>

<p><a id="markdown-collections" name="collections"></a></p>

<h2>Collections</h2>

<p>Sequence is the most basic set notion given by the Swift standard library. There is a more evolved one.</p>

<p>A collection is defined as follow :</p>

<blockquote><p>A multi-pass <em>sequence</em> with addressable positions</p></blockquote>

<p>As we saw previously, a sequence is a type that can be iterated with a <code>for…in</code> loop. It doesn’t need that the elements might be iterated over several times. And it doesn’t need that we give a way to access directly an element.</p>

<p>Collections require those last two points. As a side effect, it no longer allows us to have an infinite number of elements.</p>

<p>To be a collection, a type must conform to the <code>Collection</code> protocol.</p>

<p><a id="markdown-how-to-conform-to-collection-protocol" name="how-to-conform-to-collection-protocol"></a></p>

<h3>How to Conform to <code>Collection</code> Protocol</h3>

<p>This section comes from <a href="https://developer.apple.com/documentation/swift/collection">Collection official site</a>.</p>

<p>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the Collection protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add Collection conformance to your type, you must declare at least the following requirements:</p>

<ol>
<li>The <code>startIndex</code> and <code>endIndex</code> properties</li>
<li>A subscript that provides at least read-only access to your type’s elements</li>
<li>The <code>index(after:)</code> method for advancing an index into your collection</li>
<li>Conform to <code>Sequece</code> Protocol, as <code>Collection</code> is inherited from <code>Sequence</code></li>
</ol>


<p><a id="markdown-make-our-section-conform-to-collection-protocol" name="make-our-section-conform-to-collection-protocol"></a></p>

<h3>Make our <code>Section</code> Conform to <code>Collection</code> Protocol</h3>

<pre><code class="swift">struct Section&lt;T&gt;: Collection {
    let title: String
    let elements: [T]

    // begin: required for Collection
    var startIndex: Int { return 0 }
    var endIndex: Int { return elements.count }

    func index(after i: Int) -&gt; Int {
        return i + 1
    }

    subscript(index: Int) -&gt; T {
        return elements[index]
    }
    // end: required for Collection


    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }


    // begin: required for Sequence
    struct Iterator: IteratorProtocol {
        let array: [T]
        var currentIndex = 0

        init (_ array: [T]) {
            self.array = array
        }

        mutating func next() -&gt; T? {
            let tempIndex = currentIndex
            currentIndex += 1
            return array[safe: tempIndex]

        }
    }

    func makeIterator() -&gt; Section&lt;T&gt;.Iterator {
        return Iterator(elements)
    }
    // end: required for Sequence
}
</code></pre>

<p>The <code>endIndex</code> has to be after the last element. It allows to define an empty collection with <code>startIndex</code> = <code>endIndex</code>.</p>

<p>Like conforming to <code>Sequence</code>, we get some methods / properties for free:</p>

<pre><code class="swift">section.count
// 3
section.first
// 911
section.isEmpty
// false
section.index(of: "911")
// 0
</code></pre>

<p>We get indexOf thanks to our Elements being Equatable.</p>

<p><a id="markdown-difference-between-array-and-collection" name="difference-between-array-and-collection"></a></p>

<h2>Difference between <code>Array</code> and <code>Collection</code></h2>

<p>We created our own collection, which is great, but what about that difference of behavior between Arrays and Dictionaries we talked about at the beginning of the post? We saw that Array’s dangerous subscript was coming from the Indexable protocol, but what about Dictionaries?</p>

<p>Dictionaries, like Arrays, are a collection, as Swift defines it. They both conform to CollectionType. So Dictionaries are also required to provide an ‘unsafe’ subscript that takes an Index and returns a non optional Element. The one we’re used to is just a convenience subscript.</p>

<p>A simple example shows that it is also really easy to get a crash with Dictionaries.</p>

<pre><code class="swift">let dic = ["a": "bmw", "b": "audi", "c": "citroen"]

var index = dic.startIndex
dic[index]
// (key: "c", value: "citroen")

index = dic.index(after: index)
print(dic[index])
// (key: "b", value: "audi")

index = dic.index(after: index)
index = dic.index(after: index)
dic[index]
// Fatal error
</code></pre>

<p><strong>The last question that remains is why <code>Collection</code> requires a subscript that may crash? Simply for performance reason, it costs too much to check the validity of the given index. Crashing is faster :)</strong></p>

<p><a id="markdown-reference" name="reference"></a></p>

<h2>Reference</h2>

<ol>
<li><a href="https://medium.com/swift-programming/swift-sequences-ce22d76f120c">Swift Sequences</a></li>
<li><a href="https://medium.com/swift-programming/swift-collections-e5fff3cd6759">Swift Collections</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在swift和Objc之间转换的一些想法]]></title>
    <link href="http://hongchaozhang.github.io/blog/2018/11/13/some-ideas-on-converting-between-objc-and-swift/"/>
    <updated>2018-11-13T10:50:18+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2018/11/13/some-ideas-on-converting-between-objc-and-swift</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在工作中我们有时候需要在swift和objc之间进行转换，这时候有没有一些工具可以帮助我们呢？</p>

<blockquote><p>当然，大部分时候，我们不需要转换，因为swift和objc的类和方法可以互相暴露给对方。</p></blockquote>

<h2>objc转换成swfit</h2>

<p>搜索了一下，找到了两个工具可以做这个事情：</p>

<h3><a href="https://github.com/yahoojapan/objc2swift">objc2swift</a></h3>

<p>objc2swift是雅虎日本的一个工具，支持在线转换。<a href="https://github.com/dzenbot/XCSwiftr/blob/master/README.md">XCSwiftr</a>就是一个基于objc2swift的xcode插件，通过<a href="https://github.com/alcatraz/Alcatraz">Alcatraz</a>进行管理安装，可以在Xcode里面进行objc到swift的转换。但是xcode自从8.0开始就不支持插件了。</p>

<blockquote><p>插件(plugin)只在xcode 8.0之前的版本才支持。从8.0开始，插件就不再支持，但是引入了扩展(extension)。扩展和插件不同的一点是：扩展在独立的进程里面运行，所以扩展的崩溃不会影响到xcode，但是插件的崩溃，则会导致xcode也崩溃。估计插件崩溃导致的xcode崩溃的锅都是Apple来背，Apple很不爽，就让xcode跟插件分开在不同的进程中运行。</p></blockquote>

<p>objc2swift的转换效果很一般。</p>

<p>objc源代码：</p>

<pre><code class="objc">@interface MyClass: NSObject

- (void)sayHelloTo:(NSString*)person;

@end

@implementation MyClass

- (void)sayHelloTo:(NSString*)person {
    NSLog([NSString stringWithFormat:@"Hello, %@.", person]);
    [self performSelector:@selector(test)];

}

- (void)test {
}

@end
</code></pre>

<p>转换之后：</p>

<pre><code class="swift">class MyClass: NSObject {
    func sayHelloTo(person: String) {
        print("Hello, \(person).")
        self.performSelector("test")
    }

    func test() {

    }
}
</code></pre>

<p>几个问题：</p>

<ol>
<li>方法名称没有按照swift的习惯改写：应该为<code>sayHello(to person: String)</code>，而不是<code>sayHelloTo(person: String)</code>。</li>
<li><code>performSelector:</code>方法完全转换错误：方法名称错误，应该为<code>perform(_ aSelector: Selector!)</code>，而且参数也错误，不应该为<code>String</code>类型，应该为<code>Selector</code>类型。</li>
<li><code>test</code>方法前面没有加上<code>@objc</code>，所以不能作为<code>#selector</code>的参数。</li>
</ol>


<h3><a href="https://objectivec2swift.com/#/home">Swiftify</a></h3>

<p>swiftify也支持在线转换，而且转换效果明显好于objc2swift。如果愿意花钱，swiftify还可以支持很多功能，包括xcode扩展（注意，这里是“扩展extension”，不是“插件plugin”）、finder扩展、整个工程的转换、离线转换等。</p>

<p><img src="/images/swiftify.webp" alt="swiftify.webp" /></p>

<p>同样用上述objc源代码，转换之后为：</p>

<pre><code class="swift">class MyClass: NSObject {
    func sayHello(to person: String?) {
        print("Hello Swift, Goodbye Obj-C!")
        perform(#selector(MyClass.test))
    }

    @objc func test() {
    }
}
</code></pre>

<h2>swift转换成objc</h2>

<p><a href="https://objectivec2swift.com/#/home">Swiftify</a>的作者写了一篇博客<a href="https://www.quora.com/How-can-you-convert-Swift-to-Objective-C">How can you convert Swift to Objective-C?</a>，说明了这个问题：</p>

<p>原文是：</p>

<blockquote><p>When speaking about idiomatic Swift, converting method implementations from Swift to Objective-C is the task that cannot be solved for all cases. As you might imagine, many “modern” Swift features do not have any counterparts in Objective-C and thus cannot be converted without a human brain :)</p></blockquote>

<p>结论就是：由于swift有很多objc没有的语言特性，所以swift到objc无法完成自动转换。</p>

<p>但是转换之后的objc的头文件可以从build in “Generated Interface” ([ProjectName]-Swift.h)里面找到，拷贝出来，稍作修改即可。但是仅限于swift暴漏给objc的接口和属性。那些没有暴漏给objc的接口和属性，就需要手动去转换啦。</p>

<blockquote><p>[ProjectName]-Swift.h如果不能通过cmd+shift+O找到，可以从引用这个头文件的objc文件中通过“go to declaration"找到。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Coding Conventions]]></title>
    <link href="http://hongchaozhang.github.io/blog/2018/01/26/swift-coding-convention/"/>
    <updated>2018-01-26T11:37:05+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2018/01/26/swift-coding-convention</id>
    <content type="html"><![CDATA[<p>Collection of some Swift coding conventions, which will make Swift code more maintainable, more readable.</p>

<!-- more -->


<p>The following is conventions I like or I will likely misuse. For a complete version, go to:</p>

<ol>
<li><a href="https://github.com/raywenderlich/swift-style-guide/">The Official raywenderlich.com Swift Style Guide.</a></li>
<li>Swift <a href="https://swift.org/documentation/api-design-guidelines/">API Design Guidelines</a></li>
</ol>


<!-- TOC -->


<ul>
<li><a href="#naming">Naming</a>

<ul>
<li><a href="#try-to-form-grammatical-english-phrases">Try to Form Grammatical English Phrases</a></li>
<li><a href="#mutatingnonmutating-methods-naming">Mutating/Nonmutating Methods Naming</a></li>
<li><a href="#boolean-methods-naming">Boolean Methods Naming</a></li>
<li><a href="#protocol-naming">Protocol Naming</a></li>
<li><a href="#avoid-abbreviations">Avoid Abbreviations</a></li>
<li><a href="#delegates">Delegates</a></li>
</ul>
</li>
<li><a href="#code-organization">Code Organization</a>

<ul>
<li><a href="#protocol-conformance">Protocol Conformance</a></li>
</ul>
</li>
<li><a href="#classes-and-structures">Classes and Structures</a>

<ul>
<li><a href="#use-of-self">Use of Self</a></li>
<li><a href="#constants">Constants</a></li>
</ul>
</li>
<li><a href="#control-flow">Control Flow</a>

<ul>
<li><a href="#golden-path">Golden Path</a>

<ul>
<li><a href="#failing-guards">Failing Guards</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#argument-labels">Argument Labels</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-naming" name="naming"></a></p>

<h2>Naming</h2>

<p>Descriptive and consistent naming makes software easier to read and understand. Use the Swift naming conventions described in the <a href="https://swift.org/documentation/api-design-guidelines/">API Design Guidelines</a>. Some key principles include:</p>

<ol>
<li>prioritizing clarity over brevity</li>
<li>striving for fluent usage</li>
<li>using uppercase for types (and protocols), lowercase for everything else</li>
<li>boolean types should read like assertions</li>
<li>choosing good parameter names that serve as documentation</li>
<li>generally avoiding abbreviations</li>
<li>taking advantage of default parameters</li>
<li>labeling closure and tuple parameters</li>
<li>verb methods follow the -ed, -ing rule for the non-mutating version</li>
<li>noun methods follow the formX rule for the mutating version</li>
<li>protocols that describe what something is should read as nouns</li>
<li>protocols that describe a capability should end in -able or -ible</li>
<li>striving for clarity at the call site</li>
</ol>


<p><a id="markdown-try-to-form-grammatical-english-phrases" name="try-to-form-grammatical-english-phrases"></a></p>

<h3>Try to Form Grammatical English Phrases</h3>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">x.insert(y, at: z)          // “x, insert y at z”
x.subViews(havingColor: y)  // “x's subviews having color y”
x.capitalizingNouns()       // “x, capitalizing nouns”
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">x.insert(y, position: z)
x.subViews(color: y)
x.nounCapitalize()
</code></pre>

<p><a id="markdown-mutatingnonmutating-methods-naming" name="mutatingnonmutating-methods-naming"></a></p>

<h3>Mutating/Nonmutating Methods Naming</h3>

<p>When the operation is naturally described by a verb, use the verb’s imperative for the mutating method and apply the “ed” or “ing” suffix to name its nonmutating counterpart.</p>

<table>
<thead>
<tr>
<th> Mutating  </th>
<th> Nonmutating </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>x.sort()</code>    </td>
<td> <code>z = x.sorted()</code> </td>
</tr>
<tr>
<td> <code>x.append(y)</code> </td>
<td> <code>z = x.appending(y)</code> </td>
</tr>
</tbody>
</table>


<p><br>
When the operation is naturally described by a noun, use the noun for the nonmutating method and apply the “form” prefix to name its mutating counterpart.</p>

<table>
<thead>
<tr>
<th> Nonmutating   </th>
<th> Mutating </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>x = y.union(z)</code>  </td>
<td> <code>y.formUnion(z)</code> </td>
</tr>
<tr>
<td> <code>j = c.successor(i)</code>  </td>
<td> <code>c.formSuccessor(&amp;i)</code> </td>
</tr>
</tbody>
</table>


<p><a id="markdown-boolean-methods-naming" name="boolean-methods-naming"></a></p>

<h3>Boolean Methods Naming</h3>

<p>Uses of Boolean methods and properties should read as assertions about the receiver when the use is nonmutating, e.g. <code>x.isEmpty</code>, <code>line1.intersects(line2)</code>.</p>

<p><a id="markdown-protocol-naming" name="protocol-naming"></a></p>

<h3>Protocol Naming</h3>

<p>Protocols that describe what something is should read as nouns (e.g. <code>Collection</code>).</p>

<p>Protocols that describe a capability should be named using the suffixes -able, -ible, or -ing (e.g. <code>Equatable</code>, <code>ProgressReporting</code>).</p>

<p><a id="markdown-avoid-abbreviations" name="avoid-abbreviations"></a></p>

<h3>Avoid Abbreviations</h3>

<blockquote><p>The intended meaning for any abbreviation you use should be easily found by a <strong>web search</strong>.</p></blockquote>

<p><a id="markdown-delegates" name="delegates"></a></p>

<h3>Delegates</h3>

<p>When creating custom delegate methods, an unnamed first parameter should be the delegate source. (UIKit contains numerous examples of this.)</p>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">func namePickerView(_ namePickerView: NamePickerView, didSelectName name: String)
func namePickerViewShouldReload(_ namePickerView: NamePickerView) -&gt; Bool
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">func didSelectName(namePicker: NamePickerViewController, name: String)
func namePickerShouldReload() -&gt; Bool
</code></pre>

<p><a id="markdown-code-organization" name="code-organization"></a></p>

<h2>Code Organization</h2>

<p>Use extensions to organize your code into logical blocks of functionality. Each extension should be set off with a <code>// MARK: - comment</code> to keep things well-organized.</p>

<p><a id="markdown-protocol-conformance" name="protocol-conformance"></a></p>

<h3>Protocol Conformance</h3>

<p>In particular, when adding protocol conformance to a model, prefer adding a separate extension for the protocol methods. This keeps the related methods grouped together with the protocol and can simplify instructions to add a protocol to a class with its associated methods.</p>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">class MyViewController: UIViewController {
  // class stuff here
}

// MARK: - UITableViewDataSource
extension MyViewController: UITableViewDataSource {
  // table view data source methods
}

// MARK: - UIScrollViewDelegate
extension MyViewController: UIScrollViewDelegate {
  // scroll view delegate methods
}
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">class MyViewController: UIViewController, UITableViewDataSource, UIScrollViewDelegate {
  // all methods
}
</code></pre>

<p>For UIKit view controllers, consider grouping lifecycle, custom accessors, and IBAction in separate class extensions.</p>

<p><a id="markdown-classes-and-structures" name="classes-and-structures"></a></p>

<h2>Classes and Structures</h2>

<p><a id="markdown-use-of-self" name="use-of-self"></a></p>

<h3>Use of Self</h3>

<p>For conciseness, avoid using <code>self</code> since Swift does not require it to access an object&rsquo;s properties or invoke its methods.</p>

<p>Use <code>self</code> only when required by the compiler (in <code>@escaping</code> closures, or in initializers to disambiguate properties from arguments). In other words, if it compiles without <code>self</code> then omit it.</p>

<p><a id="markdown-constants" name="constants"></a></p>

<h3>Constants</h3>

<p>Constants are defined using the <code>let</code> keyword, and variables with the <code>var</code> keyword. Always use <code>let</code> instead of <code>var</code> if the value of the variable will not change.</p>

<blockquote><p>Tip: A good technique is to define everything using <code>let</code> and only change it to <code>var</code> if the compiler complains!</p></blockquote>

<p>You can define constants on a type rather than on an instance of that type using type properties. To declare a type property as a constant simply use <code>static let</code>. Type properties declared in this way are generally preferred over global constants because they are easier to distinguish from instance properties.</p>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">enum Math {
  static let e = 2.718281828459045235360287
  static let root2 = 1.41421356237309504880168872
}

let hypotenuse = side * Math.root2
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">let e = 2.718281828459045235360287  // pollutes global namespace
let root2 = 1.41421356237309504880168872

let hypotenuse = side * root2 // what is root2?
</code></pre>

<p><a id="markdown-control-flow" name="control-flow"></a></p>

<h2>Control Flow</h2>

<p><a id="markdown-golden-path" name="golden-path"></a></p>

<h3>Golden Path</h3>

<p>When coding with conditionals, the left-hand margin of the code should be the &ldquo;golden&rdquo; or &ldquo;happy&rdquo; path. That is, don&rsquo;t nest <code>if</code> statements. Multiple return statements are OK. The <code>guard</code> statement is built for this.</p>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">func computeFFT(context: Context?, inputData: InputData?) throws -&gt; Frequencies {

  guard let context = context else {
    throw FFTError.noContext
  }
  guard let inputData = inputData else {
    throw FFTError.noInputData
  }

  // use context and input to compute the frequencies
  return frequencies
}
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">func computeFFT(context: Context?, inputData: InputData?) throws -&gt; Frequencies {

  if let context = context {
    if let inputData = inputData {
      // use context and input to compute the frequencies

      return frequencies
    } else {
      throw FFTError.noInputData
    }
  } else {
    throw FFTError.noContext
  }
}
</code></pre>

<p>When multiple optionals are unwrapped either with <code>guard</code> or <code>if let</code>, minimize nesting by using the compound version when possible. Example:</p>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">guard let number1 = number1,
      let number2 = number2,
      let number3 = number3 else {
  fatalError("impossible")
}
// do something with numbers
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">if let number1 = number1 {
  if let number2 = number2 {
    if let number3 = number3 {
      // do something with numbers
    } else {
      fatalError("impossible")
    }
  } else {
    fatalError("impossible")
  }
} else {
  fatalError("impossible")
}
</code></pre>

<p><a id="markdown-failing-guards" name="failing-guards"></a></p>

<h4>Failing Guards</h4>

<p><code>guard</code> statements are required to exit in some way. Generally, this should be simple one line statement such as <code>return</code>, <code>throw</code>, <code>break</code>, <code>continue</code>, and <code>fatalError()</code>. Large code blocks should be avoided. If cleanup code is required for multiple exit points, consider using a <code>defer</code> block to avoid cleanup code duplication.</p>

<p><a id="markdown-argument-labels" name="argument-labels"></a></p>

<h2>Argument Labels</h2>

<ol>
<li>Good practice</li>
</ol>


<pre><code class="swift">func move(from start: Point, to end: Point)
x.move(from: x, to: y) 
</code></pre>

<ol>
<li><p>Omit all labels when arguments can’t be usefully distinguished, e.g. <code>min(number1, number2)</code>, <code>zip(sequence1, sequence2)</code>.</p></li>
<li><p>When the first argument forms part of a prepositional phrase, give it an argument label. The argument label should normally begin at the preposition, e.g. <code>x.removeBoxes(havingLength: 12)</code>.</p>

<ul>
<li>An exception for the principle above arises when the first two arguments represent parts of a single abstraction. In such cases, begin the argument label after the preposition, to keep the abstraction clear.</li>
</ul>
</li>
</ol>


<p><strong>Preferred:</strong></p>

<pre><code class="swift">a.moveTo(x: b, y: c)
a.fadeFrom(red: b, green: c, blue: d)
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">a.move(toX: b, y: c)
a.fade(fromRed: b, green: c, blue: d)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中的Error]]></title>
    <link href="http://hongchaozhang.github.io/blog/2017/10/20/errors-in-swift/"/>
    <updated>2017-10-20T16:24:35+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2017/10/20/errors-in-swift</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC depthFrom:1 depthTo:3 insertAnchor:true -->


<ul>
<li><a href="#swift-error%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">Swift Error基本使用</a>

<ul>
<li><a href="#throws-in-swift-1x"><code>throws</code> in Swift 1.x</a></li>
<li><a href="#throws-in-swift-2"><code>throws</code> in Swift 2</a></li>
<li><a href="#throws%E7%9A%84%E4%BD%BF%E7%94%A8"><code>throws</code>的使用</a></li>
<li><a href="#throws%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86"><code>throws</code>抛出错误的处理</a></li>
</ul>
</li>
<li><a href="#throws%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5"><code>throws</code>的一些实践</a>

<ul>
<li><a href="#throws%E7%9A%84%E8%B0%83%E8%AF%95%E5%92%8C%E6%96%AD%E7%82%B9"><code>throws</code>的调试和断点</a></li>
<li><a href="#throws%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><code>throws</code>仍然存在的问题</a></li>
</ul>
</li>
<li><a href="#swift-%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%A7%8D%E7%B1%BB">Swift 错误类型的种类</a>

<ul>
<li><a href="#simple-domain-error">Simple domain error</a></li>
<li><a href="#recoverable-error">Recoverable error</a></li>
<li><a href="#universal-error">Universal error</a></li>
<li><a href="#logic-failure">Logic failure</a></li>
</ul>
</li>
<li><a href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">几种常见场景下的错误处理</a>

<ul>
<li><a href="#app%E5%86%85%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD">app内资源加载</a></li>
<li><a href="#%E5%8A%A0%E8%BD%BD%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%97%B6%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF">加载当前用户信息时发生错误</a></li>
<li><a href="#%E8%BF%98%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BB%A3%E7%A0%81">还没有实现的代码</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E8%AE%BE%E5%A4%87%E4%B8%8A%E7%9A%84%E4%BC%A0%E6%84%9F%E5%99%A8%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE">调用设备上的传感器收集数据</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E7%9A%84%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95">错误处理相关的辅助方法</a>

<ul>
<li><a href="#use-custom-errors">Use Custom Errors</a></li>
<li><a href="#do-cleanup-work-using-defer">Do Cleanup Work Using <code>defer</code></a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-swift-error基本使用" name="swift-error基本使用"></a></p>

<h2>Swift Error基本使用</h2>

<p><a id="markdown-throws-in-swift-1x" name="throws-in-swift-1x"></a></p>

<h3><code>throws</code> in Swift 1.x</h3>

<p>在Objective-C中，<code>FileManager</code>的copy接口如下：</p>

<pre><code class="objc">- (BOOL)copyItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error
</code></pre>

<p>调用该方法时，写法如下：</p>

<pre><code class="swift">NSFileManager *fileManager = [NSFileManager defaultManager];
NSError *error;
[fileManager copyItemAtPath:srcPath toPath:toPath error:&amp;error];
if (error) {
    // 发生了错误
} else {
    // 复制成功
}
</code></pre>

<p>在Swift 1.x中，与Objective-C类似。方法接口如下：</p>

<pre><code class="swift">func copyItemAtPath(_ srcPath: String, toPath dstPath: String, error: NSErrorPointer)
</code></pre>

<p>使用方法如下：</p>

<pre><code class="swift">let fileManager = NSFileManager.defaultManager()
var error: NSError?
fileManager.copyItemAtPath(srcPath, toPath: dstPath, error: &amp;error)
if error != nil {
    // 发生了错误
} else {
    // 复制成功
}
</code></pre>

<p>在上面的例子中，因为这个 API 仅会在极其特定的条件下 (比如磁盘空间不足) 会出错，所以开发者为了方便，有时会直接传入 nil 来忽视掉这个错误：</p>

<pre><code class="swift">let fileManager = NSFileManager.defaultManager()
// 不关心是否发生错误
fileManager.copyItemAtPath(srcPath, toPath: dstPath, error: nil)
</code></pre>

<p><a id="markdown-throws-in-swift-2" name="throws-in-swift-2"></a></p>

<h3><code>throws</code> in Swift 2</h3>

<p>这种做法无形中降低了应用的可靠性以及从错误中恢复的能力。为了解决这个问题，Swift 2 中在编译器层级就对<code>throws</code>进行了限定。上面提到的copy接口在Swift 2中的形式为：</p>

<pre><code class="swift">func copyItem(atPath srcPath: String, toPath dstPath: String) throws
</code></pre>

<p>被标记为<code>throws</code>的API，必须被处理，否则编译器就会报错。这就在编译器层面对错误的处理进行了强制执行，保证了代码的可靠性。</p>

<p><a id="markdown-throws的使用" name="throws的使用"></a></p>

<h3><code>throws</code>的使用</h3>

<p>下面是包含<code>throws</code>的一个自动售货机实现：</p>

<pre><code class="swift">enum VendingMachineError: Error {
    case invalidSelection
    case insufficientFunds(coinsNeeded: Int)
    case outOfStock
}

struct Item {
    var price: Int
    var count: Int
}

class VendingMachine {
    var inventory = [
        "Candy Bar": Item(price: 12, count: 7),
        "Chips": Item(price: 10, count: 4),
        "Pretzels": Item(price: 7, count: 11)
    ]
    var coinsDeposited = 0

    func vend(itemNamed name: String) throws {
        guard let item = inventory[name] else {
            throw VendingMachineError.invalidSelection
        }

        guard item.count &gt; 0 else {
            throw VendingMachineError.outOfStock
        }

        guard item.price &lt;= coinsDeposited else {
            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)
        }

        coinsDeposited -= item.price

        var newItem = item
        newItem.count -= 1
        inventory[name] = newItem

        print("Dispensing \(name)")
    }
}
</code></pre>

<p><code>vend(itemNamed:)</code>方法的实现通过<code>guard</code>抛出购买过程中相应的错误。</p>

<p><a id="markdown-throws抛出错误的处理" name="throws抛出错误的处理"></a></p>

<h3><code>throws</code>抛出错误的处理</h3>

<p>被标记为<code>throws</code>的API，我们必须采用下面几种处理方式中的一种来处理，否则，编译器会报错。</p>

<h4><code>do catch</code></h4>

<pre><code class="swift">var vendingMachine = VendingMachine()
vendingMachine.coinsDeposited = 8
do {
    try buyFavoriteSnack(person: "Alice", vendingMachine: vendingMachine)
} catch VendingMachineError.invalidSelection {
    print("Invalid Selection.")
} catch VendingMachineError.outOfStock {
    print("Out of Stock.")
} catch VendingMachineError.insufficientFunds(let coinsNeeded) {
    print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
}
</code></pre>

<h4><code>try?</code></h4>

<p>使用<code>try?</code>来处理错误，将其返回值变为Optional：如果在执行过程中出现错误，接口返回<code>nil</code>，同时错误停止继续传播。比如：</p>

<pre><code class="swift">func fetchDataFromDisk() throws -&gt; Data

func fetchDataFromServer() throws -&gt; Data

func fetchData() -&gt; Data? {
    if let data = try? fetchDataFromDisk() { 
        return data 
    }
    if let data = try? fetchDataFromServer() { 
        return data 
    }
    return nil
}
</code></pre>

<h4><code>try!</code></h4>

<p>如果你非常确信一个被标记为<code>throws</code>的接口，在你的环境中不会抛出错误，可以通过<code>try!</code>来强制终止错误的继续传播。如果在执行的时候出现了错误，那么抛出运行时错误，导致程序崩溃。</p>

<p>比如，<code>loadImage(atPath:)</code>方法加载指定目录下面的一张图片到内存中，如果加载异常，会抛出错误。在下面的使用中，我们希望加载一张应用中包含的图片，这种情况下，可以通过<code>try!</code>来终止错误的继续传播。</p>

<pre><code class="swift">let photo = try! loadImage(atPath: "./Resources/John Appleseed.jpg")
</code></pre>

<h4><code>try</code></h4>

<p>也可以直接使用<code>try</code>来调用被标记为<code>throws</code>的接口，但是这种情况下，错误会继续传播，包含该调用的方法也必须被标记为<code>throws</code>才行，否则，编译器会报错。</p>

<pre><code class="swift">let favoriteSnacks = [
    "Alice": "Chips",
    "Bob": "Licorice",
    "Eve": "Pretzels",
]
func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? "Candy Bar"
    try vendingMachine.vend(itemNamed: snackName)
}
</code></pre>

<p>在这个例子中，因为<code>buyFavoriteSnack(person: vendingMachine:)</code>使用<code>try</code>调用了一个被标记为throws的接口<code>vend(itemNamed:)</code>，错误会继续传播，因此，该方法也需要标记为thorws。</p>

<p><a id="markdown-throws的一些实践" name="throws的一些实践"></a></p>

<h2><code>throws</code>的一些实践</h2>

<p><a id="markdown-throws的调试和断点" name="throws的调试和断点"></a></p>

<h3><code>throws</code>的调试和断点</h3>

<p>Swift的错误抛出并不是传统意义的exception，在调试时抛出错误并不会触发Exception断点。另外，throw本身是语言的关键字，而不是一个symbol，它也不能触发Symbolic类型的断点。如果我们希望在所有throw语句执行的时候让程序停住的话，需要一些额外的技巧。在之前 throw 的汇编实现中，可以看到所有throw语句在返回前都会进行一次<code>swift_willThrow</code>的调用，这就是一个有效的 Symbolic语句，我们设置一个<code>swift_willThrow</code>的Symbolic断点，就可以让程序在throw的时候停住，并使用调用栈信息来获知程序在哪里抛出了错误。</p>

<p>补充，在最新版本的Xcode中，Apple直接为我们在断点类型中加上了 “Swift Error Breakpoint”的选项，它背后做的就是在<code>swift_willThrow</code>上添加一个断点。不过因为有了更直接的方法，我们现在不再需要手动去添加这个符号断点了。我们可以通过设置“Swift Error Breakpoint”对throws进行断点设置和调试。设置方法如下：</p>

<p><img src="/images/Swift-Error-Breakpoint.png" alt="swift error breakpoint" /></p>

<p><a id="markdown-throws仍然存在的问题" name="throws仍然存在的问题"></a></p>

<h3><code>throws</code>仍然存在的问题</h3>

<p>不能从接口直接看出有哪些可能抛出的Error，必须看Document才行，带来了一些不便。比如，只通过接口：</p>

<pre><code class="swift">func vend(itemNamed name: String) throws
</code></pre>

<p>我们没有办法知道这个接口可能返回哪些错误。此时，要么阅读文档，获得确切的抛出错误，分别进行处理；或者将所有的错误统一处理如下：</p>

<pre><code class="swift">do {
    let snackName = favoriteSnacks[person] ?? "Candy Bar"
    try vendingMachine.vend(itemNamed: snackName)
} catch {
    // 错误抛出
}
</code></pre>

<p><a id="markdown-swift-错误类型的种类" name="swift-错误类型的种类"></a></p>

<h2>Swift 错误类型的种类</h2>

<p>参考Swift官方文档<a href="https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst">Error Handling in Swift<!-- 2.0--></a>，Swift中的错误有下面四种：</p>

<ol>
<li>Simple domain error</li>
<li>Recoverable error</li>
<li>Universal error</li>
<li>Logic failure</li>
</ol>


<p><a id="markdown-simple-domain-error" name="simple-domain-error"></a></p>

<h3>Simple domain error</h3>

<p>简单的，显而易见的错误。这类错误的最大特点是我们不需要知道原因，只需要知道错误发生，并且想要进行处理。用来表示这种错误发生的方法一般就是返回一个<code>nil</code>值。在Swift中，这类错误最常见的情况就是将某个字符串转换为整数，或者在字典尝试用某个不存在的 key 获取元素：</p>

<pre><code class="swift">// Simple Domain Error 的例子
let num = Int("hello world") // nil
let element = dic["key_not_exist"] // nil
</code></pre>

<p><strong>可能出现这种错误的接口，不需要使用<code>throws</code>来标记，只需要将接口的返回类型设置为Optional即可。</strong>在使用层面 (或者说应用逻辑) 上，这类错误一般用<code>if let</code>的可选值绑定或者是<code>guard let</code>提前进行返回处理即可。</p>

<p><a id="markdown-recoverable-error" name="recoverable-error"></a></p>

<h3>Recoverable error</h3>

<p>正如其名，这类错误应该是被容许，并且是可以恢复的。可恢复错误的发生是正常的程序路径之一，而作为开发者，我们应当去检出这类错误发生的情况，并进一步对它们进行处理，让它们恢复到我们期望的程序路径上。</p>

<p><strong>这类错误在Objective-C的时代通常用NSError类型来表示，而在Swift里则是通过throws来实现。</strong>一般我们需要检查错误的类型，并作出合理的响应。而选择忽视这类错误往往是不明智的，因为它们是用户正常使用过程中可能会出现的情况，我们应该尝试对其恢复，或者至少向用户给出合理的提示，让他们知道发生了什么。像是网络请求超时，或者写入文件时磁盘空间不足：</p>

<pre><code class="swift">// 网络请求
let url = URL(string: "https://www.example.com/")!
let task = URLSession.shared.dataTask(with: url) { data, response, error in
    if let error = error {
        // 提示用户
        self.showErrorAlert("Error: \(error.localizedDescription)")
    }
    let data = data!
    // ...
}

// 写入文件
func write(data: Data, to url: URL) {
    do {
        try data.write(to: url)
    } catch let error as NSError {
        if error.code == NSFileWriteOutOfSpaceError {
            // 尝试通过释放空间自动恢复
            removeUnusedFiles()
            write(data: data, to: url)
        } else {
            // 其他错误，提示用户
            showErrorAlert("Error: \(error.localizedDescription)")
        }
    } catch {
        showErrorAlert("Error: \(error.localizedDescription)")
    }
}
</code></pre>

<p><a id="markdown-universal-error" name="universal-error"></a></p>

<h3>Universal error</h3>

<p>这类错误理论上可以恢复，但是由于语言本身的特性所决定，我们难以得知这类错误的来源，所以一般来说也不会去处理这种错误。这类错误包括类似下面这些情形：</p>

<pre><code class="swift">// 内存不足
[Int](repeating: 100, count: .max)

// 调用栈溢出
func foo() { foo() }
foo()
</code></pre>

<p>我们可以通过设计一些手段来对这些错误进行处理，比如：检测当前的内存占用并在超过一定值后警告，或者监视栈frame数进行限制等。但是一般来说这是不必要的，也不可能涵盖全部的错误情况。更多情况下，这是由于代码触碰到了设备的物理限制和边界情况所造成的，一般我们也不去进行处理（除非是人为造成的bug）。</p>

<p>在 Swift 中，各种被使用<code>fatalError</code>进行强制终止的错误一般都可以归类到 Universal error。</p>

<p><a id="markdown-logic-failure" name="logic-failure"></a></p>

<h3>Logic failure</h3>

<p>逻辑错误是程序员的失误所造成的错误，它们应该在开发时通过代码进行修正并完全避免，而不是等到运行时再进行恢复和处理。</p>

<p>常见的 Logic failure 包括有：</p>

<pre><code class="swift">// 强制解包一个 `nil` 可选值
var name: String? = nil
name!

// 数组越界访问
let arr = [1,2,3]
let num = arr[3]

// 计算溢出
var a = Int.max
a += 1

// 强制 try 但是出现错误
try! JSONDecoder().decode(Foo.self, from: Data())
</code></pre>

<p>这类错误在实现中触发的一般是<code>assert</code>或者<code>precondition</code>。</p>

<p>和<code>fatalError</code>不同，<code>assert</code>只在进行编译优化的<code>-O</code>配置下是不触发的，而如果更进一步，将编译优化选项配置为<code>-Ounchecked</code>的话，<code>precondition</code>也将不触发。此时，各方法中的<code>precondition</code>将被跳过，因此我们可以得到最快的运行速度。但是相对地代码的安全性也将降低，因为对于越界访问或者计算溢出等错误，我们得到的将是不确定的行为。</p>

<table>
<thead>
<tr>
<th>函数 </th>
<th> fatalError </th>
<th> precondition </th>
<th> assert</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Onone </td>
<td> 触发 </td>
<td> 触发 </td>
<td> 触发</td>
</tr>
<tr>
<td>-O </td>
<td> 触发 </td>
<td> 触发 </td>
<td> -</td>
</tr>
<tr>
<td>-Ounchecked </td>
<td> 触发 </td>
<td> - </td>
<td> -</td>
</tr>
</tbody>
</table>


<p>对于Universal error一般使用<code>fatalError</code>，而对于<code>Logic failure</code>一般使用<code>assert</code>或者<code>precondition</code>。遵守这个规则会有助于我们在编码时对错误进行界定。而有时候我们也希望能尽可能多地在开发的时候捕获Logic failure，而在产品发布后尽量减少crash比例。这种情况下，相比于直接将Logic failure转换为可恢复的错误，我们最好是使用<code>assert</code>在内部进行检查，来让程序在开发时崩溃。</p>

<p><a id="markdown-几种常见场景下的错误处理" name="几种常见场景下的错误处理"></a></p>

<h2>几种常见场景下的错误处理</h2>

<p>光说不练假把式。让我们来实际判断一下下面这些情况下我们都应该选择用哪种错误处理方式吧~</p>

<p><a id="markdown-app内资源加载" name="app内资源加载"></a></p>

<h3>app内资源加载</h3>

<p>假设我们在处理一个机器学习的模型，需要从磁盘读取一份预先训练好的模型。该模型以文件的方式存储在 app bundle 中，如果读取时没有找到该模型，我们应该如何处理这个错误？</p>

<h4>方案 1 Simple domain error</h4>

<pre><code class="swift">func loadModel() -&gt; Model? {
    guard let path = Bundle.main.path(forResource: "my_pre_trained_model", ofType: "mdl") else {
        return nil
    }
    let url = URL(fileURLWithPath: path)
    guard let data = try? Data(contentOf: url) else {
        return nil
    }

    return try? ModelLoader.load(from: data)
}
</code></pre>

<h4>方案 2 Recoverable error</h4>

<pre><code class="swift">func loadModel() throws -&gt; Model {
    guard let path = Bundle.main.path(forResource: "my_pre_trained_model", ofType: "mdl") else {
        throw AppError.FileNotExisting
    }
    let url = URL(fileURLWithPath: path)
    let data = try Data(contentOf: url)
    return try ModelLoader.load(from: data)
}
</code></pre>

<h4>方案 3 Universal error</h4>

<pre><code class="swift">func loadModel() -&gt; Model {
    guard let path = Bundle.main.path(forResource: "my_pre_trained_model", ofType: "mdl") else {
        fatalError("Model file not existing")
    }
    let url = URL(fileURLWithPath: path)
    do {
        let data = try Data(contentOf: url)
        return try ModelLoader.load(from: data)
    } catch {
        fatalError("Model corrupted.")
    }
}
</code></pre>

<h4>方案 4 Logic failure</h4>

<pre><code class="swift">func loadModel() -&gt; Model {
    let path = Bundle.main.path(forResource: "my_pre_trained_model", ofType: "mdl")!
    let url = URL(fileURLWithPath: path)
    let data = try! Data(contentOf: url)
    return try! ModelLoader.load(from: data)
}
</code></pre>

<p><details>
  <summary><em>点击查看答案</em></summary></p>

<p>正确答案应该是方案 4，使用Logic failure让代码直接崩溃。</p>

<p>作为内建的存在于app bundle中模型或者配置文件，如果不存在或者无法初始化，在不考虑极端因素的前提下，一定是开发方面出现了问题，这不应该是一个可恢复的错误，无论重试多少次结果肯定是一样的。也许是开发者忘了将文件放到合适的位置，也许是文件本身出现了问题。不论是哪种情况，我们都会希望尽早发现并强制我们修正错误，而让代码崩溃可以很好地做到这一点。</p>

<p>使用Universal error同样可以让代码崩溃，但是Universal error更多是用在语言的边界情况下。而这里并非这种情况。
</details></p>

<p><a id="markdown-加载当前用户信息时发生错误" name="加载当前用户信息时发生错误"></a></p>

<h3>加载当前用户信息时发生错误</h3>

<p>我们在用户登录后会将用户信息存储在本地，每次重新打开app时我们检测并使用用户信息。当用户信息不存在时，应该进行的处理：</p>

<h4>方案 1 Simple domain error</h4>

<pre><code class="swift">func loadUser() -&gt; User? {
    let username = UserDefaults.standard.string(forKey: "com.onevcat.app.defaults.username")
    if let username {
        return User(name: username)
    } else {
        return nil
    }
}
</code></pre>

<h4>方案 2 Recoverable error</h4>

<pre><code class="swift">func loadUser() throws -&gt; User {
    let username = UserDefaults.standard.string(forKey: "com.onevcat.app.defaults.username")
    if let username {
        return User(name: username)
    } else {
        throws AppError.UsernameNotExisting
    }
}
</code></pre>

<h4>方案 3 Universal error</h4>

<pre><code class="swift">func loadUser() -&gt; User {
    let username = UserDefaults.standard.string(forKey: "com.onevcat.app.defaults.username")
    if let username {
        return User(name: username)
    } else {
        fatalError("User name not existing")
    }
}
</code></pre>

<h4>方案 4 Logic failure</h4>

<pre><code class="swift">func loadUser() -&gt; User {
    let username = UserDefaults.standard.string(forKey: "com.onevcat.app.defaults.username")
    return User(name: username!)
}
</code></pre>

<p><details>
  <summary><em>点击查看答案</em></summary></p>

<p>首先肯定排除方案3和4。“用户名不存在”是一个正常的现象，肯定不能直接crash。所以我们应该在方案1和方案2中选择。</p>

<p>对于这种情况，选择方案1 Simple domain error会更好。因为用户信息不存在是很简单的一个状况，如果用户不存在，那么我们直接让用户登录即可，这并不需要知道额外的错误信息，返回<code>nil</code>就能够很好地表达意图了。</p>

<p>当然，我们不排除今后随着情况越来越复杂，会需要区分用户信息缺失的原因 (比如是否是新用户还没有注册，还是由于原用户注销等)。但是在当前的情况下来看，这属于过度设计，暂时并不需要考虑。如果之后业务复杂到这个程度，在编译器的帮助下将Simple domain error修改为Recoverable error也不是什么难事儿。
</details></p>

<p><a id="markdown-还没有实现的代码" name="还没有实现的代码"></a></p>

<h3>还没有实现的代码</h3>

<p>假设你在为你的服务开发一个iOS框架，但是由于工期有限，有一些功能只定义了接口，没有进行具体实现。这些接口会在正式版中完成，但是我们需要预先发布给友商内测。所以除了在文档中明确标明这些内容，这些方法内部应该如何处理呢？</p>

<h4>方案 1 Simple domain error</h4>

<pre><code class="swift">func foo() -&gt; Bar? {
    return nil
}
</code></pre>

<h4>方案 2 Recoverable error</h4>

<pre><code class="swift">func foo() throws -&gt; Bar? {
    throw FrameworkError.NotImplemented
}
</code></pre>

<h4>方案 3 Universal error</h4>

<pre><code class="swift">func foo() -&gt; Bar? {
    fatalError("Not implemented yet.")
}
</code></pre>

<h4>方案 4 Logic failure</h4>

<pre><code class="swift">func foo() -&gt; Bar? {
    assertionFailure("Not implemented yet.")
    return nil
}
</code></pre>

<p><details>
  <summary><em>点击查看答案</em></summary></p>

<p>正确答案是方案3 Universal error。对于没有实现的方法，返回<code>nil</code>或者抛出错误期待用户恢复都是没有道理的，这会进一步增加框架用户的迷惑。这里的问题是语言层面的边界情况，由于没有实现，我们需要给出强力的提醒。在任意build设定下，都不应该期待用户可以成功调用这个函数，所以<code>fatalError</code>是最佳选择。</p>

<p>其实在swift继承的时候，编译器会给我们添加一个默认的未实现的接口：</p>

<pre><code class="swift">required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}
</code></pre>

<p></details></p>

<p><a id="markdown-调用设备上的传感器收集数据" name="调用设备上的传感器收集数据"></a></p>

<h3>调用设备上的传感器收集数据</h3>

<p>调用传感器的app最有意思了！不管是相机还是陀螺仪，传感器相关的app总是能带给我们很多乐趣。那么，如果想要调用传感器获取数据时，发生了错误，应该怎么办呢？</p>

<h4>方案 1 Simple domain error</h4>

<pre><code class="swift">func getDataFromSensor() -&gt; Data? {
    let sensorState = sensor.getState()
    guard sensorState == .normal else {
        return nil
    }
    return try? sensor.getData()
}
</code></pre>

<h4>方案 2 Recoverable error</h4>

<pre><code class="swift">func getDataFromSensor() throws -&gt; Data {
    let sensorState = sensor.getState()
    guard sensorState == .normal else {
        throws SensorError.stateError
    }
    return try sensor.getData()
}
</code></pre>

<h4>方案 3 Universal error</h4>

<pre><code class="swift">func loadUser() -&gt; Data {
    let sensorState = sensor.getState()
    guard sensorState == .normal, let data = try? sensor.getData() else {
        fatalError("Sensor get data failed!")
    }
    return data
}
</code></pre>

<h4>方案 4 Logic failure</h4>

<pre><code class="swift">func loadUser() -&gt; Data {
    let sensorState = sensor.getState()
    assert(sensorState == .normal, "The sensor state is not normal")
    return try! sensor.getData()
}
</code></pre>

<p><details>
  <summary><em>点击查看答案</em></summary></p>

<p>传感器由于种种原因暂时不能使用 (比如正在被其他进程占用，或者甚至设备上不存在对应的传感器)，是很有可能发生的情况。即使这个传感器的数据对应用是至关重要，不可或缺的，我们可能也会希望至少能给用户一些提示。基于这种考虑，使用方案2 Recoverable error是比较合理的选择。</p>

<p>方案1在传感器数据无关紧要的时候可能也会是一个更简单的选项。但是方案3和4会直接让程序崩溃，而且这实际上也并不是代码边界或者开发者的错误，所以不应该被考虑。
</details></p>

<p><a id="markdown-总结" name="总结"></a></p>

<h3>总结</h3>

<p>可以看到，其实在错误处理的时候，选用哪种错误是根据情景和处理需求而定的，我在参考答案也使用了很多诸如“可能”，“相较而言”等语句。虽然对于特定的场景，我们可以进行直观的考虑和决策，但这并不是教条主义般的一成不变。错误类型之间可以很容易地通过代码互相转换，这让我们在处理错误的时候可以自由选择使用的策略：比如API即使提供给我们的是Recoverable的throws形式，我们也还是可以按照需要，通过<code>try?</code>将其转为Simple domain error，或者用<code>try!</code>将其转为Logic failure。</p>

<p>能切实理解使用情景，利用这些错误类型转换的方式，灵活选取使用场景下最合适的错误类型，才能说是真正理解了这四种错误的分类依据。</p>

<p><a id="markdown-错误处理相关的辅助方法" name="错误处理相关的辅助方法"></a></p>

<h2>错误处理相关的辅助方法</h2>

<p>For custom errors in swift, refer to <a href="https://developer.apple.com/documentation/swift/error">Error</a> official document.</p>

<p><a id="markdown-use-custom-errors" name="use-custom-errors"></a></p>

<h3>Use Custom Errors</h3>

<h4>Using Enumerations as Errors</h4>

<p>Swift’s enumerations are well suited to represent simple errors. Create an enumeration that conforms to the Error protocol with a case for each possible error. If there are additional details about the error that could be helpful for recovery, use associated values to include that information.</p>

<p>The following example shows an IntParsingError enumeration that captures two different kinds of errors that can occur when parsing an integer from a string: overflow, where the value represented by the string is too large for the integer data type, and invalid input, where nonnumeric characters are found within the input.</p>

<pre><code class="swift">enum IntParsingError: Error {
    case overflow
    case invalidInput(String)
}
</code></pre>

<h4>Including More Data in Errors</h4>

<p>The following XMLParsingError conforms to Error and supply line and column position of the error.</p>

<pre><code class="swift">struct XMLParsingError: Error {
    enum ErrorKind {
        case invalidCharacter
        case mismatchedTag
        case internalError
    }

    let line: Int
    let column: Int
    let kind: ErrorKind
}

func parse(_ source: String) throws -&gt; XMLDoc {
    // ...
    throw XMLParsingError(line: 19, column: 5, kind: .mismatchedTag)
    // ...
}
</code></pre>

<p>Here’s how you can catch any XMLParsingError errors thrown by the parse(_:) function:</p>

<pre><code class="swift">do {
    let xmlDoc = try parse(myXMLData)
} catch let e as XMLParsingError {
    print("Parsing error: \(e.kind) [\(e.line):\(e.column)]")
} catch {
    print("Other error: \(error)")
}

// Prints "Parsing error: mismatchedTag [19:5]"
</code></pre>

<p><a id="markdown-do-cleanup-work-using-defer" name="do-cleanup-work-using-defer"></a></p>

<h3>Do Cleanup Work Using <code>defer</code></h3>

<p>You use a <code>defer</code> statement to execute a set of statements just before code execution leaves the current block of code. This statement lets you do any necessary cleanup that should be performed regardless of how execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as <code>return</code> or <code>break</code>. For example, you can use a <code>defer</code> statement to ensure that file descriptors are closed and manually allocated memory is freed.</p>

<pre><code class="swift">func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // Work with the file.
        }
        // close(file) is called here, at the end of the scope.
    }
}

func vend(itemNamed name: String) throws {

    defer {
        // do some clean work
    }

    guard let item = inventory[name] else {
        throw VendingMachineError.invalidSelection
    }

    guard item.count &gt; 0 else {
        throw VendingMachineError.outOfStock
    }

    guard item.price &lt;= coinsDeposited else {
        throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)
    }

    coinsDeposited -= item.price
    var newItem = item
    newItem.count -= 1
    inventory[name] = newItem

    print("Dispensing \(name)")
}
</code></pre>

<p>The above example uses a <code>defer</code> statement to ensure that the <code>open(_:)</code> function has a corresponding call to <code>close(_:)</code>.</p>

<p><a id="markdown-参考" name="参考"></a></p>

<h2>参考</h2>

<ol>
<li><a href="https://onevcat.com/2017/10/swift-error-category/">关于 Swift Error 的分类</a></li>
<li><a href="https://onevcat.com/2016/03/swift-throws/">Swift 2 throws 全解析 - 从原理到实践</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508">Error Handling Official Site</a></li>
<li><a href="https://developer.apple.com/documentation/swift/error">Error from Apple Document</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
