<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2020-11-16T21:39:18+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift Closure]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/06/04/on-swift-closure/"/>
    <updated>2019-06-04T17:24:47+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/06/04/on-swift-closure</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#function%E4%B8%8Eclosure%E7%9A%84%E5%85%B3%E7%B3%BB">Functionä¸Closureçš„å…³ç³»ï¼š</a></li>
<li><a href="#%E7%94%A8closure%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F">ç”¨Closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡</a></li>
<li><a href="#closure%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">Closureçš„è¯­æ³•ç³–ï¼š</a></li>
<li><a href="#closure%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">Closureä¸å†…å­˜ç®¡ç†ã€å†…å­˜æ³„æ¼</a>

<ul>
<li><a href="#capture-list%E7%9A%84%E5%AE%9A%E4%B9%89">Capture Listçš„å®šä¹‰</a></li>
<li><a href="#weak-and-unowned-references">Weak and Unowned References</a></li>
</ul>
</li>
<li><a href="#closure%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F">Closureæ•è·å˜é‡</a></li>
</ul>


<p><a href="https://medium.com/@abhimuralidharan/functional-swift-all-about-closures-310bc8af31dd">Functional swift: All about Closures</a></p>

<p>è¿™ç¯‡å…¨é¢è¯¦ç»†æ˜“æ‡‚åœ°ä»‹ç»äº†Swiftçš„Closureï¼ŒåŒ…æ‹¬</p>

<ul>
<li>Closureçš„è¯­æ³•ï¼ŒåŒ…æ‹¬ä¸€äº›ç®€åŒ–å†™æ³•ï¼Œå¦‚Trailing Closures</li>
<li>Closureä¸Functionçš„åŒºåˆ«</li>
<li>Closureä¸å†…å­˜ç®¡ç†ã€å†…å­˜æ³„æ¼ï¼Œå¦‚capture listçš„ä½¿ç”¨ï¼Œweakä¸unownedçš„åŒºåˆ«</li>
<li>Functionså’Œclosureséƒ½æ˜¯å¼•ç”¨ç±»å‹ï¼Œä¸æ˜¯å€¼ç±»å‹</li>
</ul>


<p>ä¹Ÿå¯ä»¥çœ‹<a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">å®˜æ–¹æ–‡æ¡£Closures</a>ï¼Œä½†æ˜¯å®˜æ–¹æ–‡æ¡£æ²¡æœ‰ä¸Šé¢çš„æ–‡ç« è¯¦ç»†ã€‚</p>

<p>ä¸‹é¢æœ‰é€‰æ‹©åœ°è®°å½•ä¸€ä¸‹ã€‚</p>

<p><a id="markdown-functionä¸closureçš„å…³ç³»" name="functionä¸closureçš„å…³ç³»"></a></p>

<h2>Functionä¸Closureçš„å…³ç³»ï¼š</h2>

<p>å‚è€ƒ<a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">å®˜æ–¹æ–‡æ¡£Closures</a>é‡Œé¢çš„ä¸‰å¥è¯ç†è§£ä¸€ä¸‹ï¼š</p>

<blockquote><ul>
<li>Global functions are closures that have a name and do not capture any values.</li>
<li>Nested functions are closures that have a name and can capture values from their enclosing function.</li>
<li>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</li>
</ul>
</blockquote>

<p>è¿˜æœ‰ä¸€ç‚¹å¾ˆé‡è¦ï¼š<strong>Closures and functions are first class types in swift</strong>ã€‚</p>

<blockquote><p>Functions and closures are first-class citizens in Swift because you can treat then like a normal value. For example, you canï¼š</p>

<ul>
<li>assign a function/closure to a local variable .</li>
<li>pass a function/closure as an argument .</li>
<li>return a function/closure .</li>
</ul>
</blockquote>

<p><a id="markdown-ç”¨closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡" name="ç”¨closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡"></a></p>

<h2>ç”¨Closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡</h2>

<pre><code class="swift">let setupViewUsingClosure: UIView = {
    let view = UIView()
    view.backgroundColor = .green
    return view
}() //IMPORTANT!!! I have added () at the end.
</code></pre>

<p><a id="markdown-closureçš„è¯­æ³•ç³–" name="closureçš„è¯­æ³•ç³–"></a></p>

<h2>Closureçš„è¯­æ³•ç³–ï¼š</h2>

<p><a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">å®˜æ–¹æ–‡æ¡£Closures</a>æœ‰ä¸ªæ€»çš„è¯´æ˜ï¼š</p>

<blockquote><p>Swiftâ€™s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios. These optimizations include:</p>

<ul>
<li>Inferring parameter and return value types from context</li>
<li>Implicit returns from single-expression closures</li>
<li>Shorthand argument names</li>
<li>Trailing closure syntax</li>
</ul>
</blockquote>

<p>å½“ä½ ç¬¬ä¸€æ¬¡çœ‹åˆ°è¿™ä¸ªå†™æ³•çš„æ—¶å€™è‚¯å®šå¾ˆç–‘æƒ‘ï¼šå‚æ•°ã€ç±»å‹ã€å‡½æ•°è°ƒç”¨æ—¶çš„æ‹¬å·éƒ½è·‘å“ªå»äº†ï¼Ÿ</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<p>ç†è§£äº†ä¸Šé¢å‡ ç‚¹ï¼Œå°±å¯ä»¥æ˜ç™½ä¸ºä»€ä¹ˆå¯ä»¥è¿™ä¹ˆå†™ï¼Œä¸‹é¢è®©æˆ‘ä»¬ä¸€æ­¥æ­¥çœ‹æ¸…æ¥šã€‚</p>

<p>Closureçš„å®šä¹‰å¦‚ä¸‹ï¼š</p>

<blockquote><p>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</p>

<pre><code class="swift">{ (params) -&gt; returnType in
    statements
}
</code></pre></blockquote>

<p>ä¸¾ä¸ªå…·ä½“çš„ä¾‹å­ï¼š</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<p>å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Inferring parameter and return value types from context</strong></li>
</ul>


<p>Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns.</p></blockquote>

<p>æ‰€ä»¥ï¼Œä¸Šé¢çš„ä»£ç å¯ä»¥å†™ä¸ºï¼š</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )
</code></pre>

<p>å†å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Implicit returns from single-expression closures</strong></li>
</ul>


<p>Single-expression closures can implicitly return the result of their single expression by omitting the return keyword from their declaration.</p></blockquote>

<p>æ‰€ä»¥ï¼Œä»£ç ç»§ç»­æ”¹ä¸ºï¼š</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
</code></pre>

<p>å†å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Shorthand argument names</strong></li>
</ul>


<p>Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closureâ€™s arguments by the names $0, $1, $2, and so on.</p></blockquote>

<p>ä»£ç ç»§ç»­æ”¹ä¸ºï¼š</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted(by: { $0 &gt; $1 } )
</code></pre>

<p>å†å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Trailing closure syntax</strong></li>
</ul>


<p>If you need to pass a closure expression to a function as the functionâ€™s final argument and the closure expression is long, it can be useful to write it as a trailing closure instead. A trailing closure is written after the function callâ€™s parentheses, even though it is still an argument to the function. When you use the trailing closure syntax, you donâ€™t write the argument label for the closure as part of the function call.</p></blockquote>

<p>ä»£ç å°±å¯ä»¥å†™æˆï¼š</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<p><a id="markdown-closureä¸å†…å­˜ç®¡ç†å†…å­˜æ³„æ¼" name="closureä¸å†…å­˜ç®¡ç†å†…å­˜æ³„æ¼"></a></p>

<h2>Closureä¸å†…å­˜ç®¡ç†ã€å†…å­˜æ³„æ¼</h2>

<p>Closureå¸¦æ¥çš„å¾ªç¯å¼•ç”¨å’Œå†…å­˜æ³„æ¼ï¼Œä¸»è¦é€šè¿‡Capture Listæ¥è§£å†³ï¼š</p>

<blockquote><p>You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closureâ€™s definition. A capture list defines the rules to use when capturing one or more reference types within the closureâ€™s body.</p></blockquote>

<p>è¯¦ç»†å†…å®¹å‚è€ƒ<a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID56">Resolving Strong Reference Cycles for Closures</a>ã€‚ä¸‹é¢æ‘˜è¦ä¸€ä¸‹ã€‚</p>

<p><a id="markdown-capture-listçš„å®šä¹‰" name="capture-listçš„å®šä¹‰"></a></p>

<h3>Capture Listçš„å®šä¹‰</h3>

<blockquote><p>Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self) or a variable initialized with some value (such as delegate = self.delegate!). These pairings are written within a pair of square braces, separated by commas.</p></blockquote>

<p>Place the capture list before a closureâ€™s parameter list and return type if they are provided:</p>

<pre><code class="swift">lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
    // closure body goes here
}
</code></pre>

<p><a id="markdown-weak-and-unowned-references" name="weak-and-unowned-references"></a></p>

<h3>Weak and Unowned References</h3>

<blockquote><p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p>

<p>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future. Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated. This enables you to check for their existence within the closureâ€™s body.</p>

<p>NOTE: If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.</p></blockquote>

<p>å…³äºunownedçš„å¦ä¸€ä¸ªè§£é‡Šæ›´æ¸…æ¥šï¼š</p>

<blockquote><p>Like a weak reference, an unowned reference does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime.</p></blockquote>

<p><a id="markdown-closureæ•è·å˜é‡" name="closureæ•è·å˜é‡"></a></p>

<h2>Closureæ•è·å˜é‡</h2>

<blockquote><p>Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as closing over those constants and variables.</p></blockquote>

<p>æ¯”å¦‚ï¼š</p>

<pre><code class="swift">// capturing values
var i = 0
var closureArray = [()-&gt;()]()
for _ in 1...5 {
    closureArray.append {
        print(i)
    }
    i += 1
}
// here i will be 5
closureArray[0]() // prints 5
closureArray[1]() // prints 5
closureArray[2]() // prints 5
closureArray[3]() // prints 5
closureArray[4]() // prints 5
</code></pre>

<p>The closure captures the current address of <code>i</code> and every time we access <code>i</code> , it . returns the current value.</p>

<p>If we want to prevent this behavior (capturing values) and print the value of i even if the properties change after their capturing inside the closure, we can explicitly capture the variable with a capture list like this:</p>

<pre><code class="swift">var closureArray2 = [()-&gt;()]()
var j = 0
for _ in 1...5 {
    closureArray2.append { [j] in
        print(j)
    }
    j += 1
}
// here i will be 5
closureArray2[0]() // prints 0
closureArray2[1]() // prints 1
closureArray2[2]() // prints 2
closureArray2[3]() // prints 3
closureArray2[4]() // prints 4
</code></pre>

<p>In this way, we keep an immutable copy of the variable <code>j</code>. Thanks to this copy, further changes to <code>j</code>, outside the closure, will not affect the closure. <code>j</code> is a let constant here. It is not mutable.</p>

<p>We can add multiple values to the capture list :</p>

<pre><code class="swift">closure.append { [j,k,l] in
    print("\(j) \(k) \(l)")
}
</code></pre>

<p>also, you can have alias names for the values captured.</p>

<pre><code class="swift">closure.append { [a = j, b = k, c = l] in
    print("\(a) \(b) \(c)")
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sequece and Collection in Swift]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/06/03/sequece-and-collection-in-swift/"/>
    <updated>2019-06-03T16:22:33+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/06/03/sequece-and-collection-in-swift</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#array-out-of-range-crash"><code>Array</code> out of Range Crash</a></li>
<li><a href="#homemade-collection">Homemade collection</a></li>
<li><a href="#sequences">Sequences</a>

<ul>
<li><a href="#how-to-conform-to-sequence-protocol">How to Conform to <code>Sequence</code> Protocol</a></li>
<li><a href="#make-our-section-conform-to-sequence-protocol">Make our <code>Section</code> Conform to <code>Sequence</code> Protocol</a></li>
<li><a href="#gifts">Gifts</a></li>
</ul>
</li>
<li><a href="#collections">Collections</a>

<ul>
<li><a href="#how-to-conform-to-collection-protocol">How to Conform to <code>Collection</code> Protocol</a></li>
<li><a href="#make-our-section-conform-to-collection-protocol">Make our <code>Section</code> Conform to <code>Collection</code> Protocol</a></li>
</ul>
</li>
<li><a href="#difference-between-array-and-collection">Difference between <code>Array</code> and <code>Collection</code></a></li>
<li><a href="#reference">Reference</a></li>
</ul>


<p>The content comes from the following posts:</p>

<ol>
<li><a href="https://medium.com/swift-programming/swift-sequences-ce22d76f120c">Swift Sequences</a></li>
<li><a href="https://medium.com/swift-programming/swift-collections-e5fff3cd6759">Swift Collections</a></li>
</ol>


<p>But some of the code inside is old and can&rsquo;t be compiled with swift 5.0. So rewritten the code using swift 5.0.</p>

<p><a id="markdown-array-out-of-range-crash" name="array-out-of-range-crash"></a></p>

<h2><code>Array</code> out of Range Crash</h2>

<p>Before diving into Swift Sequences, letâ€™s see a strange behavior.</p>

<pre><code class="swift">let array = [1, 2, 3]
array[7] ğŸ˜­

let dic = ["a": 1, "b": 2]
dic["z"] ğŸ˜

ğŸ¤”
</code></pre>

<p>In other words, when requesting an element that doesnâ€™t exist, why arrays crash whereas dictionaries donâ€™t?</p>

<p>Arrays and dictionaries are two base collections provided by the Swift standard library. We can access those collections elements through the [] notation, also known as subscript. Letâ€™s see how those subscripts are defined.</p>

<pre><code class="swift">struct Array&lt;Element&gt; {
    subscript(index: Int) -&gt; Element
}

struct Dictionary&lt;Key: Hashable, Value&gt; {
    subscript(key: Key) -&gt; Value?
}
</code></pre>

<p>Whatâ€™s interesting is that arrays have a non optional return type. Subscript canâ€™t throw errors so there are no alternatives other than a fatalError if we request an index that doesnâ€™t exist.</p>

<p>For dictionaries, on the other hand, an optional Value is returned, which allows to gracefully return nil if the index doesnâ€™t exist.</p>

<p>We can adopt dictionaries safer approach by overloading the arrays subscriptâ€Šâ€”â€Šwe canâ€™t override them. Adding an external name to the parameter is enough.</p>

<pre><code class="swift">extension Array {
    subscript(safe index: Int) -&gt; Element? {
        return index &gt;= 0 &amp;&amp; index &lt; count ? self[index] : nil
    }
}
</code></pre>

<p>We saw how we can create a new accessor to the elements of an array, but can we do the same with a homemade collection?</p>

<p><a id="markdown-homemade-collection" name="homemade-collection"></a></p>

<h2>Homemade collection</h2>

<pre><code class="swift">struct Section&lt;T&gt; {
    let title: String
    let elements: [T]
}
</code></pre>

<p>Internally, this â€˜collectionâ€™ is based on an array. This is an implementation detail for the simplicity of the example. We could have used a linked list as in this <a href="http://austinzheng.com/2015/01/24/swift-seq/">excellent article</a> by <a href="https://twitter.com/austinzheng">Austin Zheng</a>.</p>

<p>Creating a subscript on our collection is very easy, we can even reuse the arrayâ€™s extension we made earlier.</p>

<pre><code class="swift">struct Section&lt;T&gt; {
    let title: String
    let elements: [T]

    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }
}
</code></pre>

<p>An example in practice :</p>

<pre><code class="swift">let cars = ["911", "Cayman", "Cayenne"]
let section = Section(title: "Porsche", elements: cars)

section[1]
// Optional("Cayman")
</code></pre>

<p>Great! But does that make our type a collection, as Swift defines it?</p>

<p><a id="markdown-sequences" name="sequences"></a></p>

<h2>Sequences</h2>

<p>When it comes to manipulating sets, the most abstract notion given by the standard library is the Sequence, defined as</p>

<blockquote><p>A type that can be iterated with a <code>forâ€¦in</code> loop.</p></blockquote>

<p><a id="markdown-how-to-conform-to-sequence-protocol" name="how-to-conform-to-sequence-protocol"></a></p>

<h3>How to Conform to <code>Sequence</code> Protocol</h3>

<p>This section is from <a href="https://developer.apple.com/documentation/swift/sequence">Sequece official site</a>.</p>

<p>Making your own custom types conform to Sequence enables many useful operations, like for-in looping and the contains method, without much effort. To add Sequence conformance to your own custom type, add a makeIterator() method that returns an iterator.</p>

<p>Alternatively, if your type can act as its own iterator, implementing the requirements of the IteratorProtocol protocol and declaring conformance to both Sequence and IteratorProtocol are sufficient.</p>

<p>Hereâ€™s a definition of a Countdown sequence that serves as its own iterator. The makeIterator() method is provided as a default implementation.</p>

<pre><code class="swift">struct Countdown: Sequence, IteratorProtocol {
    var count: Int

    mutating func next() -&gt; Int? {
        if count == 0 {
            return nil
        } else {
            defer { count -= 1 }
            return count
        }
    }
}

let threeToGo = Countdown(count: 3)
for i in threeToGo {
    print(i)
}
// Prints "3"
// Prints "2"
// Prints "1"
</code></pre>

<p><a id="markdown-make-our-section-conform-to-sequence-protocol" name="make-our-section-conform-to-sequence-protocol"></a></p>

<h3>Make our <code>Section</code> Conform to <code>Sequence</code> Protocol</h3>

<p>The <code>Section</code> struct can&rsquo;t act as its own iterator, we need to define an iterator for it, and then return an instance of the defined iterator inside <code>func makeIterator() -&gt; Section&lt;T&gt;.Iterator</code> method.</p>

<pre><code class="swift">struct Section&lt;T&gt;: Sequence {
    let title: String
    let elements: [T]

    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }

    struct Iterator: IteratorProtocol {
        let array: [T]
        var currentIndex = 0

        init (_ array: [T]) {
            self.array = array
        }

        mutating func next() -&gt; T? {
            let tempIndex = currentIndex
            currentIndex += 1
            return array[safe: tempIndex]

        }
    }

    func makeIterator() -&gt; Section&lt;T&gt;.Iterator {
        return Iterator(elements)
    }
}
</code></pre>

<p><a id="markdown-gifts" name="gifts"></a></p>

<h3>Gifts</h3>

<p>Is that all? No! By conforming to SequenceType we also get methods for free, here is some of them.</p>

<pre><code class="swift">section.min()
// 911
section.max()
// Cayman
section.sorted()
// ["911", "Cayenne", "Cayman"]
section.contains("911")
// true
</code></pre>

<p>We get the min, max &amp; sort methods because the elements of our sequence, String in our case, are Comparable. Contains is available thanks to our elements being Equatable.</p>

<pre><code class="swift">section.filter { $0.count &gt; 3 }
// ["Cayman", "Cayenne"]
section.map { $0.count }
// [3, 6, 7]
section.reduce(0) { $0 + $1.count }
// 16
</code></pre>

<p>And for functional programming fans, filter, map and reduce are also given.</p>

<p><a id="markdown-collections" name="collections"></a></p>

<h2>Collections</h2>

<p>Sequence is the most basic set notion given by the Swift standard library. There is a more evolved one.</p>

<p>A collection is defined as follow :</p>

<blockquote><p>A multi-pass <em>sequence</em> with addressable positions</p></blockquote>

<p>As we saw previously, a sequence is a type that can be iterated with a <code>forâ€¦in</code> loop. It doesnâ€™t need that the elements might be iterated over several times. And it doesnâ€™t need that we give a way to access directly an element.</p>

<p>Collections require those last two points. As a side effect, it no longer allows us to have an infinite number of elements.</p>

<p>To be a collection, a type must conform to the <code>Collection</code> protocol.</p>

<p><a id="markdown-how-to-conform-to-collection-protocol" name="how-to-conform-to-collection-protocol"></a></p>

<h3>How to Conform to <code>Collection</code> Protocol</h3>

<p>This section comes from <a href="https://developer.apple.com/documentation/swift/collection">Collection official site</a>.</p>

<p>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the Collection protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add Collection conformance to your type, you must declare at least the following requirements:</p>

<ol>
<li>The <code>startIndex</code> and <code>endIndex</code> properties</li>
<li>A subscript that provides at least read-only access to your typeâ€™s elements</li>
<li>The <code>index(after:)</code> method for advancing an index into your collection</li>
<li>Conform to <code>Sequece</code> Protocol, as <code>Collection</code> is inherited from <code>Sequence</code></li>
</ol>


<p><a id="markdown-make-our-section-conform-to-collection-protocol" name="make-our-section-conform-to-collection-protocol"></a></p>

<h3>Make our <code>Section</code> Conform to <code>Collection</code> Protocol</h3>

<pre><code class="swift">struct Section&lt;T&gt;: Collection {
    let title: String
    let elements: [T]

    // begin: required for Collection
    var startIndex: Int { return 0 }
    var endIndex: Int { return elements.count }

    func index(after i: Int) -&gt; Int {
        return i + 1
    }

    subscript(index: Int) -&gt; T {
        return elements[index]
    }
    // end: required for Collection


    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }


    // begin: required for Sequence
    struct Iterator: IteratorProtocol {
        let array: [T]
        var currentIndex = 0

        init (_ array: [T]) {
            self.array = array
        }

        mutating func next() -&gt; T? {
            let tempIndex = currentIndex
            currentIndex += 1
            return array[safe: tempIndex]

        }
    }

    func makeIterator() -&gt; Section&lt;T&gt;.Iterator {
        return Iterator(elements)
    }
    // end: required for Sequence
}
</code></pre>

<p>The <code>endIndex</code> has to be after the last element. It allows to define an empty collection with <code>startIndex</code> = <code>endIndex</code>.</p>

<p>Like conforming to <code>Sequence</code>, we get some methods / properties for free:</p>

<pre><code class="swift">section.count
// 3
section.first
// 911
section.isEmpty
// false
section.index(of: "911")
// 0
</code></pre>

<p>We get indexOf thanks to our Elements being Equatable.</p>

<p><a id="markdown-difference-between-array-and-collection" name="difference-between-array-and-collection"></a></p>

<h2>Difference between <code>Array</code> and <code>Collection</code></h2>

<p>We created our own collection, which is great, but what about that difference of behavior between Arrays and Dictionaries we talked about at the beginning of the post? We saw that Arrayâ€™s dangerous subscript was coming from the Indexable protocol, but what about Dictionaries?</p>

<p>Dictionaries, like Arrays, are a collection, as Swift defines it. They both conform to CollectionType. So Dictionaries are also required to provide an â€˜unsafeâ€™ subscript that takes an Index and returns a non optional Element. The one weâ€™re used to is just a convenience subscript.</p>

<p>A simple example shows that it is also really easy to get a crash with Dictionaries.</p>

<pre><code class="swift">let dic = ["a": "bmw", "b": "audi", "c": "citroen"]

var index = dic.startIndex
dic[index]
// (key: "c", value: "citroen")

index = dic.index(after: index)
print(dic[index])
// (key: "b", value: "audi")

index = dic.index(after: index)
index = dic.index(after: index)
dic[index]
// Fatal error
</code></pre>

<p><strong>The last question that remains is why <code>Collection</code> requires a subscript that may crash? Simply for performance reason, it costs too much to check the validity of the given index. Crashing is faster :)</strong></p>

<p><a id="markdown-reference" name="reference"></a></p>

<h2>Reference</h2>

<ol>
<li><a href="https://medium.com/swift-programming/swift-sequences-ce22d76f120c">Swift Sequences</a></li>
<li><a href="https://medium.com/swift-programming/swift-collections-e5fff3cd6759">Swift Collections</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[åœ¨swiftå’ŒObjcä¹‹é—´è½¬æ¢çš„ä¸€äº›æƒ³æ³•]]></title>
    <link href="http://hongchaozhang.github.io/blog/2018/11/13/some-ideas-on-converting-between-objc-and-swift/"/>
    <updated>2018-11-13T10:50:18+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2018/11/13/some-ideas-on-converting-between-objc-and-swift</id>
    <content type="html"><![CDATA[<!-- more -->


<p>åœ¨å·¥ä½œä¸­æˆ‘ä»¬æœ‰æ—¶å€™éœ€è¦åœ¨swiftå’Œobjcä¹‹é—´è¿›è¡Œè½¬æ¢ï¼Œè¿™æ—¶å€™æœ‰æ²¡æœ‰ä¸€äº›å·¥å…·å¯ä»¥å¸®åŠ©æˆ‘ä»¬å‘¢ï¼Ÿ</p>

<blockquote><p>å½“ç„¶ï¼Œå¤§éƒ¨åˆ†æ—¶å€™ï¼Œæˆ‘ä»¬ä¸éœ€è¦è½¬æ¢ï¼Œå› ä¸ºswiftå’Œobjcçš„ç±»å’Œæ–¹æ³•å¯ä»¥äº’ç›¸æš´éœ²ç»™å¯¹æ–¹ã€‚</p></blockquote>

<h2>objcè½¬æ¢æˆswfit</h2>

<p>æœç´¢äº†ä¸€ä¸‹ï¼Œæ‰¾åˆ°äº†ä¸¤ä¸ªå·¥å…·å¯ä»¥åšè¿™ä¸ªäº‹æƒ…ï¼š</p>

<h3><a href="https://github.com/yahoojapan/objc2swift">objc2swift</a></h3>

<p>objc2swiftæ˜¯é›…è™æ—¥æœ¬çš„ä¸€ä¸ªå·¥å…·ï¼Œæ”¯æŒåœ¨çº¿è½¬æ¢ã€‚<a href="https://github.com/dzenbot/XCSwiftr/blob/master/README.md">XCSwiftr</a>å°±æ˜¯ä¸€ä¸ªåŸºäºobjc2swiftçš„xcodeæ’ä»¶ï¼Œé€šè¿‡<a href="https://github.com/alcatraz/Alcatraz">Alcatraz</a>è¿›è¡Œç®¡ç†å®‰è£…ï¼Œå¯ä»¥åœ¨Xcodeé‡Œé¢è¿›è¡Œobjcåˆ°swiftçš„è½¬æ¢ã€‚ä½†æ˜¯xcodeè‡ªä»8.0å¼€å§‹å°±ä¸æ”¯æŒæ’ä»¶äº†ã€‚</p>

<blockquote><p>æ’ä»¶(plugin)åªåœ¨xcode 8.0ä¹‹å‰çš„ç‰ˆæœ¬æ‰æ”¯æŒã€‚ä»8.0å¼€å§‹ï¼Œæ’ä»¶å°±ä¸å†æ”¯æŒï¼Œä½†æ˜¯å¼•å…¥äº†æ‰©å±•(extension)ã€‚æ‰©å±•å’Œæ’ä»¶ä¸åŒçš„ä¸€ç‚¹æ˜¯ï¼šæ‰©å±•åœ¨ç‹¬ç«‹çš„è¿›ç¨‹é‡Œé¢è¿è¡Œï¼Œæ‰€ä»¥æ‰©å±•çš„å´©æºƒä¸ä¼šå½±å“åˆ°xcodeï¼Œä½†æ˜¯æ’ä»¶çš„å´©æºƒï¼Œåˆ™ä¼šå¯¼è‡´xcodeä¹Ÿå´©æºƒã€‚ä¼°è®¡æ’ä»¶å´©æºƒå¯¼è‡´çš„xcodeå´©æºƒçš„é”…éƒ½æ˜¯Appleæ¥èƒŒï¼ŒAppleå¾ˆä¸çˆ½ï¼Œå°±è®©xcodeè·Ÿæ’ä»¶åˆ†å¼€åœ¨ä¸åŒçš„è¿›ç¨‹ä¸­è¿è¡Œã€‚</p></blockquote>

<p>objc2swiftçš„è½¬æ¢æ•ˆæœå¾ˆä¸€èˆ¬ã€‚</p>

<p>objcæºä»£ç ï¼š</p>

<pre><code class="objc">@interface MyClass: NSObject

- (void)sayHelloTo:(NSString*)person;

@end

@implementation MyClass

- (void)sayHelloTo:(NSString*)person {
    NSLog([NSString stringWithFormat:@"Hello, %@.", person]);
    [self performSelector:@selector(test)];

}

- (void)test {
}

@end
</code></pre>

<p>è½¬æ¢ä¹‹åï¼š</p>

<pre><code class="swift">class MyClass: NSObject {
    func sayHelloTo(person: String) {
        print("Hello, \(person).")
        self.performSelector("test")
    }

    func test() {

    }
}
</code></pre>

<p>å‡ ä¸ªé—®é¢˜ï¼š</p>

<ol>
<li>æ–¹æ³•åç§°æ²¡æœ‰æŒ‰ç…§swiftçš„ä¹ æƒ¯æ”¹å†™ï¼šåº”è¯¥ä¸º<code>sayHello(to person: String)</code>ï¼Œè€Œä¸æ˜¯<code>sayHelloTo(person: String)</code>ã€‚</li>
<li><code>performSelector:</code>æ–¹æ³•å®Œå…¨è½¬æ¢é”™è¯¯ï¼šæ–¹æ³•åç§°é”™è¯¯ï¼Œåº”è¯¥ä¸º<code>perform(_ aSelector: Selector!)</code>ï¼Œè€Œä¸”å‚æ•°ä¹Ÿé”™è¯¯ï¼Œä¸åº”è¯¥ä¸º<code>String</code>ç±»å‹ï¼Œåº”è¯¥ä¸º<code>Selector</code>ç±»å‹ã€‚</li>
<li><code>test</code>æ–¹æ³•å‰é¢æ²¡æœ‰åŠ ä¸Š<code>@objc</code>ï¼Œæ‰€ä»¥ä¸èƒ½ä½œä¸º<code>#selector</code>çš„å‚æ•°ã€‚</li>
</ol>


<h3><a href="https://objectivec2swift.com/#/home">Swiftify</a></h3>

<p>swiftifyä¹Ÿæ”¯æŒåœ¨çº¿è½¬æ¢ï¼Œè€Œä¸”è½¬æ¢æ•ˆæœæ˜æ˜¾å¥½äºobjc2swiftã€‚å¦‚æœæ„¿æ„èŠ±é’±ï¼Œswiftifyè¿˜å¯ä»¥æ”¯æŒå¾ˆå¤šåŠŸèƒ½ï¼ŒåŒ…æ‹¬xcodeæ‰©å±•ï¼ˆæ³¨æ„ï¼Œè¿™é‡Œæ˜¯â€œæ‰©å±•extensionâ€ï¼Œä¸æ˜¯â€œæ’ä»¶pluginâ€ï¼‰ã€finderæ‰©å±•ã€æ•´ä¸ªå·¥ç¨‹çš„è½¬æ¢ã€ç¦»çº¿è½¬æ¢ç­‰ã€‚</p>

<p><img src="/images/swiftify.webp" alt="swiftify.webp" /></p>

<p>åŒæ ·ç”¨ä¸Šè¿°objcæºä»£ç ï¼Œè½¬æ¢ä¹‹åä¸ºï¼š</p>

<pre><code class="swift">class MyClass: NSObject {
    func sayHello(to person: String?) {
        print("Hello Swift, Goodbye Obj-C!")
        perform(#selector(MyClass.test))
    }

    @objc func test() {
    }
}
</code></pre>

<h2>swiftè½¬æ¢æˆobjc</h2>

<p><a href="https://objectivec2swift.com/#/home">Swiftify</a>çš„ä½œè€…å†™äº†ä¸€ç¯‡åšå®¢<a href="https://www.quora.com/How-can-you-convert-Swift-to-Objective-C">How can you convert Swift to Objective-C?</a>ï¼Œè¯´æ˜äº†è¿™ä¸ªé—®é¢˜ï¼š</p>

<p>åŸæ–‡æ˜¯ï¼š</p>

<blockquote><p>When speaking about idiomatic Swift, converting method implementations from Swift to Objective-C is the task that cannot be solved for all cases. As you might imagine, many â€œmodernâ€ Swift features do not have any counterparts in Objective-C and thus cannot be converted without a human brain :)</p></blockquote>

<p>ç»“è®ºå°±æ˜¯ï¼šç”±äºswiftæœ‰å¾ˆå¤šobjcæ²¡æœ‰çš„è¯­è¨€ç‰¹æ€§ï¼Œæ‰€ä»¥swiftåˆ°objcæ— æ³•å®Œæˆè‡ªåŠ¨è½¬æ¢ã€‚</p>

<p>ä½†æ˜¯è½¬æ¢ä¹‹åçš„objcçš„å¤´æ–‡ä»¶å¯ä»¥ä»build in â€œGenerated Interfaceâ€ ([ProjectName]-Swift.h)é‡Œé¢æ‰¾åˆ°ï¼Œæ‹·è´å‡ºæ¥ï¼Œç¨ä½œä¿®æ”¹å³å¯ã€‚ä½†æ˜¯ä»…é™äºswiftæš´æ¼ç»™objcçš„æ¥å£å’Œå±æ€§ã€‚é‚£äº›æ²¡æœ‰æš´æ¼ç»™objcçš„æ¥å£å’Œå±æ€§ï¼Œå°±éœ€è¦æ‰‹åŠ¨å»è½¬æ¢å•¦ã€‚</p>

<blockquote><p>[ProjectName]-Swift.hå¦‚æœä¸èƒ½é€šè¿‡cmd+shift+Oæ‰¾åˆ°ï¼Œå¯ä»¥ä»å¼•ç”¨è¿™ä¸ªå¤´æ–‡ä»¶çš„objcæ–‡ä»¶ä¸­é€šè¿‡â€œgo to declaration"æ‰¾åˆ°ã€‚</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Coding Conventions]]></title>
    <link href="http://hongchaozhang.github.io/blog/2018/01/26/swift-coding-convention/"/>
    <updated>2018-01-26T11:37:05+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2018/01/26/swift-coding-convention</id>
    <content type="html"><![CDATA[<p>Collection of some Swift coding conventions, which will make Swift code more maintainable, more readable.</p>

<!-- more -->


<p>The following is conventions I like or I will likely misuse. For a complete version, go to:</p>

<ol>
<li><a href="https://github.com/raywenderlich/swift-style-guide/">The Official raywenderlich.com Swift Style Guide.</a></li>
<li>Swift <a href="https://swift.org/documentation/api-design-guidelines/">API Design Guidelines</a></li>
</ol>


<!-- TOC -->


<ul>
<li><a href="#naming">Naming</a>

<ul>
<li><a href="#try-to-form-grammatical-english-phrases">Try to Form Grammatical English Phrases</a></li>
<li><a href="#mutatingnonmutating-methods-naming">Mutating/Nonmutating Methods Naming</a></li>
<li><a href="#boolean-methods-naming">Boolean Methods Naming</a></li>
<li><a href="#protocol-naming">Protocol Naming</a></li>
<li><a href="#avoid-abbreviations">Avoid Abbreviations</a></li>
<li><a href="#delegates">Delegates</a></li>
</ul>
</li>
<li><a href="#code-organization">Code Organization</a>

<ul>
<li><a href="#protocol-conformance">Protocol Conformance</a></li>
</ul>
</li>
<li><a href="#classes-and-structures">Classes and Structures</a>

<ul>
<li><a href="#use-of-self">Use of Self</a></li>
<li><a href="#constants">Constants</a></li>
</ul>
</li>
<li><a href="#control-flow">Control Flow</a>

<ul>
<li><a href="#golden-path">Golden Path</a>

<ul>
<li><a href="#failing-guards">Failing Guards</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#argument-labels">Argument Labels</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-naming" name="naming"></a></p>

<h2>Naming</h2>

<p>Descriptive and consistent naming makes software easier to read and understand. Use the Swift naming conventions described in the <a href="https://swift.org/documentation/api-design-guidelines/">API Design Guidelines</a>. Some key principles include:</p>

<ol>
<li>prioritizing clarity over brevity</li>
<li>striving for fluent usage</li>
<li>using uppercase for types (and protocols), lowercase for everything else</li>
<li>boolean types should read like assertions</li>
<li>choosing good parameter names that serve as documentation</li>
<li>generally avoiding abbreviations</li>
<li>taking advantage of default parameters</li>
<li>labeling closure and tuple parameters</li>
<li>verb methods follow the -ed, -ing rule for the non-mutating version</li>
<li>noun methods follow the formX rule for the mutating version</li>
<li>protocols that describe what something is should read as nouns</li>
<li>protocols that describe a capability should end in -able or -ible</li>
<li>striving for clarity at the call site</li>
</ol>


<p><a id="markdown-try-to-form-grammatical-english-phrases" name="try-to-form-grammatical-english-phrases"></a></p>

<h3>Try to Form Grammatical English Phrases</h3>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">x.insert(y, at: z)          // â€œx, insert y at zâ€
x.subViews(havingColor: y)  // â€œx's subviews having color yâ€
x.capitalizingNouns()       // â€œx, capitalizing nounsâ€
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">x.insert(y, position: z)
x.subViews(color: y)
x.nounCapitalize()
</code></pre>

<p><a id="markdown-mutatingnonmutating-methods-naming" name="mutatingnonmutating-methods-naming"></a></p>

<h3>Mutating/Nonmutating Methods Naming</h3>

<p>When the operation is naturally described by a verb, use the verbâ€™s imperative for the mutating method and apply the â€œedâ€ or â€œingâ€ suffix to name its nonmutating counterpart.</p>

<table>
<thead>
<tr>
<th> Mutating  </th>
<th> Nonmutating </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>x.sort()</code>    </td>
<td> <code>z = x.sorted()</code> </td>
</tr>
<tr>
<td> <code>x.append(y)</code> </td>
<td> <code>z = x.appending(y)</code> </td>
</tr>
</tbody>
</table>


<p><br>
When the operation is naturally described by a noun, use the noun for the nonmutating method and apply the â€œformâ€ prefix to name its mutating counterpart.</p>

<table>
<thead>
<tr>
<th> Nonmutating   </th>
<th> Mutating </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>x = y.union(z)</code>  </td>
<td> <code>y.formUnion(z)</code> </td>
</tr>
<tr>
<td> <code>j = c.successor(i)</code>  </td>
<td> <code>c.formSuccessor(&amp;i)</code> </td>
</tr>
</tbody>
</table>


<p><a id="markdown-boolean-methods-naming" name="boolean-methods-naming"></a></p>

<h3>Boolean Methods Naming</h3>

<p>Uses of Boolean methods and properties should read as assertions about the receiver when the use is nonmutating, e.g. <code>x.isEmpty</code>, <code>line1.intersects(line2)</code>.</p>

<p><a id="markdown-protocol-naming" name="protocol-naming"></a></p>

<h3>Protocol Naming</h3>

<p>Protocols that describe what something is should read as nouns (e.g. <code>Collection</code>).</p>

<p>Protocols that describe a capability should be named using the suffixes -able, -ible, or -ing (e.g. <code>Equatable</code>, <code>ProgressReporting</code>).</p>

<p><a id="markdown-avoid-abbreviations" name="avoid-abbreviations"></a></p>

<h3>Avoid Abbreviations</h3>

<blockquote><p>The intended meaning for any abbreviation you use should be easily found by a <strong>web search</strong>.</p></blockquote>

<p><a id="markdown-delegates" name="delegates"></a></p>

<h3>Delegates</h3>

<p>When creating custom delegate methods, an unnamed first parameter should be the delegate source. (UIKit contains numerous examples of this.)</p>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">func namePickerView(_ namePickerView: NamePickerView, didSelectName name: String)
func namePickerViewShouldReload(_ namePickerView: NamePickerView) -&gt; Bool
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">func didSelectName(namePicker: NamePickerViewController, name: String)
func namePickerShouldReload() -&gt; Bool
</code></pre>

<p><a id="markdown-code-organization" name="code-organization"></a></p>

<h2>Code Organization</h2>

<p>Use extensions to organize your code into logical blocks of functionality. Each extension should be set off with a <code>// MARK: - comment</code> to keep things well-organized.</p>

<p><a id="markdown-protocol-conformance" name="protocol-conformance"></a></p>

<h3>Protocol Conformance</h3>

<p>In particular, when adding protocol conformance to a model, prefer adding a separate extension for the protocol methods. This keeps the related methods grouped together with the protocol and can simplify instructions to add a protocol to a class with its associated methods.</p>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">class MyViewController: UIViewController {
  // class stuff here
}

// MARK: - UITableViewDataSource
extension MyViewController: UITableViewDataSource {
  // table view data source methods
}

// MARK: - UIScrollViewDelegate
extension MyViewController: UIScrollViewDelegate {
  // scroll view delegate methods
}
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">class MyViewController: UIViewController, UITableViewDataSource, UIScrollViewDelegate {
  // all methods
}
</code></pre>

<p>For UIKit view controllers, consider grouping lifecycle, custom accessors, and IBAction in separate class extensions.</p>

<p><a id="markdown-classes-and-structures" name="classes-and-structures"></a></p>

<h2>Classes and Structures</h2>

<p><a id="markdown-use-of-self" name="use-of-self"></a></p>

<h3>Use of Self</h3>

<p>For conciseness, avoid using <code>self</code> since Swift does not require it to access an object&rsquo;s properties or invoke its methods.</p>

<p>Use <code>self</code> only when required by the compiler (in <code>@escaping</code> closures, or in initializers to disambiguate properties from arguments). In other words, if it compiles without <code>self</code> then omit it.</p>

<p><a id="markdown-constants" name="constants"></a></p>

<h3>Constants</h3>

<p>Constants are defined using the <code>let</code> keyword, and variables with the <code>var</code> keyword. Always use <code>let</code> instead of <code>var</code> if the value of the variable will not change.</p>

<blockquote><p>Tip: A good technique is to define everything using <code>let</code> and only change it to <code>var</code> if the compiler complains!</p></blockquote>

<p>You can define constants on a type rather than on an instance of that type using type properties. To declare a type property as a constant simply use <code>static let</code>. Type properties declared in this way are generally preferred over global constants because they are easier to distinguish from instance properties.</p>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">enum Math {
  static let e = 2.718281828459045235360287
  static let root2 = 1.41421356237309504880168872
}

let hypotenuse = side * Math.root2
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">let e = 2.718281828459045235360287  // pollutes global namespace
let root2 = 1.41421356237309504880168872

let hypotenuse = side * root2 // what is root2?
</code></pre>

<p><a id="markdown-control-flow" name="control-flow"></a></p>

<h2>Control Flow</h2>

<p><a id="markdown-golden-path" name="golden-path"></a></p>

<h3>Golden Path</h3>

<p>When coding with conditionals, the left-hand margin of the code should be the &ldquo;golden&rdquo; or &ldquo;happy&rdquo; path. That is, don&rsquo;t nest <code>if</code> statements. Multiple return statements are OK. The <code>guard</code> statement is built for this.</p>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">func computeFFT(context: Context?, inputData: InputData?) throws -&gt; Frequencies {

  guard let context = context else {
    throw FFTError.noContext
  }
  guard let inputData = inputData else {
    throw FFTError.noInputData
  }

  // use context and input to compute the frequencies
  return frequencies
}
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">func computeFFT(context: Context?, inputData: InputData?) throws -&gt; Frequencies {

  if let context = context {
    if let inputData = inputData {
      // use context and input to compute the frequencies

      return frequencies
    } else {
      throw FFTError.noInputData
    }
  } else {
    throw FFTError.noContext
  }
}
</code></pre>

<p>When multiple optionals are unwrapped either with <code>guard</code> or <code>if let</code>, minimize nesting by using the compound version when possible. Example:</p>

<p><strong>Preferred:</strong></p>

<pre><code class="swift">guard let number1 = number1,
      let number2 = number2,
      let number3 = number3 else {
  fatalError("impossible")
}
// do something with numbers
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">if let number1 = number1 {
  if let number2 = number2 {
    if let number3 = number3 {
      // do something with numbers
    } else {
      fatalError("impossible")
    }
  } else {
    fatalError("impossible")
  }
} else {
  fatalError("impossible")
}
</code></pre>

<p><a id="markdown-failing-guards" name="failing-guards"></a></p>

<h4>Failing Guards</h4>

<p><code>guard</code> statements are required to exit in some way. Generally, this should be simple one line statement such as <code>return</code>, <code>throw</code>, <code>break</code>, <code>continue</code>, and <code>fatalError()</code>. Large code blocks should be avoided. If cleanup code is required for multiple exit points, consider using a <code>defer</code> block to avoid cleanup code duplication.</p>

<p><a id="markdown-argument-labels" name="argument-labels"></a></p>

<h2>Argument Labels</h2>

<ol>
<li>Good practice</li>
</ol>


<pre><code class="swift">func move(from start: Point, to end: Point)
x.move(from: x, to: y) 
</code></pre>

<ol>
<li><p>Omit all labels when arguments canâ€™t be usefully distinguished, e.g. <code>min(number1, number2)</code>, <code>zip(sequence1, sequence2)</code>.</p></li>
<li><p>When the first argument forms part of a prepositional phrase, give it an argument label. The argument label should normally begin at the preposition, e.g. <code>x.removeBoxes(havingLength: 12)</code>.</p>

<ul>
<li>An exception for the principle above arises when the first two arguments represent parts of a single abstraction. In such cases, begin the argument label after the preposition, to keep the abstraction clear.</li>
</ul>
</li>
</ol>


<p><strong>Preferred:</strong></p>

<pre><code class="swift">a.moveTo(x: b, y: c)
a.fadeFrom(red: b, green: c, blue: d)
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="swift">a.move(toX: b, y: c)
a.fade(fromRed: b, green: c, blue: d)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swiftä¸­çš„Error]]></title>
    <link href="http://hongchaozhang.github.io/blog/2017/10/20/errors-in-swift/"/>
    <updated>2017-10-20T16:24:35+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2017/10/20/errors-in-swift</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC depthFrom:1 depthTo:3 insertAnchor:true -->


<ul>
<li><a href="#swift-error%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">Swift ErroråŸºæœ¬ä½¿ç”¨</a>

<ul>
<li><a href="#throws-in-swift-1x"><code>throws</code> in Swift 1.x</a></li>
<li><a href="#throws-in-swift-2"><code>throws</code> in Swift 2</a></li>
<li><a href="#throws%E7%9A%84%E4%BD%BF%E7%94%A8"><code>throws</code>çš„ä½¿ç”¨</a></li>
<li><a href="#throws%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86"><code>throws</code>æŠ›å‡ºé”™è¯¯çš„å¤„ç†</a></li>
</ul>
</li>
<li><a href="#throws%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E8%B7%B5"><code>throws</code>çš„ä¸€äº›å®è·µ</a>

<ul>
<li><a href="#throws%E7%9A%84%E8%B0%83%E8%AF%95%E5%92%8C%E6%96%AD%E7%82%B9"><code>throws</code>çš„è°ƒè¯•å’Œæ–­ç‚¹</a></li>
<li><a href="#throws%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><code>throws</code>ä»ç„¶å­˜åœ¨çš„é—®é¢˜</a></li>
</ul>
</li>
<li><a href="#swift-%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%A7%8D%E7%B1%BB">Swift é”™è¯¯ç±»å‹çš„ç§ç±»</a>

<ul>
<li><a href="#simple-domain-error">Simple domain error</a></li>
<li><a href="#recoverable-error">Recoverable error</a></li>
<li><a href="#universal-error">Universal error</a></li>
<li><a href="#logic-failure">Logic failure</a></li>
</ul>
</li>
<li><a href="#%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">å‡ ç§å¸¸è§åœºæ™¯ä¸‹çš„é”™è¯¯å¤„ç†</a>

<ul>
<li><a href="#app%E5%86%85%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD">appå†…èµ„æºåŠ è½½</a></li>
<li><a href="#%E5%8A%A0%E8%BD%BD%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%97%B6%E5%8F%91%E7%94%9F%E9%94%99%E8%AF%AF">åŠ è½½å½“å‰ç”¨æˆ·ä¿¡æ¯æ—¶å‘ç”Ÿé”™è¯¯</a></li>
<li><a href="#%E8%BF%98%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BB%A3%E7%A0%81">è¿˜æ²¡æœ‰å®ç°çš„ä»£ç </a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E8%AE%BE%E5%A4%87%E4%B8%8A%E7%9A%84%E4%BC%A0%E6%84%9F%E5%99%A8%E6%94%B6%E9%9B%86%E6%95%B0%E6%8D%AE">è°ƒç”¨è®¾å¤‡ä¸Šçš„ä¼ æ„Ÿå™¨æ”¶é›†æ•°æ®</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">æ€»ç»“</a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E7%9A%84%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95">é”™è¯¯å¤„ç†ç›¸å…³çš„è¾…åŠ©æ–¹æ³•</a>

<ul>
<li><a href="#use-custom-errors">Use Custom Errors</a></li>
<li><a href="#do-cleanup-work-using-defer">Do Cleanup Work Using <code>defer</code></a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">å‚è€ƒ</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-swift-erroråŸºæœ¬ä½¿ç”¨" name="swift-erroråŸºæœ¬ä½¿ç”¨"></a></p>

<h2>Swift ErroråŸºæœ¬ä½¿ç”¨</h2>

<p><a id="markdown-throws-in-swift-1x" name="throws-in-swift-1x"></a></p>

<h3><code>throws</code> in Swift 1.x</h3>

<p>åœ¨Objective-Cä¸­ï¼Œ<code>FileManager</code>çš„copyæ¥å£å¦‚ä¸‹ï¼š</p>

<pre><code class="objc">- (BOOL)copyItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error
</code></pre>

<p>è°ƒç”¨è¯¥æ–¹æ³•æ—¶ï¼Œå†™æ³•å¦‚ä¸‹ï¼š</p>

<pre><code class="swift">NSFileManager *fileManager = [NSFileManager defaultManager];
NSError *error;
[fileManager copyItemAtPath:srcPath toPath:toPath error:&amp;error];
if (error) {
    // å‘ç”Ÿäº†é”™è¯¯
} else {
    // å¤åˆ¶æˆåŠŸ
}
</code></pre>

<p>åœ¨Swift 1.xä¸­ï¼Œä¸Objective-Cç±»ä¼¼ã€‚æ–¹æ³•æ¥å£å¦‚ä¸‹ï¼š</p>

<pre><code class="swift">func copyItemAtPath(_ srcPath: String, toPath dstPath: String, error: NSErrorPointer)
</code></pre>

<p>ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š</p>

<pre><code class="swift">let fileManager = NSFileManager.defaultManager()
var error: NSError?
fileManager.copyItemAtPath(srcPath, toPath: dstPath, error: &amp;error)
if error != nil {
    // å‘ç”Ÿäº†é”™è¯¯
} else {
    // å¤åˆ¶æˆåŠŸ
}
</code></pre>

<p>åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå› ä¸ºè¿™ä¸ª API ä»…ä¼šåœ¨æå…¶ç‰¹å®šçš„æ¡ä»¶ä¸‹ (æ¯”å¦‚ç£ç›˜ç©ºé—´ä¸è¶³) ä¼šå‡ºé”™ï¼Œæ‰€ä»¥å¼€å‘è€…ä¸ºäº†æ–¹ä¾¿ï¼Œæœ‰æ—¶ä¼šç›´æ¥ä¼ å…¥ nil æ¥å¿½è§†æ‰è¿™ä¸ªé”™è¯¯ï¼š</p>

<pre><code class="swift">let fileManager = NSFileManager.defaultManager()
// ä¸å…³å¿ƒæ˜¯å¦å‘ç”Ÿé”™è¯¯
fileManager.copyItemAtPath(srcPath, toPath: dstPath, error: nil)
</code></pre>

<p><a id="markdown-throws-in-swift-2" name="throws-in-swift-2"></a></p>

<h3><code>throws</code> in Swift 2</h3>

<p>è¿™ç§åšæ³•æ— å½¢ä¸­é™ä½äº†åº”ç”¨çš„å¯é æ€§ä»¥åŠä»é”™è¯¯ä¸­æ¢å¤çš„èƒ½åŠ›ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒSwift 2 ä¸­åœ¨ç¼–è¯‘å™¨å±‚çº§å°±å¯¹<code>throws</code>è¿›è¡Œäº†é™å®šã€‚ä¸Šé¢æåˆ°çš„copyæ¥å£åœ¨Swift 2ä¸­çš„å½¢å¼ä¸ºï¼š</p>

<pre><code class="swift">func copyItem(atPath srcPath: String, toPath dstPath: String) throws
</code></pre>

<p>è¢«æ ‡è®°ä¸º<code>throws</code>çš„APIï¼Œå¿…é¡»è¢«å¤„ç†ï¼Œå¦åˆ™ç¼–è¯‘å™¨å°±ä¼šæŠ¥é”™ã€‚è¿™å°±åœ¨ç¼–è¯‘å™¨å±‚é¢å¯¹é”™è¯¯çš„å¤„ç†è¿›è¡Œäº†å¼ºåˆ¶æ‰§è¡Œï¼Œä¿è¯äº†ä»£ç çš„å¯é æ€§ã€‚</p>

<p><a id="markdown-throwsçš„ä½¿ç”¨" name="throwsçš„ä½¿ç”¨"></a></p>

<h3><code>throws</code>çš„ä½¿ç”¨</h3>

<p>ä¸‹é¢æ˜¯åŒ…å«<code>throws</code>çš„ä¸€ä¸ªè‡ªåŠ¨å”®è´§æœºå®ç°ï¼š</p>

<pre><code class="swift">enum VendingMachineError: Error {
    case invalidSelection
    case insufficientFunds(coinsNeeded: Int)
    case outOfStock
}

struct Item {
    var price: Int
    var count: Int
}

class VendingMachine {
    var inventory = [
        "Candy Bar": Item(price: 12, count: 7),
        "Chips": Item(price: 10, count: 4),
        "Pretzels": Item(price: 7, count: 11)
    ]
    var coinsDeposited = 0

    func vend(itemNamed name: String) throws {
        guard let item = inventory[name] else {
            throw VendingMachineError.invalidSelection
        }

        guard item.count &gt; 0 else {
            throw VendingMachineError.outOfStock
        }

        guard item.price &lt;= coinsDeposited else {
            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)
        }

        coinsDeposited -= item.price

        var newItem = item
        newItem.count -= 1
        inventory[name] = newItem

        print("Dispensing \(name)")
    }
}
</code></pre>

<p><code>vend(itemNamed:)</code>æ–¹æ³•çš„å®ç°é€šè¿‡<code>guard</code>æŠ›å‡ºè´­ä¹°è¿‡ç¨‹ä¸­ç›¸åº”çš„é”™è¯¯ã€‚</p>

<p><a id="markdown-throwsæŠ›å‡ºé”™è¯¯çš„å¤„ç†" name="throwsæŠ›å‡ºé”™è¯¯çš„å¤„ç†"></a></p>

<h3><code>throws</code>æŠ›å‡ºé”™è¯¯çš„å¤„ç†</h3>

<p>è¢«æ ‡è®°ä¸º<code>throws</code>çš„APIï¼Œæˆ‘ä»¬å¿…é¡»é‡‡ç”¨ä¸‹é¢å‡ ç§å¤„ç†æ–¹å¼ä¸­çš„ä¸€ç§æ¥å¤„ç†ï¼Œå¦åˆ™ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚</p>

<h4><code>do catch</code></h4>

<pre><code class="swift">var vendingMachine = VendingMachine()
vendingMachine.coinsDeposited = 8
do {
    try buyFavoriteSnack(person: "Alice", vendingMachine: vendingMachine)
} catch VendingMachineError.invalidSelection {
    print("Invalid Selection.")
} catch VendingMachineError.outOfStock {
    print("Out of Stock.")
} catch VendingMachineError.insufficientFunds(let coinsNeeded) {
    print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")
}
</code></pre>

<h4><code>try?</code></h4>

<p>ä½¿ç”¨<code>try?</code>æ¥å¤„ç†é”™è¯¯ï¼Œå°†å…¶è¿”å›å€¼å˜ä¸ºOptionalï¼šå¦‚æœåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œæ¥å£è¿”å›<code>nil</code>ï¼ŒåŒæ—¶é”™è¯¯åœæ­¢ç»§ç»­ä¼ æ’­ã€‚æ¯”å¦‚ï¼š</p>

<pre><code class="swift">func fetchDataFromDisk() throws -&gt; Data

func fetchDataFromServer() throws -&gt; Data

func fetchData() -&gt; Data? {
    if let data = try? fetchDataFromDisk() { 
        return data 
    }
    if let data = try? fetchDataFromServer() { 
        return data 
    }
    return nil
}
</code></pre>

<h4><code>try!</code></h4>

<p>å¦‚æœä½ éå¸¸ç¡®ä¿¡ä¸€ä¸ªè¢«æ ‡è®°ä¸º<code>throws</code>çš„æ¥å£ï¼Œåœ¨ä½ çš„ç¯å¢ƒä¸­ä¸ä¼šæŠ›å‡ºé”™è¯¯ï¼Œå¯ä»¥é€šè¿‡<code>try!</code>æ¥å¼ºåˆ¶ç»ˆæ­¢é”™è¯¯çš„ç»§ç»­ä¼ æ’­ã€‚å¦‚æœåœ¨æ‰§è¡Œçš„æ—¶å€™å‡ºç°äº†é”™è¯¯ï¼Œé‚£ä¹ˆæŠ›å‡ºè¿è¡Œæ—¶é”™è¯¯ï¼Œå¯¼è‡´ç¨‹åºå´©æºƒã€‚</p>

<p>æ¯”å¦‚ï¼Œ<code>loadImage(atPath:)</code>æ–¹æ³•åŠ è½½æŒ‡å®šç›®å½•ä¸‹é¢çš„ä¸€å¼ å›¾ç‰‡åˆ°å†…å­˜ä¸­ï¼Œå¦‚æœåŠ è½½å¼‚å¸¸ï¼Œä¼šæŠ›å‡ºé”™è¯¯ã€‚åœ¨ä¸‹é¢çš„ä½¿ç”¨ä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›åŠ è½½ä¸€å¼ åº”ç”¨ä¸­åŒ…å«çš„å›¾ç‰‡ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥é€šè¿‡<code>try!</code>æ¥ç»ˆæ­¢é”™è¯¯çš„ç»§ç»­ä¼ æ’­ã€‚</p>

<pre><code class="swift">let photo = try! loadImage(atPath: "./Resources/John Appleseed.jpg")
</code></pre>

<h4><code>try</code></h4>

<p>ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨<code>try</code>æ¥è°ƒç”¨è¢«æ ‡è®°ä¸º<code>throws</code>çš„æ¥å£ï¼Œä½†æ˜¯è¿™ç§æƒ…å†µä¸‹ï¼Œé”™è¯¯ä¼šç»§ç»­ä¼ æ’­ï¼ŒåŒ…å«è¯¥è°ƒç”¨çš„æ–¹æ³•ä¹Ÿå¿…é¡»è¢«æ ‡è®°ä¸º<code>throws</code>æ‰è¡Œï¼Œå¦åˆ™ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚</p>

<pre><code class="swift">let favoriteSnacks = [
    "Alice": "Chips",
    "Bob": "Licorice",
    "Eve": "Pretzels",
]
func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {
    let snackName = favoriteSnacks[person] ?? "Candy Bar"
    try vendingMachine.vend(itemNamed: snackName)
}
</code></pre>

<p>åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå› ä¸º<code>buyFavoriteSnack(person: vendingMachine:)</code>ä½¿ç”¨<code>try</code>è°ƒç”¨äº†ä¸€ä¸ªè¢«æ ‡è®°ä¸ºthrowsçš„æ¥å£<code>vend(itemNamed:)</code>ï¼Œé”™è¯¯ä¼šç»§ç»­ä¼ æ’­ï¼Œå› æ­¤ï¼Œè¯¥æ–¹æ³•ä¹Ÿéœ€è¦æ ‡è®°ä¸ºthorwsã€‚</p>

<p><a id="markdown-throwsçš„ä¸€äº›å®è·µ" name="throwsçš„ä¸€äº›å®è·µ"></a></p>

<h2><code>throws</code>çš„ä¸€äº›å®è·µ</h2>

<p><a id="markdown-throwsçš„è°ƒè¯•å’Œæ–­ç‚¹" name="throwsçš„è°ƒè¯•å’Œæ–­ç‚¹"></a></p>

<h3><code>throws</code>çš„è°ƒè¯•å’Œæ–­ç‚¹</h3>

<p>Swiftçš„é”™è¯¯æŠ›å‡ºå¹¶ä¸æ˜¯ä¼ ç»Ÿæ„ä¹‰çš„exceptionï¼Œåœ¨è°ƒè¯•æ—¶æŠ›å‡ºé”™è¯¯å¹¶ä¸ä¼šè§¦å‘Exceptionæ–­ç‚¹ã€‚å¦å¤–ï¼Œthrowæœ¬èº«æ˜¯è¯­è¨€çš„å…³é”®å­—ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªsymbolï¼Œå®ƒä¹Ÿä¸èƒ½è§¦å‘Symbolicç±»å‹çš„æ–­ç‚¹ã€‚å¦‚æœæˆ‘ä»¬å¸Œæœ›åœ¨æ‰€æœ‰throwè¯­å¥æ‰§è¡Œçš„æ—¶å€™è®©ç¨‹åºåœä½çš„è¯ï¼Œéœ€è¦ä¸€äº›é¢å¤–çš„æŠ€å·§ã€‚åœ¨ä¹‹å‰ throw çš„æ±‡ç¼–å®ç°ä¸­ï¼Œå¯ä»¥çœ‹åˆ°æ‰€æœ‰throwè¯­å¥åœ¨è¿”å›å‰éƒ½ä¼šè¿›è¡Œä¸€æ¬¡<code>swift_willThrow</code>çš„è°ƒç”¨ï¼Œè¿™å°±æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ Symbolicè¯­å¥ï¼Œæˆ‘ä»¬è®¾ç½®ä¸€ä¸ª<code>swift_willThrow</code>çš„Symbolicæ–­ç‚¹ï¼Œå°±å¯ä»¥è®©ç¨‹åºåœ¨throwçš„æ—¶å€™åœä½ï¼Œå¹¶ä½¿ç”¨è°ƒç”¨æ ˆä¿¡æ¯æ¥è·çŸ¥ç¨‹åºåœ¨å“ªé‡ŒæŠ›å‡ºäº†é”™è¯¯ã€‚</p>

<p>è¡¥å……ï¼Œåœ¨æœ€æ–°ç‰ˆæœ¬çš„Xcodeä¸­ï¼ŒAppleç›´æ¥ä¸ºæˆ‘ä»¬åœ¨æ–­ç‚¹ç±»å‹ä¸­åŠ ä¸Šäº† â€œSwift Error Breakpointâ€çš„é€‰é¡¹ï¼Œå®ƒèƒŒååšçš„å°±æ˜¯åœ¨<code>swift_willThrow</code>ä¸Šæ·»åŠ ä¸€ä¸ªæ–­ç‚¹ã€‚ä¸è¿‡å› ä¸ºæœ‰äº†æ›´ç›´æ¥çš„æ–¹æ³•ï¼Œæˆ‘ä»¬ç°åœ¨ä¸å†éœ€è¦æ‰‹åŠ¨å»æ·»åŠ è¿™ä¸ªç¬¦å·æ–­ç‚¹äº†ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½®â€œSwift Error Breakpointâ€å¯¹throwsè¿›è¡Œæ–­ç‚¹è®¾ç½®å’Œè°ƒè¯•ã€‚è®¾ç½®æ–¹æ³•å¦‚ä¸‹ï¼š</p>

<p><img src="/images/Swift-Error-Breakpoint.png" alt="swift error breakpoint" /></p>

<p><a id="markdown-throwsä»ç„¶å­˜åœ¨çš„é—®é¢˜" name="throwsä»ç„¶å­˜åœ¨çš„é—®é¢˜"></a></p>

<h3><code>throws</code>ä»ç„¶å­˜åœ¨çš„é—®é¢˜</h3>

<p>ä¸èƒ½ä»æ¥å£ç›´æ¥çœ‹å‡ºæœ‰å“ªäº›å¯èƒ½æŠ›å‡ºçš„Errorï¼Œå¿…é¡»çœ‹Documentæ‰è¡Œï¼Œå¸¦æ¥äº†ä¸€äº›ä¸ä¾¿ã€‚æ¯”å¦‚ï¼Œåªé€šè¿‡æ¥å£ï¼š</p>

<pre><code class="swift">func vend(itemNamed name: String) throws
</code></pre>

<p>æˆ‘ä»¬æ²¡æœ‰åŠæ³•çŸ¥é“è¿™ä¸ªæ¥å£å¯èƒ½è¿”å›å“ªäº›é”™è¯¯ã€‚æ­¤æ—¶ï¼Œè¦ä¹ˆé˜…è¯»æ–‡æ¡£ï¼Œè·å¾—ç¡®åˆ‡çš„æŠ›å‡ºé”™è¯¯ï¼Œåˆ†åˆ«è¿›è¡Œå¤„ç†ï¼›æˆ–è€…å°†æ‰€æœ‰çš„é”™è¯¯ç»Ÿä¸€å¤„ç†å¦‚ä¸‹ï¼š</p>

<pre><code class="swift">do {
    let snackName = favoriteSnacks[person] ?? "Candy Bar"
    try vendingMachine.vend(itemNamed: snackName)
} catch {
    // é”™è¯¯æŠ›å‡º
}
</code></pre>

<p><a id="markdown-swift-é”™è¯¯ç±»å‹çš„ç§ç±»" name="swift-é”™è¯¯ç±»å‹çš„ç§ç±»"></a></p>

<h2>Swift é”™è¯¯ç±»å‹çš„ç§ç±»</h2>

<p>å‚è€ƒSwiftå®˜æ–¹æ–‡æ¡£<a href="https://github.com/apple/swift/blob/master/docs/ErrorHandling.rst">Error Handling in Swift<!-- 2.0--></a>ï¼ŒSwiftä¸­çš„é”™è¯¯æœ‰ä¸‹é¢å››ç§ï¼š</p>

<ol>
<li>Simple domain error</li>
<li>Recoverable error</li>
<li>Universal error</li>
<li>Logic failure</li>
</ol>


<p><a id="markdown-simple-domain-error" name="simple-domain-error"></a></p>

<h3>Simple domain error</h3>

<p>ç®€å•çš„ï¼Œæ˜¾è€Œæ˜“è§çš„é”™è¯¯ã€‚è¿™ç±»é”™è¯¯çš„æœ€å¤§ç‰¹ç‚¹æ˜¯æˆ‘ä»¬ä¸éœ€è¦çŸ¥é“åŸå› ï¼Œåªéœ€è¦çŸ¥é“é”™è¯¯å‘ç”Ÿï¼Œå¹¶ä¸”æƒ³è¦è¿›è¡Œå¤„ç†ã€‚ç”¨æ¥è¡¨ç¤ºè¿™ç§é”™è¯¯å‘ç”Ÿçš„æ–¹æ³•ä¸€èˆ¬å°±æ˜¯è¿”å›ä¸€ä¸ª<code>nil</code>å€¼ã€‚åœ¨Swiftä¸­ï¼Œè¿™ç±»é”™è¯¯æœ€å¸¸è§çš„æƒ…å†µå°±æ˜¯å°†æŸä¸ªå­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•´æ•°ï¼Œæˆ–è€…åœ¨å­—å…¸å°è¯•ç”¨æŸä¸ªä¸å­˜åœ¨çš„ key è·å–å…ƒç´ ï¼š</p>

<pre><code class="swift">// Simple Domain Error çš„ä¾‹å­
let num = Int("hello world") // nil
let element = dic["key_not_exist"] // nil
</code></pre>

<p><strong>å¯èƒ½å‡ºç°è¿™ç§é”™è¯¯çš„æ¥å£ï¼Œä¸éœ€è¦ä½¿ç”¨<code>throws</code>æ¥æ ‡è®°ï¼Œåªéœ€è¦å°†æ¥å£çš„è¿”å›ç±»å‹è®¾ç½®ä¸ºOptionalå³å¯ã€‚</strong>åœ¨ä½¿ç”¨å±‚é¢ (æˆ–è€…è¯´åº”ç”¨é€»è¾‘) ä¸Šï¼Œè¿™ç±»é”™è¯¯ä¸€èˆ¬ç”¨<code>if let</code>çš„å¯é€‰å€¼ç»‘å®šæˆ–è€…æ˜¯<code>guard let</code>æå‰è¿›è¡Œè¿”å›å¤„ç†å³å¯ã€‚</p>

<p><a id="markdown-recoverable-error" name="recoverable-error"></a></p>

<h3>Recoverable error</h3>

<p>æ­£å¦‚å…¶åï¼Œè¿™ç±»é”™è¯¯åº”è¯¥æ˜¯è¢«å®¹è®¸ï¼Œå¹¶ä¸”æ˜¯å¯ä»¥æ¢å¤çš„ã€‚å¯æ¢å¤é”™è¯¯çš„å‘ç”Ÿæ˜¯æ­£å¸¸çš„ç¨‹åºè·¯å¾„ä¹‹ä¸€ï¼Œè€Œä½œä¸ºå¼€å‘è€…ï¼Œæˆ‘ä»¬åº”å½“å»æ£€å‡ºè¿™ç±»é”™è¯¯å‘ç”Ÿçš„æƒ…å†µï¼Œå¹¶è¿›ä¸€æ­¥å¯¹å®ƒä»¬è¿›è¡Œå¤„ç†ï¼Œè®©å®ƒä»¬æ¢å¤åˆ°æˆ‘ä»¬æœŸæœ›çš„ç¨‹åºè·¯å¾„ä¸Šã€‚</p>

<p><strong>è¿™ç±»é”™è¯¯åœ¨Objective-Cçš„æ—¶ä»£é€šå¸¸ç”¨NSErrorç±»å‹æ¥è¡¨ç¤ºï¼Œè€Œåœ¨Swifté‡Œåˆ™æ˜¯é€šè¿‡throwsæ¥å®ç°ã€‚</strong>ä¸€èˆ¬æˆ‘ä»¬éœ€è¦æ£€æŸ¥é”™è¯¯çš„ç±»å‹ï¼Œå¹¶ä½œå‡ºåˆç†çš„å“åº”ã€‚è€Œé€‰æ‹©å¿½è§†è¿™ç±»é”™è¯¯å¾€å¾€æ˜¯ä¸æ˜æ™ºçš„ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ç”¨æˆ·æ­£å¸¸ä½¿ç”¨è¿‡ç¨‹ä¸­å¯èƒ½ä¼šå‡ºç°çš„æƒ…å†µï¼Œæˆ‘ä»¬åº”è¯¥å°è¯•å¯¹å…¶æ¢å¤ï¼Œæˆ–è€…è‡³å°‘å‘ç”¨æˆ·ç»™å‡ºåˆç†çš„æç¤ºï¼Œè®©ä»–ä»¬çŸ¥é“å‘ç”Ÿäº†ä»€ä¹ˆã€‚åƒæ˜¯ç½‘ç»œè¯·æ±‚è¶…æ—¶ï¼Œæˆ–è€…å†™å…¥æ–‡ä»¶æ—¶ç£ç›˜ç©ºé—´ä¸è¶³ï¼š</p>

<pre><code class="swift">// ç½‘ç»œè¯·æ±‚
let url = URL(string: "https://www.example.com/")!
let task = URLSession.shared.dataTask(with: url) { data, response, error in
    if let error = error {
        // æç¤ºç”¨æˆ·
        self.showErrorAlert("Error: \(error.localizedDescription)")
    }
    let data = data!
    // ...
}

// å†™å…¥æ–‡ä»¶
func write(data: Data, to url: URL) {
    do {
        try data.write(to: url)
    } catch let error as NSError {
        if error.code == NSFileWriteOutOfSpaceError {
            // å°è¯•é€šè¿‡é‡Šæ”¾ç©ºé—´è‡ªåŠ¨æ¢å¤
            removeUnusedFiles()
            write(data: data, to: url)
        } else {
            // å…¶ä»–é”™è¯¯ï¼Œæç¤ºç”¨æˆ·
            showErrorAlert("Error: \(error.localizedDescription)")
        }
    } catch {
        showErrorAlert("Error: \(error.localizedDescription)")
    }
}
</code></pre>

<p><a id="markdown-universal-error" name="universal-error"></a></p>

<h3>Universal error</h3>

<p>è¿™ç±»é”™è¯¯ç†è®ºä¸Šå¯ä»¥æ¢å¤ï¼Œä½†æ˜¯ç”±äºè¯­è¨€æœ¬èº«çš„ç‰¹æ€§æ‰€å†³å®šï¼Œæˆ‘ä»¬éš¾ä»¥å¾—çŸ¥è¿™ç±»é”™è¯¯çš„æ¥æºï¼Œæ‰€ä»¥ä¸€èˆ¬æ¥è¯´ä¹Ÿä¸ä¼šå»å¤„ç†è¿™ç§é”™è¯¯ã€‚è¿™ç±»é”™è¯¯åŒ…æ‹¬ç±»ä¼¼ä¸‹é¢è¿™äº›æƒ…å½¢ï¼š</p>

<pre><code class="swift">// å†…å­˜ä¸è¶³
[Int](repeating: 100, count: .max)

// è°ƒç”¨æ ˆæº¢å‡º
func foo() { foo() }
foo()
</code></pre>

<p>æˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾è®¡ä¸€äº›æ‰‹æ®µæ¥å¯¹è¿™äº›é”™è¯¯è¿›è¡Œå¤„ç†ï¼Œæ¯”å¦‚ï¼šæ£€æµ‹å½“å‰çš„å†…å­˜å ç”¨å¹¶åœ¨è¶…è¿‡ä¸€å®šå€¼åè­¦å‘Šï¼Œæˆ–è€…ç›‘è§†æ ˆframeæ•°è¿›è¡Œé™åˆ¶ç­‰ã€‚ä½†æ˜¯ä¸€èˆ¬æ¥è¯´è¿™æ˜¯ä¸å¿…è¦çš„ï¼Œä¹Ÿä¸å¯èƒ½æ¶µç›–å…¨éƒ¨çš„é”™è¯¯æƒ…å†µã€‚æ›´å¤šæƒ…å†µä¸‹ï¼Œè¿™æ˜¯ç”±äºä»£ç è§¦ç¢°åˆ°äº†è®¾å¤‡çš„ç‰©ç†é™åˆ¶å’Œè¾¹ç•Œæƒ…å†µæ‰€é€ æˆçš„ï¼Œä¸€èˆ¬æˆ‘ä»¬ä¹Ÿä¸å»è¿›è¡Œå¤„ç†ï¼ˆé™¤éæ˜¯äººä¸ºé€ æˆçš„bugï¼‰ã€‚</p>

<p>åœ¨ Swift ä¸­ï¼Œå„ç§è¢«ä½¿ç”¨<code>fatalError</code>è¿›è¡Œå¼ºåˆ¶ç»ˆæ­¢çš„é”™è¯¯ä¸€èˆ¬éƒ½å¯ä»¥å½’ç±»åˆ° Universal errorã€‚</p>

<p><a id="markdown-logic-failure" name="logic-failure"></a></p>

<h3>Logic failure</h3>

<p>é€»è¾‘é”™è¯¯æ˜¯ç¨‹åºå‘˜çš„å¤±è¯¯æ‰€é€ æˆçš„é”™è¯¯ï¼Œå®ƒä»¬åº”è¯¥åœ¨å¼€å‘æ—¶é€šè¿‡ä»£ç è¿›è¡Œä¿®æ­£å¹¶å®Œå…¨é¿å…ï¼Œè€Œä¸æ˜¯ç­‰åˆ°è¿è¡Œæ—¶å†è¿›è¡Œæ¢å¤å’Œå¤„ç†ã€‚</p>

<p>å¸¸è§çš„ Logic failure åŒ…æ‹¬æœ‰ï¼š</p>

<pre><code class="swift">// å¼ºåˆ¶è§£åŒ…ä¸€ä¸ª `nil` å¯é€‰å€¼
var name: String? = nil
name!

// æ•°ç»„è¶Šç•Œè®¿é—®
let arr = [1,2,3]
let num = arr[3]

// è®¡ç®—æº¢å‡º
var a = Int.max
a += 1

// å¼ºåˆ¶ try ä½†æ˜¯å‡ºç°é”™è¯¯
try! JSONDecoder().decode(Foo.self, from: Data())
</code></pre>

<p>è¿™ç±»é”™è¯¯åœ¨å®ç°ä¸­è§¦å‘çš„ä¸€èˆ¬æ˜¯<code>assert</code>æˆ–è€…<code>precondition</code>ã€‚</p>

<p>å’Œ<code>fatalError</code>ä¸åŒï¼Œ<code>assert</code>åªåœ¨è¿›è¡Œç¼–è¯‘ä¼˜åŒ–çš„<code>-O</code>é…ç½®ä¸‹æ˜¯ä¸è§¦å‘çš„ï¼Œè€Œå¦‚æœæ›´è¿›ä¸€æ­¥ï¼Œå°†ç¼–è¯‘ä¼˜åŒ–é€‰é¡¹é…ç½®ä¸º<code>-Ounchecked</code>çš„è¯ï¼Œ<code>precondition</code>ä¹Ÿå°†ä¸è§¦å‘ã€‚æ­¤æ—¶ï¼Œå„æ–¹æ³•ä¸­çš„<code>precondition</code>å°†è¢«è·³è¿‡ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å¾—åˆ°æœ€å¿«çš„è¿è¡Œé€Ÿåº¦ã€‚ä½†æ˜¯ç›¸å¯¹åœ°ä»£ç çš„å®‰å…¨æ€§ä¹Ÿå°†é™ä½ï¼Œå› ä¸ºå¯¹äºè¶Šç•Œè®¿é—®æˆ–è€…è®¡ç®—æº¢å‡ºç­‰é”™è¯¯ï¼Œæˆ‘ä»¬å¾—åˆ°çš„å°†æ˜¯ä¸ç¡®å®šçš„è¡Œä¸ºã€‚</p>

<table>
<thead>
<tr>
<th>å‡½æ•° </th>
<th> fatalError </th>
<th> precondition </th>
<th> assert</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Onone </td>
<td> è§¦å‘ </td>
<td> è§¦å‘ </td>
<td> è§¦å‘</td>
</tr>
<tr>
<td>-O </td>
<td> è§¦å‘ </td>
<td> è§¦å‘ </td>
<td> -</td>
</tr>
<tr>
<td>-Ounchecked </td>
<td> è§¦å‘ </td>
<td> - </td>
<td> -</td>
</tr>
</tbody>
</table>


<p>å¯¹äºUniversal errorä¸€èˆ¬ä½¿ç”¨<code>fatalError</code>ï¼Œè€Œå¯¹äº<code>Logic failure</code>ä¸€èˆ¬ä½¿ç”¨<code>assert</code>æˆ–è€…<code>precondition</code>ã€‚éµå®ˆè¿™ä¸ªè§„åˆ™ä¼šæœ‰åŠ©äºæˆ‘ä»¬åœ¨ç¼–ç æ—¶å¯¹é”™è¯¯è¿›è¡Œç•Œå®šã€‚è€Œæœ‰æ—¶å€™æˆ‘ä»¬ä¹Ÿå¸Œæœ›èƒ½å°½å¯èƒ½å¤šåœ°åœ¨å¼€å‘çš„æ—¶å€™æ•è·Logic failureï¼Œè€Œåœ¨äº§å“å‘å¸ƒåå°½é‡å‡å°‘crashæ¯”ä¾‹ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œç›¸æ¯”äºç›´æ¥å°†Logic failureè½¬æ¢ä¸ºå¯æ¢å¤çš„é”™è¯¯ï¼Œæˆ‘ä»¬æœ€å¥½æ˜¯ä½¿ç”¨<code>assert</code>åœ¨å†…éƒ¨è¿›è¡Œæ£€æŸ¥ï¼Œæ¥è®©ç¨‹åºåœ¨å¼€å‘æ—¶å´©æºƒã€‚</p>

<p><a id="markdown-å‡ ç§å¸¸è§åœºæ™¯ä¸‹çš„é”™è¯¯å¤„ç†" name="å‡ ç§å¸¸è§åœºæ™¯ä¸‹çš„é”™è¯¯å¤„ç†"></a></p>

<h2>å‡ ç§å¸¸è§åœºæ™¯ä¸‹çš„é”™è¯¯å¤„ç†</h2>

<p>å…‰è¯´ä¸ç»ƒå‡æŠŠå¼ã€‚è®©æˆ‘ä»¬æ¥å®é™…åˆ¤æ–­ä¸€ä¸‹ä¸‹é¢è¿™äº›æƒ…å†µä¸‹æˆ‘ä»¬éƒ½åº”è¯¥é€‰æ‹©ç”¨å“ªç§é”™è¯¯å¤„ç†æ–¹å¼å§~</p>

<p><a id="markdown-appå†…èµ„æºåŠ è½½" name="appå†…èµ„æºåŠ è½½"></a></p>

<h3>appå†…èµ„æºåŠ è½½</h3>

<p>å‡è®¾æˆ‘ä»¬åœ¨å¤„ç†ä¸€ä¸ªæœºå™¨å­¦ä¹ çš„æ¨¡å‹ï¼Œéœ€è¦ä»ç£ç›˜è¯»å–ä¸€ä»½é¢„å…ˆè®­ç»ƒå¥½çš„æ¨¡å‹ã€‚è¯¥æ¨¡å‹ä»¥æ–‡ä»¶çš„æ–¹å¼å­˜å‚¨åœ¨ app bundle ä¸­ï¼Œå¦‚æœè¯»å–æ—¶æ²¡æœ‰æ‰¾åˆ°è¯¥æ¨¡å‹ï¼Œæˆ‘ä»¬åº”è¯¥å¦‚ä½•å¤„ç†è¿™ä¸ªé”™è¯¯ï¼Ÿ</p>

<h4>æ–¹æ¡ˆ 1 Simple domain error</h4>

<pre><code class="swift">func loadModel() -&gt; Model? {
    guard let path = Bundle.main.path(forResource: "my_pre_trained_model", ofType: "mdl") else {
        return nil
    }
    let url = URL(fileURLWithPath: path)
    guard let data = try? Data(contentOf: url) else {
        return nil
    }

    return try? ModelLoader.load(from: data)
}
</code></pre>

<h4>æ–¹æ¡ˆ 2 Recoverable error</h4>

<pre><code class="swift">func loadModel() throws -&gt; Model {
    guard let path = Bundle.main.path(forResource: "my_pre_trained_model", ofType: "mdl") else {
        throw AppError.FileNotExisting
    }
    let url = URL(fileURLWithPath: path)
    let data = try Data(contentOf: url)
    return try ModelLoader.load(from: data)
}
</code></pre>

<h4>æ–¹æ¡ˆ 3 Universal error</h4>

<pre><code class="swift">func loadModel() -&gt; Model {
    guard let path = Bundle.main.path(forResource: "my_pre_trained_model", ofType: "mdl") else {
        fatalError("Model file not existing")
    }
    let url = URL(fileURLWithPath: path)
    do {
        let data = try Data(contentOf: url)
        return try ModelLoader.load(from: data)
    } catch {
        fatalError("Model corrupted.")
    }
}
</code></pre>

<h4>æ–¹æ¡ˆ 4 Logic failure</h4>

<pre><code class="swift">func loadModel() -&gt; Model {
    let path = Bundle.main.path(forResource: "my_pre_trained_model", ofType: "mdl")!
    let url = URL(fileURLWithPath: path)
    let data = try! Data(contentOf: url)
    return try! ModelLoader.load(from: data)
}
</code></pre>

<p><details>
  <summary><em>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</em></summary></p>

<p>æ­£ç¡®ç­”æ¡ˆåº”è¯¥æ˜¯æ–¹æ¡ˆ 4ï¼Œä½¿ç”¨Logic failureè®©ä»£ç ç›´æ¥å´©æºƒã€‚</p>

<p>ä½œä¸ºå†…å»ºçš„å­˜åœ¨äºapp bundleä¸­æ¨¡å‹æˆ–è€…é…ç½®æ–‡ä»¶ï¼Œå¦‚æœä¸å­˜åœ¨æˆ–è€…æ— æ³•åˆå§‹åŒ–ï¼Œåœ¨ä¸è€ƒè™‘æç«¯å› ç´ çš„å‰æä¸‹ï¼Œä¸€å®šæ˜¯å¼€å‘æ–¹é¢å‡ºç°äº†é—®é¢˜ï¼Œè¿™ä¸åº”è¯¥æ˜¯ä¸€ä¸ªå¯æ¢å¤çš„é”™è¯¯ï¼Œæ— è®ºé‡è¯•å¤šå°‘æ¬¡ç»“æœè‚¯å®šæ˜¯ä¸€æ ·çš„ã€‚ä¹Ÿè®¸æ˜¯å¼€å‘è€…å¿˜äº†å°†æ–‡ä»¶æ”¾åˆ°åˆé€‚çš„ä½ç½®ï¼Œä¹Ÿè®¸æ˜¯æ–‡ä»¶æœ¬èº«å‡ºç°äº†é—®é¢˜ã€‚ä¸è®ºæ˜¯å“ªç§æƒ…å†µï¼Œæˆ‘ä»¬éƒ½ä¼šå¸Œæœ›å°½æ—©å‘ç°å¹¶å¼ºåˆ¶æˆ‘ä»¬ä¿®æ­£é”™è¯¯ï¼Œè€Œè®©ä»£ç å´©æºƒå¯ä»¥å¾ˆå¥½åœ°åšåˆ°è¿™ä¸€ç‚¹ã€‚</p>

<p>ä½¿ç”¨Universal erroråŒæ ·å¯ä»¥è®©ä»£ç å´©æºƒï¼Œä½†æ˜¯Universal erroræ›´å¤šæ˜¯ç”¨åœ¨è¯­è¨€çš„è¾¹ç•Œæƒ…å†µä¸‹ã€‚è€Œè¿™é‡Œå¹¶éè¿™ç§æƒ…å†µã€‚
</details></p>

<p><a id="markdown-åŠ è½½å½“å‰ç”¨æˆ·ä¿¡æ¯æ—¶å‘ç”Ÿé”™è¯¯" name="åŠ è½½å½“å‰ç”¨æˆ·ä¿¡æ¯æ—¶å‘ç”Ÿé”™è¯¯"></a></p>

<h3>åŠ è½½å½“å‰ç”¨æˆ·ä¿¡æ¯æ—¶å‘ç”Ÿé”™è¯¯</h3>

<p>æˆ‘ä»¬åœ¨ç”¨æˆ·ç™»å½•åä¼šå°†ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åœ¨æœ¬åœ°ï¼Œæ¯æ¬¡é‡æ–°æ‰“å¼€appæ—¶æˆ‘ä»¬æ£€æµ‹å¹¶ä½¿ç”¨ç”¨æˆ·ä¿¡æ¯ã€‚å½“ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨æ—¶ï¼Œåº”è¯¥è¿›è¡Œçš„å¤„ç†ï¼š</p>

<h4>æ–¹æ¡ˆ 1 Simple domain error</h4>

<pre><code class="swift">func loadUser() -&gt; User? {
    let username = UserDefaults.standard.string(forKey: "com.onevcat.app.defaults.username")
    if let username {
        return User(name: username)
    } else {
        return nil
    }
}
</code></pre>

<h4>æ–¹æ¡ˆ 2 Recoverable error</h4>

<pre><code class="swift">func loadUser() throws -&gt; User {
    let username = UserDefaults.standard.string(forKey: "com.onevcat.app.defaults.username")
    if let username {
        return User(name: username)
    } else {
        throws AppError.UsernameNotExisting
    }
}
</code></pre>

<h4>æ–¹æ¡ˆ 3 Universal error</h4>

<pre><code class="swift">func loadUser() -&gt; User {
    let username = UserDefaults.standard.string(forKey: "com.onevcat.app.defaults.username")
    if let username {
        return User(name: username)
    } else {
        fatalError("User name not existing")
    }
}
</code></pre>

<h4>æ–¹æ¡ˆ 4 Logic failure</h4>

<pre><code class="swift">func loadUser() -&gt; User {
    let username = UserDefaults.standard.string(forKey: "com.onevcat.app.defaults.username")
    return User(name: username!)
}
</code></pre>

<p><details>
  <summary><em>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</em></summary></p>

<p>é¦–å…ˆè‚¯å®šæ’é™¤æ–¹æ¡ˆ3å’Œ4ã€‚â€œç”¨æˆ·åä¸å­˜åœ¨â€æ˜¯ä¸€ä¸ªæ­£å¸¸çš„ç°è±¡ï¼Œè‚¯å®šä¸èƒ½ç›´æ¥crashã€‚æ‰€ä»¥æˆ‘ä»¬åº”è¯¥åœ¨æ–¹æ¡ˆ1å’Œæ–¹æ¡ˆ2ä¸­é€‰æ‹©ã€‚</p>

<p>å¯¹äºè¿™ç§æƒ…å†µï¼Œé€‰æ‹©æ–¹æ¡ˆ1 Simple domain errorä¼šæ›´å¥½ã€‚å› ä¸ºç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨æ˜¯å¾ˆç®€å•çš„ä¸€ä¸ªçŠ¶å†µï¼Œå¦‚æœç”¨æˆ·ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æ¥è®©ç”¨æˆ·ç™»å½•å³å¯ï¼Œè¿™å¹¶ä¸éœ€è¦çŸ¥é“é¢å¤–çš„é”™è¯¯ä¿¡æ¯ï¼Œè¿”å›<code>nil</code>å°±èƒ½å¤Ÿå¾ˆå¥½åœ°è¡¨è¾¾æ„å›¾äº†ã€‚</p>

<p>å½“ç„¶ï¼Œæˆ‘ä»¬ä¸æ’é™¤ä»Šåéšç€æƒ…å†µè¶Šæ¥è¶Šå¤æ‚ï¼Œä¼šéœ€è¦åŒºåˆ†ç”¨æˆ·ä¿¡æ¯ç¼ºå¤±çš„åŸå›  (æ¯”å¦‚æ˜¯å¦æ˜¯æ–°ç”¨æˆ·è¿˜æ²¡æœ‰æ³¨å†Œï¼Œè¿˜æ˜¯ç”±äºåŸç”¨æˆ·æ³¨é”€ç­‰)ã€‚ä½†æ˜¯åœ¨å½“å‰çš„æƒ…å†µä¸‹æ¥çœ‹ï¼Œè¿™å±äºè¿‡åº¦è®¾è®¡ï¼Œæš‚æ—¶å¹¶ä¸éœ€è¦è€ƒè™‘ã€‚å¦‚æœä¹‹åä¸šåŠ¡å¤æ‚åˆ°è¿™ä¸ªç¨‹åº¦ï¼Œåœ¨ç¼–è¯‘å™¨çš„å¸®åŠ©ä¸‹å°†Simple domain errorä¿®æ”¹ä¸ºRecoverable errorä¹Ÿä¸æ˜¯ä»€ä¹ˆéš¾äº‹å„¿ã€‚
</details></p>

<p><a id="markdown-è¿˜æ²¡æœ‰å®ç°çš„ä»£ç " name="è¿˜æ²¡æœ‰å®ç°çš„ä»£ç "></a></p>

<h3>è¿˜æ²¡æœ‰å®ç°çš„ä»£ç </h3>

<p>å‡è®¾ä½ åœ¨ä¸ºä½ çš„æœåŠ¡å¼€å‘ä¸€ä¸ªiOSæ¡†æ¶ï¼Œä½†æ˜¯ç”±äºå·¥æœŸæœ‰é™ï¼Œæœ‰ä¸€äº›åŠŸèƒ½åªå®šä¹‰äº†æ¥å£ï¼Œæ²¡æœ‰è¿›è¡Œå…·ä½“å®ç°ã€‚è¿™äº›æ¥å£ä¼šåœ¨æ­£å¼ç‰ˆä¸­å®Œæˆï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦é¢„å…ˆå‘å¸ƒç»™å‹å•†å†…æµ‹ã€‚æ‰€ä»¥é™¤äº†åœ¨æ–‡æ¡£ä¸­æ˜ç¡®æ ‡æ˜è¿™äº›å†…å®¹ï¼Œè¿™äº›æ–¹æ³•å†…éƒ¨åº”è¯¥å¦‚ä½•å¤„ç†å‘¢ï¼Ÿ</p>

<h4>æ–¹æ¡ˆ 1 Simple domain error</h4>

<pre><code class="swift">func foo() -&gt; Bar? {
    return nil
}
</code></pre>

<h4>æ–¹æ¡ˆ 2 Recoverable error</h4>

<pre><code class="swift">func foo() throws -&gt; Bar? {
    throw FrameworkError.NotImplemented
}
</code></pre>

<h4>æ–¹æ¡ˆ 3 Universal error</h4>

<pre><code class="swift">func foo() -&gt; Bar? {
    fatalError("Not implemented yet.")
}
</code></pre>

<h4>æ–¹æ¡ˆ 4 Logic failure</h4>

<pre><code class="swift">func foo() -&gt; Bar? {
    assertionFailure("Not implemented yet.")
    return nil
}
</code></pre>

<p><details>
  <summary><em>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</em></summary></p>

<p>æ­£ç¡®ç­”æ¡ˆæ˜¯æ–¹æ¡ˆ3 Universal errorã€‚å¯¹äºæ²¡æœ‰å®ç°çš„æ–¹æ³•ï¼Œè¿”å›<code>nil</code>æˆ–è€…æŠ›å‡ºé”™è¯¯æœŸå¾…ç”¨æˆ·æ¢å¤éƒ½æ˜¯æ²¡æœ‰é“ç†çš„ï¼Œè¿™ä¼šè¿›ä¸€æ­¥å¢åŠ æ¡†æ¶ç”¨æˆ·çš„è¿·æƒ‘ã€‚è¿™é‡Œçš„é—®é¢˜æ˜¯è¯­è¨€å±‚é¢çš„è¾¹ç•Œæƒ…å†µï¼Œç”±äºæ²¡æœ‰å®ç°ï¼Œæˆ‘ä»¬éœ€è¦ç»™å‡ºå¼ºåŠ›çš„æé†’ã€‚åœ¨ä»»æ„buildè®¾å®šä¸‹ï¼Œéƒ½ä¸åº”è¯¥æœŸå¾…ç”¨æˆ·å¯ä»¥æˆåŠŸè°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œæ‰€ä»¥<code>fatalError</code>æ˜¯æœ€ä½³é€‰æ‹©ã€‚</p>

<p>å…¶å®åœ¨swiftç»§æ‰¿çš„æ—¶å€™ï¼Œç¼–è¯‘å™¨ä¼šç»™æˆ‘ä»¬æ·»åŠ ä¸€ä¸ªé»˜è®¤çš„æœªå®ç°çš„æ¥å£ï¼š</p>

<pre><code class="swift">required init?(coder aDecoder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}
</code></pre>

<p></details></p>

<p><a id="markdown-è°ƒç”¨è®¾å¤‡ä¸Šçš„ä¼ æ„Ÿå™¨æ”¶é›†æ•°æ®" name="è°ƒç”¨è®¾å¤‡ä¸Šçš„ä¼ æ„Ÿå™¨æ”¶é›†æ•°æ®"></a></p>

<h3>è°ƒç”¨è®¾å¤‡ä¸Šçš„ä¼ æ„Ÿå™¨æ”¶é›†æ•°æ®</h3>

<p>è°ƒç”¨ä¼ æ„Ÿå™¨çš„appæœ€æœ‰æ„æ€äº†ï¼ä¸ç®¡æ˜¯ç›¸æœºè¿˜æ˜¯é™€èºä»ªï¼Œä¼ æ„Ÿå™¨ç›¸å…³çš„appæ€»æ˜¯èƒ½å¸¦ç»™æˆ‘ä»¬å¾ˆå¤šä¹è¶£ã€‚é‚£ä¹ˆï¼Œå¦‚æœæƒ³è¦è°ƒç”¨ä¼ æ„Ÿå™¨è·å–æ•°æ®æ—¶ï¼Œå‘ç”Ÿäº†é”™è¯¯ï¼Œåº”è¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ</p>

<h4>æ–¹æ¡ˆ 1 Simple domain error</h4>

<pre><code class="swift">func getDataFromSensor() -&gt; Data? {
    let sensorState = sensor.getState()
    guard sensorState == .normal else {
        return nil
    }
    return try? sensor.getData()
}
</code></pre>

<h4>æ–¹æ¡ˆ 2 Recoverable error</h4>

<pre><code class="swift">func getDataFromSensor() throws -&gt; Data {
    let sensorState = sensor.getState()
    guard sensorState == .normal else {
        throws SensorError.stateError
    }
    return try sensor.getData()
}
</code></pre>

<h4>æ–¹æ¡ˆ 3 Universal error</h4>

<pre><code class="swift">func loadUser() -&gt; Data {
    let sensorState = sensor.getState()
    guard sensorState == .normal, let data = try? sensor.getData() else {
        fatalError("Sensor get data failed!")
    }
    return data
}
</code></pre>

<h4>æ–¹æ¡ˆ 4 Logic failure</h4>

<pre><code class="swift">func loadUser() -&gt; Data {
    let sensorState = sensor.getState()
    assert(sensorState == .normal, "The sensor state is not normal")
    return try! sensor.getData()
}
</code></pre>

<p><details>
  <summary><em>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</em></summary></p>

<p>ä¼ æ„Ÿå™¨ç”±äºç§ç§åŸå› æš‚æ—¶ä¸èƒ½ä½¿ç”¨ (æ¯”å¦‚æ­£åœ¨è¢«å…¶ä»–è¿›ç¨‹å ç”¨ï¼Œæˆ–è€…ç”šè‡³è®¾å¤‡ä¸Šä¸å­˜åœ¨å¯¹åº”çš„ä¼ æ„Ÿå™¨)ï¼Œæ˜¯å¾ˆæœ‰å¯èƒ½å‘ç”Ÿçš„æƒ…å†µã€‚å³ä½¿è¿™ä¸ªä¼ æ„Ÿå™¨çš„æ•°æ®å¯¹åº”ç”¨æ˜¯è‡³å…³é‡è¦ï¼Œä¸å¯æˆ–ç¼ºçš„ï¼Œæˆ‘ä»¬å¯èƒ½ä¹Ÿä¼šå¸Œæœ›è‡³å°‘èƒ½ç»™ç”¨æˆ·ä¸€äº›æç¤ºã€‚åŸºäºè¿™ç§è€ƒè™‘ï¼Œä½¿ç”¨æ–¹æ¡ˆ2 Recoverable erroræ˜¯æ¯”è¾ƒåˆç†çš„é€‰æ‹©ã€‚</p>

<p>æ–¹æ¡ˆ1åœ¨ä¼ æ„Ÿå™¨æ•°æ®æ— å…³ç´§è¦çš„æ—¶å€™å¯èƒ½ä¹Ÿä¼šæ˜¯ä¸€ä¸ªæ›´ç®€å•çš„é€‰é¡¹ã€‚ä½†æ˜¯æ–¹æ¡ˆ3å’Œ4ä¼šç›´æ¥è®©ç¨‹åºå´©æºƒï¼Œè€Œä¸”è¿™å®é™…ä¸Šä¹Ÿå¹¶ä¸æ˜¯ä»£ç è¾¹ç•Œæˆ–è€…å¼€å‘è€…çš„é”™è¯¯ï¼Œæ‰€ä»¥ä¸åº”è¯¥è¢«è€ƒè™‘ã€‚
</details></p>

<p><a id="markdown-æ€»ç»“" name="æ€»ç»“"></a></p>

<h3>æ€»ç»“</h3>

<p>å¯ä»¥çœ‹åˆ°ï¼Œå…¶å®åœ¨é”™è¯¯å¤„ç†çš„æ—¶å€™ï¼Œé€‰ç”¨å“ªç§é”™è¯¯æ˜¯æ ¹æ®æƒ…æ™¯å’Œå¤„ç†éœ€æ±‚è€Œå®šçš„ï¼Œæˆ‘åœ¨å‚è€ƒç­”æ¡ˆä¹Ÿä½¿ç”¨äº†å¾ˆå¤šè¯¸å¦‚â€œå¯èƒ½â€ï¼Œâ€œç›¸è¾ƒè€Œè¨€â€ç­‰è¯­å¥ã€‚è™½ç„¶å¯¹äºç‰¹å®šçš„åœºæ™¯ï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œç›´è§‚çš„è€ƒè™‘å’Œå†³ç­–ï¼Œä½†è¿™å¹¶ä¸æ˜¯æ•™æ¡ä¸»ä¹‰èˆ¬çš„ä¸€æˆä¸å˜ã€‚é”™è¯¯ç±»å‹ä¹‹é—´å¯ä»¥å¾ˆå®¹æ˜“åœ°é€šè¿‡ä»£ç äº’ç›¸è½¬æ¢ï¼Œè¿™è®©æˆ‘ä»¬åœ¨å¤„ç†é”™è¯¯çš„æ—¶å€™å¯ä»¥è‡ªç”±é€‰æ‹©ä½¿ç”¨çš„ç­–ç•¥ï¼šæ¯”å¦‚APIå³ä½¿æä¾›ç»™æˆ‘ä»¬çš„æ˜¯Recoverableçš„throwså½¢å¼ï¼Œæˆ‘ä»¬ä¹Ÿè¿˜æ˜¯å¯ä»¥æŒ‰ç…§éœ€è¦ï¼Œé€šè¿‡<code>try?</code>å°†å…¶è½¬ä¸ºSimple domain errorï¼Œæˆ–è€…ç”¨<code>try!</code>å°†å…¶è½¬ä¸ºLogic failureã€‚</p>

<p>èƒ½åˆ‡å®ç†è§£ä½¿ç”¨æƒ…æ™¯ï¼Œåˆ©ç”¨è¿™äº›é”™è¯¯ç±»å‹è½¬æ¢çš„æ–¹å¼ï¼Œçµæ´»é€‰å–ä½¿ç”¨åœºæ™¯ä¸‹æœ€åˆé€‚çš„é”™è¯¯ç±»å‹ï¼Œæ‰èƒ½è¯´æ˜¯çœŸæ­£ç†è§£äº†è¿™å››ç§é”™è¯¯çš„åˆ†ç±»ä¾æ®ã€‚</p>

<p><a id="markdown-é”™è¯¯å¤„ç†ç›¸å…³çš„è¾…åŠ©æ–¹æ³•" name="é”™è¯¯å¤„ç†ç›¸å…³çš„è¾…åŠ©æ–¹æ³•"></a></p>

<h2>é”™è¯¯å¤„ç†ç›¸å…³çš„è¾…åŠ©æ–¹æ³•</h2>

<p>For custom errors in swift, refer to <a href="https://developer.apple.com/documentation/swift/error">Error</a> official document.</p>

<p><a id="markdown-use-custom-errors" name="use-custom-errors"></a></p>

<h3>Use Custom Errors</h3>

<h4>Using Enumerations as Errors</h4>

<p>Swiftâ€™s enumerations are well suited to represent simple errors. Create an enumeration that conforms to the Error protocol with a case for each possible error. If there are additional details about the error that could be helpful for recovery, use associated values to include that information.</p>

<p>The following example shows an IntParsingError enumeration that captures two different kinds of errors that can occur when parsing an integer from a string: overflow, where the value represented by the string is too large for the integer data type, and invalid input, where nonnumeric characters are found within the input.</p>

<pre><code class="swift">enum IntParsingError: Error {
    case overflow
    case invalidInput(String)
}
</code></pre>

<h4>Including More Data in Errors</h4>

<p>The following XMLParsingError conforms to Error and supply line and column position of the error.</p>

<pre><code class="swift">struct XMLParsingError: Error {
    enum ErrorKind {
        case invalidCharacter
        case mismatchedTag
        case internalError
    }

    let line: Int
    let column: Int
    let kind: ErrorKind
}

func parse(_ source: String) throws -&gt; XMLDoc {
    // ...
    throw XMLParsingError(line: 19, column: 5, kind: .mismatchedTag)
    // ...
}
</code></pre>

<p>Hereâ€™s how you can catch any XMLParsingError errors thrown by the parse(_:) function:</p>

<pre><code class="swift">do {
    let xmlDoc = try parse(myXMLData)
} catch let e as XMLParsingError {
    print("Parsing error: \(e.kind) [\(e.line):\(e.column)]")
} catch {
    print("Other error: \(error)")
}

// Prints "Parsing error: mismatchedTag [19:5]"
</code></pre>

<p><a id="markdown-do-cleanup-work-using-defer" name="do-cleanup-work-using-defer"></a></p>

<h3>Do Cleanup Work Using <code>defer</code></h3>

<p>You use a <code>defer</code> statement to execute a set of statements just before code execution leaves the current block of code. This statement lets you do any necessary cleanup that should be performed regardless of how execution leaves the current block of codeâ€”whether it leaves because an error was thrown or because of a statement such as <code>return</code> or <code>break</code>. For example, you can use a <code>defer</code> statement to ensure that file descriptors are closed and manually allocated memory is freed.</p>

<pre><code class="swift">func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // Work with the file.
        }
        // close(file) is called here, at the end of the scope.
    }
}

func vend(itemNamed name: String) throws {

    defer {
        // do some clean work
    }

    guard let item = inventory[name] else {
        throw VendingMachineError.invalidSelection
    }

    guard item.count &gt; 0 else {
        throw VendingMachineError.outOfStock
    }

    guard item.price &lt;= coinsDeposited else {
        throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)
    }

    coinsDeposited -= item.price
    var newItem = item
    newItem.count -= 1
    inventory[name] = newItem

    print("Dispensing \(name)")
}
</code></pre>

<p>The above example uses a <code>defer</code> statement to ensure that the <code>open(_:)</code> function has a corresponding call to <code>close(_:)</code>.</p>

<p><a id="markdown-å‚è€ƒ" name="å‚è€ƒ"></a></p>

<h2>å‚è€ƒ</h2>

<ol>
<li><a href="https://onevcat.com/2017/10/swift-error-category/">å…³äº Swift Error çš„åˆ†ç±»</a></li>
<li><a href="https://onevcat.com/2016/03/swift-throws/">Swift 2 throws å…¨è§£æ - ä»åŸç†åˆ°å®è·µ</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html#//apple_ref/doc/uid/TP40014097-CH42-ID508">Error Handling Official Site</a></li>
<li><a href="https://developer.apple.com/documentation/swift/error">Error from Apple Document</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
