<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Zhang Hongchao]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2015-10-29T10:22:51+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS中的触控事件机制]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/10/21/touch-event-in-ios/"/>
    <updated>2015-10-21T16:55:48+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/10/21/touch-event-in-ios</id>
    <content type="html"><![CDATA[<p>在iOS中有三类事件：</p>

<ul>
<li>触控事件（单点、多点触控以及各种手势操作）</li>
<li>传感器事件（重力、加速度传感器等）</li>
<li>远程控制事件（远程遥控iOS设备多媒体播放等）</li>
</ul>


<p>这里要讨论的是<strong>触控事件</strong>的机制。</p>

<p>iOS中主要有两种触控事件：</p>

<ul>
<li>手势识别类定义的触控事件</li>
<li>UIResponder中定义的触控事件</li>
</ul>


<!-- more -->


<h2>手势识别类——Gesture Recognizer</h2>

<h3>手势识别类的代码添加</h3>

<p>可以通过如下代码，在ViewController中为UIView添加手势识别类，称为Action-Target模式。每一个Gesture Recognizer关联一个View，但是一个View可以关联多个Gesture Recognizer，因为一个View可能还能响应多种触控操作方式。</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
<span class="lineno"> 2</span>     <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 3</span> 
<span class="lineno"> 4</span> <span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// 创建并初始化手势对象</span>
<span class="lineno"> 5</span> <span class="bp">UITapGestureRecognizer</span> <span class="o">*</span><span class="n">tapRecognizer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UITapGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">respondToTapGesture</span><span class="p">:)];</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="c1">// 指定操作为单击一次</span>
<span class="lineno"> 8</span> <span class="n">tapRecognizer</span><span class="p">.</span><span class="n">numberOfTapsRequired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="c1">// 为当前View添加GestureRecognizer</span>
<span class="lineno">11</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">tapRecognizer</span><span class="p">];</span>
<span class="lineno">12</span> 
<span class="lineno">13</span> <span class="c1">// ...</span>
<span class="lineno">14</span> <span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
<span class="lineno">15</span> 
<span class="lineno">16</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span></code></pre></div></p>

<h3>连续和不连续动作</h3>

<p><img src="/images/011_iOS_event_discrete_vs_continuous.png" alt="011_iOS_event_discrete_vs_continuous.png" /></p>

<p>对于不连续动作，Gesture Recognizer只会给ViewContoller发送一个单一的动作消息(action message)而，对于连续动作，Gesture Recognizer会发送多条动作消息给ViewController，直到所有的事件都结束。</p>

<h3>常见的手势识别类</h3>

<p>UIKit框架中已经提供了诸如UITapGestureRecognizer在内的六种手势识别器：</p>

<table>
<thead>
<tr>
<th>Gesture </th>
<th> UIKit class</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tapping (any number of taps)</td>
<td> UITapGestureRecognizer</td>
</tr>
<tr>
<td>Pinching in and out (for zooming a view) </td>
<td> UIPinchGestureRecognizer</td>
</tr>
<tr>
<td>Panning or dragging </td>
<td> UIPanGestureRecognizer</td>
</tr>
<tr>
<td>Swiping (in any direction) </td>
<td> UISwipeGestureRecognizer</td>
</tr>
<tr>
<td>Rotating (fingers moving in opposite directions) </td>
<td> UIRotationGestureRecognizer</td>
</tr>
<tr>
<td>Long press (also known as “touch and hold”) </td>
<td> UILongPressGestureRecognizer</td>
</tr>
</tbody>
</table>


<p>如果你需要实现自定义的手势识别器，也可以通过继承UIGestureRecognizer类并重写其中的方法来完成。</p>

<h3>事件识别过程</h3>

<p>在事件处理过程中，连续事件和不连续事件所处的状态又各有不同，首先，所有的触控事件最开始都是处于可用状态(Possible)，对应UIKit里面的UIGestureRecognizerStatePossible类，如果是不连续动作事件，则状态只会从Possible转变为已识别状态(Recognized,UIGestureRecognizerStateRecognized)或者是失败状态(Failed,UIGestureRecognizerStateFailed)。例如一次成功的单击动作，就对应了Possible-Recognized这个过程。</p>

<p><img src="/images/012_iOS_event_gesture_recognizer_state_transitions.png" alt="012_iOS_event_gesture_recognizer_state_transitions.png" /></p>

<p>如果是连续动作事件，如果事件没有失败并且连续动作的第一个动作被成功识别(Recognized)，则从Possible状态转移到Began(UIGestureRecognizerStateBegan)状态，这里表示连续动作的开始，接着会转变为Changed(UIGestureRecognizerStateChanged)状态，在这个状态下会不断循环的处理连续动作，直到动作执行完成变转变为Recognized已识别状态，最终该动作会处于完成状态(UIGestureRecognizerStateEnded)。另外，连续动作事件的处理状态也可能会从Changed状态转变为Canceled(UIGestureRecognizerStateCancelled)状态，原因是识别器认为当前的动作已经不匹配当初对事件的设定了。每个动作状态的变化，Gesture Recognizer都会发送消息(action message)给Target，也就是ViewController，它可以根据这些动作消息进行相应的处理。例如一次成功的滑动手势动作就包括按下、移动、抬起的过程，分别对应了Possible-Began-Changed-Recognized这个过程。</p>

<h2>UIResponder中定义的触控事件</h2>

<h3>UITouch和UIEvent</h3>

<p><strong>TODO</strong></p>

<p>当UIView中没有添加UIGestureRecognizer的时候，如果对UIView触发Pinch操作，如下四个事件接口函数中的<code>touches</code>都只能接收到一个touch的信息（新加的或者改变的touche）。如果想得到所有touch的信息，可以到<code>event.touches</code>中获取。</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="bp">NSSet</span><span class="o">&lt;</span><span class="bp">UITouch</span> <span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">event</span>
<span class="lineno">2</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesMoved:</span><span class="p">(</span><span class="bp">NSSet</span><span class="o">&lt;</span><span class="bp">UITouch</span> <span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">event</span>
<span class="lineno">3</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesEnded:</span><span class="p">(</span><span class="bp">NSSet</span><span class="o">&lt;</span><span class="bp">UITouch</span> <span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">event</span>
<span class="lineno">4</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesCancelled:</span><span class="p">(</span><span class="bp">NSSet</span><span class="o">&lt;</span><span class="bp">UITouch</span> <span class="o">*&gt;</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">event</span></code></pre></div></p>

<p>每个touch都有自己的<code>phase</code>，其与上述四个接口函数的关系可以从下面的例子中看出：</p>

<p><img src="/images/014_ios_event_touch_time.png" alt="014_ios_event_touch_time.png" /></p>

<h2>手势识别类和UIResponder定义的事件的传递过程</h2>

<p><img src="/images/013_iOS_event_path_of_touches.png" alt="013_iOS_event_path_of_touches.png" /></p>

<p>iOS中事件传递首先从App(UIApplication)开始，接着传递到Window(UIWindow)，在接着往下传递到View之前，Window会将事件交给GestureRecognizer，如果在此期间，GestureRecognizer识别了传递过来的事件，则该事件将不会继续传递到View去，而是像我们之前说的那样交给Target(ViewController)进行处理。如果View上没有定义GestureRecognizer，或者GestureRecognizer没有识别出这个动作，那么View中的继承自UIResponder的如下事件方法会被触发：</p>

<ul>
<li>touchesBegan:withEvent:</li>
<li>touchesMoved:withEvent:</li>
<li>touchesEnded:withEvent:</li>
<li>touchesCancelled:withEvent:</li>
</ul>


<p>比如，</p>

<ul>
<li>对于非连续行动作（比如Tap），

<ul>
<li>当View上定义了UITapGestureRecognizer，在View接受用户Tap事件时，touchesBegan:withEvent:和touchesCancelled:withEvent:会被调用，其余事件方法则不会被调用。</li>
<li>当View上没有定义UIGestureRecognizer时，在View接受用户Tap事件时，touchesBegan:withEvent:和touchesEnded:withEvent:会被调用。</li>
</ul>
</li>
<li>对于连续动作（比如Pinch），

<ul>
<li>当View上定义了UIPinchGestureRecognizer时，在View接受用户Pinch动作时，

<ul>
<li>如果Pinch动作被正确地Recognized，那么View上被触发的事件依次是：

<ul>
<li>touchesBegan</li>
<li>touchesMoved</li>
<li>touchesMoved</li>
<li>&hellip;</li>
<li>touchesMoved</li>
<li>pinch (UIGestureRecognizerStateBegan)</li>
<li>touchesCancelled</li>
<li>pinch (UIGestureRecognizerStateChanged)</li>
<li>pinch (UIGestureRecognizerStateChanged)</li>
<li>&hellip;</li>
<li>pinch (UIGestureRecognizerStateChanged)</li>
<li>pinch (UIGestureRecognizerStateEnded / UIGestureRecognizerStateRecognized)</li>
</ul>
</li>
<li>如果Pinch动作Cancelled，猜想：应该和recognized的情况类似，只是最后一步的状态是UIGestureRecognizerStateCancelled。</li>
</ul>
</li>
<li>当View上未定义UIPinchGestureRecognizer时，在View接受Pinch动作时，被触发的事件依次是：

<ul>
<li>touchesBegan</li>
<li>touchesMoved</li>
<li>touchesMoved</li>
<li>&hellip;</li>
<li>touchesMoved</li>
<li>touchesEnded</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>可以到<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html">Gesture Recognizers</a>官方文档中的“Gesture Recognizers Get the First Opportunity to Recognize a Touch”部分了解详细过程。</p>

<p>截一插图放在这里：</p>

<p><img src="/images/015_iOS_recognize_touch.png" alt="015_iOS_recognize_touch.png" /></p>

<h2>响应者链（Responder Chain）</h2>

<p>在网页上当我们讲到事件，我们会讲到事件响应链，我们会讲到事件的响应者和事件的传递方式(冒泡)，那么在app上，其实也离不开这几个问题。</p>

<p>UIResponder是所有可以响应事件的类的基类(从名字应该就可以看出来了)，其中包括最常见的UIView和UIViewController甚至是UIApplication，所以我们的UIView和UIViewController都是作为响应事件的载体，称为<strong>响应者对象（Responder Object）</strong>。UIResponder部分接口如下：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="n">NS_CLASS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">2</span><span class="n">_0</span><span class="p">)</span> <span class="k">@interface</span> <span class="bp">UIResponder</span> : <span class="bp">NSObject</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="lineno"> 4</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nullable</span> <span class="bp">UIResponder</span><span class="o">*</span><span class="p">)</span><span class="n">nextResponder</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
<span class="lineno"> 5</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">canBecomeFirstResponder</span><span class="p">;</span>    <span class="c1">// default is NO&lt;/p&gt;&lt;/li&gt;</span>
<span class="lineno"> 6</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">becomeFirstResponder</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
<span class="lineno"> 7</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">canResignFirstResponder</span><span class="p">;</span>    <span class="c1">// default is YES&lt;/p&gt;&lt;/li&gt;</span>
<span class="lineno"> 8</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">resignFirstResponder</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
<span class="lineno"> 9</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">isFirstResponder</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
<span class="lineno">10</span> <span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="lineno">11</span> 
<span class="lineno">12</span> 
<span class="lineno">13</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Generally, all responders which do custom touch handling should override all four of these methods.</span>
<span class="lineno">14</span> <span class="c1">// Your responder will receive either touchesEnded:withEvent: or touchesCancelled:withEvent: for each</span>
<span class="lineno">15</span> <span class="c1">// touch it is handling (those touches it received in touchesBegan:withEvent:).</span>
<span class="lineno">16</span> <span class="c1">// &lt;em&gt;&lt;em&gt;&lt;em&gt; You must handle cancelled touches to ensure correct behavior in your application.  Failure to</span>
<span class="lineno">17</span> <span class="c1">// do so is very likely to lead to incorrect behavior or crashes.</span>
<span class="lineno">18</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">touchesBegan</span><span class="p">:(</span><span class="bp">NSSet</span><span class="o">&lt;</span><span class="bp">UITouch</span> <span class="o">*&gt;</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">touches</span> <span class="nl">withEvent</span><span class="p">:(</span><span class="n">nullable</span> <span class="bp">UIEvent</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">event</span><span class="p">;</span>
<span class="lineno">19</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesMoved:</span><span class="p">(</span><span class="bp">NSSet</span><span class="o">&lt;</span><span class="bp">UITouch</span> <span class="o">*&gt;</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">nullable</span> <span class="bp">UIEvent</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">event</span><span class="p">;</span>
<span class="lineno">20</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesEnded:</span><span class="p">(</span><span class="bp">NSSet</span><span class="o">&lt;</span><span class="bp">UITouch</span> <span class="o">*&gt;</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">nullable</span> <span class="bp">UIEvent</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">event</span><span class="p">;</span>
<span class="lineno">21</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesCancelled:</span><span class="p">(</span><span class="n">nullable</span> <span class="bp">NSSet</span><span class="o">&lt;</span><span class="bp">UITouch</span> <span class="o">*&gt;</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">nullable</span> <span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">;</span></code></pre></div></p>

<p>那么响应链跟这个UIResponder有什么关系呢？事实事件响应链的形成和事件的响应和传递，UIResponder都帮我们做了很多事。我们的app中，所有的视图都是按照一定的结构组织起来的，即树状层次结构，每个view都有自己的superView，包括controller的topmost view(controller的self.view)。当一个view被add到superView上的时候，他的nextResponder属性就会被指向它的superView，当controller被初始化的时候，self.view(topmost view)的nextResponder会被指向所在的controller，而controller的nextResponder会被指向self.view的superView，这样，整个app就通过nextResponder串成了一条链，也就是我们所说的响应链。所以响应链就是一条虚拟的链，并没有一个对象来专门存储这样的一条链，而是通过UIResponder的属性nextResponder串连起来的。如下图：</p>

<p><img src="/images/007_iOS_responder_chain.png" alt="007_iOS_responder_chain.png" /></p>

<p>参考文章：<a href="http://zhoon.github.io/ios/2015/04/12/ios-event.html">深入浅出iOS事件机制</a>。</p>

<h3>hit-test view</h3>

<p>有了事件响应链，接下来的事情就是寻找响应事件的具体响应者了，我们称为hit-testing view，寻找这个view的过程我们称着为hit-test。</p>

<p>每当手指接触屏幕，UIApplication接收到手指的事件之后，就会去调用UIWindow的hitTest:withEvent:</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="nl">hitTest</span><span class="p">:</span> <span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span> <span class="n">point</span> <span class="nl">withEvent</span><span class="p">:</span> <span class="p">(</span><span class="bp">UIEvent</span><span class="o">*</span> <span class="p">)</span><span class="n">event</span><span class="p">{</span>
<span class="lineno"> 2</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">self</span><span class="p">.</span><span class="n">isUserInteractionEnabled</span> <span class="o">||</span> <span class="nb">self</span><span class="p">.</span><span class="n">isHidden</span> <span class="o">||</span> <span class="nb">self</span><span class="p">.</span><span class="n">alpha</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 3</span>     <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
<span class="lineno"> 4</span> <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 5</span> 
<span class="lineno"> 6</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">for</span> <span class="p">(</span><span class="bp">UIView</span><span class="o">*</span> <span class="n">v</span> <span class="k">in</span> <span class="n">subviews</span><span class="p">){</span>
<span class="lineno"> 7</span>      <span class="k">if</span> <span class="p">([</span><span class="n">v</span> <span class="nl">pointInside</span><span class="p">:</span><span class="n">point</span> <span class="nl">withEvent</span><span class="p">:</span><span class="n">event</span><span class="p">]){</span>
<span class="lineno"> 8</span>           <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="nl">hitTest</span><span class="p">:</span><span class="n">point</span> <span class="nl">withEvent</span><span class="p">:</span><span class="n">event</span><span class="p">];</span>
<span class="lineno"> 9</span>      <span class="p">}</span>
<span class="lineno">10</span>   <span class="p">}</span>
<span class="lineno">11</span> <span class="p">}</span></code></pre></div></p>

<p>注意hitTest里面是有判断当前的view是否支持点击事件，比如userInteractionEnabled、hidden、alpha等属性，都会影响一个view是否可以响应事件，如果不响应则直接返回nil。</p>

<p>我们留意到还有一个pointInside:withEvent:方法，这个方法跟hittest:withEvent:一样都是UIView的一个方法，通过他可以判断point是否在view的<strong>bound</strong>范围内。</p>

<p>下面用一幅图说明hit-test的过程：</p>

<p><img src="/images/009_iOS_hittest_2.png" alt="009_iOS_hittest_2.png" /></p>

<p>参考文章：<a href="http://zhoon.github.io/ios/2015/04/12/ios-event.html">深入浅出iOS事件机制</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Warning Messages in Xcode]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/08/31/Warning-Messages-in-Xcode/"/>
    <updated>2015-08-31T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/08/31/Warning-Messages-in-Xcode</id>
    <content type="html"><![CDATA[<p><a href="http://oleb.net/blog/2013/04/compiler-warnings-for-objective-c-developers/">Compiler Warnings for Objective-C Developers</a> is a good post for describing warning messages for Objective-C in xcode. A Chinese version can be found <a href="http://onevcat.com/2013/05/talk-about-warning/">谈谈Objective-C的警告</a>.</p>

<p>Some important things are marked here.</p>

<p>Two ways to modify complier&rsquo;s warning setting: <strong>UI Method</strong> and <strong>Custom Compiler Flags Method</strong>.</p>

<!-- more -->


<h2>UI Method</h2>

<p>In <em>Project Navigator</em>, choose the project. On the right, under <em>Build Settings</em>, <code>Apple LLVM 6.1 - Warnings - Objective c</code> and <code>Apple LLVM 6.1 - Warnings - Objective C and ARC</code> are Objective C specific settings. You may also want to see some setttings for all languages, including Objective C in <code>Apple LLVM 6.1 - Warnings - All languages</code>.</p>

<h2><em>Custom Compiler Flags</em> Method</h2>

<p>Under <em>Build Settings</em>, find <code>other warning flags</code> in <code>Apple LLVM 6.1 - Custom Compiler Flags</code>. In this section, you can use <code>-W...</code> like commands for warning settings.</p>

<p>For example, use <code>-Wall</code> to display all warnings (actually, not <em>All</em>), use <code>-Wno-unused-variable</code> to indicate not displaying <em>unused variable</em> warnings. Use space between differenct commands, like <code>-Wall -Wno-unused-variable</code>.</p>

<p>Using this way, we can set for all kinds of warnings, some of which can not be set by <em>UI Method</em> above.</p>

<p>Go to the following two refrences for details on <code>-Wall</code>, <code>-Wextra</code> and <code>-Weverything</code>:</p>

<ul>
<li><a href="http://oleb.net/blog/2013/04/compiler-warnings-for-objective-c-developers/">Compiler Warnings for Objective-C Developers</a></li>
<li><a href="http://onevcat.com/2013/05/talk-about-warning/">谈谈Objective-C的警告</a>.</li>
</ul>


<p>The following paragraph comes from the first reference:</p>

<p>If you encounter a particular warning that you actively want to suppress, check the build log. The compiler will tell you the name of each warning it has issued (-Wunused-variable in this example). You can use this name to selectively disable (with -Wno-unused-variable) or enable this specific warning in your project. In my experience, you will come up with a very short list of warnings you want to disable (probably no more than a handful).</p>

<p>Attach one image to indicate the place (red circles) to find the warning type:</p>

<p><img src="/images/006_warning_type_from_build_log.png" alt="006_warning_type_from_build_log.png" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Frameworks in iOS Development]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/08/19/Some-Frameworks-in-iOS-Development/"/>
    <updated>2015-08-19T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/08/19/Some-Frameworks-in-iOS-Development</id>
    <content type="html"><![CDATA[<p>Reference <a href="http://www.open-open.com/lib/view/open1343210425380.html">here</a>.</p>

<!-- more -->


<h3>Cocoa and Cocoa Touch</h3>

<p>是在Mac OS X系统上原生的一个编译环境。他包含两个框架，其实就是一系列的类库，Foundation和AppKit。</p>

<p>在你的iPhone等掌上设备上，使用的则是他的一个子类 - Cocoa Touch。他所支持的Foundation框架与Cocoa相同，但他的用户图形类库为UIKit，它是为掌上设备特殊设计，提供了你设备上的界面。</p>

<p>Cocoa Touch与Cocoa一个比较鲜明的区别就是Cocoa Touch并不支持垃圾回收机制，这就意味着你必须在你的代码里管理好你的内存。</p>

<h3>UIKit and AppKit</h3>

<p>UIKit是iOS上的用户图形包。UI开头的类都来自于这个框架。
AppKit是Mac OS X上的用户图形不同，类名以NS开头。</p>

<h2>some frameworks</h2>

<p><img src="/images/001_ios_frameworks.png" alt="ios_frameworks.png" /></p>

<h3>Foundation</h3>

<h3>UIKit</h3>

<h3>Core Data</h3>

<h3>Core Graphics</h3>

<h3>Core Animation</h3>

<h3>OpenGL ES</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The .dSYM File in Ios Project]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/08/17/the-dSYM-file-in-ios-project/"/>
    <updated>2015-08-17T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/08/17/the-dSYM-file-in-ios-project</id>
    <content type="html"><![CDATA[<p>This article is mainly from the following post: <a href="http://stackoverflow.com/questions/22460058/how-is-a-dsym-file-created">How is a .dSYM file created?</a>.</p>

<h3>Description</h3>

<p>A <strong>.dSYM</strong> file is a <em>debug symbols file</em>. It is generated when in xcode the <code>Strip Debug Symbols</code> setting is enabled and <code>Debug Infomation Format</code> are set to <code>DWARF with dSYM File</code> in the build settings of your project.</p>

<!-- more -->


<h3>Creatation</h3>

<p>Xcode creates the .dSYM file automatically for you when you use the Archive option. The created archive contains your app and its dSYM and is stored in <code>~/Library/Developer/Archive</code>.</p>

<h3>Usage</h3>

<p>When this setting is enabled, symbol names of your objects are removed from the resulting compiled binary (one of the many countermeasures to try and prevent would be hackers/crackers from reverse engineering your code, amongst other optimisations for binary size, etc.).</p>

<p>They are useful for re-symbolicating your crash reports. With a stripped binary, you won&rsquo;t be able to read any crash reports without first re-symbolicating them. Without the dSYM the crash report will just show memory addresses of objects and methods. Xcode uses the dSYM to put the symbols back into the crash report and allow you to read it properly.</p>

<p>dSYMs and executables have an embedded UUID which matches. So every time a build is done will cause both to get a new UUID. The consequence is that symbolication only works if the UUID of the binary that caused a crash matches the UUID of the dSYM that is used for symbolication.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC and GC]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/08/14/ARC-and-Memory-Leak/"/>
    <updated>2015-08-14T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/08/14/ARC-and-Memory-Leak</id>
    <content type="html"><![CDATA[<p>The following post mainly comes from <a href="http://docs.elementscompiler.com/Concepts/ARCvsGC/">ARC vs GC</a> and <a href="http://lists.apple.com/archives/objc-language/2011/Jun/msg00013.html">Re: ARC replacing GC? from Chris Lattner&rsquo;s mail list</a>.</p>

<p>Also reference some posts on memory leak, including <a href="http://stackoverflow.com/questions/6260256/what-kind-of-leaks-does-automatic-reference-counting-in-objective-c-not-prevent/6388601#6388601">What kind of leaks does automatic reference counting in Objective-C not prevent or minimize?</a> and <a href="http://www.reigndesign.com/blog/debugging-retain-cycles-in-objective-c-four-likely-culprits/">Debugging retain cycles in Objective-C: four likely culprits</a>.</p>

<!-- more -->


<h2>Garbage Collection</h2>

<p>Garbage Collection (or GC for short) is the technique used for life cycle management on the .NET and Java platforms. The way GC works i/Users/hongchaozhang/Develop/octopress/source/_posts/2015-07-09-Basic-Git-Commands.mds that the runtime (either the Common Language Runtime for .NET or the Java Runtime) has infrastructure in place that detects unused objects and object graphs in the background.</p>

<blockquote><p>Unfortunately, garbage collection does have a down side. Garbage collection is only available on MacOS X Version 10.5 or above. It is not available, currently (not sure if it is still true today), on iPhone, iPad, or any of the less common platforms, such as Linux or Windows.</p></blockquote>

<p>This happens at indeterminate intervals (either after a certain amount of time has passed, or when the runtime sees available memory getting low), so objects are not necessarily released at the exact moment they are no longer used.</p>

<h3>Advantages of Garbage Collection</h3>

<p>GC can clean up entire object graphs, including retain cycles.
GC happens in the background, so less memory management work is done as part of the regular application flow.</p>

<h3>Disadvantages of Garbage Collection</h3>

<p>Because GC happens in the background, the exact time frame for object releases is undetermined.
When a GC happens, other threads in the application may be temporarily put on hold.</p>

<h2>Automatic Reference Counting</h2>

<p>Automatic Reference Counting (ARC for short) as used on Cocoa takes a different approach. Rather than having the runtime look for and dispose of unused objects in the background, the compiler will inject code into the executable that keeps track of object reference counts and will release objects as necessary, automatically. In essence, if you were to disassemble an executable compiled with ARC, it would look (conceptually) as if the developer spent a lot of time meticulously keeping track of object life cycles when writing the code — except that all that hard work was done by the compiler.</p>

<h3>Advantages of Automatic Reference Counting</h3>

<p>Real-time, deterministic destruction of objects as they become unused.
No background processing, which makes it more efficient on lower-power systems, such as mobile devices.</p>

<h3>Disadvantages of Automatic Reference Counting</h3>

<p>Cannot cope with retain cycles.</p>

<blockquote><p><strong>Note:</strong> Another couple of significant memory-related concerns are the handling of <strong>Core Foundation objects</strong> and <strong>memory allocated using malloc()</strong> for types like char*.</p>

<blockquote><p>ARC does only manages Objective-C objects, so you&rsquo;ll still need to deal with <code>malloc()</code> related objects by yourself.</p>

<p>(<strong>Not very clear about this</strong>)Core Foundation types can be particularly tricky, because sometimes they need to be bridged across to matching Objective-C objects, and vice versa. This means that control needs to be transferred back and forth from ARC when bridging between CF types and Objective-C.</p></blockquote></blockquote>

<h2>Retain Cycle</h2>

<p>A so-called retain cycle happens when two (or more) objects reference each other, essentially keeping each other alive even after all external references to the objects have gone out of scope.</p>

<p>The <strong>Garbage Collection</strong> works by looking at &ldquo;reachable&rdquo; objects, it can handle retain cycles fine, and will discard entire object graphs that reference each other, if it detects no outside references exist.</p>

<p>Because <strong>Automatic Reference Counting</strong> works on a lower level and manages life cycles based on reference counts, it cannot handle retain cycles automatically, and a retain cycle will cause objects to stay in memory, essentially causing the application to &ldquo;leak&rdquo; memory.</p>
]]></content>
  </entry>
  
</feed>
