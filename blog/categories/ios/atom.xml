<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2020-02-21T12:12:30+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift Closure]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/06/04/on-swift-closure/"/>
    <updated>2019-06-04T17:24:47+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/06/04/on-swift-closure</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#function%E4%B8%8Eclosure%E7%9A%84%E5%85%B3%E7%B3%BB">Function与Closure的关系：</a></li>
<li><a href="#%E7%94%A8closure%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F">用Closure初始化一个变量</a></li>
<li><a href="#closure%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">Closure的语法糖：</a></li>
<li><a href="#closure%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">Closure与内存管理、内存泄漏</a>

<ul>
<li><a href="#capture-list%E7%9A%84%E5%AE%9A%E4%B9%89">Capture List的定义</a></li>
<li><a href="#weak-and-unowned-references">Weak and Unowned References</a></li>
</ul>
</li>
<li><a href="#closure%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F">Closure捕获变量</a></li>
</ul>


<p><a href="https://medium.com/@abhimuralidharan/functional-swift-all-about-closures-310bc8af31dd">Functional swift: All about Closures</a></p>

<p>这篇全面详细易懂地介绍了Swift的Closure，包括</p>

<ul>
<li>Closure的语法，包括一些简化写法，如Trailing Closures</li>
<li>Closure与Function的区别</li>
<li>Closure与内存管理、内存泄漏，如capture list的使用，weak与unowned的区别</li>
<li>Functions和closures都是引用类型，不是值类型</li>
</ul>


<p>也可以看<a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">官方文档Closures</a>，但是官方文档没有上面的文章详细。</p>

<p>下面有选择地记录一下。</p>

<p><a id="markdown-function与closure的关系" name="function与closure的关系"></a></p>

<h2>Function与Closure的关系：</h2>

<p>参考<a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">官方文档Closures</a>里面的三句话理解一下：</p>

<blockquote><ul>
<li>Global functions are closures that have a name and do not capture any values.</li>
<li>Nested functions are closures that have a name and can capture values from their enclosing function.</li>
<li>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</li>
</ul>
</blockquote>

<p>还有一点很重要：<strong>Closures and functions are first class types in swift</strong>。</p>

<blockquote><p>Functions and closures are first-class citizens in Swift because you can treat then like a normal value. For example, you can：</p>

<ul>
<li>assign a function/closure to a local variable .</li>
<li>pass a function/closure as an argument .</li>
<li>return a function/closure .</li>
</ul>
</blockquote>

<p><a id="markdown-用closure初始化一个变量" name="用closure初始化一个变量"></a></p>

<h2>用Closure初始化一个变量</h2>

<pre><code class="swift">let setupViewUsingClosure: UIView = {
    let view = UIView()
    view.backgroundColor = .green
    return view
}() //IMPORTANT!!! I have added () at the end.
</code></pre>

<p><a id="markdown-closure的语法糖" name="closure的语法糖"></a></p>

<h2>Closure的语法糖：</h2>

<p><a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">官方文档Closures</a>有个总的说明：</p>

<blockquote><p>Swift’s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios. These optimizations include:</p>

<ul>
<li>Inferring parameter and return value types from context</li>
<li>Implicit returns from single-expression closures</li>
<li>Shorthand argument names</li>
<li>Trailing closure syntax</li>
</ul>
</blockquote>

<p>当你第一次看到这个写法的时候肯定很疑惑：参数、类型、函数调用时的括号都跑哪去了？</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<p>理解了上面几点，就可以明白为什么可以这么写，下面让我们一步步看清楚。</p>

<p>Closure的定义如下：</p>

<blockquote><p>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</p>

<pre><code class="swift">{ (params) -&gt; returnType in
    statements
}
</code></pre></blockquote>

<p>举个具体的例子：</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<p>因为：</p>

<blockquote><ul>
<li><strong>Inferring parameter and return value types from context</strong></li>
</ul>


<p>Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns.</p></blockquote>

<p>所以，上面的代码可以写为：</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )
</code></pre>

<p>再因为：</p>

<blockquote><ul>
<li><strong>Implicit returns from single-expression closures</strong></li>
</ul>


<p>Single-expression closures can implicitly return the result of their single expression by omitting the return keyword from their declaration.</p></blockquote>

<p>所以，代码继续改为：</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
</code></pre>

<p>再因为：</p>

<blockquote><ul>
<li><strong>Shorthand argument names</strong></li>
</ul>


<p>Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names $0, $1, $2, and so on.</p></blockquote>

<p>代码继续改为：</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted(by: { $0 &gt; $1 } )
</code></pre>

<p>再因为：</p>

<blockquote><ul>
<li><strong>Trailing closure syntax</strong></li>
</ul>


<p>If you need to pass a closure expression to a function as the function’s final argument and the closure expression is long, it can be useful to write it as a trailing closure instead. A trailing closure is written after the function call’s parentheses, even though it is still an argument to the function. When you use the trailing closure syntax, you don’t write the argument label for the closure as part of the function call.</p></blockquote>

<p>代码就可以写成：</p>

<pre><code class="swift">let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<p><a id="markdown-closure与内存管理内存泄漏" name="closure与内存管理内存泄漏"></a></p>

<h2>Closure与内存管理、内存泄漏</h2>

<p>Closure带来的循环引用和内存泄漏，主要通过Capture List来解决：</p>

<blockquote><p>You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closure’s definition. A capture list defines the rules to use when capturing one or more reference types within the closure’s body.</p></blockquote>

<p>详细内容参考<a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID56">Resolving Strong Reference Cycles for Closures</a>。下面摘要一下。</p>

<p><a id="markdown-capture-list的定义" name="capture-list的定义"></a></p>

<h3>Capture List的定义</h3>

<blockquote><p>Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self) or a variable initialized with some value (such as delegate = self.delegate!). These pairings are written within a pair of square braces, separated by commas.</p></blockquote>

<p>Place the capture list before a closure’s parameter list and return type if they are provided:</p>

<pre><code class="swift">lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
    // closure body goes here
}
</code></pre>

<p><a id="markdown-weak-and-unowned-references" name="weak-and-unowned-references"></a></p>

<h3>Weak and Unowned References</h3>

<blockquote><p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p>

<p>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future. Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body.</p>

<p>NOTE: If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.</p></blockquote>

<p>关于unowned的另一个解释更清楚：</p>

<blockquote><p>Like a weak reference, an unowned reference does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime.</p></blockquote>

<p><a id="markdown-closure捕获变量" name="closure捕获变量"></a></p>

<h2>Closure捕获变量</h2>

<blockquote><p>Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as closing over those constants and variables.</p></blockquote>

<p>比如：</p>

<pre><code class="swift">// capturing values
var i = 0
var closureArray = [()-&gt;()]()
for _ in 1...5 {
    closureArray.append {
        print(i)
    }
    i += 1
}
// here i will be 5
closureArray[0]() // prints 5
closureArray[1]() // prints 5
closureArray[2]() // prints 5
closureArray[3]() // prints 5
closureArray[4]() // prints 5
</code></pre>

<p>The closure captures the current address of <code>i</code> and every time we access <code>i</code> , it . returns the current value.</p>

<p>If we want to prevent this behavior (capturing values) and print the value of i even if the properties change after their capturing inside the closure, we can explicitly capture the variable with a capture list like this:</p>

<pre><code class="swift">var closureArray2 = [()-&gt;()]()
var j = 0
for _ in 1...5 {
    closureArray2.append { [j] in
        print(j)
    }
    j += 1
}
// here i will be 5
closureArray2[0]() // prints 0
closureArray2[1]() // prints 1
closureArray2[2]() // prints 2
closureArray2[3]() // prints 3
closureArray2[4]() // prints 4
</code></pre>

<p>In this way, we keep an immutable copy of the variable <code>j</code>. Thanks to this copy, further changes to <code>j</code>, outside the closure, will not affect the closure. <code>j</code> is a let constant here. It is not mutable.</p>

<p>We can add multiple values to the capture list :</p>

<pre><code class="swift">closure.append { [j,k,l] in
    print("\(j) \(k) \(l)")
}
</code></pre>

<p>also, you can have alias names for the values captured.</p>

<pre><code class="swift">closure.append { [a = j, b = k, c = l] in
    print("\(a) \(b) \(c)")
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sequece and Collection in Swift]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/06/03/sequece-and-collection-in-swift/"/>
    <updated>2019-06-03T16:22:33+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/06/03/sequece-and-collection-in-swift</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#array-out-of-range-crash"><code>Array</code> out of Range Crash</a></li>
<li><a href="#homemade-collection">Homemade collection</a></li>
<li><a href="#sequences">Sequences</a>

<ul>
<li><a href="#how-to-conform-to-sequence-protocol">How to Conform to <code>Sequence</code> Protocol</a></li>
<li><a href="#make-our-section-conform-to-sequence-protocol">Make our <code>Section</code> Conform to <code>Sequence</code> Protocol</a></li>
<li><a href="#gifts">Gifts</a></li>
</ul>
</li>
<li><a href="#collections">Collections</a>

<ul>
<li><a href="#how-to-conform-to-collection-protocol">How to Conform to <code>Collection</code> Protocol</a></li>
<li><a href="#make-our-section-conform-to-collection-protocol">Make our <code>Section</code> Conform to <code>Collection</code> Protocol</a></li>
</ul>
</li>
<li><a href="#difference-between-array-and-collection">Difference between <code>Array</code> and <code>Collection</code></a></li>
<li><a href="#reference">Reference</a></li>
</ul>


<p>The content comes from the following posts:</p>

<ol>
<li><a href="https://medium.com/swift-programming/swift-sequences-ce22d76f120c">Swift Sequences</a></li>
<li><a href="https://medium.com/swift-programming/swift-collections-e5fff3cd6759">Swift Collections</a></li>
</ol>


<p>But some of the code inside is old and can&rsquo;t be compiled with swift 5.0. So rewritten the code using swift 5.0.</p>

<p><a id="markdown-array-out-of-range-crash" name="array-out-of-range-crash"></a></p>

<h2><code>Array</code> out of Range Crash</h2>

<p>Before diving into Swift Sequences, let’s see a strange behavior.</p>

<pre><code class="swift">let array = [1, 2, 3]
array[7] 😭

let dic = ["a": 1, "b": 2]
dic["z"] 😎

🤔
</code></pre>

<p>In other words, when requesting an element that doesn’t exist, why arrays crash whereas dictionaries don’t?</p>

<p>Arrays and dictionaries are two base collections provided by the Swift standard library. We can access those collections elements through the [] notation, also known as subscript. Let’s see how those subscripts are defined.</p>

<pre><code class="swift">struct Array&lt;Element&gt; {
    subscript(index: Int) -&gt; Element
}

struct Dictionary&lt;Key: Hashable, Value&gt; {
    subscript(key: Key) -&gt; Value?
}
</code></pre>

<p>What’s interesting is that arrays have a non optional return type. Subscript can’t throw errors so there are no alternatives other than a fatalError if we request an index that doesn’t exist.</p>

<p>For dictionaries, on the other hand, an optional Value is returned, which allows to gracefully return nil if the index doesn’t exist.</p>

<p>We can adopt dictionaries safer approach by overloading the arrays subscript — we can’t override them. Adding an external name to the parameter is enough.</p>

<pre><code class="swift">extension Array {
    subscript(safe index: Int) -&gt; Element? {
        return index &gt;= 0 &amp;&amp; index &lt; count ? self[index] : nil
    }
}
</code></pre>

<p>We saw how we can create a new accessor to the elements of an array, but can we do the same with a homemade collection?</p>

<p><a id="markdown-homemade-collection" name="homemade-collection"></a></p>

<h2>Homemade collection</h2>

<pre><code class="swift">struct Section&lt;T&gt; {
    let title: String
    let elements: [T]
}
</code></pre>

<p>Internally, this ‘collection’ is based on an array. This is an implementation detail for the simplicity of the example. We could have used a linked list as in this <a href="http://austinzheng.com/2015/01/24/swift-seq/">excellent article</a> by <a href="https://twitter.com/austinzheng">Austin Zheng</a>.</p>

<p>Creating a subscript on our collection is very easy, we can even reuse the array’s extension we made earlier.</p>

<pre><code class="swift">struct Section&lt;T&gt; {
    let title: String
    let elements: [T]

    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }
}
</code></pre>

<p>An example in practice :</p>

<pre><code class="swift">let cars = ["911", "Cayman", "Cayenne"]
let section = Section(title: "Porsche", elements: cars)

section[1]
// Optional("Cayman")
</code></pre>

<p>Great! But does that make our type a collection, as Swift defines it?</p>

<p><a id="markdown-sequences" name="sequences"></a></p>

<h2>Sequences</h2>

<p>When it comes to manipulating sets, the most abstract notion given by the standard library is the Sequence, defined as</p>

<blockquote><p>A type that can be iterated with a <code>for…in</code> loop.</p></blockquote>

<p><a id="markdown-how-to-conform-to-sequence-protocol" name="how-to-conform-to-sequence-protocol"></a></p>

<h3>How to Conform to <code>Sequence</code> Protocol</h3>

<p>This section is from <a href="https://developer.apple.com/documentation/swift/sequence">Sequece official site</a>.</p>

<p>Making your own custom types conform to Sequence enables many useful operations, like for-in looping and the contains method, without much effort. To add Sequence conformance to your own custom type, add a makeIterator() method that returns an iterator.</p>

<p>Alternatively, if your type can act as its own iterator, implementing the requirements of the IteratorProtocol protocol and declaring conformance to both Sequence and IteratorProtocol are sufficient.</p>

<p>Here’s a definition of a Countdown sequence that serves as its own iterator. The makeIterator() method is provided as a default implementation.</p>

<pre><code class="swift">struct Countdown: Sequence, IteratorProtocol {
    var count: Int

    mutating func next() -&gt; Int? {
        if count == 0 {
            return nil
        } else {
            defer { count -= 1 }
            return count
        }
    }
}

let threeToGo = Countdown(count: 3)
for i in threeToGo {
    print(i)
}
// Prints "3"
// Prints "2"
// Prints "1"
</code></pre>

<p><a id="markdown-make-our-section-conform-to-sequence-protocol" name="make-our-section-conform-to-sequence-protocol"></a></p>

<h3>Make our <code>Section</code> Conform to <code>Sequence</code> Protocol</h3>

<p>The <code>Section</code> struct can&rsquo;t act as its own iterator, we need to define an iterator for it, and then return an instance of the defined iterator inside <code>func makeIterator() -&gt; Section&lt;T&gt;.Iterator</code> method.</p>

<pre><code class="swift">struct Section&lt;T&gt;: Sequence {
    let title: String
    let elements: [T]

    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }

    struct Iterator: IteratorProtocol {
        let array: [T]
        var currentIndex = 0

        init (_ array: [T]) {
            self.array = array
        }

        mutating func next() -&gt; T? {
            let tempIndex = currentIndex
            currentIndex += 1
            return array[safe: tempIndex]

        }
    }

    func makeIterator() -&gt; Section&lt;T&gt;.Iterator {
        return Iterator(elements)
    }
}
</code></pre>

<p><a id="markdown-gifts" name="gifts"></a></p>

<h3>Gifts</h3>

<p>Is that all? No! By conforming to SequenceType we also get methods for free, here is some of them.</p>

<pre><code class="swift">section.min()
// 911
section.max()
// Cayman
section.sorted()
// ["911", "Cayenne", "Cayman"]
section.contains("911")
// true
</code></pre>

<p>We get the min, max &amp; sort methods because the elements of our sequence, String in our case, are Comparable. Contains is available thanks to our elements being Equatable.</p>

<pre><code class="swift">section.filter { $0.count &gt; 3 }
// ["Cayman", "Cayenne"]
section.map { $0.count }
// [3, 6, 7]
section.reduce(0) { $0 + $1.count }
// 16
</code></pre>

<p>And for functional programming fans, filter, map and reduce are also given.</p>

<p><a id="markdown-collections" name="collections"></a></p>

<h2>Collections</h2>

<p>Sequence is the most basic set notion given by the Swift standard library. There is a more evolved one.</p>

<p>A collection is defined as follow :</p>

<blockquote><p>A multi-pass <em>sequence</em> with addressable positions</p></blockquote>

<p>As we saw previously, a sequence is a type that can be iterated with a <code>for…in</code> loop. It doesn’t need that the elements might be iterated over several times. And it doesn’t need that we give a way to access directly an element.</p>

<p>Collections require those last two points. As a side effect, it no longer allows us to have an infinite number of elements.</p>

<p>To be a collection, a type must conform to the <code>Collection</code> protocol.</p>

<p><a id="markdown-how-to-conform-to-collection-protocol" name="how-to-conform-to-collection-protocol"></a></p>

<h3>How to Conform to <code>Collection</code> Protocol</h3>

<p>This section comes from <a href="https://developer.apple.com/documentation/swift/collection">Collection official site</a>.</p>

<p>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the Collection protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add Collection conformance to your type, you must declare at least the following requirements:</p>

<ol>
<li>The <code>startIndex</code> and <code>endIndex</code> properties</li>
<li>A subscript that provides at least read-only access to your type’s elements</li>
<li>The <code>index(after:)</code> method for advancing an index into your collection</li>
<li>Conform to <code>Sequece</code> Protocol, as <code>Collection</code> is inherited from <code>Sequence</code></li>
</ol>


<p><a id="markdown-make-our-section-conform-to-collection-protocol" name="make-our-section-conform-to-collection-protocol"></a></p>

<h3>Make our <code>Section</code> Conform to <code>Collection</code> Protocol</h3>

<pre><code class="swift">struct Section&lt;T&gt;: Collection {
    let title: String
    let elements: [T]

    // begin: required for Collection
    var startIndex: Int { return 0 }
    var endIndex: Int { return elements.count }

    func index(after i: Int) -&gt; Int {
        return i + 1
    }

    subscript(index: Int) -&gt; T {
        return elements[index]
    }
    // end: required for Collection


    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }


    // begin: required for Sequence
    struct Iterator: IteratorProtocol {
        let array: [T]
        var currentIndex = 0

        init (_ array: [T]) {
            self.array = array
        }

        mutating func next() -&gt; T? {
            let tempIndex = currentIndex
            currentIndex += 1
            return array[safe: tempIndex]

        }
    }

    func makeIterator() -&gt; Section&lt;T&gt;.Iterator {
        return Iterator(elements)
    }
    // end: required for Sequence
}
</code></pre>

<p>The <code>endIndex</code> has to be after the last element. It allows to define an empty collection with <code>startIndex</code> = <code>endIndex</code>.</p>

<p>Like conforming to <code>Sequence</code>, we get some methods / properties for free:</p>

<pre><code class="swift">section.count
// 3
section.first
// 911
section.isEmpty
// false
section.index(of: "911")
// 0
</code></pre>

<p>We get indexOf thanks to our Elements being Equatable.</p>

<p><a id="markdown-difference-between-array-and-collection" name="difference-between-array-and-collection"></a></p>

<h2>Difference between <code>Array</code> and <code>Collection</code></h2>

<p>We created our own collection, which is great, but what about that difference of behavior between Arrays and Dictionaries we talked about at the beginning of the post? We saw that Array’s dangerous subscript was coming from the Indexable protocol, but what about Dictionaries?</p>

<p>Dictionaries, like Arrays, are a collection, as Swift defines it. They both conform to CollectionType. So Dictionaries are also required to provide an ‘unsafe’ subscript that takes an Index and returns a non optional Element. The one we’re used to is just a convenience subscript.</p>

<p>A simple example shows that it is also really easy to get a crash with Dictionaries.</p>

<pre><code class="swift">let dic = ["a": "bmw", "b": "audi", "c": "citroen"]

var index = dic.startIndex
dic[index]
// (key: "c", value: "citroen")

index = dic.index(after: index)
print(dic[index])
// (key: "b", value: "audi")

index = dic.index(after: index)
index = dic.index(after: index)
dic[index]
// Fatal error
</code></pre>

<p><strong>The last question that remains is why <code>Collection</code> requires a subscript that may crash? Simply for performance reason, it costs too much to check the validity of the given index. Crashing is faster :)</strong></p>

<p><a id="markdown-reference" name="reference"></a></p>

<h2>Reference</h2>

<ol>
<li><a href="https://medium.com/swift-programming/swift-sequences-ce22d76f120c">Swift Sequences</a></li>
<li><a href="https://medium.com/swift-programming/swift-collections-e5fff3cd6759">Swift Collections</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Offline Natural Language Understanding Engine on iOS]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/05/22/offline-natural-language-understanding-engine-on-ios/"/>
    <updated>2019-05-22T16:04:28+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/05/22/offline-natural-language-understanding-engine-on-ios</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#objective">Objective</a>

<ul>
<li><a href="#what-is-a-good-nlu-engine">What is a good NLU engine</a>

<ul>
<li><a href="#deterministic-behavior">Deterministic behavior</a></li>
<li><a href="#generalization-power">Generalization power</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#design-and-workflow">Design and Workflow</a></li>
<li><a href="#deterministic-intent-parser">Deterministic Intent Parser</a></li>
<li><a href="#probabilistic-intent-parser">Probabilistic Intent Parser</a>

<ul>
<li><a href="#intent-classification">Intent Classification</a>

<ul>
<li><a href="#model-training">Model Training</a></li>
<li><a href="#model-usage">Model Usage</a></li>
</ul>
</li>
<li><a href="#slot-filling">Slot Filling</a>

<ul>
<li><a href="#model-training-1">Model Training</a></li>
<li><a href="#model-usage-1">Model Usage</a></li>
</ul>
</li>
<li><a href="#model-size">Model Size</a></li>
<li><a href="#problems-to-be-solved">Problems to Be Solved</a>

<ul>
<li><a href="#intent-classification-model-has-no-probability-output">Intent Classification Model Has No Probability Output</a></li>
<li><a href="#slot-filling-model-tagges-the-label-by-words-not-phrase">Slot Filling Model Tagges the Label by Words, not Phrase</a></li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a id="markdown-objective" name="objective"></a></p>

<h2>Objective</h2>

<p><img src="/images/NLUObjective.png" alt="nlu objective" /></p>

<p>We want an NLU Engine to understand the normal text command on Mobile. We hope the engine can know the command&rsquo;s intent and the info the command needs to execute.</p>

<p>Currently, there are many NLU related tools, like Google Dialogflow, Amazon Lex, Facebook Wit.ai, Microsoft Luis. However, they are all online tools. Considering the privacy problem, we are trying to build our own offline NLU Engine.</p>

<p><a id="markdown-what-is-a-good-nlu-engine" name="what-is-a-good-nlu-engine"></a></p>

<h3>What is a good NLU engine</h3>

<p>Let’s start by looking at a simple example, and see what you would expect from a good NLU engine.</p>

<p>First, we need some examples to train the NLU engine. Consider the following dataset, used to train a simple weather assistant with a few query examples:</p>

<ul>
<li>Give me the weather for [tomorrow](date)</li>
<li>Show me the [Paris](location) weather for [Sunday](date)</li>
</ul>


<p><a id="markdown-deterministic-behavior" name="deterministic-behavior"></a></p>

<h4>Deterministic behavior</h4>

<p>The first thing you want is that all the examples you give to train the model are correctly supported by the engine. This makes the system predictable and easy to use: if a query is not correctly parsed, then add it to the dataset and it will work right away.</p>

<p><a id="markdown-generalization-power" name="generalization-power"></a></p>

<h4>Generalization power</h4>

<p>Having this deterministic behavior is great for robustness and predictability, but a powerful NLU engine also needs to have some generalization power. You want the system not only to recognize patterns provided in the training set, but also all the possible variations that come from speaking naturally. If we go back to the previous dataset, it is reasonable to expect the NLU engine to parse a query like: “What’s the weather in Beijing right now?” even though it is not one of the training examples.</p>

<p><a id="markdown-design-and-workflow" name="design-and-workflow"></a></p>

<h2>Design and Workflow</h2>

<p><img src="/images/NLUDesign.png" alt="nlu design" /></p>

<p>In order to satisfy these objectives: deterministic behavior and generalization power, we built the processing pipeline described in the figure above. It receives a text as input, and outputs a structured response containing the intent and the list of slots. The main processing unit of the pipeline is the NLU engine. It contains two intent parsers which are called successively: a deterministic intent parser and a probabilistic one.</p>

<p>The deterministic parser relies on regular expressions to match intent and slots, which results in perfect behavior on training examples but doesn’t generalize. This parser is the first to be used because of its strictness.</p>

<p>The probabilistic parser is used whenever the first parser fails to find a match. It uses machine learning to generalize beyond the set of sentences seen at train time, thus making our NLU engine be able to cope with examples which are not in the scope of the training data set. This parser involves two successive steps: intent classification and slot filling. These two steps rely on trained machine learning models to classify intent and extract slots.</p>

<p><a id="markdown-deterministic-intent-parser" name="deterministic-intent-parser"></a></p>

<h2>Deterministic Intent Parser</h2>

<p>The Deterministic Intent Parse is the first step to be used. This parser relies on some regular expressions to match the intent and slots. If the new input has the same structure with one of the training examples, we will find its intent and slots by comparing the input with the matched regular expression.</p>

<p>The regular expressions are built based on the training examples. For a training case:</p>

<ul>
<li>What is the weather in [Alaska](location)</li>
</ul>


<p>We will build a regular expression:</p>

<ul>
<li>(what is the weather in)(?&lt;location1&gt;.+)</li>
</ul>


<p><a id="markdown-probabilistic-intent-parser" name="probabilistic-intent-parser"></a></p>

<h2>Probabilistic Intent Parser</h2>

<p>If the Deterministic Intent Parser fails to find the intent and slots, the Probabilistic Intent Parser will be used.</p>

<p>The Probabilistic Intent Parser has two steps:</p>

<ul>
<li>Intent Classification</li>
<li>Slot Filling</li>
</ul>


<p>The Intent Classification is to find the intent of the input command text, and the Slot Filling is to extract all the slots needed by the intent. These two steps are both based on trained machine models.</p>

<p>Apple has released CreateML for training natural language models, which also integrates the powerful NatrualLanguage framework functions, like Tokenization, Part of Speech, Lemmatization, Name Entity Recognition, etc. This will make the training process very simple, and the trained model will be more accurate and smaller.</p>

<p><a id="markdown-intent-classification" name="intent-classification"></a></p>

<h3>Intent Classification</h3>

<p><a id="markdown-model-training" name="model-training"></a></p>

<h4>Model Training</h4>

<p>For Intent Classification model training, we prepare the data set as follows (The size of the training data is 3282 falling into four intents.):</p>

<pre><code class="json">[
  {
    "text": "I would like the forecast in cupertino california  tomorrow", 
    "label": "searchWeatherForecast"
  }, 
  {
    "text": "Forecast in Maine USA next week", 
    "label": "searchWeatherForecast"
  }, 
...
...
  {
    "text": "Will I be able to wear open-toed shoes twenty three hours and seven minutes from now in Severn?", 
    "label": "searchWeatherForecastItem"
  }, 
  {
    "text": "Should I bring a raincoat to the Belgrade and Loreto areas of Oman at midnight?", 
    "label": "searchWeatherForecastItem"
  }, 
...
...
]
</code></pre>

<p>Apple has release CreateML framework for training machine learning models easily inside Swift playground and the trained model can be saved as mlmodel type. And the MLTextClassifier class from CreateML will benefit from Apple&rsquo;s NatrualLanguage framework for Tokenization, Part of Speech, Lemmatization, etc.</p>

<p>The training script is:</p>

<pre><code class="swift">let trainingDataPath = Bundle.main.path(forResource: "intentClassificationFile", ofType: "json", inDirectory: "Data/text/train")!
let trainingData = try! MLDataTable(contentsOf:  URL(fileURLWithPath: trainingDataPath))

// Initializing the classifier with a training data.
let classifier = try! MLTextClassifier(trainingData: trainingData, textColumn: "text", labelColumn: "label")

// Evaluating training &amp; validation accuracies.
let trainingAccuracy = (1.0 - classifier.trainingMetrics.classificationError) * 100
let validationAccuracy = (1.0 - classifier.validationMetrics.classificationError) * 100

// Initializing the properly labeled testing data from Resources folder.
let testingDataPath = Bundle.main.path(forResource: "intentClassificationFile", ofType: "json", inDirectory: "Data/text/test")!
let testingData = try! MLDataTable(contentsOf: URL(fileURLWithPath:testingDataPath))

// Counting the testing evaluation.
let evaluationMetrics = classifier.evaluation(on: testingData)
let evaluationAccuracy = (1.0 - evaluationMetrics.classificationError) * 100

// Confusion matrix in order to see which labels were classified wrongly.
let confusionMatrix = evaluationMetrics.confusion
print("Confusion matrix: \(confusionMatrix)")

// Metadata for saving the model.
let metadata = MLModelMetadata(author: "Hongchao Zhang",
                            shortDescription: "A model trained to classify weather related commands.",
                            version: "1.0")

// Saving the model. Remember to update the path.
try! classifier.write(to: URL(fileURLWithPath: "/Users/hozhang/Downloads/textClassifier.mlmodel"),
                    metadata: metadata)
</code></pre>

<p>We can get 99.23% training accuracy and 98.87% validation accuracy.</p>

<p><a id="markdown-model-usage" name="model-usage"></a></p>

<h4>Model Usage</h4>

<p>For the trained model of mlmodel type, we can use it in our iOS app through NLModel (from NatrualLanguage framework). The demo swift code may be like:</p>

<pre><code class="swift">let modelUrl = Bundle.main.url(forResource: "Data/text/textClassifier", withExtension: "mlmodel")
let compiledModelUrl = try! MLModel.compileModel(at: modelUrl!)
let classifier = try! NLModel(contentsOf: compiledModelUrl)

let text = requestText
let label = classifier.predictedLabel(for: text)

print("text: \(text)\nlabel:\(label ?? "Not detected!")")
</code></pre>

<blockquote><p><strong>How to use .mlmodel file?</strong></p>

<p>.mlmodel file needs to be compiled before using. There are two ways to do this: offline and online:</p>

<ol>
<li>offline: drag the mlmodel into your project, xcode will compile the .mlmodel for you before you build you app.</li>
<li>online: use <code>MLModel.compileModel</code> to compile your .mlmodel file at runtime. This is especially useful when your are at swift playground, where you cannot get xcode&rsquo;s help for comipling.</li>
</ol>
</blockquote>

<p><a id="markdown-slot-filling" name="slot-filling"></a></p>

<h3>Slot Filling</h3>

<p><a id="markdown-model-training-1" name="model-training-1"></a></p>

<h4>Model Training</h4>

<p>For Slot Filling model training, we prepare the data set as follows (The size of the training data is: 3282.):</p>

<pre><code class="json">[
  {
    "tokens": ["I", "would", "like", "the", "forecast", "in", "california", "tomorrow"], 
    "labels": ["none", "none", "none", "none", "none", "none", "location", "date"]
  }, 
  {
    "tokens": ["Forecast", "in", "Maine", "next week"], 
    "labels": ["none", "none", "location", "date"]
  }, 
...
...
]
</code></pre>

<p>Like Intent Classification model training, CreateML framework also makes it easy. Like MLTextClassifier, the MLWordTagger class from CreateML will also benefit from NatrualLanguage framework for Part of Speech, Lemmatization, Name Entity Recognition, etc.</p>

<p>The training script is:</p>

<pre><code class="swift">// Initializing the training data from Resources folder.
let trainingDataPath = Bundle.main.path(forResource: "slotParsingFile", ofType: "json", inDirectory: "Data/text/train")!
let trainingData = try! MLDataTable(contentsOf:  URL(fileURLWithPath: trainingDataPath))

// Initializing the classifier with a training data.
let classifier = try! MLWordTagger(trainingData: trainingData, tokenColumn: "tokens", labelColumn: "labels")

// Evaluating training &amp; validation accuracies.
let trainingAccuracy = (1.0 - classifier.trainingMetrics.taggingError) * 100
let validationAccuracy = (1.0 - classifier.validationMetrics.taggingError) * 100

// Initializing the properly labeled testing data from Resources folder.
let testingDataPath = Bundle.main.path(forResource: "slotParsingFile", ofType: "json", inDirectory: "Data/text/test")!
let testingData = try! MLDataTable(contentsOf: URL(fileURLWithPath:testingDataPath))

// Counting the testing evaluation.
let evaluationMetrics = classifier.evaluation(on: testingData)
let evaluationAccuracy = (1.0 - evaluationMetrics.taggingError) * 100

// Confusion matrix in order to see which labels were classified wrongly.
let confusionMatrix = evaluationMetrics.confusion
print("Confusion matrix: \(confusionMatrix)")

// Metadata for saving the model.
let metadata = MLModelMetadata(author: "Hongchao Zhang",
                                shortDescription: "A model trained to parse slots from weather related commands.",
                                version: "1.0")

// Saving the model. Remember to update the path.
try! classifier.write(to: URL(fileURLWithPath: "/Users/hozhang/Downloads/slotParsing.mlmodel"),
                        metadata: metadata)
</code></pre>

<p>We can get 99.64% training accuracy and 98.38% validation accuracy.</p>

<p><a id="markdown-model-usage-1" name="model-usage-1"></a></p>

<h4>Model Usage</h4>

<p>We can load the mlmodel into an NLTagger (from NatrualLanguage framework), and use the NLTagger to tag labels for each word of the input command text. The demo swift script is like:</p>

<pre><code class="swift">let weatherTagSchema = NLTagScheme("Weather")
let modelUrl = Bundle.main.url(forResource: "Data/text/slotParsing", withExtension: "mlmodel")
let compiledModelUrl = try! MLModel.compileModel(at: modelUrl!)
let taggerModel = try! NLModel(contentsOf: compiledModelUrl)

let weatherTagger = NLTagger(tagSchemes: [weatherTagSchema])
weatherTagger.setModels([taggerModel], forTagScheme: weatherTagSchema)

let text = requestText
weatherTagger.string = text
weatherTagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: weatherTagSchema, options: []) { (tag, tokenRange) -&gt; Bool in
    if let tag = tag, tag.rawValue != "Whitespace" {
        print("\(text[tokenRange]): \(tag.rawValue)")
    }
    return true
}
</code></pre>

<p><strong> Reference </strong></p>

<ol>
<li><a href="https://developer.apple.com/documentation/createml/creating_a_text_classifier_model">Creating a Text Classifier Model</a>: Apple offical site for training and using machine learning models through CreateML framework.</li>
<li>WWDC video <a href="https://developer.apple.com/videos/play/wwdc2018/713/">Introducing Natural Language Framework</a>: This session introduces NLP framework and its relation with CreateML framework.</li>
</ol>


<p><a id="markdown-model-size" name="model-size"></a></p>

<h3>Model Size</h3>

<p>For the iOS app, we hope the machine learning model size is small enough. Apple&rsquo;s NatrualLanguage framework has done many optimizations on machine learning model size. The following data is from WWDC 2018 (session 713: Introducing NatrualLanguage Framework):</p>

<table>
<thead>
<tr>
<th>&ndash; </th>
<th> Open Source CRFSuite </th>
<th> Natural Language Framework</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name Entity Recognition </td>
<td> 70MB  </td>
<td> 1.4MB</td>
</tr>
<tr>
<td>Chunking </td>
<td> 30MB </td>
<td> 1.8MB</td>
</tr>
</tbody>
</table>


<p>We can see that the model will be much smaller than that trained from an open source platform.</p>

<p>The size of the two models we trained is (The training data size is: 3282):</p>

<table>
<thead>
<tr>
<th>Model </th>
<th> Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>Intent Classification </td>
<td> 41K</td>
</tr>
<tr>
<td>Slot Filling </td>
<td> 609K</td>
</tr>
</tbody>
</table>


<p>If your model is a neural network, you can reduce the size of your model by the following way:
<a href="https://developer.apple.com/documentation/coreml/reducing_the_size_of_your_core_ml_app">Reducing the Size of Your Core ML App</a>. You can control the precision of the neural network parameters, and thus the size of the trained model.</p>

<p>If still your model is large, you can
<a href="https://developer.apple.com/documentation/coreml/core_ml_api/downloading_and_compiling_a_model_on_the_user_s_device">Downloading and Compiling a Model on the User&rsquo;s Device</a> at runtime.</p>

<p><a id="markdown-problems-to-be-solved" name="problems-to-be-solved"></a></p>

<h3>Problems to Be Solved</h3>

<p>For Probabilistic Intent Parser, we still have some problems.</p>

<p><a id="markdown-intent-classification-model-has-no-probability-output" name="intent-classification-model-has-no-probability-output"></a></p>

<h4>Intent Classification Model Has No Probability Output</h4>

<p>We may need the probability to define the reliability of the estimated intent of an input command text.</p>

<p>However, the model trained through <code>MLTextClassifier</code> has no probability output API. If we really need the probability output, we can use other platforms to train the model, like tensorflow. That way, we will not benefit from NatrualLanguage framework and we need to consider these things by ourselves, like Tokenization, Part of Speech, Lemmatization, etc.</p>

<blockquote><p>Try other tools for training models with probability output, like Turi.</p></blockquote>

<p><a id="markdown-slot-filling-model-tagges-the-label-by-words-not-phrase" name="slot-filling-model-tagges-the-label-by-words-not-phrase"></a></p>

<h4>Slot Filling Model Tagges the Label by Words, not Phrase</h4>

<p>The NLTagger class only supply the following four tag level: word, sentence, paragraph, and document. There is no &ldquo;phrase&rdquo; tag level. For example, &ldquo;New York&rdquo; will be treated as &ldquo;New&rdquo; and &ldquo;York&rdquo;, and the tagged label will both be &ldquo;location&rdquo;. We need to compose them together manually.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何控制iOS应用的屏幕方向]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/05/21/understand-ios-app-orientations/"/>
    <updated>2019-05-21T18:24:35+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/05/21/understand-ios-app-orientations</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>背景</h2>

<p>一个iOS应用默认都会支持所有的是个方向，当用户旋转屏幕的时候，应用会自动旋转。</p>

<p>有些时候，这可能不是我们想要的。比如你设计了一个只支持竖屏方向的应用，但是又想在某些时候支持Landscape模式，比如播放视频的时候。iOS应用有很多地方的设置会影响屏幕方向，iOS9之后，iPad又支持了split view，使得这个控制更加复杂。</p>

<h2>总起</h2>

<p>iPhone比较简单，因为其没有spit view的功能，iPad因为有了spilt view功能，在屏幕方向的控制上更复杂一些。</p>

<p>首先，需要明确：有哪些因素会影响到App的屏幕方向？</p>

<p><strong>1. Project设置（info.plist）</strong></p>

<p>有两个地方可以进行该项设置：</p>

<ul>
<li><p>Project->Target->General->Device Orientation</p>

<p><img src="/images/ScreenOrientationProjectSetting.png" alt="screen orientation project setting" /></p></li>
<li><p>Project的info.plist配置文件</p>

<p><img src="/images/ScreenOrientationInfoPlist.png" alt="screen orientation info plist" /></p></li>
</ul>


<p>这两个地方的设置是一致的：在一个地方改动，另一个地方会同步修改。其中：info.plist中的“Supported interface orientations (iPad)”属性对应于iPad的设置（Device选择iPad），info.plist中的“Supported interface orientations”属性对应于iPhone和Universal的设置（Device选择iPhone或者Universal，这两项的设置始终保持一致）。</p>

<p><strong>2. 在代码中设置应用支持的屏幕方向</strong></p>

<p>有两种方法可以在代码中设置应用支持的屏幕方向：</p>

<ul>
<li><code>UIApplicationDelegate</code>中的<code>supportedInterfaceOrientationsForWindow:</code>方法</li>
<li>每个<code>UIViewController</code>还可以通过<code>supportedInterfaceOrientations</code>方法设置自己支持的屏幕方向</li>
</ul>


<p>系统会自动将两种方法中支持的屏幕方向取交集，作为最终该view controller支持的屏幕方向。如果交集为空，那么应用将会Crash。</p>

<p><strong>3. <code>UIViewController</code>中的<code>shouldAutorotate</code>属性</strong></p>

<p>该属性是只读属性，用来控制该view controller可不可以旋转。可以在自己的view controller中将其override，返回自己的逻辑，甚至将其override为读写属性，可以在其它地方进行设置。比如：</p>

<pre><code class="swift">override public var shouldAutorotate: Bool {
    get {
        return self.shouldAutorotateVariable
    }
    set {
        self.shouldAutorotateVariable = newValue
    }
}
</code></pre>

<p>其中<code>shouldAutorotateVariable</code>为view controller中自定义的一私有变量。</p>

<h2>iPhone</h2>

<p>如果某个view controller中的<code>shouldAutorotate</code>被设置为<code>false</code>，那么系统将忽略下面的设置：</p>

<ul>
<li><code>UIApplicationDelegate</code>中的<code>supportedInterfaceOrientationsForWindow:</code>方法</li>
<li>该<code>UIViewController</code>通过<code>supportedInterfaceOrientations</code>方法设置的自己支持的屏幕方向</li>
</ul>


<p>系统只考虑用户在“Project设置（info.plist）”中的设置。</p>

<p>如果某个view controller中的<code>shouldAutorotate</code>未被重写（或者被重写为<code>true</code>），那么系统将优先考虑使用下面两个设置的交集：</p>

<ul>
<li><code>UIApplicationDelegate</code>中的<code>supportedInterfaceOrientationsForWindow:</code>方法</li>
<li>该<code>UIViewController</code>通过<code>supportedInterfaceOrientations</code>方法设置的自己支持的屏幕方向</li>
</ul>


<p>如果没有以上两个设置，再使用“Project设置（info.plist）”中的设置。</p>

<h2>iPad</h2>

<p>从iOS9开始，iPad开始支持split view功能。关于这个功能的设置说明，可以参考苹果官方文档：<a href="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/QuickStartForSlideOverAndSplitView.html#//apple_ref/doc/uid/TP40015145-CH13-SW1">Slide Over and Split View Quick Start</a>。简单的说，就是：如果info.plist中的“Supported interface orientations (iPad)”属性对应的值包含了四个方向，同时<code>UIRequiresFullScreen</code>对应的值为<code>NO</code>，那么系统默认该应用支持split view属性，同时系统将忽略下面两处代码：</p>

<ul>
<li><code>UIApplicationDelegate</code>中的<code>supportedInterfaceOrientationsForWindow:</code>方法</li>
<li><code>UIViewController</code>通过<code>supportedInterfaceOrientations</code>方法设置的自己支持的屏幕方向</li>
</ul>


<p>以及<code>UIViewController</code>中<code>shouldAutorotate</code>的值。</p>

<p>也就是说：支持split view的应用将不能被禁止旋转，至少不能通过本文中的方法进行禁止旋转。</p>

<p>如果info.plist中的“Supported interface orientations (iPad)”属性对应的值未包含四个方向，或者“UIRequiresFullScreen”对应的值为<code>NO</code>，那么该应用不支持split view功能，其屏幕方向控制方法同iPhone相同。</p>

<blockquote><p>注意：对于“Project设置（info.plist）”设置，建议在info.plist中进行，直接设置一下三个属性的值：
* Supported interface orientations (iPad)
* Supported interface orientations
* UIRequiresFullScreen</p>

<p>在Project->Target->General->Device Orientation中进行设置，有点迷惑性：因为即使“Device”选的是“Universal”，“iPad”下面的设置也会起作用。</p></blockquote>

<h2>参考</h2>

<ol>
<li><a href="https://mobiarch.wordpress.com/2017/04/22/controlling-screen-orientation-of-ios-apps/">Controlling Screen Orientation of iOS Apps</a></li>
<li><a href="https://stackoverflow.com/questions/32782044/ios-9-supportedinterfaceorientations-not-working/32782517#32782517">iOS 9 supportedInterfaceOrientations not working</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/QuickStartForSlideOverAndSplitView.html#//apple_ref/doc/uid/TP40015145-CH13-SW1">Slide Over and Split View Quick Start</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于AR的一些使用场景]]></title>
    <link href="http://hongchaozhang.github.io/blog/2018/08/17/some-ideas-on-ar-usage/"/>
    <updated>2018-08-17T15:13:58+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2018/08/17/some-ideas-on-ar-usage</id>
    <content type="html"><![CDATA[<p>搜集一些有意思的AR应用。</p>

<!-- more -->


<p>主要参考：<a href="https://github.com/olucurious/Awesome-ARKit">Awesome ARKit</a>。这篇post里面还有很多实用的AR Tutorial和Resouces，如果自己动手，可以参考。</p>

<ul>
<li><a href="#app-store%E4%B8%8A%E9%9D%A2%E7%9A%84app">App Store上面的App</a>

<ul>
<li><a href="#%E7%A5%9E%E5%A5%87ar">神奇AR</a></li>
<li><a href="#ikea-place">IKEA Place</a></li>
<li><a href="#wallr">Wallr</a></li>
<li><a href="#horizon-explorer">Horizon Explorer</a></li>
<li><a href="#weare">WeAre</a></li>
<li><a href="#waazy---magic-ar-video-maker">Waazy - Magic AR Video Maker</a></li>
<li><a href="#human-anatomy-atlas-2019">Human Anatomy Atlas 2019</a></li>
</ul>
</li>
<li><a href="#github%E4%B8%8A%E9%9D%A2%E7%9A%84%E9%A1%B9%E7%9B%AE">Github上面的项目</a>

<ul>
<li><a href="#arkit-occlusion-demo">arkit-occlusion-demo</a></li>
<li><a href="#arvideokit">[ARVideoKit]()</a></li>
<li><a href="#arkit-smb-homage">arkit-smb-homage</a></li>
<li><a href="#arkit-corelocation">ARKit-CoreLocation</a></li>
<li><a href="#arkitnavigationdemo">ARKitNavigationDemo</a></li>
<li><a href="#fineme">FineMe</a></li>
<li><a href="#arkitspitfire">ARKitSpitfire</a></li>
</ul>
</li>
<li><a href="#resources">Resources</a>

<ul>
<li><a href="#poly">Poly</a></li>
</ul>
</li>
</ul>


<p><a id="markdown-app-store上面的app" name="app-store上面的app"></a></p>

<h2>App Store上面的App</h2>

<p><a id="markdown-神奇arhttpsitunesapplecomcnappar-arid1327719623mt8" name="神奇ar"></a></p>

<h3><a href="https://itunes.apple.com/cn/app/%E7%A5%9E%E5%A5%87ar-%E7%89%B9%E6%95%88ar%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%9F%AD%E8%A7%86%E9%A2%91%E6%8B%8D%E6%91%84%E7%A5%9E%E5%99%A8/id1327719623?mt=8">神奇AR</a></h3>

<p>这个AR应用非常棒，号称“中国第一AR平台”。打开App，以为自己是打开了“抖音”呢。其模仿抖音的痕迹很重，但是神奇AR的视频不同于抖音里面的视频：都是真实世界和虚拟世界的深入互动。支持下载很多3D模型。</p>

<p><a href="https://itunes.apple.com/cn/app/%E7%A5%9E%E5%A5%87ar-%E7%89%B9%E6%95%88ar%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%9F%AD%E8%A7%86%E9%A2%91%E6%8B%8D%E6%91%84%E7%A5%9E%E5%99%A8/id1327719623?mt=8">神奇AR</a>还有一个很好的应用：可以让你将照片在真实场景中打开，支持默认的排列方式，也可以自由摆放多张照片。但是图片一圈都会默认带有一圈白色的过渡带和阴影，无法去除。对于不是标准长方形的图片（比如圆形的图片，圆形之外都是透明的），显示效果不佳。</p>

<p>而且，是免费的。也许是因为其主打段视频社交吧，所以免费。</p>

<p>看官方介绍：</p>

<blockquote><p>AR视频:
用户可以利用AR模型、特效、图片、视频等拍摄一段30秒的短视频，发布在神奇AR的视频流中，或者分享到各大媒体平台，将自己的创意展现给更多的人，告诉大家如何使用AR。
玩转AR:
用户可以打开AR摄像头，通过简单的操作，将AR模型放在真实世界中，创造各种神奇的景象，用AR就能创造电影里才能出现的特技。
丰富的模型:
神奇AR是一个开放内容平台，直接对接优质的AR内容提供者，他可以通过神奇AR把自己的作品第一时间开放给用户，所以我们拥有全世界最丰富的AR内容。</p></blockquote>

<p><img src="/images/shenqiar.jpg" alt="神奇 AR" /></p>

<p><a id="markdown-ikea-placehttpsitunesapplecomusappikea-placeid1279244498mt8" name="ikea-place"></a></p>

<h3><a href="https://itunes.apple.com/us/app/ikea-place/id1279244498?mt=8">IKEA Place</a></h3>

<p>宜家的官方App，有丰富的宜家家具的3D模型，真实尺寸，可以提前放置到自己的房间，看看效果。</p>

<blockquote><p>IKEA Place lets you virtually &lsquo;place&rsquo; IKEA products in your space. The app includes 3D and true-to-scale models of everything from sofas and armchairs to footstools and coffee tables. IKEA Place gives you an accurate impression of the furniture’s size, design and functionality in your home so you can stop wondering and start doing.</p></blockquote>

<p><img src="/images/IKEAPlace.jpg" alt="ikea place" /></p>

<p><a id="markdown-wallrhttpsitunesapplecomusappwallrid1278372745" name="wallr"></a></p>

<h3><a href="https://itunes.apple.com/us/app/wallr/id1278372745">Wallr</a></h3>

<p>Wallr可以让你将图片放置到真实场景的墙面上。如果你想买画装饰墙面，可以试试。不过这个功能已经在<a href="https://itunes.apple.com/cn/app/%E7%A5%9E%E5%A5%87ar-%E7%89%B9%E6%95%88ar%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%9F%AD%E8%A7%86%E9%A2%91%E6%8B%8D%E6%91%84%E7%A5%9E%E5%99%A8/id1327719623?mt=8">神奇AR</a>中实现了，而且是免费的。</p>

<p>同时放置多张图片需要花钱购买。</p>

<p><img src="/images/wallr.jpg" alt="wallr" /></p>

<p><a id="markdown-horizon-explorerhttpsitunesapplecomgbapphorizon-explorerid1326860431platformipadpreservescrollpositiontrueplatformipad" name="horizon-explorer"></a></p>

<h3><a href="https://itunes.apple.com/gb/app/horizon-explorer/id1326860431?platform=ipad&amp;preserveScrollPosition=true#platform/ipad">Horizon Explorer</a></h3>

<p>AR和地图、地理位置结合的一个应用。</p>

<p>展示你设备看到的地理位置的信息，包括距离、建筑物名称、地点名称等。并把路线在一张地图上面展示给你。</p>

<p>还可以将3D的地图展示给你，让你看看某个景点或者建筑物周围等地理信息。</p>

<p>来看官方介绍：</p>

<blockquote><p>Horizon Explorer shows you the horizon and skyline around you &amp; tells you what you&rsquo;re looking at.</p>

<p>Point your camera at a hill, village, lake or landmark and Horizon Explorer will tell you what you are looking at, how far away it is, and show you a map, and information about the point you&rsquo;re aiming at.</p>

<p>ARKit technology makes the labels and alignment much more stable than used to be possible.</p>

<p>Fly up high and see the terrain laid out below you to see what is over the hills around you, and get the lay of the land, then see the scale-model 3D map that you can walk around &amp; explore to find out what&rsquo;s behind hills, or investigate up close.</p>

<p>Tracking works best on top of a hill with an unobstructed view of your surroundings (close up trees, buildings, rocks etc. can confuse the tracking). You can drag the terrain with your finger to line up with the camera if the automatic tracking is not working very well. Or try waving your phone around in the air in a figure 8 to calibrate the compass.</p></blockquote>

<p><img src="/images/HorizonExplorer.jpg" alt="Horizon Explorer" /></p>

<p><a id="markdown-wearehttpsitunesapplecomcnappweareid1304227680platformiphonepreservescrollpositiontrueplatformiphoneplatformiphoneplatformiphone" name="weare"></a></p>

<h3><a href="https://itunes.apple.com/cn/app/weare/id1304227680?platform=iphone&amp;preserveScrollPosition=true&amp;platform=iphone#platform/iphone&amp;platform=iphone">WeAre</a></h3>

<p>这个应用可以让你选择一些照片，以设备为中心围成一圈，并缓慢移动。还可以播放视频、背景音乐和编辑3D文字。用作者的话说，“可以打造一个或温馨浪漫的回忆相册,或缥缈遥远的世界.”</p>

<p>同时还是源码可以参考：<a href="https://github.com/SherlockQi/HeavenMemoirs">HeavenMemoirs - AR相册</a></p>

<p><img src="/images/weare.jpg" alt="WeAre" /></p>

<p><a id="markdown-waazy---magic-ar-video-makerhttpsitunesapplecomusappwaazy-magic-ar-video-makerid1286992749" name="waazy---magic-ar-video-maker"></a></p>

<h3><a href="https://itunes.apple.com/us/app/waazy-magic-ar-video-maker/id1286992749">Waazy - Magic AR Video Maker</a></h3>

<p>没太看懂这个应用。感觉主要做社交视频分享。录制视频还需要AR Lens。直接看官方介绍吧：</p>

<blockquote><p>Waazy is an augmented reality short video clips shooting and sharing social network, making it possible to bring virtual characters and objects to the real world.</p>

<p>Features:
- Record cool moments with AR Lens
- Tons of free and awesome AR effects
- Can add multiple AR characters at the same time
- One tap to make all the characters dance together
- Easily move and rotate a virtual character with control pad
- Themes include fantasy, monster, fun, and landmarks
- Show your original AR videos to the world</p></blockquote>

<p><img src="/images/wazzy.jpg" alt="wazzy" /></p>

<p><a id="markdown-human-anatomy-atlas-2019httpsitunesapplecomappid1117998129" name="human-anatomy-atlas-2019"></a></p>

<h3><a href="https://itunes.apple.com/app/id1117998129">Human Anatomy Atlas 2019</a></h3>

<p>其实这个主要是展示人体内部结构的3D素材，借助AR技术投射到真实场景，没有很新鲜的AR应用场景。</p>

<p>这个应用非常专业，下载需要钱，App内还要购买。</p>

<blockquote><p>Human Anatomy Atlas offers thousands of models to help understand and communicate how the human body looks and works&ndash;and includes textbook-level definitions. Use it as a reference, instead of an anatomy textbook, or to create virtual lab experiences.
Includes over 10,000 anatomical models with descriptions in English, Spanish, French, German, Italian, Japanese, and Simplified Chinese.</p></blockquote>

<p><img src="/images/HumanAnatomyAtlas2019_1.jpg" alt="Human Anatomy Atlas 2019 1" /></p>

<p><img src="/images/HumanAnatomyAtlas2019_2.jpg" alt="Human Anatomy Atlas 2019 2" /></p>

<p><a id="markdown-github上面的项目" name="github上面的项目"></a></p>

<h2>Github上面的项目</h2>

<p><a id="markdown-arkit-occlusion-demohttpsgithubcombjarnelarkit-occlusion" name="arkit-occlusion-demo"></a></p>

<h3><a href="https://github.com/bjarnel/arkit-occlusion">arkit-occlusion-demo</a></h3>

<p>事先用一些虚拟平面将真实的墙面、柜子面、门等标记出来，就可以让虚拟的小球在房间里面来回反弹，就像撞到真实的墙上返回来一样。</p>

<p><img src="/images/occlusiongame.jpg" width="600" alt="occlusion game" /></p>

<p><a id="markdown-arvideokit" name="arvideokit"></a></p>

<h3><a href="">ARVideoKit</a></h3>

<p>一个用来录制AR视频的框架。</p>

<blockquote><p>An iOS Framework that enables developers to capture videos, photos, Live Photos, and GIFs with ARKit content.</p>

<p>In other words, you NO LONGER have to screen record/screenshot to capture videos and photos of your awesome ARKit apps!</p></blockquote>

<p>其实录屏/截屏不是也挺好的吗？！</p>

<blockquote><p>Key Features:</p>

<p>✅ Capture Photos from <code>ARSCNView</code>, <code>ARSKView</code>, and <code>SCNView</code></p>

<p>✅ Capture Live Photos &amp; GIFs from <code>ARSCNView</code>, <code>ARSKView</code>, and <code>SCNView</code></p>

<p>✅ Record Videos from <code>ARSCNView</code>, <code>ARSKView</code>, and <code>SCNView</code></p>

<p>✅ Pause/Resume video</p>

<p>✅ Allow device&rsquo;s Music playing in the background while recording a video</p>

<p>✅ Returns rendered and raw buffers in a protocol method for additional Image &amp; Video processing</p></blockquote>

<p><a id="markdown-arkit-smb-homagehttpsgithubcombjarnelarkit-smb-homage" name="arkit-smb-homage"></a></p>

<h3><a href="https://github.com/bjarnel/arkit-smb-homage">arkit-smb-homage</a></h3>

<p>在现实场景中玩超级玛丽。非常粗糙，但是创意还不错。</p>

<p><img src="/images/supermario_beginning.jpg" width="600" alt="super mario beginning" /></p>

<p><img src="/images/supermario_flag.jpg" width="600" alt="super mario flag" /></p>

<p><a id="markdown-arkit-corelocationhttpsgithubcomprojectdentarkit-corelocation" name="arkit-corelocation"></a></p>

<h3><a href="https://github.com/ProjectDent/ARKit-CoreLocation">ARKit-CoreLocation</a></h3>

<p>功能：</p>

<ol>
<li>这个库最主要的工作，是在试图整合ARKit和CoreLocation，以得到更加准确的定位，从而更好地应用于AR场景。</li>
<li>基于真实地理位置，标注出摄像头中某个建筑物或者景点的标注。这个功能类似于<a href="https://itunes.apple.com/gb/app/horizon-explorer/id1326860431?platform=ipad&amp;preserveScrollPosition=true#platform/ipad">Horizon Explorer</a>。</li>
</ol>


<p>TODO: 可以仔细看看此库附带的demo：</p>

<blockquote><p>The library and demo come with a bunch of additional features for configuration. It’s all fully documented to be sure to have a look around.</p></blockquote>

<p><img src="/images/arkit+corelocation.jpg" width="600" alt="arkit + corelocation" /></p>

<p><a id="markdown-arkitnavigationdemohttpsgithubcomchriswebb09arkitnavigationdemo" name="arkitnavigationdemo"></a></p>

<h3><a href="https://github.com/chriswebb09/ARKitNavigationDemo">ARKitNavigationDemo</a></h3>

<p>在地图上选择目的地，然后在真实场景中进行AR导航。</p>

<p>但是，这个项目也只是Demo一下，作者也很谦虚：</p>

<blockquote><p>When it loads to the map, tap a place on the map where you want to navigate to and press okay. The tap can be sluggish, so you might have to try once or twice before you get it. When the navigation screen loads, tap the screen, then give it a few seconds. You should see the nodes render.</p></blockquote>

<p>TODO: 这个项目中推荐的一些参考文献还是值得看一看的。</p>

<p><img src="/images/ARKitNavigationDemo.gif" alt="ARKitNavigationDemo" /></p>

<p><a id="markdown-finemehttpsgithubcommmoaayfindme" name="fineme"></a></p>

<h3><a href="https://github.com/mmoaay/Findme">FineMe</a></h3>

<p>可以让你的朋友根据你录制的路线图找到你：</p>

<ol>
<li>通过各种方法，记录你的起点，并让另一个人知道你的起点。比如可以通过分享起点照片，或者分享起点位置。</li>
<li>通过ARKit记录你走过的路线，并将路线分享给另一个人。</li>
<li>另一个人如果找到了你的起点，就可以根据你分享的路径找到你。</li>
</ol>


<p>但是，由于ARKit不稳定，此方法也不一定奏效。</p>

<p>作者试图通过定位和距离提高路线的稳定性，但不知效果如何，分别见于以下两个分支：</p>

<ul>
<li><a href="https://github.com/mmoaay/Findme/tree/feature/location_optimize">According to location</a></li>
<li><a href="https://github.com/mmoaay/Findme/tree/feature/distance_optimize">According to distance</a></li>
</ul>


<p><a id="markdown-arkitspitfirehttpsgithubcomchriswebb09arkitspitfire" name="arkitspitfire"></a></p>

<h3><a href="https://github.com/chriswebb09/ARKitSpitfire">ARKitSpitfire</a></h3>

<p>可以让一架3D飞机模型，根据提供的地理位置经纬度，调整姿态，并飞向那里。</p>

<p><img src="/images/ARKitSpitfire.gif" alt="ARKitSpitfire" /></p>

<p><a id="markdown-resources" name="resources"></a></p>

<h2>Resources</h2>

<p><a id="markdown-polyhttpsgithubcompiemontepoly" name="poly"></a></p>

<h3><a href="https://github.com/piemonte/Poly">Poly</a></h3>

<p><a href="https://github.com/piemonte/Poly">Poly</a>是一个iOS库，用来从<a href="https://developers.google.com/poly/">Google Poly</a>上下载3D模型，包含搜索、下载管理和缓存功能。</p>

<p><a href="https://developers.google.com/poly/develop/ios">iOS Quickstart</a>展示了如何在iOS中下载使用<a href="https://developers.google.com/poly/">Google Poly</a>上面的3D资源。</p>
]]></content>
  </entry>
  
</feed>
