<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | Zhang Hongchao]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2016-11-03T13:00:08+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS中多线程任务之间的同步]]></title>
    <link href="http://hongchaozhang.github.io/blog/2016/10/31/sync-between-multiplele-threads-tasks-in-ios-app/"/>
    <updated>2016-10-31T10:41:27+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2016/10/31/sync-between-multiplele-threads-tasks-in-ios-app</id>
    <content type="html"><![CDATA[<p>当我们使用iOS的多线程并发执行一些任务的时候，有时候需要考虑任务之间的同步问题，比如任务1和任务2执行完之后，才可以执行任务3，原因可能是任务3需要任务1和任务2执行得到的结果。</p>

<!-- more -->


<p>部分内容参考：
<a href="http://stackoverflow.com/questions/11909629/waiting-until-two-async-blocks-are-executed-before-starting-another-block">Waiting until two async blocks are executed before starting another block</a></p>

<h3>dispatch_group_notify</h3>

<p>当group中所有的block都执行完之后，<code>dispatch_group_notify</code>对应的block才会执行。并且放在同一个group中的block可以是不同queue里面的block。</p>

<p>例子：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="kt">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
<span class="lineno"> 2</span> <span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_HIGH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 3</span> 
<span class="lineno"> 4</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span> <span class="p">{</span>
<span class="lineno"> 5</span>     <span class="c1">// block1</span>
<span class="lineno"> 6</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block1</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno"> 7</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">2.0</span><span class="p">];</span>
<span class="lineno"> 8</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block1</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno"> 9</span> <span class="p">});</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">10</span> 
<span class="lineno">11</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span> <span class="p">{</span>
<span class="lineno">12</span>     <span class="c1">// block2</span>
<span class="lineno">13</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block2</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">14</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
<span class="lineno">15</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block2</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">16</span> <span class="p">});</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">17</span> 
<span class="lineno">18</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span> <span class="p">{</span>
<span class="lineno">19</span>     <span class="c1">// block3</span>
<span class="lineno">20</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block3</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">21</span> <span class="p">});</span></code></pre></div></p>

<p>输出：</p>

<p><div class="highlight"><pre><code class="language-text" data-lang="text"><span class="lineno">1</span> 2016-10-31 11:14:28.076 OCPlayground[82366:5830581] Block2 Start
<span class="lineno">2</span> 2016-10-31 11:14:28.076 OCPlayground[82366:5830578] Block1 Start
<span class="lineno">3</span> 2016-10-31 11:14:29.081 OCPlayground[82366:5830581] Block2 End
<span class="lineno">4</span> 2016-10-31 11:14:30.078 OCPlayground[82366:5830578] Block1 End
<span class="lineno">5</span> 2016-10-31 11:14:30.078 OCPlayground[82366:5830578] Block3</code></pre></div></p>

<h3>dispatch_barrier_async</h3>

<p><code>dispatch_barrier_async</code>函数的作用与barrier的意思相同，在线程任务管理中起到一个栅栏的作用，它等待所有位于barrier函数之前的操作执行完毕后执行，并且在barrier函数执行之后，barrier函数之后的操作才会得到执行，该函数需要同<code>dispatch_queue_create</code>函数生成的并行队列一起使用，不能同<code>dispatch_get_global_queue</code>返回的并行队列一起使用。</p>

<p>例子：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="c1">// dispatch_barrier_async can not be used together with dispatch_get_global_queue</span>
<span class="lineno"> 2</span> <span class="c1">// dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span>
<span class="lineno"> 3</span> <span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">com</span><span class="p">.</span><span class="n">company</span><span class="p">.</span><span class="n">app</span><span class="p">.</span><span class="n">queue</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 4</span> 
<span class="lineno"> 5</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
<span class="lineno"> 6</span>     <span class="c1">// block1</span>
<span class="lineno"> 7</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block1</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno"> 8</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">2.0</span><span class="p">];</span>
<span class="lineno"> 9</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block1</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">10</span> <span class="p">});</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">11</span> 
<span class="lineno">12</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
<span class="lineno">13</span>     <span class="c1">// block2</span>
<span class="lineno">14</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block2</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">15</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
<span class="lineno">16</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block2</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">17</span> <span class="p">});</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">18</span> 
<span class="lineno">19</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_barrier_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
<span class="lineno">20</span>     <span class="c1">// block3</span>
<span class="lineno">21</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block3</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">22</span> <span class="p">});</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">23</span> 
<span class="lineno">24</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
<span class="lineno">25</span>     <span class="c1">// block4</span>
<span class="lineno">26</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block4</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">27</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">3.0</span><span class="p">];</span>
<span class="lineno">28</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block4</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">29</span> <span class="p">});</span></code></pre></div></p>

<p>输出：</p>

<p><div class="highlight"><pre><code class="language-text" data-lang="text"><span class="lineno">1</span> 2016-10-31 12:02:08.468 OCPlayground[83918:5867777] Block1 Start
<span class="lineno">2</span> 2016-10-31 12:02:08.468 OCPlayground[83918:5867807] Block2 Start
<span class="lineno">3</span> 2016-10-31 12:02:09.474 OCPlayground[83918:5867807] Block2 End
<span class="lineno">4</span> 2016-10-31 12:02:10.469 OCPlayground[83918:5867777] Block1 End
<span class="lineno">5</span> 2016-10-31 12:02:10.469 OCPlayground[83918:5867777] Block3
<span class="lineno">6</span> 2016-10-31 12:02:10.470 OCPlayground[83918:5867777] Block4 Start
<span class="lineno">7</span> 2016-10-31 12:02:13.473 OCPlayground[83918:5867777] Block4 End</code></pre></div></p>

<h3>addDependency</h3>

<p>苹果对GCD进行了封装，有了自己的<code>NSOperationQueue</code>和<code>NSBlockOperation</code>。其中<code>NSBlockOperation</code>中添加了<code>addDepencency:</code>方法可以指定operation block之间的依赖关系。</p>

<p>例子：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="bp">NSOperation</span> <span class="o">*</span><span class="n">completionOperation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
<span class="lineno"> 4</span>     <span class="c1">// block3</span>
<span class="lineno"> 5</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block3</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno"> 6</span> <span class="p">}];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 7</span> 
<span class="lineno"> 8</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="bp">NSOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">operation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
<span class="lineno">11</span>     <span class="c1">// block1</span>
<span class="lineno">12</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block1</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">13</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">2.0</span><span class="p">];</span>
<span class="lineno">14</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block1</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">15</span> <span class="p">}];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">16</span> 
<span class="lineno">17</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">[</span><span class="n">completionOperation</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">operation</span><span class="p">];</span>
<span class="lineno">18</span> <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">operation</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">19</span> 
<span class="lineno">20</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">operation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
<span class="lineno">21</span>     <span class="c1">// block2</span>
<span class="lineno">22</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block2</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">23</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
<span class="lineno">24</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block2</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">25</span> <span class="p">}];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">26</span> 
<span class="lineno">27</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">[</span><span class="n">completionOperation</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">operation</span><span class="p">];</span>
<span class="lineno">28</span> <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">operation</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">29</span> 
<span class="lineno">30</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">completionOperation</span><span class="p">];</span></code></pre></div></p>

<p>输出：</p>

<p><div class="highlight"><pre><code class="language-text" data-lang="text"><span class="lineno">1</span> 2016-10-31 12:22:49.774 OCPlayground[84061:5887605] Block1 Start
<span class="lineno">2</span> 2016-10-31 12:22:49.774 OCPlayground[84061:5887572] Block2 Start
<span class="lineno">3</span> 2016-10-31 12:22:50.776 OCPlayground[84061:5887572] Block2 End
<span class="lineno">4</span> 2016-10-31 12:22:51.848 OCPlayground[84061:5887605] Block1 End
<span class="lineno">5</span> 2016-10-31 12:22:51.849 OCPlayground[84061:5887605] Block3</code></pre></div></p>

<h3>dispatch_semaphore</h3>

<p><a href="http://www.cnblogs.com/snailHL/p/3906112.html">关于dispatch_semaphore的使用</a>讲解的很详细。</p>

<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是<code>dispatch_semaphore_create</code>、<code>dispatch_semaphore_signal</code>和<code>dispatch_semaphore_wait</code>。</p>

<p>下面我们逐一介绍三个函数：</p>

<p>（1）<code>dispatch_semaphore_create</code>的声明为：<code>dispatch_semaphore_t  dispatch_semaphore_create(long value);</code>
返回一个<code>dispatch_semaphore_t</code>类型且值为<code>value</code>的信号量。这里的传入的参数<code>value</code>必须大于或等于0，否则<code>dispatch_semaphore_create</code>会返回<code>NULL</code>。</p>

<p>（2）<code>dispatch_semaphore_signal</code>的声明为：<code>long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</code>这个函数会使传入的信号量<code>dsema</code>的值加1。（至于返回值，参考<a href="http://www.cnblogs.com/snailHL/p/3906112.html">关于dispatch_semaphore的使用</a>。）</p>

<p> (3) <code>dispatch_semaphore_wait</code>的声明为：<code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)；</code>这个函数会使传入的信号量<code>dsema</code>的值减1。这个函数的作用是这样的：</p>

<ul>
<li>如果<code>dsema</code>信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；</li>
<li>如果<code>dsema</code>的值为0，那么这个函数就阻塞当前线程等待timeout，如果等待期间<code>dsema</code>的值被<code>dispatch_semaphore_signal</code>函数加1了，且该函数（即<code>dispatch_semaphore_wait</code>）所处线程获得了信号量，那么就继续向下执行并将信号量减1。</li>
<li>如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</li>
</ul>


<p>例子：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">my</span><span class="p">.</span><span class="n">conQ</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="n">DISPATCH_QUEUE_CONCURRENT</span><span class="p">);</span>
<span class="lineno"> 2</span> <span class="kt">dispatch_semaphore_t</span> <span class="n">mySem</span> <span class="o">=</span> <span class="n">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 3</span> 
<span class="lineno"> 4</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
<span class="lineno"> 5</span>     <span class="c1">// block1</span>
<span class="lineno"> 6</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block1</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno"> 7</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">2.0</span><span class="p">];</span>
<span class="lineno"> 8</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block1</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno"> 9</span>     <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">mySem</span><span class="p">);</span>
<span class="lineno">10</span> <span class="p">});</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">11</span> 
<span class="lineno">12</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
<span class="lineno">13</span>     <span class="c1">// block2</span>
<span class="lineno">14</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block2</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">15</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
<span class="lineno">16</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block2</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">17</span>     <span class="n">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">mySem</span><span class="p">);</span>
<span class="lineno">18</span> <span class="p">});</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">19</span> 
<span class="lineno">20</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
<span class="lineno">21</span>     <span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">mySem</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span>
<span class="lineno">22</span>     <span class="n">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">mySem</span><span class="p">,</span> <span class="n">DISPATCH_TIME_FOREVER</span><span class="p">);</span>
<span class="lineno">23</span>     <span class="c1">// block3</span>
<span class="lineno">24</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block3</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">25</span> <span class="p">});</span></code></pre></div></p>

<p>输出：</p>

<p><div class="highlight"><pre><code class="language-text" data-lang="text"><span class="lineno">1</span> 2016-10-31 22:16:34.402 OCPlayground[85158:6133417] Block1 Start
<span class="lineno">2</span> 2016-10-31 22:16:34.402 OCPlayground[85158:6133423] Block2 Start
<span class="lineno">3</span> 2016-10-31 22:16:35.405 OCPlayground[85158:6133423] Block2 End
<span class="lineno">4</span> 2016-10-31 22:16:36.403 OCPlayground[85158:6133417] Block1 End
<span class="lineno">5</span> 2016-10-31 22:16:36.404 OCPlayground[85158:6133426] Block3</code></pre></div></p>

<h3>dispatch_group_enter和dispatch_group_leave</h3>

<p>当我们碰到block里面有嵌套的block的时候，简单地使用<code>dispatch_group_notify</code>就不能解决问题了：<code>dispatch_group_notify</code>不会等到嵌套的block执行完再执行。对于这种情况，如果还坚持用<code>dispatch_group_notify</code>，可以有两种解决方案：</p>

<p><strong>方案1：</strong></p>

<p>对于嵌套的block，仍然使用<code>dispatch_group_async</code>将block放入对应的group。比如下面的例子，对于Block1里面的Block4，我们仍然使用<code>dispatch_group_async</code>将Block4放入对应的group，即可以保证Block3在Block4之后执行。也就是说，只要是在<code>dispatch_group_notify</code>对应的Block3执行之前加入group的block，都需要执行，然后才能执行<code>dispatch_group_notify</code>对应的Block3，即，当<code>dispatch_group_notify</code>对应的Block3执行的时候，group中不能有任何没有执行的其它block存在。</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
<span class="lineno">2</span>     <span class="c1">// block4 inside block 1</span>
<span class="lineno">3</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block4</span> <span class="n">inside</span> <span class="n">Block1</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">4</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
<span class="lineno">5</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block4</span> <span class="n">inside</span> <span class="n">Block1</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">6</span> <span class="p">});</span></code></pre></div></p>

<p>如果嵌套的block对应的是服务器请求的callback（比如<code>onSuccess:</code>和<code>onFailure:</code>），就不方便将其加入对应的group中。这时候就需要使用方案2。</p>

<p><strong>方案2：</strong>
通过<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>手动管理group关联的block的运行状态（或计数）。但是需要注意：进入和退出group次数必须匹配，不仅是code书写方面一致，code执行也要保证一致，否则<code>dispatch_group_notify</code>对应的Block3就不会执行到。</p>

<p>例子：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="kt">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
<span class="lineno"> 2</span> <span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_HIGH</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 3</span> 
<span class="lineno"> 4</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span> <span class="p">{</span>
<span class="lineno"> 5</span>     <span class="c1">// block1</span>
<span class="lineno"> 6</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block1</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno"> 7</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">2.0</span><span class="p">];</span>
<span class="lineno"> 8</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block1</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">dispatch_group_enter</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
<span class="lineno">11</span> <span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
<span class="lineno">12</span>     <span class="c1">// block4 inside block 1</span>
<span class="lineno">13</span>     <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Block4 inside Block1 Start&quot;</span><span class="p">);</span>
<span class="lineno">14</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
<span class="lineno">15</span>     <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Block4 inside Block1 End&quot;</span><span class="p">);</span>
<span class="lineno">16</span>     <span class="n">dispatch_group_leave</span><span class="p">(</span><span class="n">group</span><span class="p">);</span>
<span class="lineno">17</span> <span class="p">});</span>
<span class="lineno">18</span> <span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
<span class="lineno">19</span> 
<span class="lineno">20</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">});</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">21</span> 
<span class="lineno">22</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span> <span class="p">{</span>
<span class="lineno">23</span>     <span class="c1">// block2</span>
<span class="lineno">24</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block2</span> <span class="n">Start</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">25</span>     <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
<span class="lineno">26</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block2</span> <span class="n">End</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">27</span> <span class="p">});</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">28</span> 
<span class="lineno">29</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="o">^</span> <span class="p">{</span>
<span class="lineno">30</span>     <span class="c1">// block3</span>
<span class="lineno">31</span>     <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Block3</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
<span class="lineno">32</span> <span class="p">});</span></code></pre></div></p>

<p>输出：</p>

<p><div class="highlight"><pre><code class="language-text" data-lang="text"><span class="lineno">1</span> 2016-10-31 13:51:23.512 OCPlayground[84646:5947063] Block2 Start
<span class="lineno">2</span> 2016-10-31 13:51:23.512 OCPlayground[84646:5947080] Block1 Start
<span class="lineno">3</span> 2016-10-31 13:51:24.518 OCPlayground[84646:5947063] Block2 End
<span class="lineno">4</span> 2016-10-31 13:51:25.518 OCPlayground[84646:5947080] Block1 End
<span class="lineno">5</span> 2016-10-31 13:51:25.518 OCPlayground[84646:5947080] Block4 inside Block1 Start
<span class="lineno">6</span> 2016-10-31 13:51:26.521 OCPlayground[84646:5947080] Block4 inside Block1 End
<span class="lineno">7</span> 2016-10-31 13:51:26.522 OCPlayground[84646:5947063] Block3</code></pre></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在UITableViewCell中异步加载图片]]></title>
    <link href="http://hongchaozhang.github.io/blog/2016/08/02/asynchronously-load-online-images-into-uitableviewcells/"/>
    <updated>2016-08-02T16:13:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2016/08/02/asynchronously-load-online-images-into-uitableviewcells</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>当我们在<code>UITableViewCell</code>中进行比较费时的工作（比如绘图，或者加载网络图片）的时候，通常会出现下面的问题：</p>

<!-- more -->


<ol>
<li>当<code>UITableViewCell</code>移出视图的时候，这个<code>UITableViewCell</code>对应的异步操作仍然在执行。这通常会造成系统资源浪费，还可能由于这个异步操作不知道返回到哪个<code>UITableViewCell</code>而导致<code>UITableView</code>一些诡异的行为。</li>
<li><code>UITableViewCell</code>通常是重复利用的实例，这就会导致当前<code>UITableViewCell</code>可能会加载之前出现在视图中但是现在不在视图中的<code>UITableViewCell</code>的内容，在你面前变换一下<code>UITableViewCell</code>里面的内容，这是我们都不想看到的。</li>
</ol>


<h2>解决</h2>

<p>2012年的WWDC中的<em>Session 211</em> <a href="https://developer.apple.com/videos/play/wwdc2012/211/">Building Concurrent User Interfaces on iOS</a>很好地讲解了如何在一个<code>UITableViewCell</code>里面做比较费时的事情（比如绘图，或者网络请求图片），而保持app流畅，我下面的代码和<a href="https://stavash.wordpress.com/2012/12/14/advanced-issues-asynchronous-uitableviewcell-content-loading-done-right/">Advanced issues: Asynchronous UITableViewCell content loading done right</a>这一篇文章都是根据这个session实现的。</p>

<p>解决上述两个问题的基本想法：当<code>tableView:cellForRowAtIndexPath:</code>被调用的时候，去网络请求<code>UITableViewCell</code>对应的图片。当请求成功时，判断当前的<code>UITableViewCell</code>是否仍然在视图中：如果在，将请求的图片设置到<code>UITableViewCell</code>中，否则，不设置。另外，当<code>UITableViewCell</code>移出视图的时候，要取消其对应的请求，防止对后续请求造成影响。</p>

<p><a href="https://developer.apple.com/library/ios/samplecode/LazyTableImages/Introduction/Intro.html">LazyTableImages: Populating UITableView content asynchronously</a>这个实现相对简单一点：这个实现通过<code>UIScrollViewDelegate</code>中的方法，保证在用户滚动<code>UITableView</code>和<code>UITableView</code>停止之前都停止<code>UITableViewCell</code>里面的更新，只有当<code>UITableView</code>静止的时候，才去更新当前视图中的所有<code>UITableViewCell</code>。而上面的实现则能保证在用户进行滚动的同时，请求并加载图片到正确的位置。</p>

<p>主要代码：</p>

<p><div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nl">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="bp">UITableViewDelegate</span><span class="p">,</span> <span class="bp">UITableViewDataSource</span><span class="p">,</span> <span class="bp">UIScrollViewDelegate</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">var</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">String</span><span class="p">]()</span>
<span class="lineno"> 4</span> <span class="k">var</span> <span class="n">rowIndexToOperationDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="nl">String</span><span class="p">:</span><span class="bp">NSBlockOperation</span><span class="p">]()</span>
<span class="lineno"> 5</span> <span class="k">let</span> <span class="nl">downloadImageOperationQueue</span><span class="p">:</span> <span class="bp">NSOperationQueue</span> <span class="o">=</span> <span class="p">{</span>
<span class="lineno"> 6</span>     <span class="k">var</span> <span class="n">queue</span> <span class="o">=</span> <span class="bp">NSOperationQueue</span><span class="p">()</span>
<span class="lineno"> 7</span>     <span class="n">queue</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;download image queue&quot;</span>
<span class="lineno"> 8</span>     <span class="n">queue</span><span class="p">.</span><span class="n">maxConcurrentOperationCount</span> <span class="o">=</span> <span class="mi">4</span>
<span class="lineno"> 9</span>     <span class="k">return</span> <span class="n">queue</span>
<span class="lineno">10</span> <span class="p">}()</span>
<span class="lineno">11</span> 
<span class="lineno">12</span> <span class="kr">override</span> <span class="k">func</span> <span class="n">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">13</span>     <span class="nb">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
<span class="lineno">14</span>     <span class="c1">// Do any additional setup after loading the view, typically from a nib.</span>
<span class="lineno">15</span> 
<span class="lineno">16</span>     <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="mi">100</span> <span class="p">{</span>
<span class="lineno">17</span>         <span class="n">data</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;\(i)&quot;</span><span class="p">)</span>
<span class="lineno">18</span>     <span class="p">}</span>
<span class="lineno">19</span>     <span class="k">let</span> <span class="n">tableView</span> <span class="o">=</span> <span class="bp">UITableView</span><span class="p">(</span><span class="nl">frame</span><span class="p">:</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">)</span>
<span class="lineno">20</span>     <span class="n">tableView</span><span class="p">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="nb">self</span>
<span class="lineno">21</span>     <span class="n">tableView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span>
<span class="lineno">22</span>     <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">tableView</span><span class="p">)</span>
<span class="lineno">23</span> <span class="p">}</span>
<span class="lineno">24</span> 
<span class="lineno">25</span> <span class="c1">// when table view disappears, cancel all operations</span>
<span class="lineno">26</span> <span class="kr">override</span> <span class="k">func</span> <span class="n">viewDidDisappear</span><span class="p">(</span><span class="nl">animated</span><span class="p">:</span> <span class="n">Bool</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">27</span>     <span class="n">downloadImageOperationQueue</span><span class="p">.</span><span class="n">cancelAllOperations</span><span class="p">()</span>
<span class="lineno">28</span> <span class="p">}</span>
<span class="lineno">29</span> 
<span class="lineno">30</span> <span class="k">func</span> <span class="n">tableView</span><span class="p">(</span><span class="nl">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">heightForRowAtIndexPath</span> <span class="nl">indexPath</span><span class="p">:</span> <span class="bp">NSIndexPath</span><span class="p">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">CGFloat</span> <span class="p">{</span>
<span class="lineno">31</span>     <span class="k">return</span> <span class="mi">100</span>
<span class="lineno">32</span> <span class="p">}</span>
<span class="lineno">33</span> 
<span class="lineno">34</span> <span class="k">func</span> <span class="n">tableView</span><span class="p">(</span><span class="nl">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nl">section</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">Int</span> <span class="p">{</span>
<span class="lineno">35</span>     <span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">count</span>
<span class="lineno">36</span> <span class="p">}</span>
<span class="lineno">37</span> 
<span class="lineno">38</span> <span class="k">func</span> <span class="n">tableView</span><span class="p">(</span><span class="nl">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">cellForRowAtIndexPath</span> <span class="nl">indexPath</span><span class="p">:</span> <span class="bp">NSIndexPath</span><span class="p">)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="bp">UITableViewCell</span> <span class="p">{</span>
<span class="lineno">39</span>     <span class="k">var</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="p">.</span><span class="n">dequeueReusableCellWithIdentifier</span><span class="p">(</span><span class="s">&quot;cell&quot;</span><span class="p">)</span>
<span class="lineno">40</span>     <span class="k">if</span> <span class="n">cell</span> <span class="o">==</span> <span class="nb">nil</span> <span class="p">{</span>
<span class="lineno">41</span>         <span class="n">cell</span> <span class="o">=</span> <span class="bp">UITableViewCell</span><span class="p">(</span><span class="nl">style</span><span class="p">:</span> <span class="p">.</span><span class="n">Default</span><span class="p">,</span> <span class="nl">reuseIdentifier</span><span class="p">:</span> <span class="s">&quot;cell&quot;</span><span class="p">)</span>
<span class="lineno">42</span>     <span class="p">}</span>
<span class="lineno">43</span> 
<span class="lineno">44</span>     <span class="n">cell</span><span class="o">!</span><span class="p">.</span><span class="n">textLabel</span><span class="o">!</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>
<span class="lineno">45</span> 
<span class="lineno">46</span>     <span class="k">let</span> <span class="n">loadImageInfoCellOperation</span> <span class="o">=</span> <span class="bp">NSBlockOperation</span><span class="p">()</span>
<span class="lineno">47</span>     <span class="k">weak</span> <span class="k">var</span> <span class="n">weakLoadImageInfoCellOperation</span> <span class="o">=</span> <span class="n">loadImageInfoCellOperation</span>
<span class="lineno">48</span>     <span class="k">func</span> <span class="n">loadImageOperationBlock</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">49</span>         <span class="k">let</span> <span class="n">imageData</span> <span class="o">=</span> <span class="bp">NSData</span><span class="p">(</span><span class="nl">contentsOfURL</span><span class="p">:</span> <span class="bp">NSURL</span><span class="p">(</span><span class="nl">string</span><span class="p">:</span> <span class="s">&quot;http://dummyimage.com/100x100/222/fff.png&amp;amp;text=&quot;</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">])</span><span class="o">!</span><span class="p">)</span>
<span class="lineno">50</span>         <span class="k">var</span> <span class="nl">imageIcon</span><span class="p">:</span><span class="bp">UIImage</span><span class="o">?</span>
<span class="lineno">51</span>         <span class="k">if</span> <span class="k">let</span> <span class="n">imageData</span> <span class="o">=</span> <span class="n">imageData</span> <span class="p">{</span>
<span class="lineno">52</span>             <span class="n">imageIcon</span> <span class="o">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="nl">data</span><span class="p">:</span> <span class="n">imageData</span><span class="p">)</span>
<span class="lineno">53</span>         <span class="p">}</span>
<span class="lineno">54</span> 
<span class="lineno">55</span>         <span class="k">func</span> <span class="n">updateImageOperationBlock</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">56</span>             <span class="k">if</span> <span class="k">let</span> <span class="n">operation</span> <span class="o">=</span> <span class="n">weakLoadImageInfoCellOperation</span> <span class="p">{</span>
<span class="lineno">57</span>                 <span class="k">if</span> <span class="n">operation</span><span class="p">.</span><span class="n">cancelled</span> <span class="p">{</span>
<span class="lineno">58</span>                     <span class="n">rowIndexToOperationDictionary</span><span class="p">.</span><span class="n">removeValueForKey</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">])</span>
<span class="lineno">59</span>                 <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno">60</span>                     <span class="k">let</span> <span class="n">theCell</span> <span class="o">=</span> <span class="n">tableView</span><span class="p">.</span><span class="n">cellForRowAtIndexPath</span><span class="p">(</span><span class="n">indexPath</span><span class="p">)</span>
<span class="lineno">61</span>                     <span class="n">theCell</span><span class="o">?</span><span class="p">.</span><span class="n">imageView</span><span class="o">!</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">imageIcon</span>
<span class="lineno">62</span>                     <span class="n">theCell</span><span class="o">?</span><span class="p">.</span><span class="n">setNeedsLayout</span><span class="p">()</span>
<span class="lineno">63</span>                     <span class="n">rowIndexToOperationDictionary</span><span class="p">.</span><span class="n">removeValueForKey</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">])</span>
<span class="lineno">64</span>                 <span class="p">}</span>
<span class="lineno">65</span>             <span class="p">}</span>
<span class="lineno">66</span>         <span class="p">}</span>
<span class="lineno">67</span>         <span class="bp">NSOperationQueue</span><span class="p">.</span><span class="n">mainQueue</span><span class="p">().</span><span class="n">addOperationWithBlock</span><span class="p">(</span><span class="n">updateImageOperationBlock</span><span class="p">)</span>
<span class="lineno">68</span>     <span class="p">}</span>
<span class="lineno">69</span>     <span class="n">loadImageInfoCellOperation</span><span class="p">.</span><span class="n">addExecutionBlock</span><span class="p">(</span><span class="n">loadImageOperationBlock</span><span class="p">)</span>
<span class="lineno">70</span> 
<span class="lineno">71</span>     <span class="n">rowIndexToOperationDictionary</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loadImageInfoCellOperation</span>
<span class="lineno">72</span>     <span class="n">downloadImageOperationQueue</span><span class="p">.</span><span class="n">addOperation</span><span class="p">(</span><span class="n">loadImageInfoCellOperation</span><span class="p">)</span>
<span class="lineno">73</span>     <span class="n">cell</span><span class="o">?</span><span class="p">.</span><span class="n">imageView</span><span class="o">!</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="nb">nil</span>
<span class="lineno">74</span> 
<span class="lineno">75</span>     <span class="k">return</span> <span class="n">cell</span><span class="o">!</span>
<span class="lineno">76</span> <span class="p">}</span>
<span class="lineno">77</span> 
<span class="lineno">78</span> <span class="c1">// when cell is out of scene, cancel the operation</span>
<span class="lineno">79</span> <span class="k">func</span> <span class="n">tableView</span><span class="p">(</span><span class="nl">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">didEndDisplayingCell</span> <span class="nl">cell</span><span class="p">:</span> <span class="bp">UITableViewCell</span><span class="p">,</span> <span class="n">forRowAtIndexPath</span> <span class="nl">indexPath</span><span class="p">:</span> <span class="bp">NSIndexPath</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">80</span>     <span class="k">let</span> <span class="nl">loadImageInfoCellOperation</span><span class="p">:</span><span class="bp">NSBlockOperation</span><span class="o">?</span> <span class="o">=</span> <span class="n">rowIndexToOperationDictionary</span><span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]]</span>
<span class="lineno">81</span>     <span class="k">if</span> <span class="k">let</span> <span class="n">op</span> <span class="o">=</span> <span class="n">loadImageInfoCellOperation</span> <span class="p">{</span>
<span class="lineno">82</span>         <span class="n">op</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span>
<span class="lineno">83</span>         <span class="n">rowIndexToOperationDictionary</span><span class="p">.</span><span class="n">removeValueForKey</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">])</span>
<span class="lineno">84</span>     <span class="p">}</span>
<span class="lineno">85</span> 
<span class="lineno">86</span> <span class="p">}</span>
<span class="lineno">87</span> <span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
<span class="lineno">88</span> 
<span class="lineno">89</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">90</span> 
<span class="lineno">91</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<h3>其它问题</h3>

<ol>
<li><p>修改应用安全权限，确保能下载http资源。参考：<a href="http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9">How do I load an HTTP URL with App Transport Security enabled in iOS 9?</a></p></li>
<li><p>当设置的<code>UITableViewCell</code>中的图片的时候，需要调用一下<code>[cell setNeedsLayout]</code>确保其显示出来。否则，只有当你点击的时候图片才会更新出来。参考
<a href="http://stackoverflow.com/questions/9352638/cell-imageview-in-uitableview-doesnt-appear-until-selected">cell imageView in UITableView doesn&rsquo;t appear until selected</a>。</p></li>
</ol>


<h3>资源</h3>

<p>这是一个神奇的网站！可以在线定制图片颜色和内容，然后生成对应的url。参考：<a href="http://dummyimage.com/">Dynamic Dummy Image Generator</a>。所以才会有下面的效果，方便检查每个cell的图片是否正确：</p>

<p><img src="/images/async_load_online_images_into_uitableviewcells.png" alt="async_load_online_images_into_uitableviewcells.png" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C中Property和Method的可见性]]></title>
    <link href="http://hongchaozhang.github.io/blog/2016/06/16/property-and-method-visuability-of-category-and-inheritence-in-objective-c/"/>
    <updated>2016-06-16T21:48:54+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2016/06/16/property-and-method-visuability-of-category-and-inheritence-in-objective-c</id>
    <content type="html"><![CDATA[<h2>说明</h2>

<p>本来只想思考一下<em>Objective-C里Category和Inheritence中的Property和Method的可见性</em>，搜着搜着，主题有些变化，所以题目也改了。</p>

<p>这里只是一些来自参考博客的结论和自己测试得到的结论。</p>

<!-- more -->


<p>具体参考博客如下：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/4869935/objective-c-private-vs-protected-vs-public">Objective-C - Private vs Protected vs Public</a></li>
<li><a href="http://stackoverflow.com/questions/12633627/expose-a-private-objective-c-method-or-property-to-subclasses">实现public、private和protected属性和方法</a></li>
<li><a href="http://stackoverflow.com/questions/3725857/protected-methods-in-objective-c">Protected methods in Objective-C</a></li>
<li><a href="http://bootstragram.com/blog/simulating-protected-modifier-with-objective-c/">Simulating protected properties and selectors in Objective-C</a></li>
</ul>


<p>自己的测试代码为：OCPlayground。</p>

<h2>结论</h2>

<h3>来自参考博客的结论</h3>

<ol>
<li>点操作(.)只和property有关和iVar没有关系。</li>
<li><code>-&gt;</code>操作只和iVar有关，和property无关。</li>
<li>ivar中的关键字<code>public</code>、<code>private</code>和<code>protected</code>只对ivar有效，表明的是ivar的可见性，默认<code>protected</code>。子类中想用继承来的ivar，需要使用->操作符，不能使用dot操作符（dot操作符只用于property）。实例中想用ivar，只能用具有<code>public</code>属性的ivar。</li>
</ol>


<h3>来自代码测试的结论</h3>

<h4>结论1</h4>

<p>We can use <code>@property</code> in Extension the same way as <em>.h</em> file of the class. Compiler can generate the setter and getter methods for us. But in Category, compiler will not generate the setter and getter methods for us, you need to implement them manually or by using <code>@dynamic</code> to tell the compiler that the setter and getter methods are implemented somewhere else.</p>

<p>The difference comes from the fact that instance variables can be added into Extension but not Category.</p>

<h4>结论2</h4>

<p>to define whether a category can use the extended class&rsquo;s property or method, just define whether the property or method is in one &ldquo;interface&rdquo; that the category can &ldquo;see&rdquo;.</p>

<h4>结论3</h4>

<p>visibility(<code>private</code>, <code>public</code>, <code>protected</code>) does not affect methods. methods are as good as public when visible to clients (and potential pitfalls/bugs when invisible to clients). instead, visibility affects instance variables.</p>

<h4>结论4</h4>

<p>The same priciple as Category: to define whether I can use a property or method (in super class), just define whether the property or method is in an &ldquo;@interface&rdquo; the context (where you are trying to use the property or method) can &ldquo;see&rdquo;.</p>

<p>One exception: <code>performSelector:</code> can run method that are not ready in compile time but ready in runtime. However there will be one warning from the compiler. You can dismiss the warning by declaring a method with the same name in the class in which you are coding, but will introduce another warning saying that &ldquo;Method definition for *** is not found&rdquo;.</p>

<h3>Protected method</h3>

<p>来自<a href="http://stackoverflow.com/questions/3725857/protected-methods-in-objective-c">Protected methods in Objective-C</a>的protected method的实现：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="c1">/////// SuperClass.h</span>
<span class="lineno"> 2</span> <span class="k">@interface</span> <span class="nc">SuperClass</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 3</span> 
<span class="lineno"> 4</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">@end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 5</span> 
<span class="lineno"> 6</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">/////// SuperClass.m</span>
<span class="lineno"> 7</span> <span class="k">@implementation</span> <span class="nc">SuperClass</span>
<span class="lineno"> 8</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">protectedMethod</span>
<span class="lineno"> 9</span> <span class="p">{}</span>
<span class="lineno">10</span> <span class="k">@end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">11</span> 
<span class="lineno">12</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">/////// SubClass.h</span>
<span class="lineno">13</span> <span class="k">@interface</span> <span class="nc">SubClass</span> : <span class="nc">SuperClass</span>
<span class="lineno">14</span> <span class="k">@end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">15</span> 
<span class="lineno">16</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">/////// SubClass.m</span>
<span class="lineno">17</span> <span class="k">@interface</span> <span class="nc">SubClass</span> <span class="nl">(Protected)</span>
<span class="lineno">18</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">protectedMethod</span> <span class="p">;</span>
<span class="lineno">19</span> <span class="k">@end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">20</span> 
<span class="lineno">21</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">@implementation</span> <span class="nc">SubClass</span>
<span class="lineno">22</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">callerOfProtectedMethod</span>
<span class="lineno">23</span> <span class="p">{</span>
<span class="lineno">24</span>   <span class="p">[</span><span class="nb">self</span> <span class="n">protectedMethod</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// this will not generate warning</span>
<span class="lineno">25</span> <span class="p">}</span>
<span class="lineno">26</span> <span class="k">@end</span></code></pre></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios MultiplePagesViewController Usage]]></title>
    <link href="http://hongchaozhang.github.io/blog/2016/03/27/ios-multiple-page-view-controller-usage/"/>
    <updated>2016-03-27T16:58:54+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2016/03/27/ios-multiple-page-view-controller-usage</id>
    <content type="html"><![CDATA[<p>先上截图：</p>

<p><img src="/images/multiple_pages_view_controller_demo.gif" alt="multiple_pages_view_controller_demo.gif" /></p>

<p>demo地址：<a href="https://github.com/hongchaozhang/MultiplePagesViewControllerDemo.git">MultiplePagesViewControllerDemo</a></p>

<!-- more -->


<h3>demo解释</h3>

<p>首先，创建<code>MultiplePagesViewController</code>的实例，并将其和其view加入到需要的view controller 中：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">2</span> 
<span class="lineno">3</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">multiplePagesViewController</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
<span class="lineno">4</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">addChildViewController</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">multiplePagesViewController</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">5</span> 
<span class="lineno">6</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>其中，<code>self.multiplePagesViewController</code>对应的getter函数如下：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="lineno"> 4</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MultiplePagesViewController</span><span class="o">*</span><span class="p">)</span><span class="n">multiplePagesViewController</span> <span class="p">{</span>
<span class="lineno"> 5</span>   <span class="k">if</span> <span class="p">(</span><span class="o">!&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">multiplePagesViewController</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 6</span>       <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">multiplePagesViewController</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MultiplePagesViewController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="lineno"> 7</span>       <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">multiplePagesViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
<span class="lineno"> 8</span>       <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">multiplePagesViewController</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
<span class="lineno"> 9</span>   <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">10</span> 
<span class="lineno">11</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="k">return</span> <span class="n">_multiplePagesViewController</span><span class="p">;</span>
<span class="lineno">12</span> <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
<span class="lineno">13</span> <span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="lineno">14</span> 
<span class="lineno">15</span> 
<span class="lineno">16</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>并且，在<code>viewDidLayoutSubviews</code>中重新调整view的大小，以解决转屏等问题：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="lineno"> 4</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLayoutSubviews</span> <span class="p">{</span>
<span class="lineno"> 5</span>   <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLayoutSubviews</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="nb">self</span><span class="p">.</span><span class="n">multiplePagesViewController</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">;</span>
<span class="lineno"> 8</span> <span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
<span class="lineno"> 9</span> <span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="lineno">10</span> 
<span class="lineno">11</span> 
<span class="lineno">12</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>然后，只需要将你的UIViewController的实例加入<code>self.multiplePagesViewController</code>就可以了：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="lineno"> 4</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">addDefaultPageViewControllers</span> <span class="p">{</span>
<span class="lineno"> 5</span>   <span class="bp">NSInteger</span> <span class="n">vcCount</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="lineno"> 6</span>   <span class="k">for</span> <span class="p">(</span><span class="bp">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">vcCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 7</span>       <span class="n">SampleViewController</span> <span class="o">*</span><span class="n">svc</span> <span class="o">=</span> <span class="p">[[</span><span class="n">SampleViewController</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithText</span><span class="p">:[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="o">%</span><span class="n">ld</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="n">i</span><span class="p">]];</span>
<span class="lineno"> 8</span>       <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">multiplePagesViewController</span> <span class="nl">addViewController</span><span class="p">:</span><span class="n">svc</span><span class="p">];</span>
<span class="lineno"> 9</span>   <span class="p">}</span>
<span class="lineno">10</span> <span class="p">}</span><span class="o">&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
<span class="lineno">11</span> <span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="lineno">12</span> 
<span class="lineno">13</span> 
<span class="lineno">14</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p><code>MultiplePagesViewController</code>主要的两个接口如下：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;/&lt;</span><span class="n">em</span><span class="o">&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span>
<span class="lineno"> 4</span>  <span class="o">*</span>  <span class="n">add</span> <span class="n">a</span> <span class="n">new</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="bp">UIViewController</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;&gt;</span> <span class="n">instance</span>
<span class="lineno"> 5</span>  <span class="o">*</span>
<span class="lineno"> 6</span>  <span class="o">*</span>  <span class="p">@</span><span class="n">param</span> <span class="n">viewController</span>
<span class="lineno"> 7</span>  <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
<span class="lineno"> 8</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">addViewController</span><span class="p">:(</span><span class="bp">UIViewController</span><span class="o">*</span><span class="p">)</span><span class="n">viewController</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;/&lt;</span><span class="n">em</span><span class="o">&gt;*</span>
<span class="lineno">11</span>  <span class="o">*</span>  <span class="n">remove</span> <span class="n">an</span> <span class="n">existing</span> <span class="n">view</span> <span class="n">controller</span> <span class="n">by</span> <span class="n">index</span>
<span class="lineno">12</span>  <span class="o">*</span>
<span class="lineno">13</span>  <span class="o">*</span>  <span class="p">@</span><span class="n">param</span> <span class="n">viewControllerIndex</span>
<span class="lineno">14</span>  <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
<span class="lineno">15</span> <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">removeViewController</span><span class="p">:(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="n">viewControllerIndex</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">16</span> 
<span class="lineno">17</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>

<p>另外，可以在<code>MultiplePagesViewController</code>的父view controller中实现下面接口，当切换page的时候做些其它事情，比如更新view controller的title信息等。</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">@protocol</span> <span class="nc">MultiplePagesViewControllerDelegate</span> <span class="o">&lt;</span><span class="bp">NSObject</span><span class="o">&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno"> 4</span> 
<span class="lineno"> 5</span> <span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="lineno"> 6</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">pageChangedTo</span><span class="p">:(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="n">pageIndex</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
<span class="lineno"> 7</span> <span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="lineno"> 8</span> 
<span class="lineno"> 9</span> 
<span class="lineno">10</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">@end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
<span class="lineno">11</span> 
<span class="lineno">12</span> <span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span></code></pre></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ios内存管理——调试]]></title>
    <link href="http://hongchaozhang.github.io/blog/2016/02/24/ios-memory-managemement-debugging/"/>
    <updated>2016-02-24T20:51:01+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2016/02/24/ios-memory-managemement-debugging</id>
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/ios/20160222/15333.html">iOS/OS X 内存管理(二)：借助工具解决内存问题</a>讲了一些调试技巧，包括：</p>

<!-- more -->


<ul>
<li>启用Zombie Object进行悬挂指针的检测。</li>
<li>应用<em>Product -> Analysis</em>进行内存泄露的初步检测。</li>
<li>应用Leak Instrument进行内存泄露查找。</li>
<li>在以上方法不奏效的情况下，通过查看<code>dealloc</code>是否调用查看某个class是否泄露的问题。</li>
</ul>


<p>补充一下：在<em>Leak</em>页面可以打开<em>Cycles &amp; Roots</em>用图的方式查看ratain cycle的问题，截图如下：</p>

<p><img src="/images/xcode_leak_instrument_cycles_and_roots_view.png" alt="xcode_leak_instrument_cycles_and_roots_view" /></p>

<p>上文没有介绍的，也是比较麻烦的，就是leak instrument没法查出的内存泄露。最近在调试一个这样的问题，写点心得。</p>

<h3>行动前的准备</h3>

<h4>认识工具</h4>

<p>参看<a href="https://developer.apple.com/library/ios/documentation/AnalysisTools/Reference/Instruments_User_Reference/LeaksInstrument/LeaksInstrument.html">Leaks Instrument</a>和<a href="https://developer.apple.com/library/ios/documentation/AnalysisTools/Reference/Instruments_User_Reference/AllocationsInstrument/AllocationsInstrument.html#//apple_ref/doc/uid/TP40011355-CH40-SW1">Allocation Instrument</a>的官方文档。</p>

<p>补充：</p>

<ul>
<li>Leak Instrument有<em>Cycles &amp; Roots</em>界面，见上。</li>
<li>Persistent Bytes和#Persistent。#Persistent是object的数量，也就是allocation的次数，而Persistent Bytes是具体的内存大小。<strong>#Persistent是我们需要关注的，内存有没有泄露也是看这个值是不是只增不减。</strong></li>
<li>Allocation Instrument进行profile的时候，为<em>Launch Configuration for Heap Allocations</em>勾选<em>Record reference counts</em>。</li>
</ul>


<h4>编译参数设置</h4>

<p>为了保证看到代码，而不是一堆无意义的内存地址，参考<a href="http://hongchaozhang.github.io/blog/2015/08/17/the-dSYM-file-in-ios-project/">The .dSYM File in Ios Project</a>进行xcode的设置。</p>

<h3>如果<code>dealloc</code>没有被调用</h3>

<p>通过Allocation Instrument，我们可以得到内存使用情况。为了清楚地看出是哪部分最可能是内存泄露，可以使用<em>Call Trees</em>视图，然后在右边：</p>

<ul>
<li>勾选<em>Hide System Libraries</em>，排除系统影响。</li>
<li>勾选<em>Invert Call Tree</em>，使占用内存最多的分支在最前面。</li>
</ul>


<p>通过以上方法，可以大概确定是哪部分内存泄露。然后看看该class是不是被<code>dealloc</code>了。</p>

<ul>
<li>如果<code>dealloc</code>了，那不是本文要解决的问题。</li>
<li>如果<code>dealloc</code>没有调用到，继续往下看。</li>
</ul>


<h4>Retain Cycle导致<code>dealloc</code>没有被调用</h4>

<p>在ARC下，<code>dealloc</code>不能被调用，一般是因为存在Retain Cycle，而导致Retain Cycle的情况可能是下面几种可能(参考<a href="http://kkoval.blogspot.com/2014/03/ios-retain-cycle-in-arc.html">iOS Retain Cycle in ARC</a>和<a href="http://stackoverflow.com/questions/9219030/dealloc-not-being-called-on-arc-app">Dealloc not being called on ARC app</a>):</p>

<h5>1. Blocks</h5>

<p>并不是所有在block中引用<code>self</code>都会带来retain cycle，比如下面的代码就不会有内存泄露：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testSelfInCocoaBlocks</span>
<span class="lineno">2</span> <span class="p">{</span>
<span class="lineno">3</span>     <span class="bp">NSArray</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">cats</span> <span class="o">=</span> <span class="l">@[</span><span class="p">@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Smily</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="p">@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Garfild</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="p">@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Other</span> <span class="n">cat</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span>
<span class="lineno">4</span>     <span class="p">[</span><span class="n">cats</span> <span class="nl">enumerateObjectsUsingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">cat</span><span class="p">,</span> <span class="bp">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">5</span>         <span class="p">[</span><span class="nb">self</span> <span class="nl">doSomethingWithCat</span><span class="p">:</span><span class="n">cat</span><span class="p">];</span>
<span class="lineno">6</span>     <span class="p">}];</span>
<span class="lineno">7</span> <span class="p">}</span></code></pre></div></p>

<p>因为在上面的代码中，block ratain了self，但是self中没有retain这个block。只有当block中引用了self，并且self又以某种方式（比如用一个具有strong属性的Property指向该block，或者将该block加入了self的一个具有strong属性的array中）强引用了该block，才会引起内存泄露，比如：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testSelfInBlock</span>
<span class="lineno">2</span> <span class="p">{</span>
<span class="lineno">3</span>     <span class="nb">self</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
<span class="lineno">4</span>         <span class="p">[</span><span class="nb">self</span> <span class="nl">doSomethingWithCat</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Fat</span> <span class="n">Cat</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span>
<span class="lineno">5</span>     <span class="p">};</span>
<span class="lineno">6</span> <span class="p">}</span></code></pre></div></p>

<p>有时候即使没有直接引用self，也可能导致self被retain，这叫做“implicit retain”。一种可能的情况就是在block中引用了self的实例变量，比如：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">testHiddenSelfInCocoaBlocks</span>
<span class="lineno">2</span> <span class="p">{</span>
<span class="lineno">3</span>     <span class="bp">NSArray</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">cats</span> <span class="o">=</span> <span class="l">@[</span><span class="p">@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Smily</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="p">@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Garfild</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="p">@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Other</span> <span class="n">cat</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span>
<span class="lineno">4</span>     <span class="p">[</span><span class="n">cats</span> <span class="nl">enumerateObjectsUsingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">cat</span><span class="p">,</span> <span class="bp">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">5</span>         <span class="n">_aCat</span> <span class="o">=</span> <span class="n">cat</span><span class="p">;</span>
<span class="lineno">6</span>         <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
<span class="lineno">7</span>     <span class="p">}];</span>
<span class="lineno">8</span> <span class="p">}</span></code></pre></div></p>

<p>这段code在block中引用了self的实例变量<code>_aCat</code>。</p>

<p>为了避免implicit retain，可以在xcode的build setting中打开<em>implicit retain of &lsquo;self&rsquo; within blocks</em>，xcode编译器会给出警告。</p>

<h5>2. NSTimer</h5>

<p>如果在view controller中创建了NSTimer，在消失view controller的时候需要调用<code>invalidate</code>，否则会产生ratain cycle。</p>

<h5>3. Observers/NSNotificationCenter</h5>

<p>当我们在NSNotificationCenter的block中引用self的时候，也会产生retain cycle，比如：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="p">[[</span><span class="bp">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">addObserverForName</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">not</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
<span class="lineno">2</span>                                                       <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span>
<span class="lineno">3</span>                                                        <span class="nl">queue</span><span class="p">:[</span><span class="bp">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span>
<span class="lineno">4</span>                                                   <span class="nl">usingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSNotification</span> <span class="o">*</span><span class="n">note</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">5</span>         <span class="p">[</span><span class="nb">self</span> <span class="nl">doSomethingWithCat</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Noty</span> <span class="n">cat</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span>
<span class="lineno">6</span>     <span class="p">}];</span></code></pre></div></p>

<p>在不用的时候需要将self从NSNotificationCenter中移除。</p>

<h5>4. Array contained reference</h5>

<p>比如在view controller中将self放在了一个array中，而这个array在view controller消失的时候不会被释放，view controller的<code>dealloc</code>就不会被调用。</p>

<h5>5. Delegate</h5>

<p>delegate的属性应该为weak。</p>

<h4>dealloc没被调用的调试</h4>

<p>调试dealloc没有被调用的情况，参考<a href="http://stackoverflow.com/questions/14890402/instruments-allocations-track-alloc-and-dealloc-of-objects-of-user-defined-class/14891837#14891837">Instruments Allocations track alloc and dealloc of objects of user defined classes</a>，可以看到对应实例在整个生命周期中发生的所有和内存有关的事件，包括malloc，ratain，release等和每次事件的call stack。注意其中的两项设置：</p>

<ul>
<li>勾选Record reference counts，记录retain，release和autorelease事件。</li>
<li>为Allocation Lifespan选择All Objects Created，如果你想看到已经被dealloc的实例，这个可以不选。</li>
<li>在<em>Allocation List -> All Allocations</em> 中可以搜索自己感兴趣的class。</li>
<li>在reference count页面，注意使用<em>All</em>、<em>uppair</em>等进行过滤。</li>
</ul>


<h3>关于ARC下的retainCount</h3>

<p>在ARC之前，我们可以使用<code>retainCount</code>得到一个Object被retain的次数。
引入ARC之后，这个方法不能在code中使用，可以使用下面的方法获得retain的次数：</p>

<p><div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Retain</span> <span class="n">count</span> <span class="n">is</span> <span class="o">%</span><span class="n">ld</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="n">CFGetRetainCount</span><span class="p">((</span><span class="k">__bridge</span> <span class="n">CFTypeRef</span><span class="p">)</span><span class="n">myObject</span><span class="p">));</span></code></pre></div></p>

<p>或者通过设置断点，在调试窗口输入如下命令：</p>

<p><div class="highlight"><pre><code class="language-text" data-lang="text">po object.retainCount</code></pre></div></p>

<blockquote><p> <strong>我们什么时候使用retainCount？</strong></p>

<p><strong>Never！</strong></p></blockquote>

<p>参考 <a href="http://stackoverflow.com/questions/4636146/when-to-use-retaincount">When to use -retainCount?</a>。
但是偶尔在调试的时候用一下，对于一些内存管理概念的理解还是有好处的，仅此而已。</p>
]]></content>
  </entry>
  
</feed>
