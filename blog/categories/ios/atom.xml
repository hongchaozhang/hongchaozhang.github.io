<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2023-09-16T00:46:56+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SightReading(è§†å¥)åº”ç”¨å¼€å‘çŸ¥è¯†ç‚¹æ€»ç»“]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/03/01/summarize-of-sight-reading-app-developping/"/>
    <updated>2021-03-01T14:39:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/03/01/summarize-of-sight-reading-app-developping</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96">æ•°æ®æŒä¹…åŒ–</a>

<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%9D%E5%AD%98%E5%92%8C%E8%AF%BB%E5%8F%96">æ–‡ä»¶çš„ä¿å­˜å’Œè¯»å–</a></li>
<li><a href="#nsdefault%E4%BF%9D%E5%AD%98%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF">NSDefaultï¼šä¿å­˜æ ‡ç­¾ä¿¡æ¯</a></li>
<li><a href="#%E5%8F%82%E8%80%83">å‚è€ƒ</a></li>
</ul>
</li>
<li><a href="#%E6%92%AD%E6%94%BE%E8%8A%82%E6%8B%8D%E5%99%A8%E5%A3%B0%E9%9F%B3">æ’­æ”¾èŠ‚æ‹å™¨å£°éŸ³</a>

<ul>
<li><a href="#%E9%80%9A%E8%BF%87avfoundation%E6%92%AD%E6%94%BE%E5%A3%B0%E9%9F%B3">é€šè¿‡AVFoundationæ’­æ”¾å£°éŸ³</a></li>
<li><a href="#%E8%8A%82%E6%8B%8D%E5%99%A8%E9%9F%B3%E9%87%8F%E8%B0%83%E8%8A%82">èŠ‚æ‹å™¨éŸ³é‡è°ƒèŠ‚</a></li>
</ul>
</li>
<li><a href="#navigationcontroller%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E9%80%92">navigationControllerçš„ä½¿ç”¨å’Œæ•°æ®çš„ä¼ é€’</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">å‚è€ƒ</a></li>
</ul>
</li>
<li><a href="#photokit%E7%9A%84%E4%BD%BF%E7%94%A8">PhotoKitçš„ä½¿ç”¨</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">å‚è€ƒ</a></li>
</ul>
</li>
<li><a href="#alert-view">Alert View</a></li>
<li><a href="#uiimage">UIImage</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">å‚è€ƒ</a></li>
</ul>
</li>
<li><a href="#%E5%8F%AF%E7%BC%96%E8%BE%91%E7%9A%84uitableview">å¯ç¼–è¾‘çš„UITableView</a></li>
<li><a href="#calayer--cashapelayer--core-graphics">CALayer &amp; CAShapeLayer &amp; Core Graphics</a></li>
<li><a href="#%E9%9F%B3%E4%B9%90%E6%9C%AF%E8%AF%AD%E8%8B%B1%E8%AF%AD">éŸ³ä¹æœ¯è¯­è‹±è¯­</a></li>
<li><a href="#swift%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95designatedconvenience">swiftä¸­æ„é€ æ–¹æ³•designatedï¼Œconvenience</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">å‚è€ƒ</a></li>
</ul>
</li>
<li><a href="#%E7%AC%94%E8%AE%B0%E7%BB%98%E5%88%B6%E5%8A%9F%E8%83%BD">ç¬”è®°ç»˜åˆ¶åŠŸèƒ½</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-æ•°æ®æŒä¹…åŒ–" name="æ•°æ®æŒä¹…åŒ–"></a></p>

<h2>æ•°æ®æŒä¹…åŒ–</h2>

<p><a id="markdown-æ–‡ä»¶çš„ä¿å­˜å’Œè¯»å–" name="æ–‡ä»¶çš„ä¿å­˜å’Œè¯»å–"></a></p>

<h3>æ–‡ä»¶çš„ä¿å­˜å’Œè¯»å–</h3>

<ul>
<li>Jsonæ–‡ä»¶ï¼šæ¯ä¸ªä¹è°±é¡µå¯¹åº”ä¸€ä¸ªJsonæ–‡ä»¶ã€‚æ–‡ä»¶ä¿å­˜ä¹è°±æ¯å°èŠ‚çš„å¤§å°å’Œä½ç½®ä¿¡æ¯ï¼Œä»¥åŠä¹è°±çš„åŸºæœ¬ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ¯å°èŠ‚èŠ‚æ‹æ•°å’Œç”¨æˆ·è®¾ç½®çš„é€Ÿåº¦å’ŒMaskåç§»é‡ã€‚</li>
<li>pngæ–‡ä»¶ï¼šæ¯ä¸ªä¹è°±éƒ½æœ‰ä¸€ä¸ªä¹è°±å›¾ç‰‡ï¼Œå¦‚æœç”¨æˆ·åšäº†ç¬”è®°ï¼Œè¿˜æœ‰ä¸€ä¸ªç¬”è®°å›¾ç‰‡ã€‚</li>
</ul>


<p>ä¿å­˜æ–‡ä»¶çš„ä»£ç å¦‚ä¸‹ï¼š
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func getRootPath() -&gt; String? {
</span><span class='line'>    return NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;func saveImageFile() {
</span><span class='line'>    if let rootPath = Utility.getRootPath(),
</span><span class='line'>        let imageName = getFileName() {
</span><span class='line'>        let imagePath = &ldquo;(rootPath)/(imageName).png&rdquo;
</span><span class='line'>        print(&ldquo;image path: (imagePath)&rdquo;)
</span><span class='line'>        if let image = imageView.image, let imageData = image.pngData() {
</span><span class='line'>            FileManager.default.createFile(atPath: imagePath, contents: imageData, attributes: nil)
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;func saveJsonFile() {
</span><span class='line'>    if let rootPath = Utility.getRootPath(),
</span><span class='line'>        let jsonFileName = getFileName() {
</span><span class='line'>        let jsonPath = &ldquo;(rootPath)/(jsonFileName).json&rdquo;
</span><span class='line'>        print(&ldquo;image path: (jsonPath)&rdquo;)
</span><span class='line'>        let jsonDic: [String: Any] = [basicInfoKey: &lt;a href=""&gt;String: String&lt;/a&gt;, barFramesKey: barFrames]
</span><span class='line'>        if let jsonData = try? NSKeyedArchiver.archivedData(withRootObject: jsonDic, requiringSecureCoding: false) {
</span><span class='line'>            FileManager.default.createFile(atPath: jsonPath, contents: jsonData, attributes: nil)
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>è¯»å–æ–‡ä»¶çš„ä»£ç å¦‚ä¸‹ï¼š
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func loadJsonFile() {
</span><span class='line'>    if let rootPath = Utility.getRootPath(),
</span><span class='line'>        let jsonName = navigationItem.title,
</span><span class='line'>        let jsonData = FileManager.default.contents(atPath: &ldquo;(rootPath)/(jsonName).json&rdquo;),
</span><span class='line'>        let jsonObjectAny = NSKeyedUnarchiver.unarchiveObject(with: jsonData),
</span><span class='line'>        let jsonObject = jsonObjectAny as? [String: Any] {
</span><span class='line'>        if let sheetBasicInfo = jsonObject[basicInfoKey] as? [String: String] {
</span><span class='line'>            self.sheetBasicInfo = sheetBasicInfo
</span><span class='line'>        }
</span><span class='line'>        if let barFrames = jsonObject[barFramesKey] as? [Int: CGRect] {
</span><span class='line'>            self.barFrames =  barFrames
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;func loadSheetImage(with imageName: String) {
</span><span class='line'>    if let rootPath = Utility.getRootPath(),
</span><span class='line'>        let sheetImage = UIImage(contentsOfFile: &ldquo;(rootPath)/(imageName).png&rdquo;) {
</span><span class='line'>        sheetImageView.image = sheetImage
</span><span class='line'>        noteImageView.image = UIImage(contentsOfFile: &ldquo;(rootPath)/(imageName)(noteImageSubfix).png&rdquo;)
</span><span class='line'>        layoutImageView()
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p><a id="markdown-nsdefaultä¿å­˜æ ‡ç­¾ä¿¡æ¯" name="nsdefaultä¿å­˜æ ‡ç­¾ä¿¡æ¯"></a></p>

<h3>NSDefaultï¼šä¿å­˜æ ‡ç­¾ä¿¡æ¯</h3>

<pre><code>UserDefaults.standard.setValue(allTags, forKey: allTagsKey)
let allTags = UserDefaults.standard.value(forKey: allTagsKey)
</code></pre>

<p><a id="markdown-å‚è€ƒ" name="å‚è€ƒ"></a></p>

<h3>å‚è€ƒ</h3>

<ul>
<li><a href="https://www.jianshu.com/p/d1c621631f7e">iOSæ•°æ®æœ¬åœ°æŒä¹…åŒ–æ–¹æ³•æ€»ç»“</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1129341">iOSåº”ç”¨æ•°æ®å­˜å‚¨ï¼ˆæ•°æ®æŒä¹…åŒ–ï¼‰çš„å¸¸ç”¨æ–¹å¼</a></li>
<li><a href="https://www.jianshu.com/p/fad66bae5484">iOS å°†å¯¹è±¡åºåˆ—åŒ–æˆjsonï¼Œå†™å…¥æœ¬åœ°æ–‡ä»¶</a></li>
</ul>


<p><a id="markdown-æ’­æ”¾èŠ‚æ‹å™¨å£°éŸ³" name="æ’­æ”¾èŠ‚æ‹å™¨å£°éŸ³"></a></p>

<h2>æ’­æ”¾èŠ‚æ‹å™¨å£°éŸ³</h2>

<p><a id="markdown-é€šè¿‡avfoundationæ’­æ”¾å£°éŸ³" name="é€šè¿‡avfoundationæ’­æ”¾å£°éŸ³"></a></p>

<h3>é€šè¿‡AVFoundationæ’­æ”¾å£°éŸ³</h3>

<pre><code>if let audioUrl = Bundle.main.url(forResource: "FirstMeter", withExtension: "wav", subdirectory: "Resource.bundle")  {
    AudioServicesCreateSystemSoundID(audioUrl as CFURL, &amp;firstMeterId)
}
AudioServicesPlaySystemSound(self.firstMeterId)
</code></pre>

<p><a id="markdown-èŠ‚æ‹å™¨éŸ³é‡è°ƒèŠ‚" name="èŠ‚æ‹å™¨éŸ³é‡è°ƒèŠ‚"></a></p>

<h3>èŠ‚æ‹å™¨éŸ³é‡è°ƒèŠ‚</h3>

<p>åœ¨è®¾ç½®ä¸­ï¼Œå¦‚æœâ€œå£°éŸ³->é“ƒå£°å’Œè­¦æŠ¥â€ä¸‹é¢çš„â€œè·ŸéšæŒ‰é’®â€æ²¡æœ‰æ‰“å¼€ï¼Œé‚£ä¹ˆé€šè¿‡<code>AudioServicesPlaySystemSound()</code>æ’­æ”¾çš„å£°éŸ³å°±ä¼šå§‹ç»ˆç”¨ä¸€ä¸ªå›ºå®šçš„éŸ³é‡æ’­æ”¾ï¼Œå…¶å®ƒå£°éŸ³APIæ’­æ”¾çš„å£°éŸ³ï¼ˆæ¯”å¦‚<code>AVAudioPlayer</code>ï¼‰ä¼šè·Ÿéšç³»ç»ŸéŸ³é‡å˜åŒ–éŸ³é‡å¤§å°ã€‚</p>

<blockquote><p>In Settings app, Sounds->RINGER AND ALERTS, if &lsquo;Change with Buttons&rsquo; is set to Off, then sounds using AudioServicesPlaySystemSound() will always be played at a fixed volume (yet other sound API&rsquo;s such as AVAudioPlayer will respect the volume of the device).</p></blockquote>

<p><a id="markdown-navigationcontrollerçš„ä½¿ç”¨å’Œæ•°æ®çš„ä¼ é€’" name="navigationcontrollerçš„ä½¿ç”¨å’Œæ•°æ®çš„ä¼ é€’"></a></p>

<h2>navigationControllerçš„ä½¿ç”¨å’Œæ•°æ®çš„ä¼ é€’</h2>

<p>é€šè¿‡ä¸‹é¢ä¸¤ç§æ–¹æ³•è¿›è¡ŒViewControllerçš„å¼¹å‡º
<code>
let playVC = storyBoard.instantiateViewController(identifier: "Play")
playVC.navigationItem.title = filtedFileNames[indexPath.row]
navigationController?.pushViewController(playVC, animated: true)
</code>
æˆ–è€…
<code>
let colorPickerVC = UIColorPickerViewController()
colorPickerVC.selectedColor = brushColorButton.selectedColor
colorPickerVC.delegate = self
present(colorPickerVC, animated: true, completion: nil)
</code>
é€šè¿‡delegateè¿›è¡Œç›®æ ‡ViewControlleråˆ°æºViewControllerçš„æ–¹æ³•è°ƒç”¨å’Œæ•°æ®ä¼ é€’ï¼ŒæºViewControlerå¯ä»¥ç›´æ¥è®¾ç½®ç›®æ ‡ViewControllerçš„å±æ€§è¿›è¡Œæ•°æ®ä¼ é€’ã€‚</p>

<p><a id="markdown-å‚è€ƒ" name="å‚è€ƒ"></a></p>

<h3>å‚è€ƒ</h3>

<ul>
<li><a href="https://stackoverflow.com/questions/30618172/how-to-send-data-back-by-popviewcontrolleranimated-for-swift">How to send data back by popViewControllerAnimated for Swift?</a></li>
<li><a href="https://www.jianshu.com/p/319cbc53f0ba">iOSå¯¼èˆªæ§åˆ¶å™¨â€”â€”UINavigationControllerä½¿ç”¨è¯¦è§£</a></li>
<li><a href="https://blog.csdn.net/liuyinghui523/article/details/62036465">ä¸€ç¯‡è¾ƒä¸ºè¯¦ç»†çš„ Storyboardä½¿ç”¨æ–¹æ³• æ€»ç»“</a></li>
</ul>


<p><a id="markdown-photokitçš„ä½¿ç”¨" name="photokitçš„ä½¿ç”¨"></a></p>

<h2>PhotoKitçš„ä½¿ç”¨</h2>

<p>éœ€è¦åœ¨info.plisté‡Œé¢è®¾ç½®<code>NSPhotoLibraryUsageDescription</code>å±æ€§ï¼Œè®¾ç½®åœ¨è·å–æƒé™çš„æ—¶å€™æ˜¾ç¤ºç»™ç”¨æˆ·çš„å¼¹çª—ä¸­æ˜¾ç¤ºçš„å†…å®¹ã€‚</p>

<p>æ£€æŸ¥æƒé™çŠ¶æ€ï¼š
<code>
private func requestPrivilegeAndLoadPhotos() {
    let status = PHPhotoLibrary.authorizationStatus()
    if status == .authorized {
        loadPhotos()
    } else {
        PHPhotoLibrary.requestAuthorization { (status) in
            if status == .authorized {
                self.loadPhotos()
                DispatchQueue.main.async {
                    self.collection.reloadData()
                }
            } else {
                // use not grant the privilege
            }
        }
    }
}
</code></p>

<p>å¦‚æœç”¨æˆ·ç»™äº†è®¿é—®ç›¸å†Œçš„æƒé™ï¼Œé€šè¿‡ä¸‹é¢çš„æ–¹æ³•åŠ è½½æ‰€æœ‰å›¾ç‰‡ä¿¡æ¯ï¼š
<code>
private func loadPhotos() {
    let allPhotosOptions = PHFetchOptions()
    allPhotosOptions.sortDescriptors = [NSSortDescriptor(key: "creationDate", ascending: true)]
    allPhotos = PHAsset.fetchAssets(with: .image, options: allPhotosOptions)
}
</code></p>

<p>é€šè¿‡ä¸‹é¢æ–¹æ³•å°†æ‰€æœ‰å›¾ç‰‡ä¿¡æ¯æ˜¾ç¤ºåœ¨collectionåˆ—è¡¨ä¸­ï¼š
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {
</span><span class='line'>    return allPhotos.count
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {
</span><span class='line'>    if let cell = collection.dequeueReusableCell(withReuseIdentifier: cellIdentifier, for: indexPath) as? PhotoCollectionCell {
</span><span class='line'>        let assert = allPhotos.object(at: indexPath.item)
</span><span class='line'>        PHImageManager.default().requestImage(for: assert, targetSize: CGSize(width: photoCollectionWH, height: photoCollectionWH), contentMode: .aspectFill, options: .none) { (image, dic) in
</span><span class='line'>            if let image = image {
</span><span class='line'>                cell.imageView.image = image
</span><span class='line'>            }
</span><span class='line'>        }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    return cell
</span><span class='line'>} else {
</span><span class='line'>    return collection.dequeueReusableCell(withReuseIdentifier: cellIdentifier, for: indexPath)
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}</span></code></pre></td></tr></table></div></figure></p>

<p>é€šè¿‡ä¸‹é¢æ–¹æ³•ï¼Œå°†ç”¨æˆ·é€‰æ‹©çš„å›¾ç‰‡ä¼ ç»™delegateå¤„ç†ï¼ˆdelegateå¯ä»¥æ˜¯æºViewControllerï¼‰ï¼š
<code>
func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
    print("item: \(indexPath.item)")
    let assert = allPhotos.object(at: indexPath.item)
    PHImageManager.default().requestImage(for: assert, targetSize: CGSize(width: assert.pixelWidth, height: assert.pixelHeight), contentMode: .aspectFill, options: .none) { (image, dic) in
        if let image = image {
            self.delegate?.set(image: image, and: nil)
        }
    }
}
</code>
<a id="markdown-å‚è€ƒ" name="å‚è€ƒ"></a></p>

<h3>å‚è€ƒ</h3>

<ul>
<li><a href="https://developer.apple.com/documentation/photokit">å®˜æ–¹æ–‡æ¡£ï¼šPhotoKit</a></li>
<li><a href="https://www.raywenderlich.com/11764166-getting-started-with-photokit">Getting Started with PhotoKit</a></li>
</ul>


<p><a id="markdown-alert-view" name="alert-view"></a></p>

<h2>Alert View</h2>

<p><a href="https://learnappmaking.com/uialertcontroller-alerts-swift-how-to/">Displaying Alerts with UIAlertController in Swift</a></p>

<p><a id="markdown-uiimage" name="uiimage"></a></p>

<h2>UIImage</h2>

<p>ä¸‹é¢ä¸¤ä¸ªå›¾ç‰‡åŠ è½½æ–¹æ³•å¯¹cacheçš„è¿ç”¨æ˜¯ä¸ä¸€æ ·çš„ï¼š
<code>
+ (UIImage *)imageNamed:(NSString *)name: use cached images
+ (UIImage *)imageWithContentsOfFile:(NSString *)path: skip cached images and read data directly from file
</code></p>

<p><a id="markdown-å‚è€ƒ" name="å‚è€ƒ"></a></p>

<h3>å‚è€ƒ</h3>

<p><a href="https://medium.com/@maximbilan/ios-uiimage-cache-92563c3ae3c2">iOS UIImage Cache</a></p>

<p><a id="markdown-å¯ç¼–è¾‘çš„uitableview" name="å¯ç¼–è¾‘çš„uitableview"></a></p>

<h2>å¯ç¼–è¾‘çš„UITableView</h2>

<p>é€šè¿‡å®ç°ä¸‹é¢æ–¹æ³•ä¿è¯æ¯ä¸ªcellæ”¯æŒå·¦æ»‘æ“ä½œï¼š
<code>
func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool {
    return true
}
</code></p>

<p>é€šè¿‡å®ç°ä¸‹é¢çš„æ–¹æ³•ï¼Œå·¦æ»‘ä¹‹åæ˜¾ç¤ºä¸¤ä¸ªæŒ‰é’®: Edit Tagså’ŒDelete
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&gt; [UITableViewRowAction]? {
</span><span class='line'>    let deleteAction = UITableViewRowAction(style: .destructive, title: &ldquo;Delete&rdquo;) { (action, indexPath) in
</span><span class='line'>        self.deleteItem(at: indexPath)
</span><span class='line'>    }
</span><span class='line'>    let editAction = UITableViewRowAction(style: .default, title: &ldquo;Edit Tags&rdquo;) { (action, indexPath) in
</span><span class='line'>        self.editTags(for: indexPath)
</span><span class='line'>    }
</span><span class='line'>    editAction.backgroundColor = UIColor(displayP3Red: 60/255, green: 148/255, blue: 1.0, alpha: 1.0)
</span><span class='line'>    deleteAction.backgroundColor = .red&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;return [deleteAction, editAction]
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}</span></code></pre></td></tr></table></div></figure></p>

<p><a id="markdown-calayer--cashapelayer--core-graphics" name="calayer--cashapelayer--core-graphics"></a></p>

<h2>CALayer &amp; CAShapeLayer &amp; Core Graphics</h2>

<p>è¿™ä¸€å—çš„å†…å®¹å¤ªå¤šï¼Œå¸Œæœ›æœ‰æ—¶é—´å¯ä»¥å•ç‹¬æ€»ç»“ä¸€ä¸‹ã€‚</p>

<p><a id="markdown-éŸ³ä¹æœ¯è¯­è‹±è¯­" name="éŸ³ä¹æœ¯è¯­è‹±è¯­"></a></p>

<h2>éŸ³ä¹æœ¯è¯­è‹±è¯­</h2>

<p><a href="https://zhuanlan.zhihu.com/p/35999407">éŸ³ä¹æœ¯è¯­è‹±æ–‡åç§°æ±‡æ€»</a></p>

<p><a id="markdown-swiftä¸­æ„é€ æ–¹æ³•designatedconvenience" name="swiftä¸­æ„é€ æ–¹æ³•designatedconvenience"></a></p>

<h2>swiftä¸­æ„é€ æ–¹æ³•designatedï¼Œconvenience</h2>

<p>å®˜æ–¹æ–‡æ¡£ä¸­æœ‰å¦‚ä¸‹æè¿°ï¼š</p>

<ol>
<li>å­ç±»designatedæ„é€ æ–¹æ³•ä¸­å¿…é¡»è°ƒç”¨çˆ¶ç±»çš„designatedæ„é€ æ–¹æ³•ã€‚</li>
<li>convenienceæ„é€ æ–¹æ³•ä¸­å¿…é¡»è°ƒç”¨å½“å‰ç±»çš„æ„é€ æ–¹æ³•ã€‚</li>
<li>convenienceæ„é€ æ–¹æ³•å½’æ ¹ç»“åº•è¦è°ƒç”¨åˆ°designatedæ„é€ æ–¹æ³•ã€‚</li>
</ol>


<p><img src="/images/swift_init_method.webp" alt="swift init methods" /></p>

<p><a id="markdown-å‚è€ƒ" name="å‚è€ƒ"></a></p>

<h3>å‚è€ƒ</h3>

<ul>
<li><a href="https://www.jianshu.com/p/e2cce123a5af">Swiftä¹‹initæ„é€ æ–¹æ³•</a></li>
</ul>


<p><a id="markdown-ç¬”è®°ç»˜åˆ¶åŠŸèƒ½" name="ç¬”è®°ç»˜åˆ¶åŠŸèƒ½"></a></p>

<h2>ç¬”è®°ç»˜åˆ¶åŠŸèƒ½</h2>

<p>é€šè¿‡ç¬¬ä¸‰æ–¹åº“<a href="https://github.com/e7711bbear/ATSketchKit">STSketchKit</a>å®ç°ç¬”è®°åŠŸèƒ½æ”¯æŒUndo/Redoæ“ä½œã€‚å®˜æ–¹ä»‹ç»å¦‚ä¸‹ï¼š</p>

<blockquote><p>ATSketchKit is a drawing / sketching framework for iOS written in Swift.</p>

<p>It can be used as the foundation for an artistic app, a simple signature feature or more inteligent graph designing app.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[å¸®åŠ©ç»ƒä¹ é’¢ç´è§†å¥çš„åº”ç”¨SightReading]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/02/26/an-app-to-help-piano-sight-reading/"/>
    <updated>2021-02-26T14:47:28+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/02/26/an-app-to-help-piano-sight-reading</id>
    <content type="html"><![CDATA[<!-- more -->


<p>å‚è€ƒ<a href="https://github.com/hongchaozhang/SightReading">SightReading</a>è·å–åº”ç”¨ä»£ç å’Œè¯¦ç»†ä½¿ç”¨æ–¹æ³•ã€‚</p>

<h2>ç±»å›¾å’Œæ•°æ®ç»“æ„</h2>

<p><img src="/images/SightReadingClassDiagram.jpg" alt="SightReadingClassDiagram" /></p>

<p>æ ‡ç­¾ä¿å­˜åœ¨UserDefaulté‡Œé¢ï¼Œæ•°æ®æ ¼å¼å¦‚ä¸‹ï¼š</p>

<pre><code>{
    "ALL_TAGS" : ["tag1", "tag2", "tag3"],
    "å¤©ç©ºä¹‹åŸ1" : ["tag1", "tag2"],
    "å¤©ç©ºä¹‹åŸ2" : ["tag2", "tag3"],
    "å·´èµ«å°æ­¥èˆæ›²" : ["tag1"]
}
</code></pre>

<p>å¯¹äºä¹è°±â€œå¤©ç©ºä¹‹åŸ1â€ï¼Œä¿å­˜çš„æ–‡ä»¶åå¦‚ä¸‹ï¼š</p>

<ol>
<li>ä¹è°±å›¾ç‰‡ï¼šå¤©ç©ºä¹‹åŸ1.png</li>
<li>ç¬”è®°å›¾ç‰‡ï¼šå¤©ç©ºä¹‹åŸ1&amp;-note.png</li>
<li>æ¯å°èŠ‚ä½ç½®å’Œå¤§å°æ–‡ä»¶ï¼šå¤©ç©ºä¹‹åŸ1.json</li>
</ol>


<p>å…¶ä¸­jsonæ–‡ä»¶æ ¼å¼å¦‚ä¸‹ï¼š</p>

<pre><code>{
    "basic info" : {
        "tempo" : "90", // æ¯åˆ†é’ŸèŠ‚æ‹æ•°
        "meter" : "4", // æ¯å°èŠ‚èŠ‚æ‹æ•°
        "maskOffset" : "1" // Maskåç§»
    },
    "bar frames" : {
        1 : CGRect(0.01, 0.02, 0.11, 0.12), // å°èŠ‚åºå·å’Œå°èŠ‚ä½ç½®å¤§å°ï¼ˆæ˜¯ä¸€ä¸ªæ¯”ä¾‹å€¼ï¼Œç›¸å¯¹äºæ•´ä¸ªä¹è°±å›¾ç‰‡çš„å¤§å°ï¼‰ï¼Œæœ€ç»ˆæ˜¾ç¤ºçš„æ—¶å€™éœ€è¦æ ¹æ®å®é™…æ˜¾ç¤ºçš„ä¹è°±çš„å¤§å°ç®—å‡ºæ¯ä¸ªå°èŠ‚çš„ä½ç½®å’Œå¤§å°
        2 : CGRect(0.13, 0.03, 0.12, 0.11),
        .
        .
        .
    }
}
</code></pre>

<h3>æ•°æ®å¤‡ä»½</h3>

<ol>
<li>ç™¾åº¦äº‘ç›˜ä¸‹è½½ï¼ˆ<em>/MyDocument/æ­Œè°±ç®€è°±äº”çº¿è°±/SightReadingåº”ç”¨æ•°æ®å¤‡ä»½20211207/mstr.SightReading.2021-12-07.xcappdata.zip</em>ï¼‰</li>
<li>è§£å‹å¾—åˆ°<em>.xcappdata</em>æ–‡ä»¶ï¼ŒMacå³é”®â€œShow Package Contentâ€ã€‚</li>
<li><em>/App/Data/Documents/</em>ç›®å½•ä¸‹ä¿å­˜ç€ä¸Šé¢è¯´çš„å›¾ç‰‡å’Œjsonæ–‡ä»¶ï¼Œ<em>/App/Library/Preferences/</em>ç›®å½•ä¸‹ä¿å­˜ç€UserDefaultå¯¹åº”çš„plistæ–‡ä»¶ã€‚</li>
<li>xcodeè¿æ¥ipadï¼Œç‚¹å‡»<em>window->Devices and  Simulators</em>ï¼Œé€‰ä¸­iPadå’ŒSightReadingåº”ç”¨ã€‚</li>
<li>ç‚¹å‡»ä¸‹é¢çš„é½¿è½®æŒ‰é’®ï¼Œé€‰æ‹©<em>Replace container&hellip;</em>ï¼Œå°†è§£å‹å‡ºæ¥çš„<em>.xcappdata</em>æ–‡ä»¶æ›¿æ¢ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚</li>
</ol>


<h2>ä¸€äº›å…¶å®ƒé—®é¢˜</h2>

<h3>ç§»åŠ¨Maskæ—¶æ¢é¡µçš„é€»è¾‘</h3>

<p>åœ¨å‰ä¸€é¡µæœ€åä¸€äº›èŠ‚éœ€è¦æ˜¾ç¤ºMaskçš„æ—¶å€™ç›´æ¥æ¢é¡µåˆ°ä¸‹ä¸€é¡µï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™æ¼”å¥è€…å·²ç»çœ‹å®Œäº†å‰ä¸€é¡µçš„æœ€åä¸€å°èŠ‚ï¼Œå¹¶ä¸”éœ€è¦é¢„è¯»ä¸‹ä¸€é¡µçš„ç¬¬ä¸€å°èŠ‚ã€‚</p>

<h2>TODOs</h2>

<ol>
<li>ç¬”è®°é¡µé¢ä¸èƒ½æ”¹å˜å›¾ç‰‡å¤§å°ï¼Œæ¯”å¦‚è½¬å±ã€å…¨å±ç­‰ï¼Œå› ä¸ºç»˜åˆ¶ç­‰pathåæ ‡æ²¡æœ‰åšç›¸åº”çš„æ›´æ”¹ï¼Œä¼šé”™ä½ã€‚</li>
<li>ç¬”è®°é¡µé¢çš„æ©¡çš®æ“¦åŠŸèƒ½è¿˜ä¸æ”¯æŒã€‚ç°åœ¨çš„æ©¡çš®æ“¦åŠŸèƒ½å®é™…ä¸Šå°±æ˜¯ä¸åŒé¢œè‰²çš„ç”»ç¬”åŠŸèƒ½ï¼Œéœ€è¦çœŸæ­£å®ç°æ©¡çš®æ“¦åŠŸèƒ½ï¼Œéœ€è¦å¯¹æ‰€æœ‰çš„<code>ATShapeLayer</code>è¿›è¡Œä¿®æ”¹ï¼Œæ·»åŠ ä¸€ä¸ªå®Œå…¨é€æ˜çš„æ©¡çš®æ“¦çš„pathã€‚</li>
<li>æ ‡ç­¾æœ¬èº«ä¸æ”¯æŒç¼–è¾‘åŠŸèƒ½ï¼Œæ¯”å¦‚ä¿®æ”¹æ ‡ç­¾åç§°ã€åˆ é™¤æ ‡ç­¾ã€‚</li>
<li>ç•Œé¢åªæ”¯æŒè‹±æ–‡ï¼Œéœ€è¦ç¿»è¯‘æˆä¸­æ–‡ã€‚</li>
<li>å¯¹äºå˜èŠ‚æ‹çš„ä¹æ›²è¿˜ä¸æ”¯æŒã€‚å¦‚æœæŸäº›å°èŠ‚æ‹æ•°ä¼šå˜åŒ–ï¼Œé‚£ä¹ˆèŠ‚æ‹å™¨å’ŒMaskæ˜¾ç¤ºé€»è¾‘éœ€è¦é‡æ–°è€ƒè™‘ã€‚</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Closure]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/06/04/on-swift-closure/"/>
    <updated>2019-06-04T17:24:47+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/06/04/on-swift-closure</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#function%E4%B8%8Eclosure%E7%9A%84%E5%85%B3%E7%B3%BB">Functionä¸Closureçš„å…³ç³»ï¼š</a></li>
<li><a href="#%E7%94%A8closure%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F">ç”¨Closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡</a></li>
<li><a href="#closure%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">Closureçš„è¯­æ³•ç³–ï¼š</a></li>
<li><a href="#closure%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">Closureä¸å†…å­˜ç®¡ç†ã€å†…å­˜æ³„æ¼</a>

<ul>
<li><a href="#capture-list%E7%9A%84%E5%AE%9A%E4%B9%89">Capture Listçš„å®šä¹‰</a></li>
<li><a href="#weak-and-unowned-references">Weak and Unowned References</a></li>
</ul>
</li>
<li><a href="#closure%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F">Closureæ•è·å˜é‡</a></li>
</ul>


<p><a href="https://medium.com/@abhimuralidharan/functional-swift-all-about-closures-310bc8af31dd">Functional swift: All about Closures</a></p>

<p>è¿™ç¯‡å…¨é¢è¯¦ç»†æ˜“æ‡‚åœ°ä»‹ç»äº†Swiftçš„Closureï¼ŒåŒ…æ‹¬</p>

<ul>
<li>Closureçš„è¯­æ³•ï¼ŒåŒ…æ‹¬ä¸€äº›ç®€åŒ–å†™æ³•ï¼Œå¦‚Trailing Closures</li>
<li>Closureä¸Functionçš„åŒºåˆ«</li>
<li>Closureä¸å†…å­˜ç®¡ç†ã€å†…å­˜æ³„æ¼ï¼Œå¦‚capture listçš„ä½¿ç”¨ï¼Œweakä¸unownedçš„åŒºåˆ«</li>
<li>Functionså’Œclosureséƒ½æ˜¯å¼•ç”¨ç±»å‹ï¼Œä¸æ˜¯å€¼ç±»å‹</li>
</ul>


<p>ä¹Ÿå¯ä»¥çœ‹<a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">å®˜æ–¹æ–‡æ¡£Closures</a>ï¼Œä½†æ˜¯å®˜æ–¹æ–‡æ¡£æ²¡æœ‰ä¸Šé¢çš„æ–‡ç« è¯¦ç»†ã€‚</p>

<p>ä¸‹é¢æœ‰é€‰æ‹©åœ°è®°å½•ä¸€ä¸‹ã€‚</p>

<p><a id="markdown-functionä¸closureçš„å…³ç³»" name="functionä¸closureçš„å…³ç³»"></a></p>

<h2>Functionä¸Closureçš„å…³ç³»ï¼š</h2>

<p>å‚è€ƒ<a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">å®˜æ–¹æ–‡æ¡£Closures</a>é‡Œé¢çš„ä¸‰å¥è¯ç†è§£ä¸€ä¸‹ï¼š</p>

<blockquote><ul>
<li>Global functions are closures that have a name and do not capture any values.</li>
<li>Nested functions are closures that have a name and can capture values from their enclosing function.</li>
<li>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</li>
</ul>
</blockquote>

<p>è¿˜æœ‰ä¸€ç‚¹å¾ˆé‡è¦ï¼š<strong>Closures and functions are first class types in swift</strong>ã€‚</p>

<blockquote><p>Functions and closures are first-class citizens in Swift because you can treat then like a normal value. For example, you canï¼š</p>

<ul>
<li>assign a function/closure to a local variable .</li>
<li>pass a function/closure as an argument .</li>
<li>return a function/closure .</li>
</ul>
</blockquote>

<p><a id="markdown-ç”¨closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡" name="ç”¨closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡"></a></p>

<h2>ç”¨Closureåˆå§‹åŒ–ä¸€ä¸ªå˜é‡</h2>

<pre><code>let setupViewUsingClosure: UIView = {
    let view = UIView()
    view.backgroundColor = .green
    return view
}() //IMPORTANT!!! I have added () at the end.
</code></pre>

<p><a id="markdown-closureçš„è¯­æ³•ç³–" name="closureçš„è¯­æ³•ç³–"></a></p>

<h2>Closureçš„è¯­æ³•ç³–ï¼š</h2>

<p><a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">å®˜æ–¹æ–‡æ¡£Closures</a>æœ‰ä¸ªæ€»çš„è¯´æ˜ï¼š</p>

<blockquote><p>Swiftâ€™s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios. These optimizations include:</p>

<ul>
<li>Inferring parameter and return value types from context</li>
<li>Implicit returns from single-expression closures</li>
<li>Shorthand argument names</li>
<li>Trailing closure syntax</li>
</ul>
</blockquote>

<p>å½“ä½ ç¬¬ä¸€æ¬¡çœ‹åˆ°è¿™ä¸ªå†™æ³•çš„æ—¶å€™è‚¯å®šå¾ˆç–‘æƒ‘ï¼šå‚æ•°ã€ç±»å‹ã€å‡½æ•°è°ƒç”¨æ—¶çš„æ‹¬å·éƒ½è·‘å“ªå»äº†ï¼Ÿ</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<p>ç†è§£äº†ä¸Šé¢å‡ ç‚¹ï¼Œå°±å¯ä»¥æ˜ç™½ä¸ºä»€ä¹ˆå¯ä»¥è¿™ä¹ˆå†™ï¼Œä¸‹é¢è®©æˆ‘ä»¬ä¸€æ­¥æ­¥çœ‹æ¸…æ¥šã€‚</p>

<p>Closureçš„å®šä¹‰å¦‚ä¸‹ï¼š</p>

<blockquote><p>Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.</p>

<pre><code>{ (params) -&gt; returnType in
    statements
}
</code></pre></blockquote>

<p>ä¸¾ä¸ªå…·ä½“çš„ä¾‹å­ï¼š</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in
    return s1 &gt; s2
})
</code></pre>

<p>å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Inferring parameter and return value types from context</strong></li>
</ul>


<p>Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns.</p></blockquote>

<p>æ‰€ä»¥ï¼Œä¸Šé¢çš„ä»£ç å¯ä»¥å†™ä¸ºï¼š</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 } )
</code></pre>

<p>å†å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Implicit returns from single-expression closures</strong></li>
</ul>


<p>Single-expression closures can implicitly return the result of their single expression by omitting the return keyword from their declaration.</p></blockquote>

<p>æ‰€ä»¥ï¼Œä»£ç ç»§ç»­æ”¹ä¸ºï¼š</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
</code></pre>

<p>å†å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Shorthand argument names</strong></li>
</ul>


<p>Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closureâ€™s arguments by the names $0, $1, $2, and so on.</p></blockquote>

<p>ä»£ç ç»§ç»­æ”¹ä¸ºï¼š</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted(by: { $0 &gt; $1 } )
</code></pre>

<p>å†å› ä¸ºï¼š</p>

<blockquote><ul>
<li><strong>Trailing closure syntax</strong></li>
</ul>


<p>If you need to pass a closure expression to a function as the functionâ€™s final argument and the closure expression is long, it can be useful to write it as a trailing closure instead. A trailing closure is written after the function callâ€™s parentheses, even though it is still an argument to the function. When you use the trailing closure syntax, you donâ€™t write the argument label for the closure as part of the function call.</p></blockquote>

<p>ä»£ç å°±å¯ä»¥å†™æˆï¼š</p>

<pre><code>let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
rreversedNames = names.sorted { $0 &gt; $1 }
</code></pre>

<p><a id="markdown-closureä¸å†…å­˜ç®¡ç†å†…å­˜æ³„æ¼" name="closureä¸å†…å­˜ç®¡ç†å†…å­˜æ³„æ¼"></a></p>

<h2>Closureä¸å†…å­˜ç®¡ç†ã€å†…å­˜æ³„æ¼</h2>

<p>Closureå¸¦æ¥çš„å¾ªç¯å¼•ç”¨å’Œå†…å­˜æ³„æ¼ï¼Œä¸»è¦é€šè¿‡Capture Listæ¥è§£å†³ï¼š</p>

<blockquote><p>You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closureâ€™s definition. A capture list defines the rules to use when capturing one or more reference types within the closureâ€™s body.</p></blockquote>

<p>è¯¦ç»†å†…å®¹å‚è€ƒ<a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID56">Resolving Strong Reference Cycles for Closures</a>ã€‚ä¸‹é¢æ‘˜è¦ä¸€ä¸‹ã€‚</p>

<p><a id="markdown-capture-listçš„å®šä¹‰" name="capture-listçš„å®šä¹‰"></a></p>

<h3>Capture Listçš„å®šä¹‰</h3>

<blockquote><p>Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self) or a variable initialized with some value (such as delegate = self.delegate!). These pairings are written within a pair of square braces, separated by commas.</p></blockquote>

<p>Place the capture list before a closureâ€™s parameter list and return type if they are provided:</p>

<pre><code>lazy var someClosure: (Int, String) -&gt; String = {
    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in
    // closure body goes here
}
</code></pre>

<p><a id="markdown-weak-and-unowned-references" name="weak-and-unowned-references"></a></p>

<h3>Weak and Unowned References</h3>

<blockquote><p>Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.</p>

<p>Conversely, define a capture as a weak reference when the captured reference may become nil at some point in the future. Weak references are always of an optional type, and automatically become nil when the instance they reference is deallocated. This enables you to check for their existence within the closureâ€™s body.</p>

<p>NOTE: If the captured reference will never become nil, it should always be captured as an unowned reference, rather than a weak reference.</p></blockquote>

<p>å…³äºunownedçš„å¦ä¸€ä¸ªè§£é‡Šæ›´æ¸…æ¥šï¼š</p>

<blockquote><p>Like a weak reference, an unowned reference does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime.</p></blockquote>

<p><a id="markdown-closureæ•è·å˜é‡" name="closureæ•è·å˜é‡"></a></p>

<h2>Closureæ•è·å˜é‡</h2>

<blockquote><p>Closures can capture and store references to any constants and variables from the context in which they are defined. This is known as closing over those constants and variables.</p></blockquote>

<p>æ¯”å¦‚ï¼š</p>

<pre><code>// capturing values
var i = 0
var closureArray = [()-&gt;()]()
for _ in 1...5 {
    closureArray.append {
        print(i)
    }
    i += 1
}
// here i will be 5
closureArray[0]() // prints 5
closureArray[1]() // prints 5
closureArray[2]() // prints 5
closureArray[3]() // prints 5
closureArray[4]() // prints 5
</code></pre>

<p>The closure captures the current address of <code>i</code> and every time we access <code>i</code> , it . returns the current value.</p>

<p>If we want to prevent this behavior (capturing values) and print the value of i even if the properties change after their capturing inside the closure, we can explicitly capture the variable with a capture list like this:</p>

<pre><code>var closureArray2 = [()-&gt;()]()
var j = 0
for _ in 1...5 {
    closureArray2.append { [j] in
        print(j)
    }
    j += 1
}
// here i will be 5
closureArray2[0]() // prints 0
closureArray2[1]() // prints 1
closureArray2[2]() // prints 2
closureArray2[3]() // prints 3
closureArray2[4]() // prints 4
</code></pre>

<p>In this way, we keep an immutable copy of the variable <code>j</code>. Thanks to this copy, further changes to <code>j</code>, outside the closure, will not affect the closure. <code>j</code> is a let constant here. It is not mutable.</p>

<p>We can add multiple values to the capture list :</p>

<pre><code>closure.append { [j,k,l] in
    print("\(j) \(k) \(l)")
}
</code></pre>

<p>also, you can have alias names for the values captured.</p>

<pre><code>closure.append { [a = j, b = k, c = l] in
    print("\(a) \(b) \(c)")
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sequece and Collection in Swift]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/06/03/sequece-and-collection-in-swift/"/>
    <updated>2019-06-03T16:22:33+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/06/03/sequece-and-collection-in-swift</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#array-out-of-range-crash"><code>Array</code> out of Range Crash</a></li>
<li><a href="#homemade-collection">Homemade collection</a></li>
<li><a href="#sequences">Sequences</a>

<ul>
<li><a href="#how-to-conform-to-sequence-protocol">How to Conform to <code>Sequence</code> Protocol</a></li>
<li><a href="#make-our-section-conform-to-sequence-protocol">Make our <code>Section</code> Conform to <code>Sequence</code> Protocol</a></li>
<li><a href="#gifts">Gifts</a></li>
</ul>
</li>
<li><a href="#collections">Collections</a>

<ul>
<li><a href="#how-to-conform-to-collection-protocol">How to Conform to <code>Collection</code> Protocol</a></li>
<li><a href="#make-our-section-conform-to-collection-protocol">Make our <code>Section</code> Conform to <code>Collection</code> Protocol</a></li>
</ul>
</li>
<li><a href="#difference-between-array-and-collection">Difference between <code>Array</code> and <code>Collection</code></a></li>
<li><a href="#reference">Reference</a></li>
</ul>


<p>The content comes from the following posts:</p>

<ol>
<li><a href="https://medium.com/swift-programming/swift-sequences-ce22d76f120c">Swift Sequences</a></li>
<li><a href="https://medium.com/swift-programming/swift-collections-e5fff3cd6759">Swift Collections</a></li>
</ol>


<p>But some of the code inside is old and can&rsquo;t be compiled with swift 5.0. So rewritten the code using swift 5.0.</p>

<p><a id="markdown-array-out-of-range-crash" name="array-out-of-range-crash"></a></p>

<h2><code>Array</code> out of Range Crash</h2>

<p>Before diving into Swift Sequences, letâ€™s see a strange behavior.</p>

<pre><code>let array = [1, 2, 3]
array[7] ğŸ˜­

let dic = ["a": 1, "b": 2]
dic["z"] ğŸ˜

ğŸ¤”
</code></pre>

<p>In other words, when requesting an element that doesnâ€™t exist, why arrays crash whereas dictionaries donâ€™t?</p>

<p>Arrays and dictionaries are two base collections provided by the Swift standard library. We can access those collections elements through the [] notation, also known as subscript. Letâ€™s see how those subscripts are defined.</p>

<pre><code>struct Array&lt;Element&gt; {
    subscript(index: Int) -&gt; Element
}

struct Dictionary&lt;Key: Hashable, Value&gt; {
    subscript(key: Key) -&gt; Value?
}
</code></pre>

<p>Whatâ€™s interesting is that arrays have a non optional return type. Subscript canâ€™t throw errors so there are no alternatives other than a fatalError if we request an index that doesnâ€™t exist.</p>

<p>For dictionaries, on the other hand, an optional Value is returned, which allows to gracefully return nil if the index doesnâ€™t exist.</p>

<p>We can adopt dictionaries safer approach by overloading the arrays subscriptâ€Šâ€”â€Šwe canâ€™t override them. Adding an external name to the parameter is enough.</p>

<pre><code>extension Array {
    subscript(safe index: Int) -&gt; Element? {
        return index &gt;= 0 &amp;&amp; index &lt; count ? self[index] : nil
    }
}
</code></pre>

<p>We saw how we can create a new accessor to the elements of an array, but can we do the same with a homemade collection?</p>

<p><a id="markdown-homemade-collection" name="homemade-collection"></a></p>

<h2>Homemade collection</h2>

<pre><code>struct Section&lt;T&gt; {
    let title: String
    let elements: [T]
}
</code></pre>

<p>Internally, this â€˜collectionâ€™ is based on an array. This is an implementation detail for the simplicity of the example. We could have used a linked list as in this <a href="http://austinzheng.com/2015/01/24/swift-seq/">excellent article</a> by <a href="https://twitter.com/austinzheng">Austin Zheng</a>.</p>

<p>Creating a subscript on our collection is very easy, we can even reuse the arrayâ€™s extension we made earlier.</p>

<pre><code>struct Section&lt;T&gt; {
    let title: String
    let elements: [T]

    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }
}
</code></pre>

<p>An example in practice :</p>

<pre><code>let cars = ["911", "Cayman", "Cayenne"]
let section = Section(title: "Porsche", elements: cars)

section[1]
// Optional("Cayman")
</code></pre>

<p>Great! But does that make our type a collection, as Swift defines it?</p>

<p><a id="markdown-sequences" name="sequences"></a></p>

<h2>Sequences</h2>

<p>When it comes to manipulating sets, the most abstract notion given by the standard library is the Sequence, defined as</p>

<blockquote><p>A type that can be iterated with a <code>forâ€¦in</code> loop.</p></blockquote>

<p><a id="markdown-how-to-conform-to-sequence-protocol" name="how-to-conform-to-sequence-protocol"></a></p>

<h3>How to Conform to <code>Sequence</code> Protocol</h3>

<p>This section is from <a href="https://developer.apple.com/documentation/swift/sequence">Sequece official site</a>.</p>

<p>Making your own custom types conform to Sequence enables many useful operations, like for-in looping and the contains method, without much effort. To add Sequence conformance to your own custom type, add a makeIterator() method that returns an iterator.</p>

<p>Alternatively, if your type can act as its own iterator, implementing the requirements of the IteratorProtocol protocol and declaring conformance to both Sequence and IteratorProtocol are sufficient.</p>

<p>Hereâ€™s a definition of a Countdown sequence that serves as its own iterator. The makeIterator() method is provided as a default implementation.</p>

<pre><code>struct Countdown: Sequence, IteratorProtocol {
    var count: Int

    mutating func next() -&gt; Int? {
        if count == 0 {
            return nil
        } else {
            defer { count -= 1 }
            return count
        }
    }
}

let threeToGo = Countdown(count: 3)
for i in threeToGo {
    print(i)
}
// Prints "3"
// Prints "2"
// Prints "1"
</code></pre>

<p><a id="markdown-make-our-section-conform-to-sequence-protocol" name="make-our-section-conform-to-sequence-protocol"></a></p>

<h3>Make our <code>Section</code> Conform to <code>Sequence</code> Protocol</h3>

<p>The <code>Section</code> struct can&rsquo;t act as its own iterator, we need to define an iterator for it, and then return an instance of the defined iterator inside <code>func makeIterator() -&gt; Section&lt;T&gt;.Iterator</code> method.</p>

<pre><code>struct Section&lt;T&gt;: Sequence {
    let title: String
    let elements: [T]

    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }

    struct Iterator: IteratorProtocol {
        let array: [T]
        var currentIndex = 0

        init (_ array: [T]) {
            self.array = array
        }

        mutating func next() -&gt; T? {
            let tempIndex = currentIndex
            currentIndex += 1
            return array[safe: tempIndex]

        }
    }

    func makeIterator() -&gt; Section&lt;T&gt;.Iterator {
        return Iterator(elements)
    }
}
</code></pre>

<p><a id="markdown-gifts" name="gifts"></a></p>

<h3>Gifts</h3>

<p>Is that all? No! By conforming to SequenceType we also get methods for free, here is some of them.</p>

<pre><code>section.min()
// 911
section.max()
// Cayman
section.sorted()
// ["911", "Cayenne", "Cayman"]
section.contains("911")
// true
</code></pre>

<p>We get the min, max &amp; sort methods because the elements of our sequence, String in our case, are Comparable. Contains is available thanks to our elements being Equatable.</p>

<pre><code>section.filter { $0.count &gt; 3 }
// ["Cayman", "Cayenne"]
section.map { $0.count }
// [3, 6, 7]
section.reduce(0) { $0 + $1.count }
// 16
</code></pre>

<p>And for functional programming fans, filter, map and reduce are also given.</p>

<p><a id="markdown-collections" name="collections"></a></p>

<h2>Collections</h2>

<p>Sequence is the most basic set notion given by the Swift standard library. There is a more evolved one.</p>

<p>A collection is defined as follow :</p>

<blockquote><p>A multi-pass <em>sequence</em> with addressable positions</p></blockquote>

<p>As we saw previously, a sequence is a type that can be iterated with a <code>forâ€¦in</code> loop. It doesnâ€™t need that the elements might be iterated over several times. And it doesnâ€™t need that we give a way to access directly an element.</p>

<p>Collections require those last two points. As a side effect, it no longer allows us to have an infinite number of elements.</p>

<p>To be a collection, a type must conform to the <code>Collection</code> protocol.</p>

<p><a id="markdown-how-to-conform-to-collection-protocol" name="how-to-conform-to-collection-protocol"></a></p>

<h3>How to Conform to <code>Collection</code> Protocol</h3>

<p>This section comes from <a href="https://developer.apple.com/documentation/swift/collection">Collection official site</a>.</p>

<p>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the Collection protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add Collection conformance to your type, you must declare at least the following requirements:</p>

<ol>
<li>The <code>startIndex</code> and <code>endIndex</code> properties</li>
<li>A subscript that provides at least read-only access to your typeâ€™s elements</li>
<li>The <code>index(after:)</code> method for advancing an index into your collection</li>
<li>Conform to <code>Sequece</code> Protocol, as <code>Collection</code> is inherited from <code>Sequence</code></li>
</ol>


<p><a id="markdown-make-our-section-conform-to-collection-protocol" name="make-our-section-conform-to-collection-protocol"></a></p>

<h3>Make our <code>Section</code> Conform to <code>Collection</code> Protocol</h3>

<pre><code>struct Section&lt;T&gt;: Collection {
    let title: String
    let elements: [T]

    // begin: required for Collection
    var startIndex: Int { return 0 }
    var endIndex: Int { return elements.count }

    func index(after i: Int) -&gt; Int {
        return i + 1
    }

    subscript(index: Int) -&gt; T {
        return elements[index]
    }
    // end: required for Collection


    subscript(safe index: Int) -&gt; T? {
        return elements[safe: index]
    }


    // begin: required for Sequence
    struct Iterator: IteratorProtocol {
        let array: [T]
        var currentIndex = 0

        init (_ array: [T]) {
            self.array = array
        }

        mutating func next() -&gt; T? {
            let tempIndex = currentIndex
            currentIndex += 1
            return array[safe: tempIndex]

        }
    }

    func makeIterator() -&gt; Section&lt;T&gt;.Iterator {
        return Iterator(elements)
    }
    // end: required for Sequence
}
</code></pre>

<p>The <code>endIndex</code> has to be after the last element. It allows to define an empty collection with <code>startIndex</code> = <code>endIndex</code>.</p>

<p>Like conforming to <code>Sequence</code>, we get some methods / properties for free:</p>

<pre><code>section.count
// 3
section.first
// 911
section.isEmpty
// false
section.index(of: "911")
// 0
</code></pre>

<p>We get indexOf thanks to our Elements being Equatable.</p>

<p><a id="markdown-difference-between-array-and-collection" name="difference-between-array-and-collection"></a></p>

<h2>Difference between <code>Array</code> and <code>Collection</code></h2>

<p>We created our own collection, which is great, but what about that difference of behavior between Arrays and Dictionaries we talked about at the beginning of the post? We saw that Arrayâ€™s dangerous subscript was coming from the Indexable protocol, but what about Dictionaries?</p>

<p>Dictionaries, like Arrays, are a collection, as Swift defines it. They both conform to CollectionType. So Dictionaries are also required to provide an â€˜unsafeâ€™ subscript that takes an Index and returns a non optional Element. The one weâ€™re used to is just a convenience subscript.</p>

<p>A simple example shows that it is also really easy to get a crash with Dictionaries.</p>

<pre><code>let dic = ["a": "bmw", "b": "audi", "c": "citroen"]

var index = dic.startIndex
dic[index]
// (key: "c", value: "citroen")

index = dic.index(after: index)
print(dic[index])
// (key: "b", value: "audi")

index = dic.index(after: index)
index = dic.index(after: index)
dic[index]
// Fatal error
</code></pre>

<p><strong>The last question that remains is why <code>Collection</code> requires a subscript that may crash? Simply for performance reason, it costs too much to check the validity of the given index. Crashing is faster :)</strong></p>

<p><a id="markdown-reference" name="reference"></a></p>

<h2>Reference</h2>

<ol>
<li><a href="https://medium.com/swift-programming/swift-sequences-ce22d76f120c">Swift Sequences</a></li>
<li><a href="https://medium.com/swift-programming/swift-collections-e5fff3cd6759">Swift Collections</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Offline Natural Language Understanding Engine on iOS]]></title>
    <link href="http://hongchaozhang.github.io/blog/2019/05/22/offline-natural-language-understanding-engine-on-ios/"/>
    <updated>2019-05-22T16:04:28+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2019/05/22/offline-natural-language-understanding-engine-on-ios</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#objective">Objective</a>

<ul>
<li><a href="#what-is-a-good-nlu-engine">What is a good NLU engine</a>

<ul>
<li><a href="#deterministic-behavior">Deterministic behavior</a></li>
<li><a href="#generalization-power">Generalization power</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#design-and-workflow">Design and Workflow</a></li>
<li><a href="#deterministic-intent-parser">Deterministic Intent Parser</a></li>
<li><a href="#probabilistic-intent-parser">Probabilistic Intent Parser</a>

<ul>
<li><a href="#intent-classification">Intent Classification</a>

<ul>
<li><a href="#model-training">Model Training</a></li>
<li><a href="#model-usage">Model Usage</a></li>
</ul>
</li>
<li><a href="#slot-filling">Slot Filling</a>

<ul>
<li><a href="#model-training-1">Model Training</a></li>
<li><a href="#model-usage-1">Model Usage</a></li>
</ul>
</li>
<li><a href="#model-size">Model Size</a></li>
<li><a href="#problems-to-be-solved">Problems to Be Solved</a>

<ul>
<li><a href="#intent-classification-model-has-no-probability-output">Intent Classification Model Has No Probability Output</a></li>
<li><a href="#slot-filling-model-tagges-the-label-by-words-not-phrase">Slot Filling Model Tagges the Label by Words, not Phrase</a></li>
</ul>
</li>
</ul>
</li>
</ul>


<p><a id="markdown-objective" name="objective"></a></p>

<h2>Objective</h2>

<p><img src="/images/NLUObjective.png" alt="nlu objective" /></p>

<p>We want an NLU Engine to understand the normal text command on Mobile. We hope the engine can know the command&rsquo;s intent and the info the command needs to execute.</p>

<p>Currently, there are many NLU related tools, like Google Dialogflow, Amazon Lex, Facebook Wit.ai, Microsoft Luis. However, they are all online tools. Considering the privacy problem, we are trying to build our own offline NLU Engine.</p>

<p><a id="markdown-what-is-a-good-nlu-engine" name="what-is-a-good-nlu-engine"></a></p>

<h3>What is a good NLU engine</h3>

<p>Letâ€™s start by looking at a simple example, and see what you would expect from a good NLU engine.</p>

<p>First, we need some examples to train the NLU engine. Consider the following dataset, used to train a simple weather assistant with a few query examples:</p>

<ul>
<li>Give me the weather for [tomorrow](date)</li>
<li>Show me the [Paris](location) weather for [Sunday](date)</li>
</ul>


<p><a id="markdown-deterministic-behavior" name="deterministic-behavior"></a></p>

<h4>Deterministic behavior</h4>

<p>The first thing you want is that all the examples you give to train the model are correctly supported by the engine. This makes the system predictable and easy to use: if a query is not correctly parsed, then add it to the dataset and it will work right away.</p>

<p><a id="markdown-generalization-power" name="generalization-power"></a></p>

<h4>Generalization power</h4>

<p>Having this deterministic behavior is great for robustness and predictability, but a powerful NLU engine also needs to have some generalization power. You want the system not only to recognize patterns provided in the training set, but also all the possible variations that come from speaking naturally. If we go back to the previous dataset, it is reasonable to expect the NLU engine to parse a query like: â€œWhatâ€™s the weather in Beijing right now?â€ even though it is not one of the training examples.</p>

<p><a id="markdown-design-and-workflow" name="design-and-workflow"></a></p>

<h2>Design and Workflow</h2>

<p><img src="/images/NLUDesign.png" alt="nlu design" /></p>

<p>In order to satisfy these objectives: deterministic behavior and generalization power, we built the processing pipeline described in the figure above. It receives a text as input, and outputs a structured response containing the intent and the list of slots. The main processing unit of the pipeline is the NLU engine. It contains two intent parsers which are called successively: a deterministic intent parser and a probabilistic one.</p>

<p>The deterministic parser relies on regular expressions to match intent and slots, which results in perfect behavior on training examples but doesnâ€™t generalize. This parser is the first to be used because of its strictness.</p>

<p>The probabilistic parser is used whenever the first parser fails to find a match. It uses machine learning to generalize beyond the set of sentences seen at train time, thus making our NLU engine be able to cope with examples which are not in the scope of the training data set. This parser involves two successive steps: intent classification and slot filling. These two steps rely on trained machine learning models to classify intent and extract slots.</p>

<p><a id="markdown-deterministic-intent-parser" name="deterministic-intent-parser"></a></p>

<h2>Deterministic Intent Parser</h2>

<p>The Deterministic Intent Parse is the first step to be used. This parser relies on some regular expressions to match the intent and slots. If the new input has the same structure with one of the training examples, we will find its intent and slots by comparing the input with the matched regular expression.</p>

<p>The regular expressions are built based on the training examples. For a training case:</p>

<ul>
<li>What is the weather in [Alaska](location)</li>
</ul>


<p>We will build a regular expression:</p>

<ul>
<li>(what is the weather in)(?&lt;location1&gt;.+)</li>
</ul>


<p><a id="markdown-probabilistic-intent-parser" name="probabilistic-intent-parser"></a></p>

<h2>Probabilistic Intent Parser</h2>

<p>If the Deterministic Intent Parser fails to find the intent and slots, the Probabilistic Intent Parser will be used.</p>

<p>The Probabilistic Intent Parser has two steps:</p>

<ul>
<li>Intent Classification</li>
<li>Slot Filling</li>
</ul>


<p>The Intent Classification is to find the intent of the input command text, and the Slot Filling is to extract all the slots needed by the intent. These two steps are both based on trained machine models.</p>

<p>Apple has released CreateML for training natural language models, which also integrates the powerful NatrualLanguage framework functions, like Tokenization, Part of Speech, Lemmatization, Name Entity Recognition, etc. This will make the training process very simple, and the trained model will be more accurate and smaller.</p>

<p><a id="markdown-intent-classification" name="intent-classification"></a></p>

<h3>Intent Classification</h3>

<p><a id="markdown-model-training" name="model-training"></a></p>

<h4>Model Training</h4>

<p>For Intent Classification model training, we prepare the data set as follows (The size of the training data is 3282 falling into four intents.):</p>

<pre><code>[
  {
    "text": "I would like the forecast in cupertino california  tomorrow", 
    "label": "searchWeatherForecast"
  }, 
  {
    "text": "Forecast in Maine USA next week", 
    "label": "searchWeatherForecast"
  }, 
...
...
  {
    "text": "Will I be able to wear open-toed shoes twenty three hours and seven minutes from now in Severn?", 
    "label": "searchWeatherForecastItem"
  }, 
  {
    "text": "Should I bring a raincoat to the Belgrade and Loreto areas of Oman at midnight?", 
    "label": "searchWeatherForecastItem"
  }, 
...
...
]
</code></pre>

<p>Apple has release CreateML framework for training machine learning models easily inside Swift playground and the trained model can be saved as mlmodel type. And the MLTextClassifier class from CreateML will benefit from Apple&rsquo;s NatrualLanguage framework for Tokenization, Part of Speech, Lemmatization, etc.</p>

<p>The training script is:</p>

<pre><code>let trainingDataPath = Bundle.main.path(forResource: "intentClassificationFile", ofType: "json", inDirectory: "Data/text/train")!
let trainingData = try! MLDataTable(contentsOf:  URL(fileURLWithPath: trainingDataPath))

// Initializing the classifier with a training data.
let classifier = try! MLTextClassifier(trainingData: trainingData, textColumn: "text", labelColumn: "label")

// Evaluating training &amp; validation accuracies.
let trainingAccuracy = (1.0 - classifier.trainingMetrics.classificationError) * 100
let validationAccuracy = (1.0 - classifier.validationMetrics.classificationError) * 100

// Initializing the properly labeled testing data from Resources folder.
let testingDataPath = Bundle.main.path(forResource: "intentClassificationFile", ofType: "json", inDirectory: "Data/text/test")!
let testingData = try! MLDataTable(contentsOf: URL(fileURLWithPath:testingDataPath))

// Counting the testing evaluation.
let evaluationMetrics = classifier.evaluation(on: testingData)
let evaluationAccuracy = (1.0 - evaluationMetrics.classificationError) * 100

// Confusion matrix in order to see which labels were classified wrongly.
let confusionMatrix = evaluationMetrics.confusion
print("Confusion matrix: \(confusionMatrix)")

// Metadata for saving the model.
let metadata = MLModelMetadata(author: "Hongchao Zhang",
                            shortDescription: "A model trained to classify weather related commands.",
                            version: "1.0")

// Saving the model. Remember to update the path.
try! classifier.write(to: URL(fileURLWithPath: "/Users/hozhang/Downloads/textClassifier.mlmodel"),
                    metadata: metadata)
</code></pre>

<p>We can get 99.23% training accuracy and 98.87% validation accuracy.</p>

<p><a id="markdown-model-usage" name="model-usage"></a></p>

<h4>Model Usage</h4>

<p>For the trained model of mlmodel type, we can use it in our iOS app through NLModel (from NatrualLanguage framework). The demo swift code may be like:</p>

<pre><code>let modelUrl = Bundle.main.url(forResource: "Data/text/textClassifier", withExtension: "mlmodel")
let compiledModelUrl = try! MLModel.compileModel(at: modelUrl!)
let classifier = try! NLModel(contentsOf: compiledModelUrl)

let text = requestText
let label = classifier.predictedLabel(for: text)

print("text: \(text)\nlabel:\(label ?? "Not detected!")")
</code></pre>

<blockquote><p><strong>How to use .mlmodel file?</strong></p>

<p>.mlmodel file needs to be compiled before using. There are two ways to do this: offline and online:</p>

<ol>
<li>offline: drag the mlmodel into your project, xcode will compile the .mlmodel for you before you build you app.</li>
<li>online: use <code>MLModel.compileModel</code> to compile your .mlmodel file at runtime. This is especially useful when your are at swift playground, where you cannot get xcode&rsquo;s help for comipling.</li>
</ol>
</blockquote>

<p><a id="markdown-slot-filling" name="slot-filling"></a></p>

<h3>Slot Filling</h3>

<p><a id="markdown-model-training-1" name="model-training-1"></a></p>

<h4>Model Training</h4>

<p>For Slot Filling model training, we prepare the data set as follows (The size of the training data is: 3282.):</p>

<pre><code>[
  {
    "tokens": ["I", "would", "like", "the", "forecast", "in", "california", "tomorrow"], 
    "labels": ["none", "none", "none", "none", "none", "none", "location", "date"]
  }, 
  {
    "tokens": ["Forecast", "in", "Maine", "next week"], 
    "labels": ["none", "none", "location", "date"]
  }, 
...
...
]
</code></pre>

<p>Like Intent Classification model training, CreateML framework also makes it easy. Like MLTextClassifier, the MLWordTagger class from CreateML will also benefit from NatrualLanguage framework for Part of Speech, Lemmatization, Name Entity Recognition, etc.</p>

<p>The training script is:</p>

<pre><code>// Initializing the training data from Resources folder.
let trainingDataPath = Bundle.main.path(forResource: "slotParsingFile", ofType: "json", inDirectory: "Data/text/train")!
let trainingData = try! MLDataTable(contentsOf:  URL(fileURLWithPath: trainingDataPath))

// Initializing the classifier with a training data.
let classifier = try! MLWordTagger(trainingData: trainingData, tokenColumn: "tokens", labelColumn: "labels")

// Evaluating training &amp; validation accuracies.
let trainingAccuracy = (1.0 - classifier.trainingMetrics.taggingError) * 100
let validationAccuracy = (1.0 - classifier.validationMetrics.taggingError) * 100

// Initializing the properly labeled testing data from Resources folder.
let testingDataPath = Bundle.main.path(forResource: "slotParsingFile", ofType: "json", inDirectory: "Data/text/test")!
let testingData = try! MLDataTable(contentsOf: URL(fileURLWithPath:testingDataPath))

// Counting the testing evaluation.
let evaluationMetrics = classifier.evaluation(on: testingData)
let evaluationAccuracy = (1.0 - evaluationMetrics.taggingError) * 100

// Confusion matrix in order to see which labels were classified wrongly.
let confusionMatrix = evaluationMetrics.confusion
print("Confusion matrix: \(confusionMatrix)")

// Metadata for saving the model.
let metadata = MLModelMetadata(author: "Hongchao Zhang",
                                shortDescription: "A model trained to parse slots from weather related commands.",
                                version: "1.0")

// Saving the model. Remember to update the path.
try! classifier.write(to: URL(fileURLWithPath: "/Users/hozhang/Downloads/slotParsing.mlmodel"),
                        metadata: metadata)
</code></pre>

<p>We can get 99.64% training accuracy and 98.38% validation accuracy.</p>

<p><a id="markdown-model-usage-1" name="model-usage-1"></a></p>

<h4>Model Usage</h4>

<p>We can load the mlmodel into an NLTagger (from NatrualLanguage framework), and use the NLTagger to tag labels for each word of the input command text. The demo swift script is like:</p>

<pre><code>let weatherTagSchema = NLTagScheme("Weather")
let modelUrl = Bundle.main.url(forResource: "Data/text/slotParsing", withExtension: "mlmodel")
let compiledModelUrl = try! MLModel.compileModel(at: modelUrl!)
let taggerModel = try! NLModel(contentsOf: compiledModelUrl)

let weatherTagger = NLTagger(tagSchemes: [weatherTagSchema])
weatherTagger.setModels([taggerModel], forTagScheme: weatherTagSchema)

let text = requestText
weatherTagger.string = text
weatherTagger.enumerateTags(in: text.startIndex..&lt;text.endIndex, unit: .word, scheme: weatherTagSchema, options: []) { (tag, tokenRange) -&gt; Bool in
    if let tag = tag, tag.rawValue != "Whitespace" {
        print("\(text[tokenRange]): \(tag.rawValue)")
    }
    return true
}
</code></pre>

<p><strong> Reference </strong></p>

<ol>
<li><a href="https://developer.apple.com/documentation/createml/creating_a_text_classifier_model">Creating a Text Classifier Model</a>: Apple offical site for training and using machine learning models through CreateML framework.</li>
<li>WWDC video <a href="https://developer.apple.com/videos/play/wwdc2018/713/">Introducing Natural Language Framework</a>: This session introduces NLP framework and its relation with CreateML framework.</li>
</ol>


<p><a id="markdown-model-size" name="model-size"></a></p>

<h3>Model Size</h3>

<p>For the iOS app, we hope the machine learning model size is small enough. Apple&rsquo;s NatrualLanguage framework has done many optimizations on machine learning model size. The following data is from WWDC 2018 (session 713: Introducing NatrualLanguage Framework):</p>

<table>
<thead>
<tr>
<th>&ndash; </th>
<th> Open Source CRFSuite </th>
<th> Natural Language Framework</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name Entity Recognition </td>
<td> 70MB  </td>
<td> 1.4MB</td>
</tr>
<tr>
<td>Chunking </td>
<td> 30MB </td>
<td> 1.8MB</td>
</tr>
</tbody>
</table>


<p>We can see that the model will be much smaller than that trained from an open source platform.</p>

<p>The size of the two models we trained is (The training data size is: 3282):</p>

<table>
<thead>
<tr>
<th>Model </th>
<th> Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>Intent Classification </td>
<td> 41K</td>
</tr>
<tr>
<td>Slot Filling </td>
<td> 609K</td>
</tr>
</tbody>
</table>


<p>If your model is a neural network, you can reduce the size of your model by the following way:
<a href="https://developer.apple.com/documentation/coreml/reducing_the_size_of_your_core_ml_app">Reducing the Size of Your Core ML App</a>. You can control the precision of the neural network parameters, and thus the size of the trained model.</p>

<p>If still your model is large, you can
<a href="https://developer.apple.com/documentation/coreml/core_ml_api/downloading_and_compiling_a_model_on_the_user_s_device">Downloading and Compiling a Model on the User&rsquo;s Device</a> at runtime.</p>

<p><a id="markdown-problems-to-be-solved" name="problems-to-be-solved"></a></p>

<h3>Problems to Be Solved</h3>

<p>For Probabilistic Intent Parser, we still have some problems.</p>

<p><a id="markdown-intent-classification-model-has-no-probability-output" name="intent-classification-model-has-no-probability-output"></a></p>

<h4>Intent Classification Model Has No Probability Output</h4>

<p>We may need the probability to define the reliability of the estimated intent of an input command text.</p>

<p>However, the model trained through <code>MLTextClassifier</code> has no probability output API. If we really need the probability output, we can use other platforms to train the model, like tensorflow. That way, we will not benefit from NatrualLanguage framework and we need to consider these things by ourselves, like Tokenization, Part of Speech, Lemmatization, etc.</p>

<blockquote><p>Try other tools for training models with probability output, like Turi.</p></blockquote>

<p><a id="markdown-slot-filling-model-tagges-the-label-by-words-not-phrase" name="slot-filling-model-tagges-the-label-by-words-not-phrase"></a></p>

<h4>Slot Filling Model Tagges the Label by Words, not Phrase</h4>

<p>The NLTagger class only supply the following four tag level: word, sentence, paragraph, and document. There is no &ldquo;phrase&rdquo; tag level. For example, &ldquo;New York&rdquo; will be treated as &ldquo;New&rdquo; and &ldquo;York&rdquo;, and the tagged label will both be &ldquo;location&rdquo;. We need to compose them together manually.</p>
]]></content>
  </entry>
  
</feed>
