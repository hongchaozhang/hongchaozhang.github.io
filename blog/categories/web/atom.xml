<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Web | Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/web/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2018-01-30T18:08:12+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Javascript Interview Questions]]></title>
    <link href="http://hongchaozhang.github.io/blog/2018/01/30/javascript-interview-questions/"/>
    <updated>2018-01-30T17:58:11+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2018/01/30/javascript-interview-questions</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>use strict</h2>

<p>What are the benefits of including 'use strict' at the beginning of a JavaScript source file?
在严格模式(&lsquo;use strict&rsquo;)下进行 JavaScript 开发有神马好处？</p>

<ol>
<li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的Javascript做好铺垫。</li>
</ol>


<h2>请指出以下代码的区别：function Person(){}、var person = Person()、var person = new Person()？</h2>

<h2>解释 function foo() {} 与 var foo = function() {} 用法的区别</h2>

<p>Refer to <a href="https://libuchao.com/2012/06/25/function-declaration-vs-function-expression">函数声明 VS 函数表达式</a>.</p>

<pre><code class="javascript">// 方法一：函数声明
function foo() {}

// 方法二：函数表达式
var foo = function () {};
</code></pre>

<p>方法一和方法二都创建了一个函数，且命名为 foo，但是二者还是有区别的。JavaScript 解释器中存在一种变量声明被<strong>提升</strong>（hoisting）的机制，也就是说变量（函数）的声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被<strong>提升</strong>至最前面。</p>

<p>例如以下代码段：</p>

<pre><code class="javascript">alert(foo); // function foo() {}
alert(bar); // undefined
function foo() {}
var bar = function bar_fn() {};
alert(foo); // function foo() {}
alert(bar); // function bar_fn() {}
</code></pre>

<p>JavaScript引擎执行以上代码的顺序可能是这样的：</p>

<ol>
<li>创建变量 foo 和 bar，并将它们都赋值为 undefined。</li>
<li>创建函数 foo 的函数体，并将其赋值给变量 foo。</li>
<li>执行前面的两个 alert。</li>
<li>创建函数 bar_fn，并将其赋值给 bar。</li>
<li>执行后面的两个 alert。</li>
</ol>


<h2>setTimeout() and  closure</h2>

<p>Refer to <a href="http://web.jobbole.com/90954/">80% 应聘者都不及格的 JS 面试题</a>.</p>

<ol>
<li>基本问题：</li>
</ol>


<p>下面程序的输出是什么？</p>

<pre><code class="javascript">for (var i = 0; i &lt; 5; i++) {
    setTimeout(function() {
        console.log(i);
    }, 1000);
}
 
console.log(i);
</code></pre>

<p>答案：5 -> 5,5,5,5,5，即第1个5直接输出，1秒之后，输出5个5；</p>

<ol>
<li>拓展</li>
</ol>


<p>如果期望代码的输出变成：5 -> 0,1,2,3,4，该怎么改造代码？请用闭包实现。</p>

<pre><code class="javascript">for (var i = 0; i &lt; 5; i++) {
    (function(j) {  // j = i
        setTimeout(function() {
            console.log(j);
        }, 1000);
    })(i);
}
 
console.log(i);
</code></pre>

<h2>reflow(回流) and repaint(重绘)</h2>

<p>引起reflow的原因，如何避免reflow？Refer to <a href="http://harttle.land/2015/08/11/reflow-repaint.html">减少页面回流与重绘（Reflow &amp; Repaint）</a>.</p>

<p>offsetWidth引起reflow</p>

<h2>NaN</h2>

<p><strong>问题</strong></p>

<p>神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?</p>

<p><strong>答案</strong></p>

<p>NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，其类型是 <code>Number</code>，可以通过 <code>isNaN(param)</code> 来判断一个值是否是 NaN：</p>

<pre><code class="javascript">console.log(isNaN(NaN)); //true
console.log(isNaN(23)); //false
console.log(isNaN('ds')); //true
console.log(isNaN('32131sdasd')); //true
console.log(NaN === NaN); //false
console.log(NaN === undefined); //false
console.log(undefined === undefined); //false
console.log(typeof NaN); //number
console.log(Object.prototype.toString.call(NaN)); //[object Number]
</code></pre>

<h2>Hybrid Mobile性能问题，交互问题</h2>

<h2>数组的插入</h2>

<p>对数组进行下面两个操作，时间和空间复杂度分别是多少？
- inset(at index: Int) 时间复杂度O(n)
- append(element) 时间复杂度O(1)</p>

<p>参考Swift关于Array.append方法效率的说明<a href="https://developer.apple.com/documentation/swift/array">Growing the Size of an Array</a></p>

<p>Every array reserves a specific amount of memory to hold its contents. When you add elements to an array and that array begins to exceed its reserved capacity, the array allocates a larger region of memory and copies its elements into the new storage. The new storage is a multiple of the old storage’s size. This exponential growth strategy means that appending an element happens in constant time, averaging the performance of many append operations. Append operations that trigger reallocation have a performance cost, but they occur less and less often as the array grows larger.</p>

<p>If you know approximately how many elements you will need to store, use the reserveCapacity(_:) method before appending to the array to avoid intermediate reallocations. Use the capacity and count properties to determine how many more elements the array can store without allocating larger storage.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Https工作过程]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/12/29/https-workflow/"/>
    <updated>2015-12-29T16:21:19+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/12/29/https-workflow</id>
    <content type="html"><![CDATA[<p>摘录在此，备忘。</p>

<p>HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。</p>

<p>具体的加密过程看下图：</p>

<!-- more -->


<p><img src="/images/https-workflow.png" alt="https-workflow" /></p>

<ol>
<li><p>客户端发起HTTPS请求</p>

<p> 用户在浏览器里输入一个https网址，然后连接到server的443端口。</p></li>
<li><p>服务端的配置</p>

<p> 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p></li>
<li><p>传送证书</p>

<p> 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p></li>
<li><p>客户端解析证书</p>

<p> 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p></li>
<li><p>传送加密信息</p>

<p> 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p></li>
<li><p>服务段解密信息</p>

<p> 服务端用自己的私钥解密后，得到了客户端传过来的随机值，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和随机值通过某种算法混合在一起，这样除非知道随机值，不然无法获取内容，而正好客户端和服务端都知道这个随机值，所以只要加密算法够彪悍，这个随机值够复杂，数据就够安全。</p></li>
<li><p>传输加密后的信息</p>

<p> 这部分信息是服务段用客户端传过来的随机值加密后的信息，可以在客户端被还原。</p></li>
<li><p>客户端解密信息</p>

<p> 客户端用之前生成的随机值解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p></li>
</ol>


<h3>References</h3>

<p><del>https的基本概念，请参考</del><a href="http://www.cnblogs.com/P_Chou/archive/2010/12/27/https-ssl-certification.html"><del>浅谈https\ssl\数字证书</del></a></p>

<p>https的传输过程，请参考：<a href="http://www.jb51.net/network/68135.html">图解HTTPS协议加密解密全过程</a></p>

<p>https/http/get/post: 请参考<a href="http://cuishen.iteye.com/blog/2019925">http https get post 的区别，定义/安全性/性能</a>和<a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html">浅谈HTTP中Get与Post的区别</a></p>

<p>其实百度百科中关于<a href="http://baike.baidu.com/view/14121.htm">https</a>的解释也是十分清楚了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Font Size in Html - Px, Em, Rem]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/08/03/Font-size-in-Html/"/>
    <updated>2015-08-03T00:00:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/08/03/Font-size-in-Html</id>
    <content type="html"><![CDATA[<p>Refer <a href="http://snook.ca/archives/html_and_css/font-size-with-rem">here</a></p>

<p>Three units of measurements to size the text in html files to discuss:</p>

<ol>
<li>px</li>
<li>em</li>
<li>rem</li>
</ol>


<!-- more -->


<h2>Sizing with <code>px</code></h2>

<p><code>px</code> has some problems with IE of versions earlier then IE9 when changing text size with browser function.</p>

<h2>Sizing with <code>em</code></h2>

<p>To solve the issue in IE, we can use <code>em</code> instead. See <a href="http://clagnut.com/blog/348/">here</a> for more details. The <code>em</code> way modifies the base font size on the <code>body</code> using a percentage.</p>

<p>However, there is a <strong>font size compounds</strong> problem for this em-based sizing. That is, if you set <code>li { font-size:1.4em }</code>, the <code>li</code> element inside another <code>li</code> element will become bigger. Guess[<strong>TODO</strong>]: the base font size is not on the body, it is on the <code>li</code> element outside.</p>

<h2>Sizing with <code>rem</code></h2>

<p>The em unit is relative to the font-size of the parent, which causes the compounding issue. The rem unit is relative to the root—or the html—element. That means that we can define a single font size on the html element and define all rem units to be a percentage of that. (Comming from the <a href="http://snook.ca/archives/html_and_css/font-size-with-rem">reference</a>)</p>
]]></content>
  </entry>
  
</feed>
