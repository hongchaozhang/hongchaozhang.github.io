<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web | Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/web/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2024-03-25T00:27:25+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Learning Note 2023]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/09/15/react-learning-note-2023/"/>
    <updated>2023-09-15T17:33:08+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/09/15/react-learning-note-2023</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#react-state-is-updated-in-a-batch">React state is updated in a “batch”</a></li>
<li><a href="#update-react-state-with-a-new-object-do-not-mute-existing-one">Update react state with a new object, do not mute existing one</a></li>
<li><a href="#declarative-ui">Declarative UI</a></li>
<li><a href="#react-redux">React-redux</a></li>
<li><a href="#hooks">Hooks</a></li>
<li><a href="#react%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F">React中的变量</a></li>
<li><a href="#useeffect">useEffect</a>

<ul>
<li><a href="#clean-up-function">clean up function</a></li>
</ul>
</li>
<li><a href="#usememo">useMemo</a></li>
<li><a href="#two-ways-to-store-previous-props">two ways to store previous props</a>

<ul>
<li><a href="#useref">useRef</a></li>
<li><a href="#usestate">useState</a></li>
</ul>
</li>
<li><a href="#fetch-data%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98">fetch data的两个问题</a>

<ul>
<li><a href="#race-condition">race condition</a></li>
<li><a href="#undo">undo</a></li>
</ul>
</li>
<li><a href="#effect-event">Effect Event</a>

<ul>
<li><a href="#what-is-reactive">what is reactive</a></li>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution:</a></li>
<li><a href="#supress-react-lint-error">Supress react lint error</a></li>
</ul>
</li>
<li><a href="#how-to-review-effect-dependencies">How to review effect dependencies</a>

<ul>
<li><a href="#ways-to-review-and-fix-this">ways to review and fix this</a></li>
</ul>
</li>
<li><a href="#object-and-function-compare">Object and function compare</a></li>
<li><a href="#usememo-and-usecallback">useMemo and useCallback</a></li>
<li><a href="#forwardref">forwardRef</a>

<ul>
<li><a href="#useref-1">useRef</a></li>
<li><a href="#basic-concepts">basic concepts</a></li>
<li><a href="#expose-dom-node">expose dom node</a></li>
<li><a href="#expose-an-object">expose an object</a></li>
</ul>
</li>
<li><a href="#custom-hook">Custom Hook</a></li>
<li><a href="#strict-mode">strict mode</a></li>
<li><a href="#other-rules">Other Rules</a>

<ul>
<li><a href="#data-from-parent-to-child">data from parent to child</a></li>
<li><a href="#usesyncexternalstore">useSyncExternalStore</a></li>
<li><a href="#useeffect-dependencies">useEffect dependencies</a></li>
</ul>
</li>
</ul>


<h2>React state is updated in a “batch”</h2>

<p>This means that you can not get the state immediately after you change it.</p>

<p>number will be 1 after one click:
<code>
export default function Counter() {
  const [number, setNumber] = useState(0);
  return (
    &lt;&gt;
      &lt;h1&gt;{number}&lt;/h1&gt;
      &lt;button onClick={() =&gt; {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}&gt;+3&lt;/button&gt;
    &lt;/&gt;
  )
}
</code>
To make the number to be 3, pass a update function to the setNumber function. An update function will be queued and executed later.
<code>
export default function Counter() {
  const [number, setNumber] = useState(0);
  return (
    &lt;&gt;
      &lt;h1&gt;{number}&lt;/h1&gt;
      &lt;button onClick={() =&gt; {
        setNumber(n =&gt; n + 1);
        setNumber(n =&gt; n + 1);
        setNumber(n =&gt; n + 1);
      }}&gt;+3&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></p>

<h2>Update react state with a new object, do not mute existing one</h2>

<p>Use <code>…</code> , the object spread operator:
<code>
setPerson({
  ...person, // Copy the old fields
  firstName: e.target.value // But override this one
});
</code>
Note that spread syntax is shallow: it only copies one level deep. To update nested object:
<code>
setPerson({
  ...person, // Copy other fields
  artwork: { // but replace the artwork
    ...person.artwork, // with the same one
    city: 'New Delhi' // but in New Delhi!
  }
});
</code>
For updating array object:
<code>
setArtists([
  { id: nextId++, name: name },
  ...artists // Put old items at the end
]);
</code>
<code>Immer</code> is a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you.
<code>
updatePerson(draft =&gt; {
  draft.artwork.city = 'Lagos';
});
</code>
Using <code>Immer</code> for array:
<code>
updateMyTodos(draft =&gt; {
  const artwork = draft.find(a =&gt; a.id === artworkId);
  artwork.seen = nextSeen;
});
</code></p>

<h2>Declarative UI</h2>

<ul>
<li>Declarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).</li>
<li>When developing a component, Think in declarative UI way:

<ol>
<li>Identify all its visual states.</li>
<li>Determine the human and computer triggers for state changes.</li>
<li>Model the state with useState.</li>
<li>Remove non-essential state to avoid bugs and paradoxes.</li>
<li>Connect the event handlers to set state.</li>
</ol>
</li>
</ul>


<h2>React-redux</h2>

<ul>
<li>useReducer+useContext?</li>
<li>Provider</li>
<li>Context</li>
</ul>


<h2>Hooks</h2>

<ul>
<li>useContext: 跨层传输props，不用一层一层传下去</li>
<li>useEffect: Use them to synchronize your component with a system outside of React.</li>
</ul>


<h2>React中的变量</h2>

<ul>
<li>Props：immutable, 触发rerender，不记忆(retained by component)</li>
<li>State：immutable, 触发rerender，记忆(retained by React)</li>
<li>useRef：mutable, 不触发rerender，记忆(retained by React)</li>
</ul>


<h2>useEffect</h2>

<p>Effects let you specify side effects that are caused by rendering itself, rather than by a particular event.</p>

<p>Effects run at the end of a <em>commit</em> after the screen updates. That is, useEffect “delays” a piece of code from running until that render is reflected on the screen.</p>

<h3>clean up function</h3>

<p>You can use a clean up function to clean up the effect. For example, if you subscribe to an external data source, you can unsubscribe it in the clean up function.
```
useEffect(() => {
  const connection = createConnection();
  connection.connect();
  return () => {
    connection.disconnect();
  };
}, []);</p>

<p>useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener(&lsquo;scroll&rsquo;, handleScroll);
  return () => window.removeEventListener(&lsquo;scroll&rsquo;, handleScroll);
}, []);
```
<strong>React will call your cleanup function each time before the next Effect runs again, and one final time when the component unmounts (gets removed).</strong>
That is, the cleanup function runs not only during unmount, but before every re-render with changed dependencies.</p>

<h2>useMemo</h2>

<p>useMemo和useEffect都可以加依赖，但是useMemo在render过程起作用，而useEffect在commit之后起作用。
所以，如果是render依赖的变量值，用useMemo，不用useEffect+useState。</p>

<p>不推荐：
<code>
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // 🔴 Avoid: redundant state and unnecessary Effect
  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() =&gt; {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);
  // ...
}
</code>
推荐：
<code>
import { useMemo, useState } from 'react';
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  const visibleTodos = useMemo(() =&gt; {
    // ✅ Does not re-run unless todos or filter change
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);
  // ...
}
</code></p>

<h2>two ways to store previous props</h2>

<h3>useRef</h3>

<p><code>prevProps</code> updates after render:
<code>
  const prevProps = useRef();
  useEffect(() =&gt; {
    prevProps.current = props;
  }, [props]);
</code></p>

<h3>useState</h3>

<p><code>prevItems</code> is ready when render:
<code>
  const [prevItems, setPrevItems] = useState(items);
  if (items !== prevItems) {
    setPrevItems(items);
  }
</code></p>

<h2>fetch data的两个问题</h2>

<h3>race condition</h3>

<p>输入特别快的时候，很多search的request连续发出，不能保证回来的顺序，会出问题。
解决方法：给useEffect提供cleanup函数解决
```
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);
  useEffect(() => {
    let ignore = false;
    fetchResults(query, page).then(json => {
      if (!ignore) {
        setResults(json);
      }
    });
    return () => {
      ignore = true;
    };
  }, [query, page]);</p>

<p>  function handleNextPageClick() {
    setPage(page + 1);
  }
  // &hellip;
}
```</p>

<h3>undo</h3>

<p>没看懂：<a href="https://react.dev/learn/you-might-not-need-an-effect#fetching-data">https://react.dev/learn/you-might-not-need-an-effect#fetching-data</a></p>

<h2>Effect Event</h2>

<h3>what is reactive</h3>

<p>variables which can change due to a re-render
* Logic inside event handlers (or Effect Event) is not reactive.
* Logic inside Effects is reactive.</p>

<h3>Problem</h3>

<pre><code>function ChatRoom({ roomId, theme }) {
  useEffect(() =&gt; {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () =&gt; {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () =&gt; {
      connection.disconnect()
    };
  }, [roomId, theme]); // ✅ All dependencies declared
  // ...
</code></pre>

<p>When reconnected, a notification will be shown, and the notificaiton will consider the theme.
But when the theme changes, the notification will also be shown, which is not expected.</p>

<h3>Solution:</h3>

<p>Use Effect Event to separate this non-reactive logic from the reactive Effect around it.
```
function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification(&lsquo;Connected!&rsquo;, theme);
  });</p>

<p>  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on(&lsquo;connected&rsquo;, () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // &hellip;
```</p>

<p>You can think of Effect Events as being very similar to event handlers. The main difference is that event handlers run in response to a user interactions, whereas Effect Events are triggered by you from Effects. Effect Events let you “break the chain” between the reactivity of Effects and code that should not be reactive.</p>

<h3>Supress react lint error</h3>

<p>React linter ask you to add all reactive variables into the Effect dependencies.
Effect Events let you fix many patterns where you might be tempted to suppress the dependency linter.</p>

<h2>How to review effect dependencies</h2>

<p>Every time you adjust the Effect’s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is “no”:</p>

<ul>
<li>You might want to re-execute different parts of your Effect under different conditions.</li>
<li>You might want to only read the latest value of some dependency instead of “reacting” to its changes.</li>
<li>A dependency may change too often unintentionally because it’s an object or a function.</li>
</ul>


<h3>ways to review and fix this</h3>

<ul>
<li>Should this code move to an event handler?</li>
<li>Is your Effect doing several unrelated things?

<ul>
<li>If different parts of your Effect should re-run for different reasons, split it into several Effects.</li>
</ul>
</li>
<li>Are you reading some state to calculate the next state?

<ul>
<li>Use update function. Use <code>setMessages([...messages, receivedMessage])</code> instead of <code>setMessages(msgs =&gt; [...msgs, receivedMessage])</code></li>
</ul>
</li>
<li>In JavaScript, objects and functions are considered different if they were created at different times.</li>
<li>Try to avoid object and function dependencies. Move them outside the component or inside the Effect.

<ul>
<li>Move static objects and functions outside your component
```
function createOptions() {
return {
serverUrl: &lsquo;<a href="https://localhost:1234">https://localhost:1234</a>&rsquo;,
roomId: &lsquo;music&rsquo;
};
}</li>
</ul>
</li>
</ul>


<p>function ChatRoom() {
  const [message, setMessage] = useState(&lsquo;&rsquo;);</p>

<p>  useEffect(() => {
    const options = createOptions();
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []); // ✅ All dependencies declared
  // &hellip;
<code>
    * Move dynamic objects and functions inside your Effect
</code>
const serverUrl = &lsquo;<a href="https://localhost:1234">https://localhost:1234</a>&rsquo;;</p>

<p>function ChatRoom({ roomId }) {
  const [message, setMessage] = useState(&lsquo;&rsquo;);</p>

<p>  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // &hellip;
<code>
* Read primitive values from objects
</code>
function ChatRoom({ options }) {
  const [message, setMessage] = useState(&lsquo;&rsquo;);</p>

<p>  const { roomId, serverUrl } = options;
  useEffect(() => {
    const connection = createConnection({
      roomId: roomId,
      serverUrl: serverUrl
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // ✅ All dependencies declared
  // &hellip;
```</p>

<h2>Object and function compare</h2>

<pre><code>import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  // Temporarily disable the linter to demonstrate the problem
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const options = {
    serverUrl: serverUrl,
    roomId: roomId
  };

  useEffect(() =&gt; {
    const connection = createConnection(options);
    connection.connect();
    return () =&gt; connection.disconnect();
  }, [options]);

  return (
    &lt;&gt;
      &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;
      &lt;input value={message} onChange={e =&gt; setMessage(e.target.value)} /&gt;
    &lt;/&gt;
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    &lt;&gt;
      &lt;label&gt;
        Choose the chat room:{' '}
        &lt;select
          value={roomId}
          onChange={e =&gt; setRoomId(e.target.value)}
        &gt;
          &lt;option value="general"&gt;general&lt;/option&gt;
          &lt;option value="travel"&gt;travel&lt;/option&gt;
          &lt;option value="music"&gt;music&lt;/option&gt;
        &lt;/select&gt;
      &lt;/label&gt;
      &lt;hr /&gt;
      &lt;ChatRoom roomId={roomId} /&gt;
    &lt;/&gt;
  );
}
</code></pre>

<p>In the example above, the input only updates the message state variable. From the user’s perspective, this should not affect the chat connection. However, every time you update the message, your component re-renders. When your component re-renders, the code inside of it runs again from scratch.</p>

<p>A new options object is created from scratch on every re-render of the ChatRoom component. React sees that the options object is a different object from the options object created during the last render. This is why it re-synchronizes your Effect (which depends on options), and the chat re-connects as you type.</p>

<p>This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesn’t matter that the contents inside of them may be the same!</p>

<p>Object and function dependencies can make your Effect re-synchronize more often than you need.</p>

<p>This is why, whenever possible, you should try to avoid objects and functions as your Effect’s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them.</p>

<h2>useMemo and useCallback</h2>

<ul>
<li>useMemo caches the result of calling your function.</li>
<li>useCallback caches the function itself. React will not call your function.</li>
</ul>


<h2>forwardRef</h2>

<p>First, get familar with <code>useRef</code>:</p>

<h3>useRef</h3>

<p>ref.current is set during the <em>commit</em> process, not <em>render</em> process, so do not read or write ref.current during rendering. We can use ref.current in event handler or useEffect.</p>

<h3>basic concepts</h3>

<pre><code>const MyInput = forwardRef(function MyInput(props, ref) {
  return (
    &lt;label&gt;
      {props.label}
      &lt;input ref={ref} /&gt;
    &lt;/label&gt;
  );
});
</code></pre>

<p>The ref attribute passed by the parent component. The ref can be an object or a function. You should either
* pass the ref you receive to another component, or
* pass it to useImperativeHandle.</p>

<h3>expose dom node</h3>

<p>The parent <code>Form</code> component accesses the \<input\> DOM node exposed by <code>MyInput</code>.
```
import { forwardRef } from &lsquo;react&rsquo;;</p>

<p>const MyInput = forwardRef(function MyInput(props, ref) {
  const { label, &hellip;otherProps } = props;
  return (
    <label>
      {label}
      <input {...otherProps} ref={ref} />
    </label>
  );
});</p>

<p>function Form() {
  const ref = useRef(null);</p>

<p>  function handleClick() {
    ref.current.focus();
  }</p>

<p>  return (
    <form>
      <MyInput label="Enter your name:" ref={ref} />
      <button type="button" onClick={handleClick}>
        Edit
      </button>
    </form>
  );
}
```</p>

<h3>expose an object</h3>

<p>Use <code>useImperativeHandle</code> to expose an object referenced by <code>ref</code>:
```
import { forwardRef, useRef, useImperativeHandle } from &lsquo;react&rsquo;;</p>

<p>const MyInput = forwardRef(function MyInput(props, ref) {
  const inputRef = useRef(null);</p>

<p>  useImperativeHandle(ref, () => {
    return {
      focus() {
        inputRef.current.focus();
      },
      scrollIntoView() {
        inputRef.current.scrollIntoView();
      },
    };
  }, []);</p>

<p>  return <input {...props} ref={inputRef} />;
});
```</p>

<h2>Custom Hook</h2>

<p>You must follow these naming conventions:</p>

<ul>
<li>React component names must start with a capital letter, like StatusBar and SaveButton. React components also need to return something that React knows how to display, like a piece of JSX.</li>
<li>Hook names must start with use followed by a capital letter, like useState (built-in) or useOnlineStatus (custom, like earlier on the page). Hooks may return arbitrary values.</li>
</ul>


<p>This convention guarantees that you can always look at a component and know where its state, Effects, and other React features might “hide”. For example, if you see a getColor() function call inside your component, you can be sure that it can’t possibly contain React state inside because its name doesn’t start with use. However, a function call like useOnlineStatus() will most likely contain calls to other Hooks inside!</p>

<p>If your linter is configured for React, it will enforce this naming convention.</p>

<p>Note that custom Hooks only share stateful logic, not state itself.</p>

<h2>strict mode</h2>

<p><StrictMode> lets you find common bugs in your components early during development.</p>

<p>Strict Mode enables the following development-only behaviors:
* Your components will re-render an extra time to find bugs caused by impure rendering.
* Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.
* Your components will be checked for usage of deprecated APIs.</p>

<h2>Other Rules</h2>

<h3>data from parent to child</h3>

<p>When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, and pass it down to the child.
This is simpler and keeps the data flow predictable: the data flows down from the parent to the child.</p>

<h3>useSyncExternalStore</h3>

<h3>useEffect dependencies</h3>

<p>All variables from the component body used by the Effect should be in the Effect dependency list. However, you could instead “prove” to the linter that these values aren’t reactive values, i.e. that they can’t change as a result of a re-render. For example, if serverUrl and roomId don’t depend on rendering and always have the same values, you can move them outside the component. Now they don’t need to be dependencies:
```
const serverUrl = &lsquo;<a href="https://localhost:1234">https://localhost:1234</a>&rsquo;; // serverUrl is not reactive
const roomId = &lsquo;general&rsquo;; // roomId is not reactive</p>

<p>function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ✅ All dependencies declared
  // &hellip;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重学前端-通过window属性了解协议API]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/10/08/chongxueqianduan-tongguo-window-liaojie-protocol-api/"/>
    <updated>2022-10-08T17:18:04+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/10/08/chongxueqianduan-tongguo-window-liaojie-protocol-api</id>
    <content type="html"><![CDATA[<!-- more -->


<p>浏览器的API数目繁多，这一节课，我设计了一个实验，我们一起来给API分分类。</p>

<p>我们按照每个API所在的标准来分类。所以，我们用代码来反射浏览器环境中全局对象的属性，然后我们用JavaScript的filter方法来逐步过滤掉已知的属性。</p>

<p>接下来，我们整理API的方法如下：</p>

<ol>
<li>从Window的属性中，找到API名称；</li>
<li>查阅MDN或者Google，找到API所在的标准；</li>
<li>阅读标准，手工或者用代码整理出标准中包含的API；</li>
<li>用代码在Window的属性中过滤掉标准中涉及的API。</li>
<li>重复这个过程，我们可以找到所有的API对应的标准。</li>
</ol>


<p>原文点击<a href="/assets/resources/37%E4%B8%A8%E6%B5%8F%E8%A7%88%E5%99%A8API%EF%BC%88%E5%B0%8F%E5%AE%9E%E9%AA%8C%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%89%8B%E6%95%B4%E7%90%86%E5%85%A8%E9%83%A8API.html">这里</a>获取。</p>

<p>从原文整理出来的html文件点击<a href="/assets/resources/traverseWindows.html">这里</a>获取。</p>

<p>关键js代码如下：</p>

<pre><code>function filterOut(names, props) {
    let set = new Set();
    props.forEach(o =&gt; set.add(o));
    return names.filter(e =&gt; !set.has(e));
}

let names = Object.getOwnPropertyNames(window)
console.log(names)

// 过滤JavaScript 标准规定的属性
let js = new Set();
let objects = ["BigInt", "BigInt64Array", "BigUint64Array", "Infinity", "NaN", "undefined", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "Array", "Date", "RegExp", "Promise", "Proxy", "Map", "WeakMap", "Set", "WeakSet", "Function", "Boolean", "String", "Number", "Symbol", "Object", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray", "Atomics", "JSON", "Math", "Reflect", "escape", "unescape"];
objects.forEach(o =&gt; js.add(o));
names = names.filter(e =&gt; !js.has(e));
console.log('\nnames after filtering JS Standard:')
console.log(names)

// 接下来我们看看已经讲过的 DOM 部分，DOM 部分包含了 document 属性和一系列的构造器，我们可以用 JavaScript 的 prototype 来过滤构造器。
names = names.filter( e =&gt; {
    try { 
        return !(window[e].prototype instanceof Node)
    } catch(err) {
        return true;
    }
}).filter( e =&gt; e != "Node")
console.log('\nnames after filtering DOM:')
console.log(names)

// 接下来我们要找到 Window 对象的定义，我们在下面链接中可以找到。https://html.spec.whatwg.org/#window 这里有一个 Window 接口，是使用 WebIDL 定义的，我们手工把其中的函数和属性整理出来
let windowprops = new Set();
objects = ["window", "self", "document", "name", "location", "history", "customElements", "locationbar", "menubar", " personalbar", "scrollbars", "statusbar", "toolbar", "status", "close", "closed", "stop", "focus", " blur", "frames", "length", "top", "opener", "parent", "frameElement", "open", "navigator", "applicationCache", "alert", "confirm", "prompt", "print", "postMessage", "console"];
objects.forEach(o =&gt; windowprops.add(o));
names = names.filter(e =&gt; !windowprops.has(e));
console.log('\nnames after filtering WebIDL:')
console.log(names)

// 我们还要过滤掉所有的事件，也就是 on 开头的属性。
names = names.filter( e =&gt; !e.match(/^on/))
// webkit 前缀的私有属性我们也过滤掉：
names = names.filter( e =&gt; !e.match(/^webkit/))
// 除此之外，我们在 HTML 标准中还能找到所有的接口，这些我们也过滤掉：
let interfaces = new Set();
objects = ["ApplicationCache", "AudioTrack", "AudioTrackList", "BarProp", "BeforeUnloadEvent", "BroadcastChannel", "CanvasGradient", "CanvasPattern", "CanvasRenderingContext2D", "CloseEvent", "CustomElementRegistry", "DOMStringList", "DOMStringMap", "DataTransfer", "DataTransferItem", "DataTransferItemList", "DedicatedWorkerGlobalScope", "Document", "DragEvent", "ErrorEvent", "EventSource", "External", "FormDataEvent", "HTMLAllCollection", "HashChangeEvent", "History", "ImageBitmap", "ImageBitmapRenderingContext", "ImageData", "Location", "MediaError", "MessageChannel", "MessageEvent", "MessagePort", "MimeType", "MimeTypeArray", "Navigator", "OffscreenCanvas", "OffscreenCanvasRenderingContext2D", "PageTransitionEvent", "Path2D", "Plugin", "PluginArray", "PopStateEvent", "PromiseRejectionEvent", "RadioNodeList", "SharedWorker", "SharedWorkerGlobalScope", "Storage", "StorageEvent", "TextMetrics", "TextTrack", "TextTrackCue", "TextTrackCueList", "TextTrackList", "TimeRanges", "TrackEvent", "ValidityState", "VideoTrack", "VideoTrackList", "WebSocket", "Window", "Worker", "WorkerGlobalScope", "WorkerLocation", "WorkerNavigator"];
objects.forEach(o =&gt; interfaces.add(o));
names = names.filter(e =&gt; !interfaces.has(e));
console.log('\nnames after filtering HTML:')
console.log(names)

// 过滤i18n api
names = names.filter(e =&gt; e != "Intl")
console.log(names)

/* Streams 标准
    接下来我看到的属性是： ByteLengthQueuingStrategy。
    同样经过查阅，它来自 WHATWG 的 Streams 标准：
    https://streams.spec.whatwg.org/#blqs-class
*/
names = filterOut(names, ["ReadableStream", "ReadableStreamDefaultReader", "ReadableStreamBYOBReader", "ReadableStreamDefaultController", "ReadableByteStreamController", "ReadableStreamBYOBRequest", "WritableStream", "WritableStreamDefaultWriter", "WritableStreamDefaultController", "TransformStream", "TransformStreamDefaultController", "ByteLengthQueuingStrategy", "CountQueuingStrategy"]);
console.log(names)

/*
    接下来我看到的属性是：WebGLContext​Event。
    显然，这个属性来自 WebGL 标准：
    https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15
*/
names = filterOut(names, ["WebGLContextEvent","WebGLObject", "WebGLBuffer", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLTexture", "WebGLUniformLocation", "WebGLActiveInfo", "WebGLShaderPrecisionFormat", "WebGLRenderingContext"]);
console.log(names)

/*
    Web Audio API
    下一个属性是 WaveShaperNode。这个属性名听起来就跟声音有关，这个属性来自 W3C 的 Web Audio API 标准。
    我们来看一下标准：
    https://www.w3.org/TR/webaudio/
*/
names = filterOut(names, ["AudioContext", "AudioNode", "AnalyserNode", "AudioBuffer", "AudioBufferSourceNode", "AudioDestinationNode", "AudioParam", "AudioListener", "AudioWorklet", "AudioWorkletGlobalScope", "AudioWorkletNode", "AudioWorkletProcessor", "BiquadFilterNode", "ChannelMergerNode", "ChannelSplitterNode", "ConstantSourceNode", "ConvolverNode", "DelayNode", "DynamicsCompressorNode", "GainNode", "IIRFilterNode", "MediaElementAudioSourceNode", "MediaStreamAudioSourceNode", "MediaStreamTrackAudioSourceNode", "MediaStreamAudioDestinationNode", "PannerNode", "PeriodicWave", "OscillatorNode", "StereoPannerNode", "WaveShaperNode", "ScriptProcessorNode", "AudioProcessingEvent"]);
console.log(names)

/*
    Encoding 标准
    在我的环境中，下一个属性是 TextDecoder，经过查阅得知，这个属性也来自一份 WHATWG 的标准，Encoding：
    https://encoding.spec.whatwg.org/#dom-textencoder
*/
names = filterOut(names, ["TextDecoder", "TextEncoder", "TextDecoderStream", "TextEncoderStream"]);
console.log(names)

/*
    Web Cryptography API
    我们继续看下去，下一个属性是 SubtleCrypto，这个属性来自 Web Cryptography API，也是 W3C 的标准。
    https://www.w3.org/TR/WebCryptoAPI/
    这份标准中规定了三个 Class 和一个 Window 对象的扩展，给 Window 对象添加了一个属性 crypto。
*/
names = filterOut(names, ["CryptoKey", "SubtleCrypto", "Crypto", "crypto"]);
console.log(names)

/*
    Media Source Extensions
    下一个属性是 SourceBufferList，它来自于：
    https://www.w3.org/TR/media-source/
    这份标准中包含了三个接口，这份标准还扩展了一些接口，但是没有扩展 window。
*/
names = filterOut(names, ["MediaSource", "SourceBuffer", "SourceBufferList"]);
console.log(names)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[web性能优化]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/03/21/web-xingneng-youhua/"/>
    <updated>2022-03-21T23:30:53+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/03/21/web-xingneng-youhua</id>
    <content type="html"><![CDATA[<!-- more -->


<p>从web渲染全过程分析，从下面几个方面进行性能优化考虑：</p>

<ol>
<li>HTTP请求性能优化</li>
<li>浏览器内渲染性能优化</li>
</ol>


<h2>HTTP(s)请求性能优化</h2>

<ul>
<li>参考极客时间课程《透视HTTP协议》的39和40两节课。</li>
<li>另外，<a href="/blog/2021/05/26/toushi-http-xieyi/">极客时间-罗剑锋-《透视HTTP协议》总结</a>中的章节<a href="/blog/2021/05/26/toushi-http-xieyi/#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">http性能优化</a>，有一个概括性的描述。</li>
<li>相关内容个人总结参考<a href="/blog/2022/03/08/http-xingneng-youhua/">HTTP(s)请求性能优化</a>。</li>
</ul>


<h2>浏览器内渲染性能优化</h2>

<ul>
<li>参考极客时间课程《让你页面速度飞起来 Web前端性能优化》</li>
<li>相关内容个人总结参考<a href="/blog/2022/01/04/web-qianduan-xingneng-youhua/">极客时间-Web前端性能优化</a>。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP(s)请求性能优化]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/03/08/http-xingneng-youhua/"/>
    <updated>2022-03-08T16:44:40+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/03/08/http-xingneng-youhua</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7">性能测试工具</a></li>
<li><a href="#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">HTTP性能优化</a>

<ul>
<li><a href="#%E5%BC%80%E6%BA%90">开源</a></li>
<li><a href="#%E8%8A%82%E6%B5%81">节流</a></li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="#%E5%8D%87%E7%BA%A7%E5%88%B0http2">升级到HTTP/2</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E8%B5%84%E6%BA%90%E5%90%88%E5%B9%B6">关于资源合并</a></li>
</ul>
</li>
<li><a href="#https%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">HTTPs性能优化</a>

<ul>
<li><a href="#1-%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96cpussl%E5%8A%A0%E9%80%9F%E5%8D%A1ssl%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1%E5%99%A8">1. 硬件优化：CPU，SSL加速卡，SSL加速服务器</a></li>
<li><a href="#2-%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96">2. 软件优化：</a></li>
</ul>
</li>
</ul>


<!-- /TOC -->


<p><a id="markdown-性能测试工具" name="性能测试工具"></a></p>

<h2>性能测试工具</h2>

<ol>
<li><p>在 Linux 上，最常用的性能测试工具可能就是 ab（Apache Bench）了，比如，下面的命令指定了并发数 100，总共发送 10000 个请求：</p>

<pre><code class="`"> ab -c 100 -n 10000 'http://www.xxx.com'
</code></pre></li>
<li><p>系统资源监控方面，Linux 自带的工具也非常多，常用的有 uptime、top、vmstat、netstat、sar 等等，可能你比我还要熟悉，我就列几个简单的例子吧：</p>

<pre><code class="`"> top             # 查看 CPU 和内存占用情况
 vmstat  2       # 每 2 秒检查一次系统状态
 sar -n DEV 2    # 看所有网卡的流量，定时 2 秒检查
</code></pre></li>
<li>之前讲 HTTPS 时介绍过一个专门的网站<a href="https://www.ssllabs.com/">SSLLabs</a>，而对于 HTTP 性能优化，也有一个专门的测试网站<a href="https://www.webpagetest.org/">WebPageTest</a>。它的特点是在世界各地建立了很多的测试点，可以任意选择地理位置、机型、操作系统和浏览器发起测试，非常方便，用法也很简单。网站测试的最终结果是一个直观的“瀑布图”（Waterfall Chart），清晰地列出了页面中所有资源加载的先后顺序和时间消耗。</li>
<li>Chrome 等浏览器自带的开发者工具也可以很好地观察客户端延迟指标，面板左边有每个 URI 具体消耗的时间，面板的右边也有瀑布图。</li>
</ol>


<p><a id="markdown-http性能优化" name="http性能优化"></a></p>

<h2>HTTP性能优化</h2>

<p><a id="markdown-开源" name="开源"></a></p>

<h3>开源</h3>

<ul>
<li>Nginx及相关配置</li>
<li>HTTP启用长连接
<a id="markdown-节流" name="节流"></a></li>
</ul>


<h3>节流</h3>

<ul>
<li>数据压缩：图片，json等</li>
<li>html/css/js的minify</li>
<li>去除不必要的Header属性</li>
<li>减少域名数量和重定向次数
<a id="markdown-缓存" name="缓存"></a></li>
</ul>


<h3>缓存</h3>

<ul>
<li>服务器缓存：Redis</li>
<li>CDN缓存
<a id="markdown-升级到http2" name="升级到http2"></a></li>
</ul>


<h3>升级到HTTP/2</h3>

<ul>
<li>消除了应用层的队头阻塞，拥有头部压缩、二进制帧、多路复用、流量控制、服务器推送等许多新特性，大幅度提升了 HTTP 的传输效率。
<a id="markdown-关于资源合并" name="关于资源合并"></a></li>
</ul>


<h3>关于资源合并</h3>

<ul>
<li>“资源合并”在 HTTP/1 里减少了多次请求的成本，但在 HTTP/2 里因为有头部压缩和多路复用，传输小文件的成本很低，所以合并就失去了意义。而且“资源合并”还有一个缺点，就是降低了缓存的可用性，只要一个小文件更新，整个缓存就完全失效，必须重新下载。</li>
<li>所以在现在的大带宽和 CDN 应用场景下，应当尽量少用资源合并（JS、CSS 图片合并，数据内嵌），让资源的粒度尽可能地小，才能更好地发挥缓存的作用。</li>
</ul>


<p><a id="markdown-https性能优化" name="https性能优化"></a></p>

<h2>HTTPs性能优化</h2>

<p><a id="markdown-1-硬件优化cpussl加速卡ssl加速服务器" name="1-硬件优化cpussl加速卡ssl加速服务器"></a></p>

<h3>1. 硬件优化：CPU，SSL加速卡，SSL加速服务器</h3>

<p><a id="markdown-2-软件优化" name="2-软件优化"></a></p>

<h3>2. 软件优化：</h3>

<ol>
<li>软件升级：Linux内核，Nginx，OpenSSL</li>
<li>协议优化：

<ul>
<li>TLS1.3</li>
<li>密钥交换协议尽量选用椭圆曲线ECDHE算法，能够把握手的消息往返由 2-RTT 减少到 1-RTT，达到与 TLS1.3 类似的效果。</li>
<li>Nginx配置密码套件和椭圆曲线，将优先使用的放在前面。</li>
</ul>
</li>
<li>证书优化：

<ul>
<li>CRL（Certificate revocation list，证书吊销列表）由 CA 定期发布，里面是所有被撤销信任的证书序号，查询这个列表就可以知道证书是否有效。</li>
<li>现在 CRL 基本上不用了，取而代之的是 OCSP（在线证书状态协议，Online Certificate Status Protocol），向 CA 发送查询请求，让 CA 返回证书的有效状态。</li>
<li>“OCSP Stapling”（OCSP 装订），它可以让服务器预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的时间。</li>
</ul>
</li>
<li>会话复用：

<ul>
<li>我们再回想一下 HTTPS 建立连接的过程：先是 TCP 三次握手，然后是 TLS 一次握手。这后一次握手的重点是算出主密钥“Master Secret”，而主密钥每次连接都要重新计算，未免有点太浪费了，如果能够把“辛辛苦苦”算出来的主密钥缓存一下“重用”，不就可以免去了握手和计算的成本了吗？</li>
<li>这种做法就叫“会话复用”（TLS session resumption），和 HTTP Cache 一样，也是提高 HTTPS 性能的“大杀器”，被浏览器和服务器广泛应用。</li>
<li>会话复用分两种

<ul>
<li>第一种叫“Session ID”：“Session ID”是最早出现的会话复用技术，也是应用最广的，但它也有缺点，服务器必须保存每一个客户端的会话数据，对于拥有百万、千万级别用户的网站来说存储量就成了大问题，加重了服务器的负担。</li>
<li>第二种叫“Session Ticket”：它有点类似 HTTP 的 Cookie，存储的责任由服务器转移到了客户端</li>
</ul>
</li>
<li>预共享密钥：

<ul>
<li>在发送 Ticket 的同时会带上应用数据（Early Data），免去了 1.2 里的服务器确认步骤，这种方式叫“Pre-shared Key”，简称为“PSK”。</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>上面的内容来自极客时间的《透视HTTP协议》课程的39和40两节课。
另外，<a href="/blog/2021/05/26/toushi-http-xieyi/">极客时间-罗剑锋-《透视HTTP协议》总结</a>中的章节<a href="/blog/2021/05/26/toushi-http-xieyi/#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">http性能优化</a>，有一个概括性的描述。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[极客时间-Web前端性能优化]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/01/04/web-qianduan-xingneng-youhua/"/>
    <updated>2022-01-04T18:06:29+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/01/04/web-qianduan-xingneng-youhua</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%90%88%E5%B9%B6">资源压缩与合并</a>

<ul>
<li><a href="#%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96">图片优化</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E9%A2%84%E5%8A%A0%E8%BD%BD">图片的懒加载预加载</a>

<ul>
<li><a href="#%E6%87%92%E5%8A%A0%E8%BD%BD">懒加载：</a></li>
<li><a href="#%E9%A2%84%E5%8A%A0%E8%BD%BD">预加载：</a></li>
</ul>
</li>
<li><a href="#html%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">HTML渲染过程</a></li>
<li><a href="#%E9%87%8D%E7%BB%98%E5%A4%96%E8%A7%82%E4%B8%8E%E5%9B%9E%E6%B5%81%E5%B8%83%E5%B1%80redrawreflow">重绘（外观）与回流（布局）redraw/reflow</a>

<ul>
<li><a href="#top-and-translate">top and translate</a></li>
<li><a href="#opacity%E6%9B%BF%E6%8D%A2visibility"><code>opacity</code>替换<code>visibility</code></a></li>
<li><a href="#css%E7%9A%84class%E6%9B%BF%E4%BB%A3style">css的class替代style</a></li>
<li><a href="#displaynone"><code>display:none</code></a></li>
<li><a href="#%E6%85%8E%E7%94%A8clientwidth">慎用<code>clientWidth</code></a></li>
<li><a href="#%E5%B0%91%E7%94%A8table%E5%B8%83%E5%B1%80">少用table布局。</a></li>
<li><a href="#%E5%8A%A8%E7%94%BB%E7%9A%84%E5%88%B7%E6%96%B0%E7%8E%87%E5%92%8C%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E5%B9%B3%E8%A1%A1">动画的刷新率和页面性能平衡</a></li>
<li><a href="#%E5%B0%86gif%E5%9B%BE%E5%8D%95%E7%8B%AC%E6%88%90%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%B1%82">将gif图单独成一个图层</a></li>
<li><a href="#%E5%90%AF%E7%94%A8gpu%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F">启用GPU硬件加速</a></li>
</ul>
</li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8">浏览器存储</a></li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93">服务器端渲染</a></li>
</ul>


<!-- /TOC -->


<p>总结极客时间课程《让你页面速度飞起来 Web前端性能优化》</p>

<p><a id="markdown-资源压缩与合并" name="资源压缩与合并"></a></p>

<h2>资源压缩与合并</h2>

<p>资源合并会减少请求次数，总体上降低请求时间。但是，也不能不加考虑地都合并到一起，这样会影响首页渲染速度。</p>

<p><a id="markdown-图片优化" name="图片优化"></a></p>

<h3>图片优化</h3>

<ol>
<li>图片<strong>雪碧图</strong>，不能太大，太大影响首屏渲染性能。一个页面的小图放在一起，生成一张雪碧图即可。</li>
<li><strong>inline image</strong>，inline image内嵌在html里面，作为html的一部分和html一起加载。当图片大小小于8KB时，考虑使用inline image。</li>
<li><strong>使用webp格式图片</strong>，webp格式图片由google推出，android平台支持好，apple safari浏览器有兼容性问题（2020年Mac OS Big Sur中的Safari 14已经支持WebP格式。）</li>
<li><strong>jpg</strong>、<strong>png</strong>、<strong>svg</strong>等图片格式各有其特点和应用场合。</li>
</ol>


<p>另附上两个工具软件：</p>

<ol>
<li><a href="https://tinypng.com">图片压缩网站</a></li>
<li><a href="www.spritecow.com">雪碧图生成网站</a></li>
</ol>


<p><a id="markdown-图片的懒加载预加载" name="图片的懒加载预加载"></a></p>

<h2>图片的懒加载预加载</h2>

<p><a id="markdown-懒加载" name="懒加载"></a></p>

<h3>懒加载：</h3>

<p>通过图片进入可视区域的时候再设置img的src属性，进行请求。或者通过库实现。</p>

<p><a id="markdown-预加载" name="预加载"></a></p>

<h3>预加载：</h3>

<ol>
<li>使用<code>image</code>标签引入，先设置<code>display:none</code>。需要显示的时候再通过设置<code>display</code>属性将其显示出来。</li>
<li>在js中<code>new image</code>，并且设置<code>image</code>的<code>src</code>，进行图片下载，保存在js的变量中，但是不显示，需要的时候直接拿过来显示即可。</li>
<li>使用<code>XMLHttpRequest</code>，可以清楚知道请求的过程，但是存在跨域的问题。</li>
<li>或者通过库实现：preloader.js</li>
</ol>


<p><a id="markdown-html渲染过程" name="html渲染过程"></a></p>

<h2>HTML渲染过程</h2>

<ol>
<li>顺序执行，并发加载：为了让资源并发加载，可以部署多个CDN，以突破浏览器对单个域名并发加载数量的限制（4-6个）。

<ol>
<li><a href="https://juejin.cn/post/6844904035628089357">突破浏览器域名并发限制的解决方案</a></li>
<li>浏览器为什么要有这个限制，针对这个限制我们在开发的时候怎么优化？参考<a href="https://segmentfault.com/a/1190000039157302">前端性能优化篇——浏览器同域名并发请求对限制</a></li>
</ol>
</li>
<li>css加载延迟，页面先显示出没有样式的内容，原因是：css没有在header中引入，而是通过其他方式加载，比如在js中加载css。但是在header中通过link加载css也有缺点：阻塞页面渲染和js执行，但是不阻塞外部脚本的加载（得益于webkit的预扫描功能），但是阻塞执行。</li>
<li><code>script</code>和<code>import</code>引入方式：<code>script</code>引入js是同步的，阻塞页面渲染。结合<code>differ</code>和<code>sync</code>标签影响js引入过程。不阻塞资源的加载（得益于webkit的预扫描功能）。</li>
<li>SPA：单页应用，动态加载，路由到相关页面再加载相关的资源。</li>
</ol>


<p><a id="markdown-重绘外观与回流布局redrawreflow" name="重绘外观与回流布局redrawreflow"></a></p>

<h2>重绘（外观）与回流（布局）redraw/reflow</h2>

<p>css性能让js变慢：css影响layout，进而产生重绘与回流。多次的重绘与回流使得UI线程多次工作，而UI线程的启动会阻塞js线程的执行。</p>

<p>下面是一些有关<strong>回流与重绘</strong>实战演练。通过观察Chrome的Performance调试工具分析渲染过程和性能瓶颈。截图如下：</p>

<p><img src="/images/chrome_performance_demo.jpg" alt="chrome_performance_demo.jpg" /></p>

<p><a id="markdown-top-and-translate" name="top-and-translate"></a></p>

<h3>top and translate</h3>

<p>相比于<code>top</code>，<code>translate</code>没有回流的过程，对于dom结构复杂的页面，性能提升比较明显。</p>

<p><details>
  <summary>Code using <code>top</code></summary></p>

<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;style&gt;
        #rect {
            position: relative;
            top: 0;
            width: 100px;
            height: 100px;
            background: blue;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="rect"&gt;&lt;/div&gt;
    &lt;script&gt;
        setTimeout(() =&gt; {
            document.getElementById("rect").style.top = "100px";
        }, 2000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p></details></p>

<p><details>
  <summary>Code using <code>transform</code></summary></p>

<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;style&gt;
        #rect {
            position: relative;
            transform: translateY(0);
            width: 100px;
            height: 100px;

            background: blue;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="rect"&gt;&lt;/div&gt;
    &lt;script&gt;
        setTimeout(() =&gt; {
            document.getElementById("rect").style.transform = "translateY(100px)";
        }, 2000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p></details></p>

<p><a id="markdown-opacity替换visibility" name="opacity替换visibility"></a></p>

<h3><code>opacity</code>替换<code>visibility</code></h3>

<p><code>opaciy</code>：如果被修改的dom元素自己是一个图层，不触发回流和重绘（试验结果：没有回流，但是有重绘）；否则，触发回流和重绘。
<code>visibility</code>：不触发回流，只触发重绘。</p>

<p><a id="markdown-css的class替代style" name="css的class替代style"></a></p>

<h3>css的class替代style</h3>

<p>多个dom样式通过class一次改动多条style属性，减少回流和重绘的次数</p>

<p><a id="markdown-displaynone" name="displaynone"></a></p>

<h3><code>display:none</code></h3>

<p>先设置<code>display</code>为<code>none</code>，再修改各种属性，再将<code>display</code>设回来。</p>

<p><a id="markdown-慎用clientwidth" name="慎用clientwidth"></a></p>

<h3>慎用<code>clientWidth</code></h3>

<p>不要在循环中获取dom的<code>clientWidth</code>，否则会flash掉浏览器的缓冲区，使浏览器性能下降。</p>

<p>缓冲区是浏览器的优化机制，将多个改动合并成一次改动，以便提高效率。</p>

<p><a id="markdown-少用table布局" name="少用table布局"></a></p>

<h3>少用table布局。</h3>

<p>修改某一<code>td</code>的宽度，会使得所有<code>td</code>进行回流。</p>

<p><a id="markdown-动画的刷新率和页面性能平衡" name="动画的刷新率和页面性能平衡"></a></p>

<h3>动画的刷新率和页面性能平衡</h3>

<p><a id="markdown-将gif图单独成一个图层" name="将gif图单独成一个图层"></a></p>

<h3>将gif图单独成一个图层</h3>

<p>通过设置某些css属性，将某个dom做成一个图层：</p>

<ol>
<li><code>will-change</code></li>
<li><code>transform: translateZ(0)</code></li>
<li><code>translate3d(0,0,0)</code></li>
</ol>


<p><a id="markdown-启用gpu硬件加速" name="启用gpu硬件加速"></a></p>

<h3>启用GPU硬件加速</h3>

<p>启用GPU加速，会减少重绘的时间，但是图层增多，图层合并的时间会增加，这里也有个平衡需要把握。</p>

<p>细节参考<a href="https://lz5z.com/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-CSS3%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/">Web 性能优化-CSS3 硬件加速(GPU 加速)</a></p>

<p><a id="markdown-浏览器存储" name="浏览器存储"></a></p>

<h2>浏览器存储</h2>

<ol>
<li>cdn域名和主站域名区分开，防止获取静态资源携带cookie，浪费带宽。</li>
<li>通过service worker开启另一个线程，和主页通过<code>postMessage</code>互相通信。</li>
<li>通过浏览器performance profile查看性能瓶颈和改进效果。</li>
<li>增加图层是减少的重绘与回流的时间与增加的图层合并时间的增加之间的平衡。比如通过设置translate3d开启GPU加速。</li>
<li>获取offsetHeight为什么会降低效率？使缓冲区域失效，因为要得到一个真实的尺寸。缓冲区域是浏览器的一个优化机制，通过将多次更改dom综合起来一次更新，提高效率。</li>
</ol>


<p><a id="markdown-缓存" name="缓存"></a></p>

<h2>缓存</h2>

<p><strong>强缓存</strong>
如果命中，不需要发请求到服务器。</p>

<ol>
<li>cache-control: max-age, s-max-age</li>
<li>expires:</li>
</ol>


<p><strong>协商缓存（弱缓存）</strong>
需要发请求到服务器询问本地缓存是否可用。如果可用，服务器返回304，不携带具体内容，具体内容从本地缓存中读取。如果不可用，服务器直接返回内容。</p>

<ol>
<li>last-modified:</li>
<li>if-modified-since: 304</li>
<li>e-tag:</li>
<li>if-none-match:</li>
</ol>


<p>浏览器缓存流程如下：</p>

<p><img src="/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="浏览器缓存流程图.png" /></p>

<p>关于缓存，下面两篇文章介绍的很清楚：</p>

<ol>
<li><a href="https://www.jiqizhixin.com/articles/2020-07-24-12">Web 缓存介绍</a></li>
<li><a href="https://segmentfault.com/a/1190000010787023">HTTP 缓存之浏览器刷新行为</a>: disable cache setting in the developper tool</li>
</ol>


<p><a id="markdown-服务器端渲染" name="服务器端渲染"></a></p>

<h2>服务器端渲染</h2>

<ol>
<li>vue-ssr (server-side-rendering)</li>
<li>react-ssr</li>
<li>代价：需要一个universal的code base，保证其在服务器端和浏览器端都能运行。</li>
</ol>

]]></content>
  </entry>
  
</feed>
