<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web | Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/web/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2025-04-11T00:23:23+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Babel工作原理]]></title>
    <link href="http://hongchaozhang.github.io/blog/2025/03/24/babel-workflow/"/>
    <updated>2025-03-24T23:20:31+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2025/03/24/babel-workflow</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Babel is a JavaScript compiler。
主要用于将 ECMAScript 2015+（ES6 及以上）的 JavaScript 代码转换成能够在当前和旧版浏览器环境中兼容运行的代码版本。</p>

<h1>配置</h1>

<p>Babel 的配置文件通常是<code>.babelrc.json</code>或<code>babel.config.json</code>，可以在其中配置需要使用的插件和预设:</p>

<pre><code>{
  "presets": [...],
  "plugins": [...]
}
</code></pre>

<p>甚至可以直接写在<code>package.json</code>中：</p>

<pre><code>{
  ...,
  "babel": {
    "presets": [...],
    "plugins": [...]
  },
  ...
}
</code></pre>

<p>更加灵活的，可以在<code>webpack.config.js</code>中访问 Node.js 的 APIs：</p>

<pre><code>module.exports = function (api) {
  api.cache(true);

  const presets = [ ... ];
  const plugins = [ ... ];

  if (process.env["ENV"] === "prod") {
    plugins.push(...);
  }

  return {
    presets,
    plugins
  };
}
</code></pre>

<h1>工作流程</h1>

<p><img src="/images/babel-workflow.png" alt="babel workflow" /></p>

<p>Babel 的编译过程与大多数编程语言的编译器类似，分为三个主要阶段：解析（Parsing）、转换（Transformation）和生成（Code Generation）</p>

<h2>解析（Parsing）</h2>

<p>这一阶段将代码字符串解析成抽象语法树（AST，Abstract Syntax Tree）<a href="https://developer.aliyun.com/article/1303957">2</a><a href="https://blog.csdn.net/ByteDanceTech/article/details/126900235">3</a>。AST 是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构<a href="https://developer.aliyun.com/article/1303957">2</a>。
解析过程又分为两个步骤：</p>

<ul>
<li>分词：将整个代码字符串分割成语法单元数组：tokenizer，keyword</li>
<li>语法分析：建立分析语法单元之间的关系<a href="https://developer.aliyun.com/article/1303957">2</a></li>
</ul>


<p>例如，一个简单的<code>console.log('zcy');</code>会被解析成包含程序结构、表达式语句、调用表达式等节点的 AST<a href="https://developer.aliyun.com/article/1303957">2</a>。</p>

<pre><code>{
  "type": "Program",
  "body": [
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "CallExpression",
        "callee": {
          "type": "MemberExpression",
          "computed": false,
          "object": {
            "type": "Identifier",
            "name": "console"
          },
          "property": {
            "type": "Identifier",
            "name": "log"
          }
        },
        "arguments": [
          {
          "type": "Literal",
          "value": "zcy",
          "raw": "'zcy'"
          }
        ]
      }
    }
  ],
  "sourceType": "script"
}
</code></pre>

<h2>转换（Transformation）</h2>

<p>这一阶段对 AST 进行转换操作<a href="https://developer.aliyun.com/article/1303957">2</a><a href="https://blog.csdn.net/ByteDanceTech/article/details/126900235">3</a>。转换通常通过 Babel plugin（插件）或者 preset（预设）实现，每个插件可以访问 AST 并对其进行修改，例如将箭头函数的节点转换为普通函数节点。</p>

<h3>plugin（插件）</h3>

<p>Babel 本身只是一个编译器，可以理解为一个框架，就像一个纯函数<code>const babel = code =&gt; code</code>一样，只负责解析然后生成代码。要实现具体的转换功能，需要添加和使用插件（plugins）。
例如，要将箭头函数转换为普通函数，可以使用官方提供的<code>@babel/plugin-transform-arrow-functions</code>插件<a href="https://www.xuwenchao.site/blogs/babel.html">1</a>。每个插件负责特定类型的语法转换，开发者可以根据需要添加相应的插件。</p>

<h3>presets（预设）</h3>

<p>如果要编译一个完整的应用，单独配置每个所需的插件会非常繁琐。为了解决这个问题，Babel 引入了 presets（预设）的概念<a href="https://www.xuwenchao.site/blogs/babel.html">1</a>。
presets 可以理解为 plugins 和部分配置的集合，使用预设可以避免单独配置每个 plugin 和参数，直接使用已经组合好的配置即可<a href="https://www.xuwenchao.site/blogs/babel.html">1</a>。常见的预设包括<code>@babel/preset-env</code>、<code>@babel/preset-react</code>等。</p>

<p>@babel/preset-env 包含以下插件：</p>

<ul>
<li>@babel/plugin-transform-template-literals</li>
<li>@babel/plugin-transform-literals</li>
<li>@babel/plugin-transform-function-name</li>
<li>@babel/plugin-transform-arrow-functions</li>
<li>@babel/plugin-transform-block-scoped-functions</li>
<li>@babel/plugin-transform-classes</li>
<li>@babel/plugin-transform-object-super</li>
</ul>


<p>@babel/preset-react 包含以下插件：</p>

<ul>
<li>@babel/plugin-syntax-jsx</li>
<li>@babel/plugin-transform-react-jsx</li>
<li>@babel/plugin-transform-react-display-name</li>
</ul>


<h2>生成（Code Generation）</h2>

<p>最后一个阶段是根据转换后的 AST 生成新的代码字符串。这一过程包括将 AST 中的每个节点映射回字符串形式，并生成源码映射（source maps）。</p>

<h1>结论</h1>

<p>Babel 作为现代前端开发的重要工具，为开发者提供了使用最新 JavaScript 特性的能力，同时保证了代码在各种浏览器环境中的兼容性。深入理解 Babel 的基本概念、工作流程和使用方法，对于前端开发者提升开发效率和代码质量有着重要意义。</p>

<p>从入门的基本使用，到进阶的插件开发，再到专业的性能优化，Babel 的学习是一个循序渐进的过程。随着对 Babel 的不断深入学习和实践，开发者能够更加灵活地利用这一工具，构建更加现代化、高效的前端应用。</p>

<h1>应用场景</h1>

<ul>
<li>编辑器</li>
<li>LSP language server protocol</li>
<li>语法高亮，自动补全</li>
<li>静态代码分析</li>
<li>代码转换</li>
<li>代码压缩和优化</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS resolution rules and specificity]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/06/17/css-resolution-rules-and-specificity/"/>
    <updated>2024-06-17T11:53:39+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/06/17/css-resolution-rules-and-specificity</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Description</h2>

<p>The css property doesn&rsquo;t take effect in the release build but works fine in the debug build.</p>

<h2>Root cause</h2>

<p>We applied two css classes in one dom node and didn’t specify the priority (have the same css specificity (0,1,0)), thus the CSS class order matters: the latter one will override the previous one.</p>

<p>However, the css class order is not stable between the debug and release builds.</p>

<h2>Solution</h2>

<p>After fixing, the classes are like this:</p>

<p><img src="/images/css-specificity-1.png" alt="css-specificity-1" /></p>

<p>We can use the scss file helper tools in VS Code:</p>

<p><img src="/images/css-specificity-2.png" alt="css-specificity-2" /></p>

<p>Caution while nesting &amp; :</p>

<p><img src="/images/css-specificity-3.png" alt="css-specificity-3" /></p>

<h2><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance">Cascade</a></h2>

<p>When two rules from the same cascade layer apply and both have equal specificity, the one that is defined last in the stylesheet is the one that will be used.</p>

<p>There are three factors to consider, listed here in increasing order of importance. Later ones overrule earlier ones:</p>

<h3>Source order</h3>

<h3><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity">Specificity</a></h3>

<ul>
<li>one identifier selector has 1-0-0 specificity</li>
<li>one class selector (attribute selector) has 0-1-0 specificity</li>
<li>one element selector has 0-0-1 specificity</li>
<li>The specificity weight of :not/:is/:has comes from the selector parameter in the list of selectors with the highest specificity.</li>
<li>Combinators, such as +, >, ~, &ldquo; &rdquo;, and ||, may make a selector more specific in what is selected but they don&rsquo;t add any value to the specificity weight.</li>
</ul>


<p><img src="/images/css-specificity-4.png" alt="css-specificity-4" /></p>

<h3>Importance</h3>

<ul>
<li>inline style</li>
<li><code>!important</code>: DO NOT use <code>!important</code>. It makes the CSS hard to maintain and debug.

<ul>
<li>See a demo for <code>!important</code> <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#!important">here</a>.</li>
</ul>
</li>
</ul>


<h2>Other info</h2>

<p>The VS Code should have issues with “specificity” calculation.</p>

<p><img src="/images/css-specificity-5.png" alt="css-specificity-5" /></p>

<p>The specificity should be 0-2-0.</p>

<p>More examples can be seen from here: <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity#three-column_comparison">Specificity</a></p>

<p><img src="/images/css-specificity-6.png" alt="css-specificity-6" /></p>

<p>Some online css specificity calculator can be used for testing:</p>

<p><a href="https://specificity.keegan.st/">Specificity Calculator</a></p>

<h2>How to avoid such issues?</h2>

<ul>
<li>Make sure all the loaded CSSs have different css specificity.</li>
<li>Review the CSS in the developer tool.</li>
<li>For a specific css property, filter out all CSSs which contains it.</li>
<li>Make sure the CSS you want to apply have the highest css specificity.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Learning Note 2023]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/09/15/react-learning-note-2023/"/>
    <updated>2023-09-15T17:33:08+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/09/15/react-learning-note-2023</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#react-state-is-updated-in-a-batch">React state is updated in a “batch”</a></li>
<li><a href="#update-react-state-with-a-new-object-do-not-mute-existing-one">Update react state with a new object, do not mute existing one</a></li>
<li><a href="#declarative-ui">Declarative UI</a></li>
<li><a href="#react-redux">React-redux</a></li>
<li><a href="#hooks">Hooks</a></li>
<li><a href="#react%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F">React中的变量</a></li>
<li><a href="#useeffect">useEffect</a>

<ul>
<li><a href="#clean-up-function">clean up function</a></li>
</ul>
</li>
<li><a href="#usememo">useMemo</a></li>
<li><a href="#two-ways-to-store-previous-props">two ways to store previous props</a>

<ul>
<li><a href="#useref">useRef</a></li>
<li><a href="#usestate">useState</a></li>
</ul>
</li>
<li><a href="#fetch-data%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98">fetch data的两个问题</a>

<ul>
<li><a href="#race-condition">race condition</a></li>
<li><a href="#undo">undo</a></li>
</ul>
</li>
<li><a href="#effect-event">Effect Event</a>

<ul>
<li><a href="#what-is-reactive">what is reactive</a></li>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution:</a></li>
<li><a href="#supress-react-lint-error">Supress react lint error</a></li>
</ul>
</li>
<li><a href="#how-to-review-effect-dependencies">How to review effect dependencies</a>

<ul>
<li><a href="#ways-to-review-and-fix-this">ways to review and fix this</a></li>
</ul>
</li>
<li><a href="#object-and-function-compare">Object and function compare</a></li>
<li><a href="#usememo-and-usecallback">useMemo and useCallback</a></li>
<li><a href="#forwardref">forwardRef</a>

<ul>
<li><a href="#useref-1">useRef</a></li>
<li><a href="#basic-concepts">basic concepts</a></li>
<li><a href="#expose-dom-node">expose dom node</a></li>
<li><a href="#expose-an-object">expose an object</a></li>
</ul>
</li>
<li><a href="#custom-hook">Custom Hook</a></li>
<li><a href="#strict-mode">strict mode</a></li>
<li><a href="#other-rules">Other Rules</a>

<ul>
<li><a href="#data-from-parent-to-child">data from parent to child</a></li>
<li><a href="#usesyncexternalstore">useSyncExternalStore</a></li>
<li><a href="#useeffect-dependencies">useEffect dependencies</a></li>
</ul>
</li>
</ul>


<h2>React state is updated in a “batch”</h2>

<p>This means that you can not get the state immediately after you change it.</p>

<p>number will be 1 after one click:
<code>
export default function Counter() {
  const [number, setNumber] = useState(0);
  return (
    &lt;&gt;
      &lt;h1&gt;{number}&lt;/h1&gt;
      &lt;button onClick={() =&gt; {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}&gt;+3&lt;/button&gt;
    &lt;/&gt;
  )
}
</code>
To make the number to be 3, pass a update function to the setNumber function. An update function will be queued and executed later.
<code>
export default function Counter() {
  const [number, setNumber] = useState(0);
  return (
    &lt;&gt;
      &lt;h1&gt;{number}&lt;/h1&gt;
      &lt;button onClick={() =&gt; {
        setNumber(n =&gt; n + 1);
        setNumber(n =&gt; n + 1);
        setNumber(n =&gt; n + 1);
      }}&gt;+3&lt;/button&gt;
    &lt;/&gt;
  )
}
</code></p>

<h2>Update react state with a new object, do not mute existing one</h2>

<p>Use <code>…</code> , the object spread operator:
<code>
setPerson({
  ...person, // Copy the old fields
  firstName: e.target.value // But override this one
});
</code>
Note that spread syntax is shallow: it only copies one level deep. To update nested object:
<code>
setPerson({
  ...person, // Copy other fields
  artwork: { // but replace the artwork
    ...person.artwork, // with the same one
    city: 'New Delhi' // but in New Delhi!
  }
});
</code>
For updating array object:
<code>
setArtists([
  { id: nextId++, name: name },
  ...artists // Put old items at the end
]);
</code>
<code>Immer</code> is a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you.
<code>
updatePerson(draft =&gt; {
  draft.artwork.city = 'Lagos';
});
</code>
Using <code>Immer</code> for array:
<code>
updateMyTodos(draft =&gt; {
  const artwork = draft.find(a =&gt; a.id === artworkId);
  artwork.seen = nextSeen;
});
</code></p>

<h2>Declarative UI</h2>

<ul>
<li>Declarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).</li>
<li>When developing a component, Think in declarative UI way:

<ol>
<li>Identify all its visual states.</li>
<li>Determine the human and computer triggers for state changes.</li>
<li>Model the state with useState.</li>
<li>Remove non-essential state to avoid bugs and paradoxes.</li>
<li>Connect the event handlers to set state.</li>
</ol>
</li>
</ul>


<h2>React-redux</h2>

<ul>
<li>useReducer+useContext?</li>
<li>Provider</li>
<li>Context</li>
</ul>


<h2>Hooks</h2>

<ul>
<li>useContext: 跨层传输props，不用一层一层传下去</li>
<li>useEffect: Use them to synchronize your component with a system outside of React.</li>
</ul>


<h2>React中的变量</h2>

<ul>
<li>Props：immutable, 触发rerender，不记忆(retained by component)</li>
<li>State：immutable, 触发rerender，记忆(retained by React)</li>
<li>useRef：mutable, 不触发rerender，记忆(retained by React)</li>
</ul>


<h2>useEffect</h2>

<p>Effects let you specify side effects that are caused by rendering itself, rather than by a particular event.</p>

<p>Effects run at the end of a <em>commit</em> after the screen updates. That is, useEffect “delays” a piece of code from running until that render is reflected on the screen.</p>

<h3>clean up function</h3>

<p>You can use a clean up function to clean up the effect. For example, if you subscribe to an external data source, you can unsubscribe it in the clean up function.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>useEffect(() =&gt; {
</span><span class='line'>  const connection = createConnection();
</span><span class='line'>  connection.connect();
</span><span class='line'>  return () =&gt; {
</span><span class='line'>    connection.disconnect();
</span><span class='line'>  };
</span><span class='line'>}, []);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;useEffect(() =&gt; {
</span><span class='line'>  function handleScroll(e) {
</span><span class='line'>    console.log(window.scrollX, window.scrollY);
</span><span class='line'>  }
</span><span class='line'>  window.addEventListener(&lsquo;scroll&rsquo;, handleScroll);
</span><span class='line'>  return () =&gt; window.removeEventListener(&lsquo;scroll&rsquo;, handleScroll);
</span><span class='line'>}, []);</span></code></pre></td></tr></table></div></figure>
<strong>React will call your cleanup function each time before the next Effect runs again, and one final time when the component unmounts (gets removed).</strong>
That is, the cleanup function runs not only during unmount, but before every re-render with changed dependencies.</p>

<h2>useMemo</h2>

<p>useMemo和useEffect都可以加依赖，但是useMemo在render过程起作用，而useEffect在commit之后起作用。
所以，如果是render依赖的变量值，用useMemo，不用useEffect+useState。</p>

<p>不推荐：
<code>
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // 🔴 Avoid: redundant state and unnecessary Effect
  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() =&gt; {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);
  // ...
}
</code>
推荐：
<code>
import { useMemo, useState } from 'react';
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  const visibleTodos = useMemo(() =&gt; {
    // ✅ Does not re-run unless todos or filter change
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);
  // ...
}
</code></p>

<h2>two ways to store previous props</h2>

<h3>useRef</h3>

<p><code>prevProps</code> updates after render:
<code>
  const prevProps = useRef();
  useEffect(() =&gt; {
    prevProps.current = props;
  }, [props]);
</code></p>

<h3>useState</h3>

<p><code>prevItems</code> is ready when render:
<code>
  const [prevItems, setPrevItems] = useState(items);
  if (items !== prevItems) {
    setPrevItems(items);
  }
</code></p>

<h2>fetch data的两个问题</h2>

<h3>race condition</h3>

<p>输入特别快的时候，很多search的request连续发出，不能保证回来的顺序，会出问题。
解决方法：给useEffect提供cleanup函数解决
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function SearchResults({ query }) {
</span><span class='line'>  const [results, setResults] = useState([]);
</span><span class='line'>  const [page, setPage] = useState(1);
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    let ignore = false;
</span><span class='line'>    fetchResults(query, page).then(json =&gt; {
</span><span class='line'>      if (!ignore) {
</span><span class='line'>        setResults(json);
</span><span class='line'>      }
</span><span class='line'>    });
</span><span class='line'>    return () =&gt; {
</span><span class='line'>      ignore = true;
</span><span class='line'>    };
</span><span class='line'>  }, [query, page]);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  function handleNextPageClick() {
</span><span class='line'>    setPage(page + 1);
</span><span class='line'>  }
</span><span class='line'>  // &hellip;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<h3>undo</h3>

<p>没看懂：<a href="https://react.dev/learn/you-might-not-need-an-effect#fetching-data">https://react.dev/learn/you-might-not-need-an-effect#fetching-data</a></p>

<h2>Effect Event</h2>

<h3>what is reactive</h3>

<p>variables which can change due to a re-render
* Logic inside event handlers (or Effect Event) is not reactive.
* Logic inside Effects is reactive.</p>

<h3>Problem</h3>

<pre><code>function ChatRoom({ roomId, theme }) {
  useEffect(() =&gt; {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () =&gt; {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () =&gt; {
      connection.disconnect()
    };
  }, [roomId, theme]); // ✅ All dependencies declared
  // ...
</code></pre>

<p>When reconnected, a notification will be shown, and the notificaiton will consider the theme.
But when the theme changes, the notification will also be shown, which is not expected.</p>

<h3>Solution:</h3>

<p>Use Effect Event to separate this non-reactive logic from the reactive Effect around it.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function ChatRoom({ roomId, theme }) {
</span><span class='line'>  const onConnected = useEffectEvent(() =&gt; {
</span><span class='line'>    showNotification(&lsquo;Connected!&rsquo;, theme);
</span><span class='line'>  });&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection(serverUrl, roomId);
</span><span class='line'>    connection.on(&lsquo;connected&rsquo;, () =&gt; {
</span><span class='line'>      onConnected();
</span><span class='line'>    });
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, [roomId]); // ✅ All dependencies declared
</span><span class='line'>  // &hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>You can think of Effect Events as being very similar to event handlers. The main difference is that event handlers run in response to a user interactions, whereas Effect Events are triggered by you from Effects. Effect Events let you “break the chain” between the reactivity of Effects and code that should not be reactive.</p>

<h3>Supress react lint error</h3>

<p>React linter ask you to add all reactive variables into the Effect dependencies.
Effect Events let you fix many patterns where you might be tempted to suppress the dependency linter.</p>

<h2>How to review effect dependencies</h2>

<p>Every time you adjust the Effect’s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is “no”:</p>

<ul>
<li>You might want to re-execute different parts of your Effect under different conditions.</li>
<li>You might want to only read the latest value of some dependency instead of “reacting” to its changes.</li>
<li>A dependency may change too often unintentionally because it’s an object or a function.</li>
</ul>


<h3>ways to review and fix this</h3>

<ul>
<li>Should this code move to an event handler?</li>
<li>Is your Effect doing several unrelated things?

<ul>
<li>If different parts of your Effect should re-run for different reasons, split it into several Effects.</li>
</ul>
</li>
<li>Are you reading some state to calculate the next state?

<ul>
<li>Use update function. Use <code>setMessages([...messages, receivedMessage])</code> instead of <code>setMessages(msgs =&gt; [...msgs, receivedMessage])</code></li>
</ul>
</li>
<li>In JavaScript, objects and functions are considered different if they were created at different times.</li>
<li>Try to avoid object and function dependencies. Move them outside the component or inside the Effect.

<ul>
<li>Move static objects and functions outside your component
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function createOptions() {
</span><span class='line'>return {
</span><span class='line'>serverUrl: &lsquo;&lt;a href="https://localhost:1234"&gt;https://localhost:1234&lt;/a&gt;&rsquo;,
</span><span class='line'>roomId: &lsquo;music&rsquo;
</span><span class='line'>};
</span><span class='line'>}&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>&lt;/li&gt;
</span><span class='line'>&lt;/ul&gt;
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p&gt;function ChatRoom() {
</span><span class='line'>  const [message, setMessage] = useState(&lsquo;&rsquo;);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  useEffect(() =&gt; {
</span><span class='line'>    const options = createOptions();
</span><span class='line'>    const connection = createConnection();
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, []); // ✅ All dependencies declared
</span><span class='line'>  // &hellip;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>    * Move dynamic objects and functions inside your Effect
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>const serverUrl = &lsquo;&lt;a href="https://localhost:1234"&gt;https://localhost:1234&lt;/a&gt;&rsquo;;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;function ChatRoom({ roomId }) {
</span><span class='line'>  const [message, setMessage] = useState(&lsquo;&rsquo;);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  useEffect(() =&gt; {
</span><span class='line'>    const options = {
</span><span class='line'>      serverUrl: serverUrl,
</span><span class='line'>      roomId: roomId
</span><span class='line'>    };
</span><span class='line'>    const connection = createConnection(options);
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, [roomId]); // ✅ All dependencies declared
</span><span class='line'>  // &hellip;
</span><span class='line'>&lt;code&gt;
</span><span class='line'>* Read primitive values from objects
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>function ChatRoom({ options }) {
</span><span class='line'>  const [message, setMessage] = useState(&lsquo;&rsquo;);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  const { roomId, serverUrl } = options;
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection({
</span><span class='line'>      roomId: roomId,
</span><span class='line'>      serverUrl: serverUrl
</span><span class='line'>    });
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, [roomId, serverUrl]); // ✅ All dependencies declared
</span><span class='line'>  // &hellip;</span></code></pre></td></tr></table></div></figure></p>

<h2>Object and function compare</h2>

<pre><code>import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  // Temporarily disable the linter to demonstrate the problem
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const options = {
    serverUrl: serverUrl,
    roomId: roomId
  };

  useEffect(() =&gt; {
    const connection = createConnection(options);
    connection.connect();
    return () =&gt; connection.disconnect();
  }, [options]);

  return (
    &lt;&gt;
      &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;
      &lt;input value={message} onChange={e =&gt; setMessage(e.target.value)} /&gt;
    &lt;/&gt;
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    &lt;&gt;
      &lt;label&gt;
        Choose the chat room:{' '}
        &lt;select
          value={roomId}
          onChange={e =&gt; setRoomId(e.target.value)}
        &gt;
          &lt;option value="general"&gt;general&lt;/option&gt;
          &lt;option value="travel"&gt;travel&lt;/option&gt;
          &lt;option value="music"&gt;music&lt;/option&gt;
        &lt;/select&gt;
      &lt;/label&gt;
      &lt;hr /&gt;
      &lt;ChatRoom roomId={roomId} /&gt;
    &lt;/&gt;
  );
}
</code></pre>

<p>In the example above, the input only updates the message state variable. From the user’s perspective, this should not affect the chat connection. However, every time you update the message, your component re-renders. When your component re-renders, the code inside of it runs again from scratch.</p>

<p>A new options object is created from scratch on every re-render of the ChatRoom component. React sees that the options object is a different object from the options object created during the last render. This is why it re-synchronizes your Effect (which depends on options), and the chat re-connects as you type.</p>

<p>This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesn’t matter that the contents inside of them may be the same!</p>

<p>Object and function dependencies can make your Effect re-synchronize more often than you need.</p>

<p>This is why, whenever possible, you should try to avoid objects and functions as your Effect’s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them.</p>

<h2>useMemo and useCallback</h2>

<ul>
<li>useMemo caches the result of calling your function.</li>
<li>useCallback caches the function itself. React will not call your function.</li>
</ul>


<h2>forwardRef</h2>

<p>First, get familar with <code>useRef</code>:</p>

<h3>useRef</h3>

<p>ref.current is set during the <em>commit</em> process, not <em>render</em> process, so do not read or write ref.current during rendering. We can use ref.current in event handler or useEffect.</p>

<h3>basic concepts</h3>

<pre><code>const MyInput = forwardRef(function MyInput(props, ref) {
  return (
    &lt;label&gt;
      {props.label}
      &lt;input ref={ref} /&gt;
    &lt;/label&gt;
  );
});
</code></pre>

<p>The ref attribute passed by the parent component. The ref can be an object or a function. You should either
* pass the ref you receive to another component, or
* pass it to useImperativeHandle.</p>

<h3>expose dom node</h3>

<p>The parent <code>Form</code> component accesses the \<input\> DOM node exposed by <code>MyInput</code>.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import { forwardRef } from &lsquo;react&rsquo;;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;const MyInput = forwardRef(function MyInput(props, ref) {
</span><span class='line'>  const { label, &hellip;otherProps } = props;
</span><span class='line'>  return (
</span><span class='line'>    &lt;label&gt;
</span><span class='line'>      {label}
</span><span class='line'>      &lt;input {...otherProps} ref={ref} /&gt;
</span><span class='line'>    &lt;/label&gt;
</span><span class='line'>  );
</span><span class='line'>});&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;function Form() {
</span><span class='line'>  const ref = useRef(null);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  function handleClick() {
</span><span class='line'>    ref.current.focus();
</span><span class='line'>  }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  return (
</span><span class='line'>    &lt;form&gt;
</span><span class='line'>      &lt;MyInput label="Enter your name:" ref={ref} /&gt;
</span><span class='line'>      &lt;button type="button" onClick={handleClick}&gt;
</span><span class='line'>        Edit
</span><span class='line'>      &lt;/button&gt;
</span><span class='line'>    &lt;/form&gt;
</span><span class='line'>  );
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<h3>expose an object</h3>

<p>Use <code>useImperativeHandle</code> to expose an object referenced by <code>ref</code>:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import { forwardRef, useRef, useImperativeHandle } from &lsquo;react&rsquo;;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;const MyInput = forwardRef(function MyInput(props, ref) {
</span><span class='line'>  const inputRef = useRef(null);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  useImperativeHandle(ref, () =&gt; {
</span><span class='line'>    return {
</span><span class='line'>      focus() {
</span><span class='line'>        inputRef.current.focus();
</span><span class='line'>      },
</span><span class='line'>      scrollIntoView() {
</span><span class='line'>        inputRef.current.scrollIntoView();
</span><span class='line'>      },
</span><span class='line'>    };
</span><span class='line'>  }, []);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;  return &lt;input {...props} ref={inputRef} /&gt;;
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure></p>

<h2>Custom Hook</h2>

<p>You must follow these naming conventions:</p>

<ul>
<li>React component names must start with a capital letter, like StatusBar and SaveButton. React components also need to return something that React knows how to display, like a piece of JSX.</li>
<li>Hook names must start with use followed by a capital letter, like useState (built-in) or useOnlineStatus (custom, like earlier on the page). Hooks may return arbitrary values.</li>
</ul>


<p>This convention guarantees that you can always look at a component and know where its state, Effects, and other React features might “hide”. For example, if you see a getColor() function call inside your component, you can be sure that it can’t possibly contain React state inside because its name doesn’t start with use. However, a function call like useOnlineStatus() will most likely contain calls to other Hooks inside!</p>

<p>If your linter is configured for React, it will enforce this naming convention.</p>

<p>Note that custom Hooks only share stateful logic, not state itself.</p>

<h2>strict mode</h2>

<p><StrictMode> lets you find common bugs in your components early during development.</p>

<p>Strict Mode enables the following development-only behaviors:
* Your components will re-render an extra time to find bugs caused by impure rendering.
* Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.
* Your components will be checked for usage of deprecated APIs.</p>

<h2>Other Rules</h2>

<h3>data from parent to child</h3>

<p>When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, and pass it down to the child.
This is simpler and keeps the data flow predictable: the data flows down from the parent to the child.</p>

<h3>useSyncExternalStore</h3>

<h3>useEffect dependencies</h3>

<p>All variables from the component body used by the Effect should be in the Effect dependency list. However, you could instead “prove” to the linter that these values aren’t reactive values, i.e. that they can’t change as a result of a re-render. For example, if serverUrl and roomId don’t depend on rendering and always have the same values, you can move them outside the component. Now they don’t need to be dependencies:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const serverUrl = &lsquo;&lt;a href="https://localhost:1234"&gt;https://localhost:1234&lt;/a&gt;&rsquo;; // serverUrl is not reactive
</span><span class='line'>const roomId = &lsquo;general&rsquo;; // roomId is not reactive&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;function ChatRoom() {
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection(serverUrl, roomId);
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; {
</span><span class='line'>      connection.disconnect();
</span><span class='line'>    };
</span><span class='line'>  }, []); // ✅ All dependencies declared
</span><span class='line'>  // &hellip;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重学前端-通过window属性了解协议API]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/10/08/chongxueqianduan-tongguo-window-liaojie-protocol-api/"/>
    <updated>2022-10-08T17:18:04+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/10/08/chongxueqianduan-tongguo-window-liaojie-protocol-api</id>
    <content type="html"><![CDATA[<!-- more -->


<p>浏览器的API数目繁多，这一节课，我设计了一个实验，我们一起来给API分分类。</p>

<p>我们按照每个API所在的标准来分类。所以，我们用代码来反射浏览器环境中全局对象的属性，然后我们用JavaScript的filter方法来逐步过滤掉已知的属性。</p>

<p>接下来，我们整理API的方法如下：</p>

<ol>
<li>从Window的属性中，找到API名称；</li>
<li>查阅MDN或者Google，找到API所在的标准；</li>
<li>阅读标准，手工或者用代码整理出标准中包含的API；</li>
<li>用代码在Window的属性中过滤掉标准中涉及的API。</li>
<li>重复这个过程，我们可以找到所有的API对应的标准。</li>
</ol>


<p>原文点击<a href="/assets/resources/37%E4%B8%A8%E6%B5%8F%E8%A7%88%E5%99%A8API%EF%BC%88%E5%B0%8F%E5%AE%9E%E9%AA%8C%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%89%8B%E6%95%B4%E7%90%86%E5%85%A8%E9%83%A8API.html">这里</a>获取。</p>

<p>从原文整理出来的html文件点击<a href="/assets/resources/traverseWindows.html">这里</a>获取。</p>

<p>关键js代码如下：</p>

<pre><code>function filterOut(names, props) {
    let set = new Set();
    props.forEach(o =&gt; set.add(o));
    return names.filter(e =&gt; !set.has(e));
}

let names = Object.getOwnPropertyNames(window)
console.log(names)

// 过滤JavaScript 标准规定的属性
let js = new Set();
let objects = ["BigInt", "BigInt64Array", "BigUint64Array", "Infinity", "NaN", "undefined", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "Array", "Date", "RegExp", "Promise", "Proxy", "Map", "WeakMap", "Set", "WeakSet", "Function", "Boolean", "String", "Number", "Symbol", "Object", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray", "Atomics", "JSON", "Math", "Reflect", "escape", "unescape"];
objects.forEach(o =&gt; js.add(o));
names = names.filter(e =&gt; !js.has(e));
console.log('\nnames after filtering JS Standard:')
console.log(names)

// 接下来我们看看已经讲过的 DOM 部分，DOM 部分包含了 document 属性和一系列的构造器，我们可以用 JavaScript 的 prototype 来过滤构造器。
names = names.filter( e =&gt; {
    try { 
        return !(window[e].prototype instanceof Node)
    } catch(err) {
        return true;
    }
}).filter( e =&gt; e != "Node")
console.log('\nnames after filtering DOM:')
console.log(names)

// 接下来我们要找到 Window 对象的定义，我们在下面链接中可以找到。https://html.spec.whatwg.org/#window 这里有一个 Window 接口，是使用 WebIDL 定义的，我们手工把其中的函数和属性整理出来
let windowprops = new Set();
objects = ["window", "self", "document", "name", "location", "history", "customElements", "locationbar", "menubar", " personalbar", "scrollbars", "statusbar", "toolbar", "status", "close", "closed", "stop", "focus", " blur", "frames", "length", "top", "opener", "parent", "frameElement", "open", "navigator", "applicationCache", "alert", "confirm", "prompt", "print", "postMessage", "console"];
objects.forEach(o =&gt; windowprops.add(o));
names = names.filter(e =&gt; !windowprops.has(e));
console.log('\nnames after filtering WebIDL:')
console.log(names)

// 我们还要过滤掉所有的事件，也就是 on 开头的属性。
names = names.filter( e =&gt; !e.match(/^on/))
// webkit 前缀的私有属性我们也过滤掉：
names = names.filter( e =&gt; !e.match(/^webkit/))
// 除此之外，我们在 HTML 标准中还能找到所有的接口，这些我们也过滤掉：
let interfaces = new Set();
objects = ["ApplicationCache", "AudioTrack", "AudioTrackList", "BarProp", "BeforeUnloadEvent", "BroadcastChannel", "CanvasGradient", "CanvasPattern", "CanvasRenderingContext2D", "CloseEvent", "CustomElementRegistry", "DOMStringList", "DOMStringMap", "DataTransfer", "DataTransferItem", "DataTransferItemList", "DedicatedWorkerGlobalScope", "Document", "DragEvent", "ErrorEvent", "EventSource", "External", "FormDataEvent", "HTMLAllCollection", "HashChangeEvent", "History", "ImageBitmap", "ImageBitmapRenderingContext", "ImageData", "Location", "MediaError", "MessageChannel", "MessageEvent", "MessagePort", "MimeType", "MimeTypeArray", "Navigator", "OffscreenCanvas", "OffscreenCanvasRenderingContext2D", "PageTransitionEvent", "Path2D", "Plugin", "PluginArray", "PopStateEvent", "PromiseRejectionEvent", "RadioNodeList", "SharedWorker", "SharedWorkerGlobalScope", "Storage", "StorageEvent", "TextMetrics", "TextTrack", "TextTrackCue", "TextTrackCueList", "TextTrackList", "TimeRanges", "TrackEvent", "ValidityState", "VideoTrack", "VideoTrackList", "WebSocket", "Window", "Worker", "WorkerGlobalScope", "WorkerLocation", "WorkerNavigator"];
objects.forEach(o =&gt; interfaces.add(o));
names = names.filter(e =&gt; !interfaces.has(e));
console.log('\nnames after filtering HTML:')
console.log(names)

// 过滤i18n api
names = names.filter(e =&gt; e != "Intl")
console.log(names)

/* Streams 标准
    接下来我看到的属性是： ByteLengthQueuingStrategy。
    同样经过查阅，它来自 WHATWG 的 Streams 标准：
    https://streams.spec.whatwg.org/#blqs-class
*/
names = filterOut(names, ["ReadableStream", "ReadableStreamDefaultReader", "ReadableStreamBYOBReader", "ReadableStreamDefaultController", "ReadableByteStreamController", "ReadableStreamBYOBRequest", "WritableStream", "WritableStreamDefaultWriter", "WritableStreamDefaultController", "TransformStream", "TransformStreamDefaultController", "ByteLengthQueuingStrategy", "CountQueuingStrategy"]);
console.log(names)

/*
    接下来我看到的属性是：WebGLContext​Event。
    显然，这个属性来自 WebGL 标准：
    https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15
*/
names = filterOut(names, ["WebGLContextEvent","WebGLObject", "WebGLBuffer", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLTexture", "WebGLUniformLocation", "WebGLActiveInfo", "WebGLShaderPrecisionFormat", "WebGLRenderingContext"]);
console.log(names)

/*
    Web Audio API
    下一个属性是 WaveShaperNode。这个属性名听起来就跟声音有关，这个属性来自 W3C 的 Web Audio API 标准。
    我们来看一下标准：
    https://www.w3.org/TR/webaudio/
*/
names = filterOut(names, ["AudioContext", "AudioNode", "AnalyserNode", "AudioBuffer", "AudioBufferSourceNode", "AudioDestinationNode", "AudioParam", "AudioListener", "AudioWorklet", "AudioWorkletGlobalScope", "AudioWorkletNode", "AudioWorkletProcessor", "BiquadFilterNode", "ChannelMergerNode", "ChannelSplitterNode", "ConstantSourceNode", "ConvolverNode", "DelayNode", "DynamicsCompressorNode", "GainNode", "IIRFilterNode", "MediaElementAudioSourceNode", "MediaStreamAudioSourceNode", "MediaStreamTrackAudioSourceNode", "MediaStreamAudioDestinationNode", "PannerNode", "PeriodicWave", "OscillatorNode", "StereoPannerNode", "WaveShaperNode", "ScriptProcessorNode", "AudioProcessingEvent"]);
console.log(names)

/*
    Encoding 标准
    在我的环境中，下一个属性是 TextDecoder，经过查阅得知，这个属性也来自一份 WHATWG 的标准，Encoding：
    https://encoding.spec.whatwg.org/#dom-textencoder
*/
names = filterOut(names, ["TextDecoder", "TextEncoder", "TextDecoderStream", "TextEncoderStream"]);
console.log(names)

/*
    Web Cryptography API
    我们继续看下去，下一个属性是 SubtleCrypto，这个属性来自 Web Cryptography API，也是 W3C 的标准。
    https://www.w3.org/TR/WebCryptoAPI/
    这份标准中规定了三个 Class 和一个 Window 对象的扩展，给 Window 对象添加了一个属性 crypto。
*/
names = filterOut(names, ["CryptoKey", "SubtleCrypto", "Crypto", "crypto"]);
console.log(names)

/*
    Media Source Extensions
    下一个属性是 SourceBufferList，它来自于：
    https://www.w3.org/TR/media-source/
    这份标准中包含了三个接口，这份标准还扩展了一些接口，但是没有扩展 window。
*/
names = filterOut(names, ["MediaSource", "SourceBuffer", "SourceBufferList"]);
console.log(names)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[web性能优化]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/03/21/web-xingneng-youhua/"/>
    <updated>2022-03-21T23:30:53+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/03/21/web-xingneng-youhua</id>
    <content type="html"><![CDATA[<!-- more -->


<p>从web渲染全过程分析，从下面几个方面进行性能优化考虑：</p>

<ol>
<li>HTTP请求性能优化</li>
<li>浏览器内渲染性能优化</li>
</ol>


<h2>HTTP(s)请求性能优化</h2>

<ul>
<li>参考极客时间课程《透视HTTP协议》的39和40两节课。</li>
<li>另外，<a href="/blog/2021/05/26/toushi-http-xieyi/">极客时间-罗剑锋-《透视HTTP协议》总结</a>中的章节<a href="/blog/2021/05/26/toushi-http-xieyi/#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">http性能优化</a>，有一个概括性的描述。</li>
<li>相关内容个人总结参考<a href="/blog/2022/03/08/http-xingneng-youhua/">HTTP(s)请求性能优化</a>。</li>
</ul>


<h2>浏览器内渲染性能优化</h2>

<ul>
<li>参考极客时间课程《让你页面速度飞起来 Web前端性能优化》</li>
<li>相关内容个人总结参考<a href="/blog/2022/01/04/web-qianduan-xingneng-youhua/">极客时间-Web前端性能优化</a>。</li>
</ul>

]]></content>
  </entry>
  
</feed>
