<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web | Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/web/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2022-03-08T18:22:04+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[web性能优化综述]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/03/08/http-xingneng-youhua/"/>
    <updated>2022-03-08T16:44:40+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/03/08/http-xingneng-youhua</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#https%E8%AF%B7%E6%B1%82%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">HTTP(s)请求性能优化</a>

<ul>
<li><a href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7">性能测试工具</a></li>
<li><a href="#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">HTTP性能优化</a>

<ul>
<li><a href="#%E5%BC%80%E6%BA%90">开源</a></li>
<li><a href="#%E8%8A%82%E6%B5%81">节流</a></li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="#%E5%8D%87%E7%BA%A7%E5%88%B0http2">升级到HTTP/2</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E8%B5%84%E6%BA%90%E5%90%88%E5%B9%B6">关于资源合并</a></li>
</ul>
</li>
<li><a href="#https%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">HTTPs性能优化</a>

<ul>
<li><a href="#1-%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96cpussl%E5%8A%A0%E9%80%9F%E5%8D%A1ssl%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1%E5%99%A8">1. 硬件优化：CPU，SSL加速卡，SSL加速服务器</a></li>
<li><a href="#2-%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96">2. 软件优化：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">浏览器内渲染性能优化</a></li>
</ul>


<!-- /TOC -->


<p>从web渲染全过程分析，从下面几个方面进行性能优化考虑：</p>

<ol>
<li>HTTP请求性能优化</li>
<li>浏览器内渲染性能优化</li>
</ol>


<p><a id="markdown-https请求性能优化" name="https请求性能优化"></a></p>

<h2>HTTP(s)请求性能优化</h2>

<p><a id="markdown-性能测试工具" name="性能测试工具"></a></p>

<h3>性能测试工具</h3>

<ol>
<li><p>在 Linux 上，最常用的性能测试工具可能就是 ab（Apache Bench）了，比如，下面的命令指定了并发数 100，总共发送 10000 个请求：</p>

<pre><code class="`"> ab -c 100 -n 10000 'http://www.xxx.com'
</code></pre></li>
<li><p>系统资源监控方面，Linux 自带的工具也非常多，常用的有 uptime、top、vmstat、netstat、sar 等等，可能你比我还要熟悉，我就列几个简单的例子吧：</p>

<pre><code class="`"> top             # 查看 CPU 和内存占用情况
 vmstat  2       # 每 2 秒检查一次系统状态
 sar -n DEV 2    # 看所有网卡的流量，定时 2 秒检查
</code></pre></li>
<li>之前讲 HTTPS 时介绍过一个专门的网站<a href="https://www.ssllabs.com/">SSLLabs</a>，而对于 HTTP 性能优化，也有一个专门的测试网站<a href="https://www.webpagetest.org/">WebPageTest</a>。它的特点是在世界各地建立了很多的测试点，可以任意选择地理位置、机型、操作系统和浏览器发起测试，非常方便，用法也很简单。网站测试的最终结果是一个直观的“瀑布图”（Waterfall Chart），清晰地列出了页面中所有资源加载的先后顺序和时间消耗。</li>
<li>Chrome 等浏览器自带的开发者工具也可以很好地观察客户端延迟指标，面板左边有每个 URI 具体消耗的时间，面板的右边也有瀑布图。</li>
</ol>


<p><a id="markdown-http性能优化" name="http性能优化"></a></p>

<h3>HTTP性能优化</h3>

<p><a id="markdown-开源" name="开源"></a></p>

<h4>开源</h4>

<ul>
<li>Nginx及相关配置</li>
<li>HTTP启用长连接
<a id="markdown-节流" name="节流"></a></li>
</ul>


<h4>节流</h4>

<ul>
<li>数据压缩：图片，json等</li>
<li>html/css/js的minify</li>
<li>去除不必要的Header属性</li>
<li>减少域名数量和重定向次数
<a id="markdown-缓存" name="缓存"></a></li>
</ul>


<h4>缓存</h4>

<ul>
<li>服务器缓存：Redis</li>
<li>CDN缓存
<a id="markdown-升级到http2" name="升级到http2"></a></li>
</ul>


<h4>升级到HTTP/2</h4>

<ul>
<li>消除了应用层的队头阻塞，拥有头部压缩、二进制帧、多路复用、流量控制、服务器推送等许多新特性，大幅度提升了 HTTP 的传输效率。
<a id="markdown-关于资源合并" name="关于资源合并"></a></li>
</ul>


<h4>关于资源合并</h4>

<ul>
<li>“资源合并”在 HTTP/1 里减少了多次请求的成本，但在 HTTP/2 里因为有头部压缩和多路复用，传输小文件的成本很低，所以合并就失去了意义。而且“资源合并”还有一个缺点，就是降低了缓存的可用性，只要一个小文件更新，整个缓存就完全失效，必须重新下载。</li>
<li>所以在现在的大带宽和 CDN 应用场景下，应当尽量少用资源合并（JS、CSS 图片合并，数据内嵌），让资源的粒度尽可能地小，才能更好地发挥缓存的作用。</li>
</ul>


<p><a id="markdown-https性能优化" name="https性能优化"></a></p>

<h3>HTTPs性能优化</h3>

<p><a id="markdown-1-硬件优化cpussl加速卡ssl加速服务器" name="1-硬件优化cpussl加速卡ssl加速服务器"></a></p>

<h4>1. 硬件优化：CPU，SSL加速卡，SSL加速服务器</h4>

<p><a id="markdown-2-软件优化" name="2-软件优化"></a></p>

<h4>2. 软件优化：</h4>

<ol>
<li>软件升级：Linux内核，Nginx，OpenSSL</li>
<li>协议优化：

<ul>
<li>TLS1.3</li>
<li>密钥交换协议尽量选用椭圆曲线ECDHE算法，能够把握手的消息往返由 2-RTT 减少到 1-RTT，达到与 TLS1.3 类似的效果。</li>
<li>Nginx配置密码套件和椭圆曲线，将优先使用的放在前面。</li>
</ul>
</li>
<li>证书优化：

<ul>
<li>CRL（Certificate revocation list，证书吊销列表）由 CA 定期发布，里面是所有被撤销信任的证书序号，查询这个列表就可以知道证书是否有效。</li>
<li>现在 CRL 基本上不用了，取而代之的是 OCSP（在线证书状态协议，Online Certificate Status Protocol），向 CA 发送查询请求，让 CA 返回证书的有效状态。</li>
<li>“OCSP Stapling”（OCSP 装订），它可以让服务器预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的时间。</li>
</ul>
</li>
<li>会话复用：

<ul>
<li>我们再回想一下 HTTPS 建立连接的过程：先是 TCP 三次握手，然后是 TLS 一次握手。这后一次握手的重点是算出主密钥“Master Secret”，而主密钥每次连接都要重新计算，未免有点太浪费了，如果能够把“辛辛苦苦”算出来的主密钥缓存一下“重用”，不就可以免去了握手和计算的成本了吗？</li>
<li>这种做法就叫“会话复用”（TLS session resumption），和 HTTP Cache 一样，也是提高 HTTPS 性能的“大杀器”，被浏览器和服务器广泛应用。</li>
<li>会话复用分两种

<ul>
<li>第一种叫“Session ID”：“Session ID”是最早出现的会话复用技术，也是应用最广的，但它也有缺点，服务器必须保存每一个客户端的会话数据，对于拥有百万、千万级别用户的网站来说存储量就成了大问题，加重了服务器的负担。</li>
<li>第二种叫“Session Ticket”：它有点类似 HTTP 的 Cookie，存储的责任由服务器转移到了客户端</li>
</ul>
</li>
<li>预共享密钥：

<ul>
<li>在发送 Ticket 的同时会带上应用数据（Early Data），免去了 1.2 里的服务器确认步骤，这种方式叫“Pre-shared Key”，简称为“PSK”。</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>上面的内容来自极客时间的《透视HTTP协议》课程的39和40两节课。
另外，<a href="/blog/2021/05/26/toushi-http-xieyi/">极客时间-罗剑锋-《透视HTTP协议》总结</a>中的章节<a href="/blog/2021/05/26/toushi-http-xieyi/#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">http性能优化</a>，有一个概括性的描述。</p>

<p><a id="markdown-浏览器内渲染性能优化" name="浏览器内渲染性能优化"></a></p>

<h2>浏览器内渲染性能优化</h2>

<p>参考<a href="/blog/2022/01/04/web-qianduan-xingneng-youhua/">极客时间-Web前端性能优化</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[极客时间-Web前端性能优化]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/01/04/web-qianduan-xingneng-youhua/"/>
    <updated>2022-01-04T18:06:29+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/01/04/web-qianduan-xingneng-youhua</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%90%88%E5%B9%B6">资源压缩与合并</a>

<ul>
<li><a href="#%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96">图片优化</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E9%A2%84%E5%8A%A0%E8%BD%BD">图片的懒加载预加载</a>

<ul>
<li><a href="#%E6%87%92%E5%8A%A0%E8%BD%BD">懒加载：</a></li>
<li><a href="#%E9%A2%84%E5%8A%A0%E8%BD%BD">预加载：</a></li>
</ul>
</li>
<li><a href="#html%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">HTML渲染过程</a></li>
<li><a href="#%E9%87%8D%E7%BB%98%E5%A4%96%E8%A7%82%E4%B8%8E%E5%9B%9E%E6%B5%81%E5%B8%83%E5%B1%80redrawreflow">重绘（外观）与回流（布局）redraw/reflow</a>

<ul>
<li><a href="#top-and-translate">top and translate</a></li>
<li><a href="#opacity%E6%9B%BF%E6%8D%A2visibility"><code>opacity</code>替换<code>visibility</code></a></li>
<li><a href="#css%E7%9A%84class%E6%9B%BF%E4%BB%A3style">css的class替代style</a></li>
<li><a href="#displaynone"><code>display:none</code></a></li>
<li><a href="#%E6%85%8E%E7%94%A8clientwidth">慎用<code>clientWidth</code></a></li>
<li><a href="#%E5%B0%91%E7%94%A8table%E5%B8%83%E5%B1%80">少用table布局。</a></li>
<li><a href="#%E5%8A%A8%E7%94%BB%E7%9A%84%E5%88%B7%E6%96%B0%E7%8E%87%E5%92%8C%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E5%B9%B3%E8%A1%A1">动画的刷新率和页面性能平衡</a></li>
<li><a href="#%E5%B0%86gif%E5%9B%BE%E5%8D%95%E7%8B%AC%E6%88%90%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%B1%82">将gif图单独成一个图层</a></li>
<li><a href="#%E5%90%AF%E7%94%A8gpu%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F">启用GPU硬件加速</a></li>
</ul>
</li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8">浏览器存储</a></li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93">服务器端渲染</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-资源压缩与合并" name="资源压缩与合并"></a></p>

<h2>资源压缩与合并</h2>

<p>资源合并会减少请求次数，总体上降低请求时间。但是，也不能不加考虑地都合并到一起，这样会影响首页渲染速度。</p>

<p><a id="markdown-图片优化" name="图片优化"></a></p>

<h3>图片优化</h3>

<ol>
<li>图片<strong>雪碧图</strong>，不能太大，太大影响首屏渲染性能。一个页面的小图放在一起，生成一张雪碧图即可。</li>
<li><strong>inline image</strong>，inline image内嵌在html里面，作为html的一部分和html一起加载。当图片大小小于8KB时，考虑使用inline image。</li>
<li><strong>使用webp格式图片</strong>，webp格式图片由google推出，android平台支持好，apple safari浏览器有兼容性问题（2020年Mac OS Big Sur中的Safari 14已经支持WebP格式。）</li>
<li><strong>jpg</strong>、<strong>png</strong>、<strong>svg</strong>等图片格式各有其特点和应用场合。</li>
</ol>


<p>另附上两个工具软件：</p>

<ol>
<li><a href="https://tinypng.com">图片压缩网站</a></li>
<li><a href="www.spritecow.com">雪碧图生成网站</a></li>
</ol>


<p><a id="markdown-图片的懒加载预加载" name="图片的懒加载预加载"></a></p>

<h2>图片的懒加载预加载</h2>

<p><a id="markdown-懒加载" name="懒加载"></a></p>

<h3>懒加载：</h3>

<p>通过图片进入可视区域的时候再设置img的src属性，进行请求。或者通过库实现。</p>

<p><a id="markdown-预加载" name="预加载"></a></p>

<h3>预加载：</h3>

<ol>
<li>使用<code>image</code>标签引入，先设置<code>display:none</code>。需要显示的时候再通过设置<code>display</code>属性将其显示出来。</li>
<li>在js中<code>new image</code>，并且设置<code>image</code>的<code>src</code>，进行图片下载，保存在js的变量中，但是不显示，需要的时候直接拿过来显示即可。</li>
<li>使用<code>XMLHttpRequest</code>，可以清楚知道请求的过程，但是存在跨域的问题。</li>
<li>或者通过库实现：preloader.js</li>
</ol>


<p><a id="markdown-html渲染过程" name="html渲染过程"></a></p>

<h2>HTML渲染过程</h2>

<ol>
<li>顺序执行，并发加载：为了让资源并发加载，可以部署多个CDN，以突破浏览器对单个域名并发加载数量的限制（4-6个）。

<ol>
<li><a href="https://juejin.cn/post/6844904035628089357">突破浏览器域名并发限制的解决方案</a></li>
<li>浏览器为什么要有这个限制，针对这个限制我们在开发的时候怎么优化？参考<a href="https://segmentfault.com/a/1190000039157302">前端性能优化篇——浏览器同域名并发请求对限制</a></li>
</ol>
</li>
<li>css加载延迟，页面先显示出没有样式的内容，原因是：css没有在header中引入，而是通过其他方式加载，比如在js中加载css。但是在header中通过link加载css也有缺点：阻塞页面渲染和js执行，但是不阻塞外部脚本的加载（得益于webkit的预扫描功能），但是阻塞执行。</li>
<li><code>script</code>和<code>import</code>引入方式：<code>script</code>引入js是同步的，阻塞页面渲染。结合<code>differ</code>和<code>sync</code>标签影响js引入过程。不阻塞资源的加载（得益于webkit的预扫描功能）。</li>
<li>SPA：单页应用，动态加载，路由到相关页面再加载相关的资源。</li>
</ol>


<p><a id="markdown-重绘外观与回流布局redrawreflow" name="重绘外观与回流布局redrawreflow"></a></p>

<h2>重绘（外观）与回流（布局）redraw/reflow</h2>

<p>css性能让js变慢：css影响layout，进而产生重绘与回流。多次的重绘与回流使得UI线程多次工作，而UI线程的启动会阻塞js线程的执行。</p>

<p>下面是一些有关<strong>回流与重绘</strong>实战演练。通过观察Chrome的Performance调试工具分析渲染过程和性能瓶颈。截图如下：</p>

<p><img src="/images/chrome_performance_demo.jpg" alt="chrome_performance_demo.jpg" /></p>

<p><a id="markdown-top-and-translate" name="top-and-translate"></a></p>

<h3>top and translate</h3>

<p>相比于<code>top</code>，<code>translate</code>没有回流的过程，对于dom结构复杂的页面，性能提升比较明显。</p>

<p><details>
  <summary>Code using <code>top</code></summary></p>

<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;style&gt;
        #rect {
            position: relative;
            top: 0;
            width: 100px;
            height: 100px;
            background: blue;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="rect"&gt;&lt;/div&gt;
    &lt;script&gt;
        setTimeout(() =&gt; {
            document.getElementById("rect").style.top = "100px";
        }, 2000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p></details></p>

<p><details>
  <summary>Code using <code>transform</code></summary></p>

<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;style&gt;
        #rect {
            position: relative;
            transform: translateY(0);
            width: 100px;
            height: 100px;

            background: blue;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="rect"&gt;&lt;/div&gt;
    &lt;script&gt;
        setTimeout(() =&gt; {
            document.getElementById("rect").style.transform = "translateY(100px)";
        }, 2000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p></details></p>

<p><a id="markdown-opacity替换visibility" name="opacity替换visibility"></a></p>

<h3><code>opacity</code>替换<code>visibility</code></h3>

<p><code>opaciy</code>：如果被修改的dom元素自己是一个图层，不触发回流和重绘（试验结果：没有回流，但是有重绘）；否则，触发回流和重绘。
<code>visibility</code>：不触发回流，只触发重绘。</p>

<p><a id="markdown-css的class替代style" name="css的class替代style"></a></p>

<h3>css的class替代style</h3>

<p>多个dom样式通过class一次改动多条style属性，减少回流和重绘的次数</p>

<p><a id="markdown-displaynone" name="displaynone"></a></p>

<h3><code>display:none</code></h3>

<p>先设置<code>display</code>为<code>none</code>，再修改各种属性，再将<code>display</code>设回来。</p>

<p><a id="markdown-慎用clientwidth" name="慎用clientwidth"></a></p>

<h3>慎用<code>clientWidth</code></h3>

<p>不要在循环中获取dom的<code>clientWidth</code>，否则会flash掉浏览器的缓冲区，使浏览器性能下降。</p>

<p>缓冲区是浏览器的优化机制，将多个改动合并成一次改动，以便提高效率。</p>

<p><a id="markdown-少用table布局" name="少用table布局"></a></p>

<h3>少用table布局。</h3>

<p>修改某一<code>td</code>的宽度，会使得所有<code>td</code>进行回流。</p>

<p><a id="markdown-动画的刷新率和页面性能平衡" name="动画的刷新率和页面性能平衡"></a></p>

<h3>动画的刷新率和页面性能平衡</h3>

<p><a id="markdown-将gif图单独成一个图层" name="将gif图单独成一个图层"></a></p>

<h3>将gif图单独成一个图层</h3>

<p>通过设置某些css属性，将某个dom做成一个图层：</p>

<ol>
<li><code>will-change</code></li>
<li><code>transform: translateZ(0)</code></li>
<li><code>translate3d(0,0,0)</code></li>
</ol>


<p><a id="markdown-启用gpu硬件加速" name="启用gpu硬件加速"></a></p>

<h3>启用GPU硬件加速</h3>

<p>启用GPU加速，会减少重绘的时间，但是图层增多，图层合并的时间会增加，这里也有个平衡需要把握。</p>

<p>细节参考<a href="https://lz5z.com/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-CSS3%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/">Web 性能优化-CSS3 硬件加速(GPU 加速)</a></p>

<p><a id="markdown-浏览器存储" name="浏览器存储"></a></p>

<h2>浏览器存储</h2>

<ol>
<li>cdn域名和主站域名区分开，防止获取静态资源携带cookie，浪费带宽。</li>
<li>通过service worker开启另一个线程，和主页通过<code>postMessage</code>互相通信。</li>
<li>通过浏览器performance profile查看性能瓶颈和改进效果。</li>
<li>增加图层是减少的重绘与回流的时间与增加的图层合并时间的增加之间的平衡。比如通过设置translate3d开启GPU加速。</li>
<li>获取offsetHeight为什么会降低效率？使缓冲区域失效，因为要得到一个真实的尺寸。缓冲区域是浏览器的一个优化机制，通过将多次更改dom综合起来一次更新，提高效率。</li>
</ol>


<p><a id="markdown-缓存" name="缓存"></a></p>

<h2>缓存</h2>

<p><strong>强缓存</strong>
如果命中，不需要发请求到服务器。</p>

<ol>
<li>cache-control: max-age, s-max-age</li>
<li>expires:</li>
</ol>


<p><strong>协商缓存（弱缓存）</strong>
需要发请求到服务器询问本地缓存是否可用。如果可用，服务器返回304，不携带具体内容，具体内容从本地缓存中读取。如果不可用，服务器直接返回内容。</p>

<ol>
<li>last-modified:</li>
<li>if-modified-since: 304</li>
<li>e-tag:</li>
<li>if-none-match:</li>
</ol>


<p>浏览器缓存流程如下：</p>

<p><img src="/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="浏览器缓存流程图.png" /></p>

<p>关于缓存，下面两篇文章介绍的很清楚：</p>

<ol>
<li><a href="https://www.jiqizhixin.com/articles/2020-07-24-12">Web 缓存介绍</a></li>
<li><a href="https://segmentfault.com/a/1190000010787023">HTTP 缓存之浏览器刷新行为</a>: disable cache setting in the developper tool</li>
</ol>


<p><a id="markdown-服务器端渲染" name="服务器端渲染"></a></p>

<h2>服务器端渲染</h2>

<ol>
<li>vue-ssr (server-side-rendering)</li>
<li>react-ssr</li>
<li>代价：需要一个universal的code base，保证其在服务器端和浏览器端都能运行。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[极客时间-深入浅出云计算]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/12/06/shenru-qianchu-yunjisuan/"/>
    <updated>2021-12-06T10:21:06+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/12/06/shenru-qianchu-yunjisuan</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#01--%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%8F%AF%E7%94%A8%E5%8C%BA%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E4%BA%91%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83">01 | 区域和可用区：欢迎来到云端数据中心</a></li>
<li><a href="#02--%E4%BA%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%80%E4%BA%91%E7%AB%AF%E6%94%92%E6%9C%BA%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%B9%E6%98%93%E5%BF%BD%E8%A7%86%E7%9A%84%E8%A6%81%E7%82%B9">02 | 云虚拟机（一）：云端“攒机”，有哪些容易忽视的要点?</a></li>
<li><a href="#03-%E4%B8%A8%E4%BA%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BA%8C%E7%9C%BC%E8%8A%B1%E7%BC%AD%E4%B9%B1%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%8B%E5%8F%B7%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">03 丨云虚拟机（二）：眼花缭乱的虚拟机型号，我该如何选择？</a></li>
<li><a href="#04-%E4%B8%A8%E4%BA%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%89%E8%80%81%E6%9D%BF%E8%A6%81%E6%B1%82%E7%9C%81%E7%9C%81%E7%9C%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A6%99%E6%8B%9B">04 丨云虚拟机（三）：老板要求省省省，有哪些妙招？</a></li>
<li><a href="#05--%E4%BA%91%E7%A1%AC%E7%9B%98%E4%BA%91%E4%B8%8Aio%E5%88%B0%E5%BA%95%E7%BB%99%E4%B8%8D%E7%BB%99%E5%8A%9B">05 | 云硬盘：云上IO到底给不给力？</a></li>
<li><a href="#06--%E4%BA%91%E4%B8%8A%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E5%BC%80%E5%90%88%E6%9C%89%E5%BA%A6%E7%BC%96%E7%BB%87%E6%97%A0%E5%BD%A2%E4%B9%8B%E7%BD%91">06 | 云上虚拟网络：开合有度，编织无形之网</a>

<ul>
<li><a href="#%E5%BC%B9%E6%80%A7%E7%BD%91%E5%8D%A1">弹性网卡</a></li>
<li><a href="#%E5%85%AC%E7%BD%91ip%E5%92%8C%E5%BC%B9%E6%80%A7ip">公网IP和弹性IP</a></li>
</ul>
</li>
<li><a href="#07--%E4%BA%91%E7%AB%AF%E6%9E%B6%E6%9E%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%95%85%E9%9A%9C%E5%90%8C%E8%88%9E%E4%B8%8E%E4%BC%B8%E7%BC%A9%E5%85%B1%E7%94%9F">07 | 云端架构最佳实践：与故障同舞，与伸缩共生</a></li>
<li><a href="#08-%E4%B8%A8%E4%BA%91%E4%B8%8A%E8%BF%90%E7%BB%B4%E4%BA%91%E7%AB%AF%E7%A9%B6%E7%AB%9F%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E8%BF%90%E7%BB%B4%E9%9C%80%E8%A6%81%E6%80%8E%E6%A0%B7%E7%9A%84%E8%BF%90%E7%BB%B4">08 丨云上运维：云端究竟需不需要运维？需要怎样的运维？</a></li>
<li><a href="#09--%E4%BB%80%E4%B9%88%E6%98%AFpaas%E6%80%8E%E6%A0%B7%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%92%8C%E8%AF%84%E4%BC%B0paas">09 | 什么是PaaS？怎样深入理解和评估PaaS？</a></li>
<li><a href="#10--%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9C%8B%E4%BC%BC%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8E%84%E6%9C%BA">10 | 对象存储：看似简单的存储服务都有哪些玄机？</a>

<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7">对象存储的高级特性</a></li>
</ul>
</li>
<li><a href="#11--%E5%BA%94%E7%94%A8%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1web%E5%BA%94%E7%94%A8%E6%80%8E%E6%A0%B7%E5%9C%A8%E4%BA%91%E4%B8%8A%E5%AE%89%E5%AE%B6">11 | 应用托管服务：Web应用怎样在云上安家？</a></li>
<li><a href="#12--%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E6%AD%8C%E7%8C%9B%E8%BF%9B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B0%E8%B4%B5">12 | 云数据库：高歌猛进的数据库“新贵”</a>

<ul>
<li><a href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E5%BA%93">云原生数据库</a></li>
</ul>
</li>
<li><a href="#13--%E4%BA%91%E4%B8%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BA%91%E8%AE%A1%E7%AE%97%E9%81%87%E4%B8%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A0%AA%E7%A7%B0%E5%A4%A9%E4%BD%9C%E4%B9%8B%E5%90%88">13 | 云上大数据：云计算遇上大数据，为什么堪称天作之合？</a></li>
<li><a href="#14--%E4%BA%91%E4%B8%8A%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%E4%BB%8Edocker%E5%88%B0kubernetes%E8%BF%8E%E6%8E%A5%E4%BA%91%E5%8E%9F%E7%94%9F%E6%B5%AA%E6%BD%AE">14 | 云上容器服务：从Docker到Kubernetes，迎接云原生浪潮</a></li>
<li><a href="#15--%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A1%E7%AE%97%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4%E6%95%88%E7%8E%87%E7%9A%84%E5%A4%9A%E9%9D%A2%E6%89%8B">15 | 无服务器计算：追求极致效率的多面手</a></li>
<li><a href="#16--%E4%BA%91%E4%B8%8Aai%E6%9C%8D%E5%8A%A1%E4%BA%91ai%E8%83%BD%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E5%B8%AE%E5%8A%A9%E6%9E%84%E5%BB%BA%E6%99%BA%E8%83%BD%E5%BA%94%E7%94%A8">16 | 云上AI服务：云AI能从哪些方面帮助构建智能应用？</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-01--区域和可用区欢迎来到云端数据中心" name="01--区域和可用区欢迎来到云端数据中心"></a></p>

<h2>01 | 区域和可用区：欢迎来到云端数据中心</h2>

<p><a id="markdown-02--云虚拟机一云端攒机有哪些容易忽视的要点" name="02--云虚拟机一云端攒机有哪些容易忽视的要点"></a></p>

<h2>02 | 云虚拟机（一）：云端“攒机”，有哪些容易忽视的要点?</h2>

<p>传统的虚拟化（虚拟机），往往是对单一物理机器资源的纵向切割，计算、存储、网络等各方面的能力都是一台物理机的子集。因此，从可伸缩性的角度来说，传统虚拟机存在较大的局限，当物理机的局部出现故障时，也很容易影响到里面的虚拟机。</p>

<p>得益于云端大规模的专属硬件以及高速的内部网络，云虚拟机的组成则有所不同。除了核心的 CPU 与内存部分仍属于一台宿主机外，它的网络、硬盘等其他部分，则可以超脱于宿主机之外，享受云端其他基础设施的能力。大致架构如下图所示：</p>

<p><img src="/images/%E4%BA%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B5%84%E6%BA%90%E6%9E%84%E6%88%90.jpeg" alt="云虚拟机资源构成" /></p>

<p>所以，云虚拟机，与其说是由一台宿主机虚拟而成的，不如说是云数据中心中的不同部分一起协作，“拼凑”而成的一台机器。这样虚拟出来的机器，我们在使用感受上其实与传统服务器并无不同，但在可扩展性和故障隔离方面，它就具有很大的优势了。</p>

<p><a id="markdown-03-丨云虚拟机二眼花缭乱的虚拟机型号我该如何选择" name="03-丨云虚拟机二眼花缭乱的虚拟机型号我该如何选择"></a></p>

<h2>03丨云虚拟机（二）：眼花缭乱的虚拟机型号，我该如何选择？</h2>

<p><a id="markdown-04-丨云虚拟机三老板要求省省省有哪些妙招" name="04-丨云虚拟机三老板要求省省省有哪些妙招"></a></p>

<h2>04丨云虚拟机（三）：老板要求省省省，有哪些妙招？</h2>

<p><a id="markdown-05--云硬盘云上io到底给不给力" name="05--云硬盘云上io到底给不给力"></a></p>

<h2>05 | 云硬盘：云上IO到底给不给力？</h2>

<p>云厂商对于云盘，一般会帮你在存储端同步和保留至少三份副本的数据。所以说，云硬盘的冗余度和可用性是非常之高的，一般极少发生云硬盘数据丢失的情况，你大可放心地使用。</p>

<p>云盘性能指标：</p>

<ul>
<li>IOPS</li>
<li>吞吐量</li>
<li>访问延时</li>
</ul>


<p>云硬盘与传统磁盘的真正差异在于，绝大多数的云硬盘都是<strong>远程</strong>的。</p>

<p>我们都知道，在经典计算机的体系结构中，硬盘是通过本地机器内部主板的高速总线，与 CPU、内存等部件相连接；而在云端，你的硬盘则很可能并不在宿主机上，而是在专用的磁盘服务器阵列中，两者是通过数据中心内部的特有IO线路进行连接的。</p>

<p>理解了这样的一个结构，你就能明白，有些云上的“IO优化实例”（AWS 上称为 EBS-Optimized）是指什么了。它就是指云虚拟机与云硬盘之间的网络传输，进行了软硬件层面的优化，这样可以充分地发挥所挂载磁盘的性能。现在较新型号、较强性能的云虚拟机，一般都自动启用了这个优化。</p>

<p>云存储的性能级别：</p>

<p><img src="/images/%E4%BA%91%E5%AD%98%E5%82%A8%E7%9A%84%E7%BA%A7%E5%88%AB.jpeg" alt="云存储的级别" /></p>

<p>除了云盘性能等级，还有一个指标也是影响云盘性能的重要指标：云盘容量。不论是哪种磁盘类型，它的容量大小几乎都与性能正向相关。同等的性能等级下，云硬盘的容量越大，一般来说它的性能就越高，直到达到这个等级的上限。这是由云上磁盘能力共享的底层设计所决定的。</p>

<p>所以在某些时候，你可能需要刻意地增大所申请的云硬盘的容量，以获取更高的性能，即便这些额外的空间不一定能被用上。</p>

<p><a id="markdown-06--云上虚拟网络开合有度编织无形之网" name="06--云上虚拟网络开合有度编织无形之网"></a></p>

<h2>06 | 云上虚拟网络：开合有度，编织无形之网</h2>

<p>虚拟私有网络（Virtual Private Cloud，简称 VPC），是云计算网络端最重要的概念之一，它是指构建在云上的、相互隔离的、用户可以自主控制的私有网络环境。虚拟私有网络有时也称为专有网络（阿里云）或虚拟网络（Virtual Network 或 VNet，Azure 的叫法）。</p>

<p>上面的概念解释也许不太好理解，其实用通俗的话来讲，私有网络就是一张属于你自己的内网。内网之内的服务器和设备，可以比较自由地互相通信，与外界默认是隔离的。如果外部互联网，或者其他虚拟网络需要连接，则需要额外的配置。</p>

<p>所以说，虚拟私有网络，就是你在云上的保护网，能够有效地保护网内的各种设施。有的时候，你可能还要同时创建多个虚拟网络，让它们各司其职，实现更精细的隔离。</p>

<p><a id="markdown-弹性网卡" name="弹性网卡"></a></p>

<h3>弹性网卡</h3>

<p>云上的网卡，之所以被称为“弹性”网卡，是因为它具备以下特征：</p>

<ol>
<li>一个虚拟机可以绑定多块网卡，有主网卡和辅助网卡之分；</li>
<li>一块网卡隶属于一个子网，可以配置同一子网内的多个私有 IP；</li>
<li>辅助网卡可以动态解绑，还能够绑定到另一台虚拟机上。</li>
</ol>


<p><a id="markdown-公网ip和弹性ip" name="公网ip和弹性ip"></a></p>

<h3>公网IP和弹性IP</h3>

<p>在绝大多数的云上，创建虚拟机时都会有一个选项，问你“是否同时为虚拟机分配一个公网 IP 地址”。如果你选择“是”，这样机器启动后，就会拥有一个自动分配的公网地址，便于你从自己的电脑连接到这个实例。这在很多时候都是最方便的选择。</p>

<p>但对于生产环境，我的推荐是，尽量不要使用和依赖这个自动生成的公有 IP。因为它本质上是一个从公有云的 IP 池中临时租用给你的 IP。如果你的机器关闭或重启，下次获得的 IP 可能就完全不同了。</p>

<p>这时，我们真正应该用到的是弹性 IP（Elastic IP），有些云称为 eIP。弹性 IP 一旦生成，它所对应的 IP 是固定、不会变化的，而且完全属于你所有。这非常适合需要稳定 IP 的生产环境。</p>

<p>请不要被它的名字迷惑，它所谓的弹性，其实是指可以非常自由地解绑和再次绑定到任意目标。你本质上是买下了这个 IP 的所有权，将这个 IP 赋予谁，是你的权利，而且你还可以动态按需切换。</p>

<p><a id="markdown-07--云端架构最佳实践与故障同舞与伸缩共生" name="07--云端架构最佳实践与故障同舞与伸缩共生"></a></p>

<h2>07 | 云端架构最佳实践：与故障同舞，与伸缩共生</h2>

<p>云上架构最需要注意什么呢？就像我在标题所描述的那样，云端架构一方面需要处理和应对可能出现的<strong>故障</strong>，保证架构和服务的可用性；另一方面则是需要充分利用好云端的<strong>弹性</strong>，要能够根据负载进行灵活的伸缩。</p>

<p>那么，云上可能出现哪些不同层面的故障？相应的故障范围和应对措施又会是怎样的呢？</p>

<p><strong>第一种故障是在宿主机的级别，这也是从概率上来说最常见的一种故障。</strong>当宿主机出现硬件故障等问题后，毫无疑问将影响位于同一宿主机上的多个虚拟机。为了避免产生这样的影响，当我们承载重要业务时，就需要创建多台虚拟机组成的集群，共同来进行支撑。这样，当一台虚拟机出现故障时，还有其他几台机器能够保证在线。</p>

<p>这里需要注意的是，<strong>我们需要保证多个虚拟机不在同一台宿主机上，甚至不处于同一个机架上，以免这些虚拟机一起受到局部事故的影响。</strong></p>

<p><strong>第二种规模更大的故障，是在数据中心，也就是可用区的层面。</strong>要应对这类故障，我们就需要<strong>多可用区的实例部署</strong>。</p>

<p><strong>第三种更严重的故障，就是整个区域级别的事故了。</strong>当然这种一般非常少见，只有地震等不可抗力因素，或者人为过失引发出的一系列连锁反应，才有可能造成这么大的影响。区域级别的事故一般都难免会对业务造成影响了。这时能够进行补救的，主要看<strong>多区域架构层面是否有相关的预案</strong>。</p>

<p>再更进一步的万全之策，就需要考虑<strong>多云</strong>了。也就是同时选用多家云厂商的公有云，一起来服务业务。虽然集成多个异构的云会带来额外的成本，但这能够最大限度地降低服务风险，因为两家云厂商同时出问题的概率实在是太低了。更何况，多云还能带来避免厂商锁定的好处，现在其实也越来越多见了。</p>

<p>当然，盲目地追求可用性也不可取。<strong>根据业务需求，在成本投入与可用性之间获得一个最佳的平衡，才是你应该追求的目标。</strong></p>

<p><a id="markdown-08-丨云上运维云端究竟需不需要运维需要怎样的运维" name="08-丨云上运维云端究竟需不需要运维需要怎样的运维"></a></p>

<h2>08丨云上运维：云端究竟需不需要运维？需要怎样的运维？</h2>

<p><a id="markdown-09--什么是paas怎样深入理解和评估paas" name="09--什么是paas怎样深入理解和评估paas"></a></p>

<h2>09 | 什么是PaaS？怎样深入理解和评估PaaS？</h2>

<p>PaaS 是在 IaaS 的基础上又做了许多工作，构建了很多关键抽象和可复用的单元，让我们用户能够在更上层进行应用的构建，把更多精力放在业务逻辑上。</p>

<p>所以 PaaS 服务的优势，就在于生产力，在于效率，尤其是在搭建和运维层面。</p>

<p><a id="markdown-10--对象存储看似简单的存储服务都有哪些玄机" name="10--对象存储看似简单的存储服务都有哪些玄机"></a></p>

<h2>10 | 对象存储：看似简单的存储服务都有哪些玄机？</h2>

<p>同样是存储服务，对象存储和前面我们 IaaS 部分讲过的云硬盘存储有什么区别呢？</p>

<p>第一个主要区别，在于<strong>访问的接口与形式</strong>。</p>

<p>云硬盘其实是挂载到虚拟机的虚拟硬盘，它是通过实现操作系统级别的底层接口，作为虚拟机的块存储设备而存在。我们也必须连接到相关的虚拟机，才能访问它里面的数据。</p>

<p>而对象存储，本质是一个网络化的服务，调用方主要通过高层的 API 和 SDK 来和它进行交互。不管是面向外部公开互联网服务，还是和内部应用程序对接，对象存储都是通过提供像 HTTP 这样的网络接口来实现的。所以它的独立性很强，不需要依赖其他组件就可以运作。</p>

<p>第二个主要区别，也是对象存储的一大特征，就是对象存储内本身不存在一个真正的文件系统，而是更接近一个<strong>键值</strong>（Key-Value）形式的存储服务。</p>

<p>键值系统和云硬盘上经典文件系统的<strong>核心差异</strong>，就在于文件系统保存了更多的元数据，尤其是实现了目录结构和目录操作。而键值系统中，所谓的目录其实是多个对象共享的路径前缀，可以说是用前缀模拟出了目录。</p>

<p>第三个主要区别，在于对象存储的<strong>据大容量</strong>。</p>

<p><a id="markdown-对象存储的高级特性" name="对象存储的高级特性"></a></p>

<h3>对象存储的高级特性</h3>

<p>第一个重要特性，是<strong>存储分层</strong>。</p>

<p><img src="/images/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%88%86%E5%B1%82.jpeg" alt="对象存储分层" /></p>

<p>存储分层的存在，让原本价格低廉的云上存储更加具有成本竞争力。给你举个例子，现在归档层的存储费用，在典型情况下大约是每 GB 每月 1 分钱左右，是不是低得惊人？所以，很多用户上云的一个应用场景就是，把原本占用大量传统磁盘的备份文件，利用对象存储的归档能力长期保存。</p>

<p>第二个值得称道的特性，是<strong>生命周期管理</strong>。可以对存储对象设置过期规则。</p>

<p>第三个特性，则是对象的<strong>版本管理</strong>。</p>

<p><a id="markdown-11--应用托管服务web应用怎样在云上安家" name="11--应用托管服务web应用怎样在云上安家"></a></p>

<h2>11 | 应用托管服务：Web应用怎样在云上安家？</h2>

<p>你可以使用虚拟机和其他 IaaS 组件来搭建你的网站。但用 IaaS，你需要操心的事情比较多，包括虚拟机的创建、运行环境的搭建和依赖安装、高可用性和水平扩展的架构等等。而且一旦应用的规模大了，每次应用的更新升级也会是件麻烦事，另外你还要操心 Web 漏洞的弥补修复。</p>

<p>那么，能不能有一个平台服务，来帮助我们解决所有这些基础架构问题，让我们只需要专注于应用构建本身就好了呢？当然是有的，这就是云上应用托管 PaaS 服务的由来。</p>

<p><a id="markdown-12--云数据库高歌猛进的数据库新贵" name="12--云数据库高歌猛进的数据库新贵"></a></p>

<h2>12 | 云数据库：高歌猛进的数据库“新贵”</h2>

<p>而近年来随着云计算的兴起，云数据库作为一支新生力量，一路高歌猛进，打破了数据库市场的原有格局，也进入了越来越多开发者的视野当中。这类 PaaS 服务的朴素思想就是，将数据库服务搬到云上，让用户更方便轻松地使用、管理和维护数据库。</p>

<p><a id="markdown-云原生数据库" name="云原生数据库"></a></p>

<h3>云原生数据库</h3>

<p>云原生数据库：完全为云设计、能够充分发挥云的特点和优势的数据库。</p>

<p>出于生态发展和降低学习难度的需要，绝大多数的云原生数据库仍然保留了 SQL 等常见接口（有的还支持不同 SQL 方言的选择），但除此以外，云原生数据库大都进行了全面革新和重新设计，有的云会大刀阔斧地改造开源代码，有的甚至脱离了现有包袱，完全重新构建。</p>

<p>这样的尝试取得了巨大的成功，业界也逐渐形成了一系列不同领域的云原生数据库矩阵，大大拓展了云上数据库的范畴和影响力。</p>

<p>我这里也为你整理了一张表格，按照厂商和云数据库的类型进行了梳理和比较。其中，标红的部分是相当值得你关注的自研云原生数据库。</p>

<p><img src="/images/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E5%BA%93.jpeg" alt="云原生数据库" /></p>

<p><a id="markdown-13--云上大数据云计算遇上大数据为什么堪称天作之合" name="13--云上大数据云计算遇上大数据为什么堪称天作之合"></a></p>

<h2>13 | 云上大数据：云计算遇上大数据，为什么堪称天作之合？</h2>

<p><a id="markdown-14--云上容器服务从docker到kubernetes迎接云原生浪潮" name="14--云上容器服务从docker到kubernetes迎接云原生浪潮"></a></p>

<h2>14 | 云上容器服务：从Docker到Kubernetes，迎接云原生浪潮</h2>

<p><a id="markdown-15--无服务器计算追求极致效率的多面手" name="15--无服务器计算追求极致效率的多面手"></a></p>

<h2>15 | 无服务器计算：追求极致效率的多面手</h2>

<p>无服务器（Serverless）完全屏蔽了计算资源，它是在真正地引导你不再去关心底层环境，你只要遵循标准方式来直接编写业务代码就可以了。其中一个具体应用就是函数即服务（FaaS，Function as a service)。</p>

<p>各大云厂商现在都已经推出了各自的无服务器计算服务，比如 AWS 的 <strong>Lambda</strong>，阿里云的<strong>函数计算</strong>，微软Azure的<strong>Azure Function</strong>，微信的<strong>云函数</strong>。</p>

<p>为了让这个云函数能够对外服务，我们接下来就需要为它添加一个 <strong>API网关触发器</strong>，这样当 API 被外界访问时，这个云函数就会被触发执行并返回结果给网关。</p>

<p>API 网关是一个独立的 PaaS 服务，它可以和云函数联动使用。它的作用是为外界访问提供一个端点，并引流到我们的后台计算服务。</p>

<p>无服务器计算灵活轻量，便于迭代。但是，我们还是要记得恪守冷静客观的原则。一定不要忽略了 Serverless 服务的限制，毕竟它的本质是受限的环境。<strong>冷启动的延时、内存的限制、云函数的运行时长、并发数上限</strong>等等，这些都是你大规模深入应用之前需要评估考虑的问题。虽然云厂商一直在改进，这些客观限制在当下对于你的场景是否造成了实质性障碍，也是你目前是否选择 Serverless 计算的一个重要依据。</p>

<p><a id="markdown-16--云上ai服务云ai能从哪些方面帮助构建智能应用" name="16--云上ai服务云ai能从哪些方面帮助构建智能应用"></a></p>

<h2>16 | 云上AI服务：云AI能从哪些方面帮助构建智能应用？</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Nodejs-Express-MongoDB搭建服务器]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/10/27/mean-with-nodejs-express-mongodb/"/>
    <updated>2021-10-27T15:47:25+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/10/27/mean-with-nodejs-express-mongodb</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Demo source code on the github: <a href="https://github.com/hongchaozhang/nodejs-express-mongodb">Github demo source code</a>.</p>

<h2>Steps to start the server:</h2>

<ol>
<li>Clone the <a href="https://github.com/hongchaozhang/nodejs-express-mongodb">Github demo source code</a>.</li>
<li>install MongoDB with the steps from <a href="https://cloud.tencent.com/developer/article/1770288">Mac OSX 平台 MongoDB 的安装及管理</a>.</li>
<li>Config MongoDB and start it with <code>mongod --dbpath /usr/local/var/mongodb --logpath /usr/local/var/log/mongodb/mongo.log --fork</code>.</li>
<li>Start the server by running <code>node server.js</code>.</li>
<li>Test the APIs by curl or Postman (recommended).</li>
</ol>


<h3>Note</h3>

<h4>nodejs version</h4>

<p>If you meet the following error while running <code>node server.js</code>, check your nodejs version to make sure you are using 12 and above. <code>14.17.6</code> is tested. The error is:
<code>
/Users/hozhang/Develop/PracticeProjects/nodejs-express-mongodb/node_modules/whatwg-url/lib/encoding.js:2
const utf8Encoder = new TextEncoder();
ReferenceError: TextEncoder is not defined
</code></p>

<h4>How to start/shutdown MongoDB</h4>

<ol>
<li>After correctly configuring your MongoDB, use the following command to start it:
 <code>mongod --dbpath /usr/local/var/mongodb --logpath /usr/local/var/log/mongodb/mongo.log --fork</code></li>
<li>After enter the mongo environment by running <code>mongo</code>, use the following command to shutdown the MongoDB:
 ```

<blockquote><p>use admin;
db.shutdownServer();
 ```</p></blockquote></li>
</ol>


<h4>MongoDB Compass</h4>

<p>Use the official UI tool to manage your MongoDB data: MongoDB Compass.</p>

<h4>Postman</h4>

<p>Use the Postman to act as a client. It is convenient to config/manage the request.</p>

<h2>code explanation</h2>

<p>Refer to <a href="https://www.bezkoder.com/node-express-mongodb-crud-rest-api/">Node.js, Express &amp; MongoDb: Build a CRUD Rest Api example</a> for detailed code explanation.</p>

<h2>References</h2>

<ul>
<li><a href="https://cloud.tencent.com/developer/article/1770288">Mac OSX 平台 MongoDB 的安装及管理</a></li>
<li><a href="https://www.bezkoder.com/node-express-mongodb-crud-rest-api/">Node.js, Express &amp; MongoDb: Build a CRUD Rest Api example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[极客时间-罗剑锋-《透视HTTP协议》总结]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi/"/>
    <updated>2021-05-26T18:32:49+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82">协议分层</a></li>
<li><a href="#dns">DNS</a>

<ul>
<li><a href="#dns%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B">DNS访问过程</a></li>
<li><a href="#dns%E7%9A%84%E7%BC%93%E5%AD%98">DNS的缓存</a></li>
<li><a href="#dns%E6%96%B0%E7%8E%A9%E6%B3%95">DNS新玩法</a></li>
</ul>
</li>
<li><a href="#%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%86%8D%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E9%9D%A2%E7%A9%B6%E7%AB%9F%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">键入网址再按下回车，后面究竟发生了什么？</a></li>
<li><a href="#tls%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">TLS握手过程</a></li>
<li><a href="#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">http性能优化</a></li>
<li><a href="#%E8%AF%95%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac">试验环境搭建（Mac）</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-协议分层" name="协议分层"></a></p>

<h2>协议分层</h2>

<p>TCP/IP的四层模型和OSI的七层模型之间的对应关系：</p>

<p><img src="/images/20200526%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="20200526四层协议和七层协议的对应关系.png" /></p>

<p>详细说一下TCP/IP的四层模型：</p>

<ul>
<li>第一层叫“<strong>链接层</strong>”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</li>
<li>第二层叫“<strong>网际层</strong>”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</li>
<li>第三层叫“<strong>传输层</strong>”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</li>
<li>协议栈的第四层叫“<strong>应用层</strong>”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。</li>
</ul>


<p>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>

<p>有了上面的概念，才可能理解下面的术语：</p>

<ul>
<li>四层负载均衡：指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</li>
<li>七层负载均衡：指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</li>
</ul>


<p>下面以TCP/IP的四层模型来说明请求数据的发送和接收过程：</p>

<p><img src="/images/20200526%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="20200526四层模型工作过程模型.png" /></p>

<p>发送过程就是一层一层包裹的过程，接收的过程就是一层一层拨开的过程。</p>

<p><a id="markdown-dns" name="dns"></a></p>

<h2>DNS</h2>

<p><a id="markdown-dns访问过程" name="dns访问过程"></a></p>

<h3>DNS访问过程</h3>

<p>域名必须转换成IP才能进行网络访问。这个过程需要DNS（Domain Name System）。</p>

<p>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</p>

<ol>
<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>
<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>
<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。</li>
</ol>


<p>DNS三层结构示意图如下：</p>

<p><img src="/images/20200526%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.png" alt="20200526域名服务器层级结构.png" /></p>

<p>有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。</p>

<p>例如，你要访问“www.apple.com”，就要进行下面的三次查询：</p>

<ol>
<li>访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</li>
<li>访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</li>
<li>最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。</li>
</ol>


<p><a id="markdown-dns的缓存" name="dns的缓存"></a></p>

<h3>DNS的缓存</h3>

<p>虽然核心的 DNS 系统遍布全球，服务能力很强也很稳定，但如果全世界的网民都往这个系统里挤，即使不挤瘫痪了，访问速度也会很慢。</p>

<p>所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“<strong>缓存</strong>”。</p>

<p><strong>首先</strong>，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</p>

<p>这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。</p>

<p><strong>其次</strong>，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到 DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</p>

<p><strong>另外</strong>，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</p>

<p><a id="markdown-dns新玩法" name="dns新玩法"></a></p>

<h3>DNS新玩法</h3>

<p>除了解析得到IP地址，DNS还可以用来做一些其他事情。</p>

<ol>
<li>第一种，也是最简单的，“重定向”。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。实现停机维护期间服务不中断。</li>
<li>第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名，而且这种方式也兼具了第一种“玩法”的优势。</li>
<li>第三种“玩法”包含了前两种，也就是基于域名实现的负载均衡。在计算IP的时候考虑哪台主机资源充足，更适合提供服务，就返回哪台服务器的IP地址。</li>
</ol>


<p><a id="markdown-键入网址再按下回车后面究竟发生了什么" name="键入网址再按下回车后面究竟发生了什么"></a></p>

<h2>键入网址再按下回车，后面究竟发生了什么？</h2>

<p>当用户在浏览器地址栏输入<a href="">http://127.0.0.1/</a>，并按下回车之后，浏览器和服务器之间的行为如下：</p>

<p><img src="/images/20200526http%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B.png" width="400" alt="20200526http请求全过程.png" /></p>

<ol>
<li>首先是TCP连接的建立：经过 SYN、SYN/ACK、ACK 的三个包之后，浏览器与服务器的 TCP 连接就建立起来了。</li>
<li>有了可靠的 TCP 连接通道后，HTTP 协议就可以开始工作了。于是，浏览器按照 HTTP 协议规定的格式，通过 TCP 发送了一个“GET / HTTP/1.1”请求报文，也就是 Wireshark 里的第四个包。</li>
<li>随后，Web 服务器回复了第五个包，在 TCP 协议层面确认：“刚才的报文我已经收到了”，不过这个 TCP 包 HTTP 协议是看不见的。</li>
<li>Web 服务器收到报文后在内部就要处理这个请求。同样也是依据 HTTP 协议的规定，解析报文，看看浏览器发送这个请求想要干什么。它一看，原来是要求获取根目录下的默认文件，好吧，那我就从磁盘上把那个文件全读出来，再拼成符合 HTTP 格式的报文，发回去吧。这就是第六个包“HTTP/1.1 200 OK”，底层走的还是 TCP 协议。</li>
<li>同样的，浏览器也要给服务器回复一个 TCP 的 ACK 确认，“你的响应报文收到了，多谢。”，即第七个包。</li>
<li>这时浏览器就收到了响应数据，但里面是什么呢？所以也要解析报文。一看，服务器给我的是个 HTML 文件，好，那我就调用排版引擎、JavaScript 引擎等等处理一下，然后在浏览器窗口里展现出了欢迎页面。</li>
<li>这之后还有两个来回，共四个包，重复了相同的步骤。这是浏览器自动请求了作为网站图标的“favicon.ico”文件，与我们输入的网址无关。但因为我们的实验环境没有这个文件，所以服务器在硬盘上找不到，返回了一个“404 Not Found”。</li>
<li>最后是TCP关闭连接的“四次挥手”。但是当你通过抓包软件抓包的时候可能看不到这几个包，因为HTTP/1.1 长连接特性，默认不会立即关闭连接。</li>
</ol>


<p>至此，“键入网址再按下回车”的全过程就结束了。</p>

<p>当然，上面只是一个极简网络模型。真实世界中的应用复杂很多。</p>

<ol>
<li>上面是直接输入了IP地址，如果输入的是域名，那么在上面所有步骤之前还有DNS解析过程。</li>
<li>如果用的是https通信协议，在TCP连接建立之后还要有TLS连接的建立。</li>
<li>别忘了互联网上还有另外一个重要的角色 CDN，它也会在 DNS 的解析过程中“插上一脚”。DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。</li>
<li>如果你的请求跳过CDN，到达目标服务器，这时发生的事情如下：目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如四层的 LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群。</li>
<li>负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish，它们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力。</li>
<li>如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。它们又会再访问后面的 MySQL、PostgreSQL、MongoDB 等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份。</li>
<li>应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。</li>
<li>最后网站的响应数据回到了你的设备，它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。</li>
</ol>


<p>综合考虑上面的因素，整体的workflow可以表示如下：</p>

<p><img src="/images/NetworkRequestWorkflow.svg" alt="NetworkRequestWorkflow.svg" /></p>

<p><a id="markdown-tls握手过程" name="tls握手过程"></a></p>

<h2>TLS握手过程</h2>

<p>关于“TLS如何保证安全”这个话题，参考<a href="https://www.zhihu.com/question/52493697">知乎回答</a>。上面这篇文中的“编程指北”的回答最清晰。身份认证可以直接看3.5和3.6小节。真正申请一个SSL证书需要知道的常识：<a href="https://www.cnblogs.com/mafly/p/ssl.html">一篇文章让你搞懂 SSL 证书</a>。</p>

<p>简要过程图：</p>

<p><img src="/images/20200526TLS%E9%93%BE%E6%8E%A5%E7%AE%80%E8%A6%81%E8%BF%87%E7%A8%8B.png" width="400" alt="20200526TLS链接简要过程.png" /></p>

<p>详细过程图：</p>

<p><img src="/images/20200526TLS%E9%93%BE%E6%8E%A5%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.png" width="400" alt="20200526TLS链接详细过程.png" /></p>

<p>详细的分析解说参考原文：<a href="/assets/resources/26%E4%B8%A8%E4%BF%A1%E4%BB%BB%E5%A7%8B%E4%BA%8E%E6%8F%A1%E6%89%8B%EF%BC%9ATLS1.2%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.html">26丨信任始于握手：TLS1.2连接过程解析.html</a></p>

<p><a id="markdown-http性能优化" name="http性能优化"></a></p>

<h2>http性能优化</h2>

<p>关于http性能优化更详细的介绍，参见<a href="/blog/2022/03/08/http-xingneng-youhua/">Web性能优化综述</a>的章节<a href="/blog/2022/03/08/http-xingneng-youhua/#https%E8%AF%B7%E6%B1%82%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">https请求性能优化</a>。</p>

<p><strong>HTTP性能优化面面观（上）</strong></p>

<ol>
<li>性能优化是一个复杂的概念，在 HTTP 里可以分解为服务器性能优化、客户端性能优化和传输链路优化；</li>
<li>服务器有三个主要的性能指标：吞吐量、并发数和响应时间，此外还需要考虑资源利用率；</li>
<li>客户端的基本性能指标是延迟，影响因素有地理距离、带宽、DNS 查询、TCP 握手等；</li>
<li>从服务器到客户端的传输链路可以分为三个部分，我们能够优化的是前两个部分，也就是“第一公里”和“中间一公里”；</li>
<li>有很多工具可以测量这些指标，服务器端有 ab、top、sar 等，客户端可以使用测试网站，浏览器的开发者工具。</li>
</ol>


<p><strong>HTTP性能优化面面观（下）</strong></p>

<ol>
<li>花钱购买硬件、软件或者服务可以直接提升网站的服务能力，其中最有价值的是 CDN；</li>
<li>不花钱也可以优化 HTTP，三个关键词是“开源”“节流”和“缓存”；</li>
<li>后端应该选用高性能的 Web 服务器，开启长连接，提升 TCP 的传输效率；</li>
<li>前端应该启用 gzip、br 压缩，减小文本、图片的体积，尽量少传不必要的头字段；</li>
<li>缓存是无论何时都不能忘记的性能优化利器，应该总使用 Etag 或 Last-modified 字段标记资源；</li>
<li>升级到 HTTP/2 能够直接获得许多方面的性能提升，但要留意一些 HTTP/1 的“反模式”。</li>
</ol>


<p><a id="markdown-试验环境搭建mac" name="试验环境搭建mac"></a></p>

<h2>试验环境搭建（Mac）</h2>

<ol>
<li>安装homebrew</li>
<li>使用homebrew安装OpenResty
<code>brew install openresty/brew/openresty</code></li>
<li>clone项目源码
<code>git clone https://github.com/chronolaw/http_study</code></li>
<li>启动项目

<ul>
<li><code>cd http_study/www/</code> 脚本必须在www目录下运行，才能找到nginx.conf</li>
<li><code>./run.sh start</code> 启动实验环境</li>
<li><code>./run.sh list</code> 列出实验环境的Nginx进程</li>
<li><code>./run.sh reload</code> 重启实验环境</li>
<li><code>./run.sh stop</code> 停止实验环境</li>
</ul>
</li>
<li>启动 OpenResty 之后，就可以用浏览器或者 curl 来验证课程里的各个测试 URI，但之前不要忘记修改“/etc/hosts”添加域名解析。</li>
</ol>

]]></content>
  </entry>
  
</feed>
