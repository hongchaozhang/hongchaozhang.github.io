<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web | Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/blog/categories/web/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2021-05-27T17:31:37+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[极客时间-罗剑锋-《透视HTTP协议》总结]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi/"/>
    <updated>2021-05-26T18:32:49+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82">协议分层</a></li>
<li><a href="#dns">DNS</a>

<ul>
<li><a href="#dns%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B">DNS访问过程</a></li>
<li><a href="#dns%E7%9A%84%E7%BC%93%E5%AD%98">DNS的缓存</a></li>
<li><a href="#dns%E6%96%B0%E7%8E%A9%E6%B3%95">DNS新玩法</a></li>
</ul>
</li>
<li><a href="#%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%86%8D%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E9%9D%A2%E7%A9%B6%E7%AB%9F%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">键入网址再按下回车，后面究竟发生了什么？</a></li>
<li><a href="#tls%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">TLS握手过程</a></li>
<li><a href="#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">http性能优化</a></li>
<li><a href="#%E8%AF%95%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac">试验环境搭建（Mac）</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-协议分层" name="协议分层"></a></p>

<h2>协议分层</h2>

<p>TCP/IP的四层模型和OSI的七层模型之间的对应关系：</p>

<p><img src="/images/20200526%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="20200526四层协议和七层协议的对应关系.png" /></p>

<p>详细说一下TCP/IP的四层模型：</p>

<ul>
<li>第一层叫“<strong>链接层</strong>”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</li>
<li>第二层叫“<strong>网际层</strong>”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</li>
<li>第三层叫“<strong>传输层</strong>”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</li>
<li>协议栈的第四层叫“<strong>应用层</strong>”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。</li>
</ul>


<p>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>

<p>有了上面的概念，才可能理解下面的术语：</p>

<ul>
<li>四层负载均衡：指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</li>
<li>七层负载均衡：指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</li>
</ul>


<p>下面以TCP/IP的四层模型来说明请求数据的发送和接收过程：</p>

<p><img src="/images/20200526%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="20200526四层模型工作过程模型.png" /></p>

<p>发送过程就是一层一层包裹的过程，接收的过程就是一层一层拨开的过程。</p>

<p><a id="markdown-dns" name="dns"></a></p>

<h2>DNS</h2>

<p><a id="markdown-dns访问过程" name="dns访问过程"></a></p>

<h3>DNS访问过程</h3>

<p>域名必须转换成IP才能进行网络访问。这个过程需要DNS（Domain Name System）。</p>

<p>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</p>

<ol>
<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>
<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>
<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。</li>
</ol>


<p>DNS三层结构示意图如下：</p>

<p><img src="/images/20200526%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.png" alt="20200526域名服务器层级结构.png" /></p>

<p>有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。</p>

<p>例如，你要访问“www.apple.com”，就要进行下面的三次查询：</p>

<ol>
<li>访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</li>
<li>访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</li>
<li>最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。</li>
</ol>


<p><a id="markdown-dns的缓存" name="dns的缓存"></a></p>

<h3>DNS的缓存</h3>

<p>虽然核心的 DNS 系统遍布全球，服务能力很强也很稳定，但如果全世界的网民都往这个系统里挤，即使不挤瘫痪了，访问速度也会很慢。</p>

<p>所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“<strong>缓存</strong>”。</p>

<p><strong>首先</strong>，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</p>

<p>这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。</p>

<p><strong>其次</strong>，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到 DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</p>

<p><strong>另外</strong>，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</p>

<p><a id="markdown-dns新玩法" name="dns新玩法"></a></p>

<h3>DNS新玩法</h3>

<p>除了解析得到IP地址，DNS还可以用来做一些其他事情。</p>

<ol>
<li>第一种，也是最简单的，“重定向”。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。实现停机维护期间服务不中断。</li>
<li>第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名，而且这种方式也兼具了第一种“玩法”的优势。</li>
<li>第三种“玩法”包含了前两种，也就是基于域名实现的负载均衡。在计算IP的时候考虑哪台主机资源充足，更适合提供服务，就返回哪台服务器的IP地址。</li>
</ol>


<p><a id="markdown-键入网址再按下回车后面究竟发生了什么" name="键入网址再按下回车后面究竟发生了什么"></a></p>

<h2>键入网址再按下回车，后面究竟发生了什么？</h2>

<p>当用户在浏览器地址栏输入<a href="">http://127.0.0.1/</a>，并按下回车之后，浏览器和服务器之间的行为如下：</p>

<p><img src="/images/20200526http%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B.png" width="400" alt="20200526http请求全过程.png" /></p>

<ol>
<li>首先是TCP连接的建立：经过 SYN、SYN/ACK、ACK 的三个包之后，浏览器与服务器的 TCP 连接就建立起来了。</li>
<li>有了可靠的 TCP 连接通道后，HTTP 协议就可以开始工作了。于是，浏览器按照 HTTP 协议规定的格式，通过 TCP 发送了一个“GET / HTTP/1.1”请求报文，也就是 Wireshark 里的第四个包。</li>
<li>随后，Web 服务器回复了第五个包，在 TCP 协议层面确认：“刚才的报文我已经收到了”，不过这个 TCP 包 HTTP 协议是看不见的。</li>
<li>Web 服务器收到报文后在内部就要处理这个请求。同样也是依据 HTTP 协议的规定，解析报文，看看浏览器发送这个请求想要干什么。它一看，原来是要求获取根目录下的默认文件，好吧，那我就从磁盘上把那个文件全读出来，再拼成符合 HTTP 格式的报文，发回去吧。这就是第六个包“HTTP/1.1 200 OK”，底层走的还是 TCP 协议。</li>
<li>同样的，浏览器也要给服务器回复一个 TCP 的 ACK 确认，“你的响应报文收到了，多谢。”，即第七个包。</li>
<li>这时浏览器就收到了响应数据，但里面是什么呢？所以也要解析报文。一看，服务器给我的是个 HTML 文件，好，那我就调用排版引擎、JavaScript 引擎等等处理一下，然后在浏览器窗口里展现出了欢迎页面。</li>
<li>这之后还有两个来回，共四个包，重复了相同的步骤。这是浏览器自动请求了作为网站图标的“favicon.ico”文件，与我们输入的网址无关。但因为我们的实验环境没有这个文件，所以服务器在硬盘上找不到，返回了一个“404 Not Found”。</li>
<li>最后是TCP关闭连接的“四次挥手”。但是当你通过抓包软件抓包的时候可能看不到这几个包，因为HTTP/1.1 长连接特性，默认不会立即关闭连接。</li>
</ol>


<p>至此，“键入网址再按下回车”的全过程就结束了。</p>

<p>当然，上面只是一个极简网络模型。真实世界中的应用复杂很多。</p>

<ol>
<li>上面是直接输入了IP地址，如果输入的是域名，那么在上面所有步骤之前还有DNS解析过程。</li>
<li>如果用的是https通信协议，在TCP连接建立之后还要有TLS连接的建立。</li>
<li>别忘了互联网上还有另外一个重要的角色 CDN，它也会在 DNS 的解析过程中“插上一脚”。DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。</li>
<li>如果你的请求跳过CDN，到达目标服务器，这时发生的事情如下：目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如四层的 LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群。</li>
<li>负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish，它们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力。</li>
<li>如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。它们又会再访问后面的 MySQL、PostgreSQL、MongoDB 等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份。</li>
<li>应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。</li>
<li>最后网站的响应数据回到了你的设备，它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。</li>
</ol>


<p>综合考虑上面的因素，整体的workflow可以表示如下：</p>

<p><img src="/images/NetworkRequestWorkflow.svg" alt="NetworkRequestWorkflow.svg" /></p>

<p><a id="markdown-tls握手过程" name="tls握手过程"></a></p>

<h2>TLS握手过程</h2>

<p>关于“TLS如何保证安全”这个话题，参考<a href="https://www.zhihu.com/question/52493697">知乎回答</a>。上面这篇文中的“编程指北”的回答最清晰。身份认证可以直接看3.5和3.6小节。真正申请一个SSL证书需要知道的常识：<a href="https://www.cnblogs.com/mafly/p/ssl.html">一篇文章让你搞懂 SSL 证书</a>。</p>

<p>简要过程图：</p>

<p><img src="/images/20200526TLS%E9%93%BE%E6%8E%A5%E7%AE%80%E8%A6%81%E8%BF%87%E7%A8%8B.png" width="400" alt="20200526TLS链接简要过程.png" /></p>

<p>详细过程图：</p>

<p><img src="/images/20200526TLS%E9%93%BE%E6%8E%A5%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.png" width="400" alt="20200526TLS链接详细过程.png" /></p>

<p>详细的分析解说参考原文：<a href="/assets/resources/26%E4%B8%A8%E4%BF%A1%E4%BB%BB%E5%A7%8B%E4%BA%8E%E6%8F%A1%E6%89%8B%EF%BC%9ATLS1.2%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.html">26丨信任始于握手：TLS1.2连接过程解析.html</a></p>

<p><a id="markdown-http性能优化" name="http性能优化"></a></p>

<h2>http性能优化</h2>

<p>HTTP性能优化面面观（上）</p>

<ol>
<li>性能优化是一个复杂的概念，在 HTTP 里可以分解为服务器性能优化、客户端性能优化和传输链路优化；</li>
<li>服务器有三个主要的性能指标：吞吐量、并发数和响应时间，此外还需要考虑资源利用率；</li>
<li>客户端的基本性能指标是延迟，影响因素有地理距离、带宽、DNS 查询、TCP 握手等；</li>
<li>从服务器到客户端的传输链路可以分为三个部分，我们能够优化的是前两个部分，也就是“第一公里”和“中间一公里”；</li>
<li>有很多工具可以测量这些指标，服务器端有 ab、top、sar 等，客户端可以使用测试网站，浏览器的开发者工具。</li>
</ol>


<p>HTTP性能优化面面观（下）</p>

<ol>
<li>花钱购买硬件、软件或者服务可以直接提升网站的服务能力，其中最有价值的是 CDN；</li>
<li>不花钱也可以优化 HTTP，三个关键词是“开源”“节流”和“缓存”；</li>
<li>后端应该选用高性能的 Web 服务器，开启长连接，提升 TCP 的传输效率；</li>
<li>前端应该启用 gzip、br 压缩，减小文本、图片的体积，尽量少传不必要的头字段；</li>
<li>缓存是无论何时都不能忘记的性能优化利器，应该总使用 Etag 或 Last-modified 字段标记资源；</li>
<li>升级到 HTTP/2 能够直接获得许多方面的性能提升，但要留意一些 HTTP/1 的“反模式”。</li>
</ol>


<p><a id="markdown-试验环境搭建mac" name="试验环境搭建mac"></a></p>

<h2>试验环境搭建（Mac）</h2>

<ol>
<li>安装homebrew</li>
<li>使用homebrew安装OpenResty
<code>brew install openresty/brew/openresty</code></li>
<li>clone项目源码
<code>git clone https://github.com/chronolaw/http_study</code></li>
<li>启动项目

<ul>
<li><code>cd http_study/www/</code> 脚本必须在www目录下运行，才能找到nginx.conf</li>
<li><code>./run.sh start</code> 启动实验环境</li>
<li><code>./run.sh list</code> 列出实验环境的Nginx进程</li>
<li><code>./run.sh reload</code> 重启实验环境</li>
<li><code>./run.sh stop</code> 停止实验环境</li>
</ul>
</li>
<li>启动 OpenResty 之后，就可以用浏览器或者 curl 来验证课程里的各个测试 URI，但之前不要忘记修改“/etc/hosts”添加域名解析。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS中的white-space，word-break和word-wrap]]></title>
    <link href="http://hongchaozhang.github.io/blog/2020/07/02/css-white-space-word-break-and-word-wrap/"/>
    <updated>2020-07-02T10:27:04+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2020/07/02/css-white-space-word-break-and-word-wrap</id>
    <content type="html"><![CDATA[<!-- more -->


<p><code>white-space</code>、<code>word-break</code>、<code>word-wrap</code>（<code>overflow-wrap</code>）估计是css里最基本却又容易让人迷惑的三个属性了。</p>

<h2><code>white-space</code></h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space"><code>white-space</code></a>：正如它的名字，这个属性是用来<strong>控制空白字符的显示的，同时还能控制是否自动换行</strong>。它有6个值：</p>

<ol>
<li>normal：默认值。空格被合并，自动换行。</li>
<li>nowrap：不仅空格被合并，换行符无效，连原本的自动换行都没了！只有\&lt;/br>才能导致换行！所以这个值的表现还是挺简单的，我们可以理解为"永不换行"。</li>
<li>pre：下面四个用来保留空格，不常用。详情参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space">MDN介绍</a>。</li>
<li>pre-wrap</li>
<li>pre-line</li>
<li>break-space</li>
</ol>


<p>下面的表格记录的很详细：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 属性值 </th>
<th style="text-align:center;"> 换行符 </th>
<th style="text-align:center;"> 空格和制表符 </th>
<th style="text-align:center;"> 文字换行 </th>
<th style="text-align:center;"> 行尾空格 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">normal </td>
<td style="text-align:center;"> 合并    </td>
<td style="text-align:center;"> 合并    </td>
<td style="text-align:center;"> 换行    </td>
<td style="text-align:center;"> 删除 </td>
</tr>
<tr>
<td style="text-align:center;">nowrap </td>
<td style="text-align:center;"> 合并    </td>
<td style="text-align:center;"> 合并    </td>
<td style="text-align:center;"> 不换行 </td>
<td style="text-align:center;"> 删除 </td>
</tr>
<tr>
<td style="text-align:center;">pre    </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 不换行 </td>
<td style="text-align:center;"> 保留 </td>
</tr>
<tr>
<td style="text-align:center;">pre-wrap   </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 换行    </td>
<td style="text-align:center;"> 挂起 </td>
</tr>
<tr>
<td style="text-align:center;">pre-line   </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 合并    </td>
<td style="text-align:center;"> 换行    </td>
<td style="text-align:center;"> 删除 </td>
</tr>
<tr>
<td style="text-align:center;">break-spaces   </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 换行    </td>
<td style="text-align:center;"> 换行 </td>
</tr>
</tbody>
</table>


<h2><code>word-break</code></h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a>指定了怎样在单词内断行。这里说的单词在英文中很明显，但是，对于中文、日文和韩文（合称CJK文本）整段话都是一个单词。</p>

<p><code>word-break</code>共有三个选项：</p>

<ol>
<li>normal：使用默认的断行规则。</li>
<li>break-all：对于non-CJK文本，可在任意字符间断行。</li>
<li>keep-all：CJK文本不断行。 Non-CJK文本表现同normal。</li>
</ol>


<h2><code>word-wrap</code> (<code>overflow-wrap</code>)</h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-wrap"><code>word-wrap</code>(<code>overflow-wrap</code>)</a>控制长度超过一行的单词是否被拆分换行。有两个值：</p>

<ol>
<li>normal：长度超过一行的单词也不允许拆成两行显示。</li>
<li>break-word：长度超过一行的单词允许被拆分成两行显示。</li>
</ol>


<h2>总结</h2>

<ul>
<li><code>white-space</code>，<strong>控制空白字符的显示，同时还能控制是否自动换行</strong>。</li>
<li><code>word-break</code>，<strong>控制单词如何被拆分换行</strong>。</li>
<li><code>word-wrap</code>（<code>overflow-wrap</code>）<strong>控制长度超过一行的单词是否被拆分换行</strong>，是<code>word-break</code>的补充。</li>
</ul>


<h2>参考</h2>

<p>实际效果可以参考<a href="https://juejin.im/post/5b8905456fb9a01a105966b4">彻底搞懂word-break、word-wrap、white-space</a>及其其提供的一个<a href="https://codepen.io/YGYOOO/pen/jvyrWK">测试页面</a>。</p>

<p>MDN的官方文档当然是不得不看的：</p>

<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space"><code>white-space</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-wrap"><code>word-wrap</code>(<code>overflow-wrap</code>)</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iframe之外能否知道iframe里面产生的事件？]]></title>
    <link href="http://hongchaozhang.github.io/blog/2020/06/04/can-events-inside-iframe-bubble-out-of-iframe/"/>
    <updated>2020-06-04T11:55:31+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2020/06/04/can-events-inside-iframe-bubble-out-of-iframe</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E9%97%AE%E9%A2%98">问题</a>

<ul>
<li><a href="#%E8%B5%84%E6%96%99%E4%B8%80">资料一</a></li>
<li><a href="#%E8%B5%84%E6%96%99%E4%BA%8C">资料二</a></li>
<li><a href="#%E8%B5%84%E6%96%99%E4%B8%89">资料三</a></li>
</ul>
</li>
</ul>


<!-- /TOC -->


<p><a id="markdown-问题" name="问题"></a></p>

<h2>问题</h2>

<p>iframe里面产生的click事件，外面有没有办法知道？</p>

<p><a id="markdown-资料一" name="资料一"></a></p>

<h3>资料一</h3>

<p>根据<a href="https://stackoverflow.com/questions/2381336/detect-click-into-iframe-using-javascript/32138108">Detect Click into Iframe using JavaScript</a>，</p>

<ol>
<li>我们只能监测到发生在iframe上的'mouseover'、'mouseout'等事件，至于鼠标进入iframe之后发生的事情，我们是没有办法获取的。</li>
<li>对于试图在iframe上面盖一层透明的dom来截获鼠标事件的想法也是不可取的，因为一旦事件被截获，便没有办法再次dispatch到iframe内部去。</li>
<li>以上结论基于不同源的两个网页。</li>
</ol>


<p><a id="markdown-资料二" name="资料二"></a></p>

<h3>资料二</h3>

<p><a href="https://stackoverflow.com/questions/40109631/event-bubbling-not-happen-in-iframe">Event bubbling not happen in IFrame</a>解释来为什么iframe里面的事件不能bubble出iframe。</p>

<blockquote><p>Bubbling is specced to happen only through a single <strong>document tree</strong>. The iframe is a separate document tree, and so events that bubble through its tree terminate at the root of the iframe&rsquo;s document and do not travel across the boundary into the host document.</p></blockquote>

<p><a id="markdown-资料三" name="资料三"></a></p>

<h3>资料三</h3>

<p>如果满足同源策略，那么可以通过下面的方法将iframe内部的事件传到外部(参考<a href="https://stackoverflow.com/questions/5645485/detect-mousemove-when-over-an-iframe/11865037#11865037">Detect mousemove when over an iframe?</a>)：</p>

<pre><code class="javascript">// This example assumes execution from the parent of the the iframe

function bubbleIframeMouseMove(iframe){
    // Save any previous onmousemove handler
    var existingOnMouseMove = iframe.contentWindow.onmousemove;

    // Attach a new onmousemove listener
    iframe.contentWindow.onmousemove = function(e){
        // Fire any existing onmousemove listener 
        if(existingOnMouseMove) existingOnMouseMove(e);

        // Create a new event for the this window
        var evt = document.createEvent("MouseEvents");

        // We'll need this to offset the mouse move appropriately
        var boundingClientRect = iframe.getBoundingClientRect();

        // Initialize the event, copying exiting event values
        // for the most part
        evt.initMouseEvent( 
            "mousemove", 
            true, // bubbles
            false, // not cancelable 
            window,
            e.detail,
            e.screenX,
            e.screenY, 
            e.clientX + boundingClientRect.left, 
            e.clientY + boundingClientRect.top, 
            e.ctrlKey, 
            e.altKey,
            e.shiftKey, 
            e.metaKey,
            e.button, 
            null // no related element
        );

        // Dispatch the mousemove event on the iframe element
        iframe.dispatchEvent(evt);
    };
}

// Get the iframe element we want to track mouse movements on
var myIframe = document.getElementById("myIframe");

// Run it through the function to setup bubbling
bubbleIframeMouseMove(myIframe);
</code></pre>

<p>You can now listen for mousemove on the iframe element or any of its parent elements. As the event will bubble up as you would expect.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浏览器的同源策略和跨域解决方法]]></title>
    <link href="http://hongchaozhang.github.io/blog/2020/06/04/same-origin-and-cross-domain/"/>
    <updated>2020-06-04T11:21:46+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2020/06/04/same-origin-and-cross-domain</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E5%90%8C%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89">同源的定义</a></li>
<li><a href="#%E6%B2%A1%E6%9C%89%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E7%9A%84%E5%8D%B1%E9%99%A9%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">没有同源策略的危险（为什么需要同源策略）</a></li>
<li><a href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E7%9A%84%E9%99%90%E5%88%B6">同源策略的限制</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95--%E6%9C%AC%E5%9C%B0%E9%80%9A%E4%BF%A1">常用跨域的解决方法&ndash;本地通信</a>

<ul>
<li><a href="#%E4%BF%AE%E6%94%B9documentdomain%E5%B1%9E%E6%80%A7">修改<code>document.domain</code>属性</a></li>
<li><a href="#%E5%80%9F%E5%8A%A9windownamelocationhash">借助<code>window.name</code>、<code>location.hash</code></a></li>
<li><a href="#%E4%BD%BF%E7%94%A8windowpostmessage">使用<code>window.postMessage</code></a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95--ajax%E8%AF%B7%E6%B1%82%E9%99%90%E5%88%B6">常用跨域的解决方法&ndash;AJAX请求限制</a>

<ul>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%90%86">服务器代理</a></li>
<li><a href="#jsonp">JSONP</a></li>
<li><a href="#websocket">WebSocket</a></li>
<li><a href="#cors">CORS</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-同源的定义" name="同源的定义"></a></p>

<h2>同源的定义</h2>

<p>根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">MDN同源的定义</a>：如果两个URL的protocol、port(如果有指定的话)和host都相同的话，则这两个URL是同源。</p>

<p>下表给出了与 URL <a href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a> 的源进行对比的示例:</p>

<table>
<thead>
<tr>
<th> URL </th>
<th> 结果 </th>
<th> 原因 </th>
</tr>
</thead>
<tbody>
<tr>
<td> <a href="http://store.company.com/dir2/other.html">http://store.company.com/dir2/other.html</a> </td>
<td> 同源 </td>
<td> 只有路径不同 </td>
</tr>
<tr>
<td> <a href="http://store.company.com/dir/inner/another.html">http://store.company.com/dir/inner/another.html</a> </td>
<td> 同源 </td>
<td> 只有路径不同 </td>
</tr>
<tr>
<td> <a href="https://store.company.com/secure.html">https://store.company.com/secure.html</a> </td>
<td> 失败 </td>
<td> 协议（protocol）不同 </td>
</tr>
<tr>
<td> <a href="http://store.company.com:81/dir/etc.html">http://store.company.com:81/dir/etc.html</a> </td>
<td> 失败 </td>
<td> 端口（port）不同 ( <a href="http://">http://</a> 默认端口是80) </td>
</tr>
<tr>
<td> <a href="http://news.company.com/dir/other.html">http://news.company.com/dir/other.html</a> </td>
<td> 失败 </td>
<td> 主机（host）不同 </td>
</tr>
</tbody>
</table>


<p><a id="markdown-没有同源策略的危险为什么需要同源策略" name="没有同源策略的危险为什么需要同源策略"></a></p>

<h2>没有同源策略的危险（为什么需要同源策略）</h2>

<p>同源策略的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>

<p>下面从DOM同源策略和XMLHttpRequest同源策略来举例说明：</p>

<p><strong>如果没有DOM同源策略</strong>，也就是说不同域的iframe之间可以相互访问Dom结构，那么黑客可以这样进行攻击：</p>

<ol>
<li>做一个假网站，里面用iframe嵌套一个银行网站<a href="">http://mybank.com</a>。</li>
<li>把iframe宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。</li>
<li>这时如果用户输入账号密码，我们的主网站可以跨域访问到<a href="">http://mybank.com</a>的dom节点，就可以拿到用户的账户密码了。</li>
</ol>


<p><strong>如果没有XMLHttpRequest同源策略</strong>，那么黑客可以进行CSRF（跨站请求伪造）攻击：</p>

<ol>
<li>用户登录了自己的银行页面<a href="">http://mybank.com</a>，<a href="">http://mybank.com</a>向用户的cookie中添加用户标识。</li>
<li>用户浏览了恶意页面<a href="">http://evil.com</a>，执行了页面中的恶意AJAX请求代码。</li>
<li><a href="">http://evil.com</a>向<a href="">http://mybank.com</a>发起AJAX请求，请求会默认把<a href="">http://mybank.com</a>对应cookie也同时发送过去。</li>
<li>银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。</li>
<li>而且由于Ajax在后台执行，用户无法感知这一过程。</li>
</ol>


<p>其它例子可以参考：</p>

<ol>
<li>知乎<a href="https://zhuanlan.zhihu.com/p/28562290">跨域的那些事儿</a></li>
<li><a href="https://segmentfault.com/a/1190000015597029">不要再问我跨域的问题了</a></li>
</ol>


<p><a id="markdown-同源策略的限制" name="同源策略的限制"></a></p>

<h2>同源策略的限制</h2>

<p>如果非同源，共有三种行为受到限制。</p>

<ol>
<li>Cookie、LocalStorage 和 IndexDB 无法读取。</li>
<li>DOM 无法获得。</li>
<li>AJAX 请求不能发送。</li>
</ol>


<p>比如试图从不同源的iframe里面获取dom结构就会报错：</p>

<pre><code class="javascript">document.getElementById("myIFrame").contentWindow.document
// Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.
</code></pre>

<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响：明明两个网页都是自己写的，但是属于不同的源，也就没有办法互相访问。</p>

<p>下面列举一些方法，介绍如何规避上面三种限制。前提是两个URL都是自己写的网页，否则无法使用。这也正是同源策略的作用所在：对于第三方的一个网页，你是无法超越上面三种限制的，这也就保证了安全。</p>

<p><a id="markdown-常用跨域的解决方法--本地通信" name="常用跨域的解决方法--本地通信"></a></p>

<h2>常用跨域的解决方法&ndash;本地通信</h2>

<p><a id="markdown-修改documentdomain属性" name="修改documentdomain属性"></a></p>

<h3>修改<code>document.domain</code>属性</h3>

<p>Cookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享。浏览器允许通过设置<code>document.domain</code>共享Cookie。</p>

<p>但是，<code>document.domain</code>只适用于“主域名相同，而子域名不同”的情况。这种方式非常适用于iframe跨域的情况。</p>

<p>举例来说，A网页是<a href="">http://w1.example.com/a.html</a>，B网页是<a href="">http://w2.example.com/b.html</a>，那么只要这两个网页同时设置相同的<code>document.domain</code>，两个网页就可以共享Cookie。</p>

<p>注意，这种方法只适用于Cookie和iframe窗口，LocalStorage和IndexDB无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。</p>

<p>另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。</p>

<p><a id="markdown-借助windownamelocationhash" name="借助windownamelocationhash"></a></p>

<h3>借助<code>window.name</code>、<code>location.hash</code></h3>

<p>这两种方法可以说是一种“破解”。</p>

<p>以<code>window.name</code>为例。浏览器窗口有<code>window.name</code>属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p>

<p><a id="markdown-使用windowpostmessage" name="使用windowpostmessage"></a></p>

<h3>使用<code>window.postMessage</code></h3>

<p><code>window.name</code>和<code>location.hash</code>是“破解”方法，<code>window.postMessage</code>则具有官方背景。HTML5为了解决跨文档通信（Cross-document messaging）问题，引入了这个全新的API <code>window.postMessage</code>。</p>

<p>这个API为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。</p>

<p>举例来说，父窗口<a href="">http://aaa.com</a>向子窗口<a href="">http://bbb.com</a>发消息，调用<code>postMessage</code>方法就可以了。</p>

<pre><code class="javascript">var popup = window.open('http://bbb.com', 'title');
popup.postMessage('Hello World!', 'http://bbb.com');
</code></pre>

<p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即"协议 + 域名 + 端口"。也可以设为*，表示不限制域名，向所有窗口发送。</p>

<p>子窗口向父窗口发送消息的写法类似。</p>

<pre><code class="javascript">window.opener.postMessage('Nice to see you', 'http://aaa.com');
</code></pre>

<p>父窗口和子窗口都可以通过message事件，监听对方的消息。</p>

<pre><code class="javascript">window.addEventListener('message', function(e) {
  console.log(e.data);
},false);
</code></pre>

<p>message事件的事件对象event，提供以下三个属性。</p>

<ol>
<li><code>event.source</code>：发送消息的窗口</li>
<li><code>event.origin</code>: 消息发向的网址</li>
<li><code>event.data</code>: 消息内容</li>
</ol>


<blockquote><p>注：通过window.postMessage，读写其他窗口的 LocalStorage 也成为了可能。</p></blockquote>

<p><a id="markdown-常用跨域的解决方法--ajax请求限制" name="常用跨域的解决方法--ajax请求限制"></a></p>

<h2>常用跨域的解决方法&ndash;AJAX请求限制</h2>

<p>后面几种方法都是为了解决不同源网页之间的AJAX请求问题。</p>

<p><a id="markdown-服务器代理" name="服务器代理"></a></p>

<h3>服务器代理</h3>

<p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端。</p>

<p><a id="markdown-jsonp" name="jsonp"></a></p>

<h3>JSONP</h3>

<p>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p>

<p>它的基本思想是，网页通过添加一个\&lt;script>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p>

<p>首先，网页动态插入\&lt;script>元素，由它向跨源网址发出请求。</p>

<pre><code class="javascript">function addScriptTag(src) {
  var script = document.createElement('script');
  script.setAttribute("type","text/javascript");
  script.src = src;
  document.body.appendChild(script);
}

window.onload = function () {
  addScriptTag('http://example.com/ip?callback=foo');
}

function foo(data) {
  console.log('Your public IP address is: ' + data.ip);
};
</code></pre>

<p>上面代码通过动态添加\&lt;script>元素，向服务器<a href="">example.com</a>发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。</p>

<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>

<pre><code class="javascript">foo({
  "ip": "8.8.8.8"
});
</code></pre>

<p>由于\&lt;script>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。</p>

<p><a id="markdown-websocket" name="websocket"></a></p>

<h3>WebSocket</h3>

<p>WebSocket是一种通信协议。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>

<p>下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。</p>

<pre><code class="json">GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
</code></pre>

<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（<code>origin</code>），即发自哪个域名。</p>

<p>正是因为有了<code>Origin</code>这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>

<pre><code class="json">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre>

<p><a id="markdown-cors" name="cors"></a></p>

<h3>CORS</h3>

<p>CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。</p>

<p><a id="markdown-参考" name="参考"></a></p>

<h2>参考</h2>

<ul>
<li>阮一峰的<a href="https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">MDN同源的定义</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[https工作过程]]></title>
    <link href="http://hongchaozhang.github.io/blog/2015/12/29/https-workflow/"/>
    <updated>2015-12-29T16:21:19+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2015/12/29/https-workflow</id>
    <content type="html"><![CDATA[<p>摘录在此，备忘。</p>

<p>HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。</p>

<p>具体的加密过程看下图：</p>

<!-- more -->


<p><img src="/images/https-workflow.png" alt="https-workflow" /></p>

<ol>
<li><p>客户端发起HTTPS请求</p>

<p> 用户在浏览器里输入一个https网址，然后连接到server的443端口。</p></li>
<li><p>服务端的配置</p>

<p> 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p></li>
<li><p>传送证书</p>

<p> 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p></li>
<li><p>客户端解析证书</p>

<p> 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p></li>
<li><p>传送加密信息</p>

<p> 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p></li>
<li><p>服务段解密信息</p>

<p> 服务端用自己的私钥解密后，得到了客户端传过来的随机值，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和随机值通过某种算法混合在一起，这样除非知道随机值，不然无法获取内容，而正好客户端和服务端都知道这个随机值，所以只要加密算法够彪悍，这个随机值够复杂，数据就够安全。</p></li>
<li><p>传输加密后的信息</p>

<p> 这部分信息是服务段用客户端传过来的随机值加密后的信息，可以在客户端被还原。</p></li>
<li><p>客户端解密信息</p>

<p> 客户端用之前生成的随机值解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p></li>
</ol>


<h3>References</h3>

<p><del>https的基本概念，请参考</del><a href="http://www.cnblogs.com/P_Chou/archive/2010/12/27/https-ssl-certification.html"><del>浅谈https\ssl\数字证书</del></a></p>

<p>https的传输过程，请参考：<a href="http://www.jb51.net/network/68135.html">图解HTTPS协议加密解密全过程</a></p>

<p>https/http/get/post: 请参考<a href="http://cuishen.iteye.com/blog/2019925">http https get post 的区别，定义/安全性/性能</a>和<a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html">浅谈HTTP中Get与Post的区别</a></p>

<p>其实百度百科中关于<a href="http://baike.baidu.com/view/14121.htm">https</a>的解释也是十分清楚了。</p>
]]></content>
  </entry>
  
</feed>
