<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2025-04-08T00:42:28+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Babel工作原理]]></title>
    <link href="http://hongchaozhang.github.io/blog/2025/03/24/babel-workflow/"/>
    <updated>2025-03-24T23:20:31+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2025/03/24/babel-workflow</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Babel is a JavaScript compiler。
主要用于将 ECMAScript 2015+（ES6 及以上）的 JavaScript 代码转换成能够在当前和旧版浏览器环境中兼容运行的代码版本。</p>

<h1>配置</h1>

<p>Babel 的配置文件通常是<code>.babelrc.json</code>或<code>babel.config.json</code>，可以在其中配置需要使用的插件和预设:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "presets": [...],
</span><span class='line'>  "plugins": [...]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>甚至可以直接写在<code>package.json</code>中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  ...,
</span><span class='line'>  "babel": {
</span><span class='line'>    "presets": [...],
</span><span class='line'>    "plugins": [...]
</span><span class='line'>  },
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>更加灵活的，可以在<code>webpack.config.js</code>中访问 Node.js 的 APIs：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module.exports = function (api) {
</span><span class='line'>  api.cache(true);
</span><span class='line'>
</span><span class='line'>  const presets = [ ... ];
</span><span class='line'>  const plugins = [ ... ];
</span><span class='line'>
</span><span class='line'>  if (process.env["ENV"] === "prod") {
</span><span class='line'>    plugins.push(...);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return {
</span><span class='line'>    presets,
</span><span class='line'>    plugins
</span><span class='line'>  };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h1>工作流程</h1>

<p><img src="http://hongchaozhang.github.io/images/babel-workflow.png" alt="babel workflow" /></p>

<p>Babel 的编译过程与大多数编程语言的编译器类似，分为三个主要阶段：解析（Parsing）、转换（Transformation）和生成（Code Generation）</p>

<h2>解析（Parsing）</h2>

<p>这一阶段将代码字符串解析成抽象语法树（AST，Abstract Syntax Tree）<a href="https://developer.aliyun.com/article/1303957">2</a><a href="https://blog.csdn.net/ByteDanceTech/article/details/126900235">3</a>。AST 是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构<a href="https://developer.aliyun.com/article/1303957">2</a>。
解析过程又分为两个步骤：</p>

<ul>
<li>分词：将整个代码字符串分割成语法单元数组：tokenizer，keyword</li>
<li>语法分析：建立分析语法单元之间的关系<a href="https://developer.aliyun.com/article/1303957">2</a></li>
</ul>


<p>例如，一个简单的<code>console.log('zcy');</code>会被解析成包含程序结构、表达式语句、调用表达式等节点的 AST<a href="https://developer.aliyun.com/article/1303957">2</a>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "type": "Program",
</span><span class='line'>  "body": [
</span><span class='line'>    {
</span><span class='line'>      "type": "ExpressionStatement",
</span><span class='line'>      "expression": {
</span><span class='line'>        "type": "CallExpression",
</span><span class='line'>        "callee": {
</span><span class='line'>          "type": "MemberExpression",
</span><span class='line'>          "computed": false,
</span><span class='line'>          "object": {
</span><span class='line'>            "type": "Identifier",
</span><span class='line'>            "name": "console"
</span><span class='line'>          },
</span><span class='line'>          "property": {
</span><span class='line'>            "type": "Identifier",
</span><span class='line'>            "name": "log"
</span><span class='line'>          }
</span><span class='line'>        },
</span><span class='line'>        "arguments": [
</span><span class='line'>          {
</span><span class='line'>          "type": "Literal",
</span><span class='line'>          "value": "zcy",
</span><span class='line'>          "raw": "'zcy'"
</span><span class='line'>          }
</span><span class='line'>        ]
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  ],
</span><span class='line'>  "sourceType": "script"
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>转换（Transformation）</h2>

<p>这一阶段对 AST 进行转换操作<a href="https://developer.aliyun.com/article/1303957">2</a><a href="https://blog.csdn.net/ByteDanceTech/article/details/126900235">3</a>。转换通常通过 Babel plugin（插件）或者 preset（预设）实现，每个插件可以访问 AST 并对其进行修改，例如将箭头函数的节点转换为普通函数节点。</p>

<h3>plugin（插件）</h3>

<p>Babel 本身只是一个编译器，可以理解为一个框架，就像一个纯函数<code>const babel = code =&gt; code</code>一样，只负责解析然后生成代码。要实现具体的转换功能，需要添加和使用插件（plugins）。
例如，要将箭头函数转换为普通函数，可以使用官方提供的<code>@babel/plugin-transform-arrow-functions</code>插件<a href="https://www.xuwenchao.site/blogs/babel.html">1</a>。每个插件负责特定类型的语法转换，开发者可以根据需要添加相应的插件。</p>

<h3>presets（预设）</h3>

<p>如果要编译一个完整的应用，单独配置每个所需的插件会非常繁琐。为了解决这个问题，Babel 引入了 presets（预设）的概念<a href="https://www.xuwenchao.site/blogs/babel.html">1</a>。
presets 可以理解为 plugins 和部分配置的集合，使用预设可以避免单独配置每个 plugin 和参数，直接使用已经组合好的配置即可<a href="https://www.xuwenchao.site/blogs/babel.html">1</a>。常见的预设包括<code>@babel/preset-env</code>、<code>@babel/preset-react</code>等。</p>

<p>@babel/preset-env 包含以下插件：</p>

<ul>
<li>@babel/plugin-transform-template-literals</li>
<li>@babel/plugin-transform-literals</li>
<li>@babel/plugin-transform-function-name</li>
<li>@babel/plugin-transform-arrow-functions</li>
<li>@babel/plugin-transform-block-scoped-functions</li>
<li>@babel/plugin-transform-classes</li>
<li>@babel/plugin-transform-object-super</li>
</ul>


<p>@babel/preset-react 包含以下插件：</p>

<ul>
<li>@babel/plugin-syntax-jsx</li>
<li>@babel/plugin-transform-react-jsx</li>
<li>@babel/plugin-transform-react-display-name</li>
</ul>


<h2>生成（Code Generation）</h2>

<p>最后一个阶段是根据转换后的 AST 生成新的代码字符串。这一过程包括将 AST 中的每个节点映射回字符串形式，并生成源码映射（source maps）。</p>

<h1>结论</h1>

<p>Babel 作为现代前端开发的重要工具，为开发者提供了使用最新 JavaScript 特性的能力，同时保证了代码在各种浏览器环境中的兼容性。深入理解 Babel 的基本概念、工作流程和使用方法，对于前端开发者提升开发效率和代码质量有着重要意义。</p>

<p>从入门的基本使用，到进阶的插件开发，再到专业的性能优化，Babel 的学习是一个循序渐进的过程。随着对 Babel 的不断深入学习和实践，开发者能够更加灵活地利用这一工具，构建更加现代化、高效的前端应用。</p>

<h1>应用场景</h1>

<ul>
<li>编辑器</li>
<li>LSP language server protocol</li>
<li>语法高亮，自动补全</li>
<li>静态代码分析</li>
<li>代码转换</li>
<li>代码压缩和优化</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[道金斯《自私的基因》读后感]]></title>
    <link href="http://hongchaozhang.github.io/blog/2025/03/10/zisi-de-jiyin/"/>
    <updated>2025-03-10T00:10:07+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2025/03/10/zisi-de-jiyin</id>
    <content type="html"><![CDATA[<!-- more -->


<h3><strong>一、核心理论框架</strong></h3>

<ol>
<li><p><strong>自然选择的真正单位</strong></p>

<ul>
<li>达尔文进化论升级版：自然选择作用于基因（而非个体/物种）</li>
<li>基因本质：自私的分子程序，唯一目标是自我复制与永续存在</li>
<li>生命体定位：基因的"生存机器"，如鱼是游动的基因载体，鸟是飞行的基因载体</li>
</ul>
</li>
<li><p><strong>利他行为的基因逻辑</strong></p>

<ul>
<li>表面矛盾：羚羊跳跃示警看似牺牲，实为展示体能（降低被捕食概率）</li>
<li>终极本质：所有行为（包括利他）均为基因延续服务，不存在纯粹无私</li>
<li>零阶道理：基因选择。一阶道理：利他行为，羚羊跳跃提醒同伴，互利行为。</li>
</ul>
</li>
</ol>


<h3><strong>二、四大生物学谜题解析</strong></h3>

<h4><strong>1. 衰老与死亡的基因密码</strong></h4>

<ul>
<li> 致死基因筛选机制：

<ul>
<li>早发致死基因（如幼年癌症基因）→ 被自然选择淘汰</li>
<li>晚发致死基因（如老年疾病基因）→ 成功遗传（因已完成生育）</li>
</ul>
</li>
<li> 延长寿命的可能路径：

<ul>
<li>延迟生育策略（理论可行但无现实操作性）

<ul>
<li>禁止人40岁之前生育，经过自然选择，可以让一些重病推迟到人年龄大的时候发生。</li>
</ul>
</li>
<li>欺骗基因识别系统（如干预衰老标志物研究）</li>
</ul>
</li>
</ul>


<h4><strong>2. 两性生殖的进化困境</strong></h4>

<ul>
<li> 基因视角的生殖悖论：

<ul>
<li>有性生殖成本：后代仅继承50%基因 + 择偶竞争消耗</li>
<li>基因操控真相：性基因强制其他基因配对交换（如同公交车强制换客）</li>
</ul>
</li>
<li> 对比案例：蚜虫无性生殖的高效 vs 人类有性生殖的普遍性</li>
</ul>


<h4><strong>3. 亲缘关系的数学本质</strong></h4>

<ul>
<li><p> 亲疏量化模型：</p>

<table>
<thead>
<tr>
<th> 亲属关系 </th>
<th> 基因相似度 </th>
</tr>
</thead>
<tbody>
<tr>
<td> 子女/同胞 </td>
<td> 50% </td>
</tr>
<tr>
<td> 孙辈/祖辈 </td>
<td> 25% </td>
</tr>
<tr>
<td> 表亲 </td>
<td> 12.5% </td>
</tr>
</tbody>
</table>
</li>
<li><p> 亲属偏好现象解释：</p>

<ul>
<li>母系识别优势：姥姥 > 奶奶（确定性：女儿生育 > 儿子生育）</li>
<li>投资策略演化：母亲偏袒幼子（资源集中投资生存率最低者）</li>
</ul>
</li>
</ul>


<h4><strong>4. 突破基因控制的可能</strong></h4>

<ul>
<li> 意识革命：人类大脑产生自主决策能力（基因编程的意外产物）</li>
<li> 反抗途径：

<ul>
<li>文化教育：构建利他主义社会规范（如计划生育对抗繁殖本能）</li>
<li>表观遗传学：环境改变基因表达（后书时代的科学进展）</li>
</ul>
</li>
<li> 对于不婚不育群体，基因不在乎，因为他们会被淘汰。</li>
</ul>


<h3><strong>三、延伸思考与启示</strong></h3>

<ol>
<li><p><strong>生命观重构</strong></p>

<ul>
<li>基因永生：个体生命短暂，基因链永恒延续</li>
<li>存在意义：生命本质是基因传递的载体程序</li>
</ul>
</li>
<li><p><strong>社会行为解码</strong></p>

<ul>
<li>爱情本质：基因匹配的生物学冲动</li>
<li>道德起源：基因为保障群体存续衍生的合作策略</li>
</ul>
</li>
<li><p><strong>人类特殊性</strong></p>

<ul>
<li>意识特权：唯一能理解自身基因机制并反抗的生物</li>
<li>文明意义：通过教育/科技构建"超基因文明"的可能性</li>
</ul>
</li>
</ol>


<h3><strong>四、关键金句（适用于传播）</strong></h3>

<ol>
<li>&ldquo;我们不是基因的主人，而是它精心打造的生存机器&rdquo;</li>
<li>&ldquo;母爱是基因写就的投资算法，亲情是相似DNA的相互识别&rdquo;</li>
<li>&ldquo;生物学没有无私，只有伪装成高尚的精密算计&rdquo;</li>
<li>&ldquo;人类最伟大的进化成就，是获得了反抗造物主（基因）的思维能力&rdquo;</li>
</ol>


<h3><strong>五、人生的意义</strong></h3>

<p>虽然一些美好的现象被基因控制，但是，我们宁愿相信不是这样的，除非我们能找到除此之外的人生的意义，不然活着就没有意义了。</p>

<p>还有一个类似的问题，就是自由意志。虽然科学一再证实，人类没有自由意志。但是，我们宁愿相信人有自由意志，因为这样活着才有意义。</p>

<p>这个也可以从基因的角度理解一下，人分成两类，一类相信人有自由意志，一类不相信人有自由意志。也许最终胜出的就是相信自由意志的人，也就是我们这些人。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[李俊慧的经济学]]></title>
    <link href="http://hongchaozhang.github.io/blog/2025/03/09/lijunhui-jingjixue/"/>
    <updated>2025-03-09T11:07:39+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2025/03/09/lijunhui-jingjixue</id>
    <content type="html"><![CDATA[<!-- more -->


<p>以下是整理后的经济学课程核心观点框架，按逻辑结构组织：</p>

<h3>一、科学方法论与经济学基础</h3>

<ol>
<li><p><strong>科学方法论</strong></p>

<ol>
<li>假设：归纳总结出该领域的“公理”（如理性人）</li>
<li>逻辑演绎：根据公理进行逻辑推理，得到一些定理。这一部分可长可短，不是必须的。（数学建模）</li>
<li>事实验证：根据事实或者实验结果验证前两步得到的结论（公理和定理）（证伪导向）</li>
</ol>
</li>
<li><p><strong>科学本质</strong></p>

<ul>
<li>科学理论核心标准：可证伪性（波普尔）＞可度量性</li>
<li>有效假设特征：体系完备性＞前提正确性（如中医阴阳五行/经济学的理性人假设）</li>
<li>奥卡姆剃刀原则：简单有效理论优先（供需理论＞复杂消费者理论）</li>
<li>科学和正确的四种象限关系：科学正确＞科学错误＞非科学正确＞非科学错误

<ul>
<li>四脚动物有四条腿，不具有可证伪性。</li>
<li>进化论也不具有可证伪性！</li>
</ul>
</li>
<li>质疑第一步的假设是不科学的。只能通过第三部来验证第二步的结论。可证伪性是第三阶段要做的事情，需要提出一个逆反命题来作为证伪的入口。</li>
</ul>
</li>
<li><p><strong>警惕经济学中常见的"伪科学"特征</strong></p>

<ul>
<li>套套逻辑（同义反复）</li>
<li>不可证伪命题（如行为经济学陷阱中的"有时理性有时非理性"）</li>
</ul>
</li>
</ol>


<h3>二、核心经济理论体系</h3>

<h4>价格理论框架</h4>

<ul>
<li> 需求定律本质：</li>
<li> 相对价格＞货币价格</li>
<li> 需求变化≠需求量变化</li>
<li> 边际分析核心地位：筛选关键局限条件的数学工具（导数思维）</li>
</ul>


<h4>特殊物品辨析</h4>

<ul>
<li> 吉芬物品悖论：市场自淘汰机制（类似基因选择）</li>
<li> 奢侈品功能：降低陌生人社会的信息费用</li>
<li> 贫穷物品，富裕物品：需求曲线的不同弹性</li>
</ul>


<p>以上例子都是试图推翻需求定律。也许有些人确实会在物品相同的情况下买贵的东西，但是这种人很快就会消失在市场中。这就像不自私的基因会被淘汰一样。</p>

<blockquote><p>与此类似，不婚不育是某些年轻人的观念，对于这一点我不担心，因为这种人会在自然选择之下会消失。</p></blockquote>

<p>消费者理论太复杂，供需理论简单有效，根据奥卡姆剃刀原则，我们应该选择供需理论。</p>

<ol>
<li><strong>均衡观革新</strong>

<ul>
<li>任何状态都是均衡：含交易费用的理性选择结果。</li>
<li>非均衡状态是对物理学的拙劣模仿，任何选择都是理性的选择，考虑了交易城本，是边际分析法。任何时候都是均衡的。</li>
<li>非均衡是错误的，但是可以用来快速判断一个结论是否正确。

<ul>
<li>如果非均衡，那么一定有什么边界条件没有说清楚，你要相信，现在的状态就是理性（自私）选择的结果。</li>
<li>澳门伴手礼香气周围门店没有跟风，就是非均衡，肯定还有什么原因没有找到。</li>
</ul>
</li>
</ul>
</li>
</ol>


<h3>三、政府干预批判</h3>

<ol>
<li><p><strong>价格管制后果</strong></p>

<ul>
<li>典型案例：</li>
<li>限广令→视频平台崛起</li>
<li>义务教育→私立学校/学区房溢价</li>
<li>医疗价格管制→以药养医/检查泛滥

<ul>
<li>医生收红包 -> 国家禁止收红包 -> 以药养医，租值消散更大，解释为什么药物价格这么贵 -> 国家药价管制 -> 医生多开检查 -> 租值消散越来越大</li>
</ul>
</li>
<li>租值消散规律：管制强度与寻租方式正相关</li>
</ul>
</li>
<li><p><strong>管制本质辨析</strong></p>

<ul>
<li>产权视角：医生vs加油站员工收红包的本质差异

<ul>
<li>医生收红包和加油站员工收红包本质不同，因为产权归属不同。医生是产权人，不是腐败，睁一只眼闭一只眼，加油站员工不是产权人，是腐败，要消灭。</li>
</ul>
</li>
<li>&ldquo;免费最贵"定理：货币支付是租值消散最小方式</li>
</ul>
</li>
</ol>


<h3>四、制度经济学洞见</h3>

<ol>
<li><p><strong>法律经济分析</strong></p>

<ul>
<li>恶法悖论：</li>
<li>严格执行→租值消散</li>
<li>松散执行→法律权威受损</li>
<li>恶法，不是无知就是无耻</li>
<li>计划生育废除阻力：部门生存逻辑</li>
</ul>
</li>
<li><p><strong>计划与市场边界</strong></p>

<ul>
<li>科斯定理应用：企业规模受内部交易费用限制</li>
<li>列宁式计划经济的根本缺陷：忽略规模不经济</li>
</ul>
</li>
</ol>


<h3>五、经济学思维工具</h3>

<ol>
<li><p><strong>分析框架转换</strong></p>

<ul>
<li>实证分析三步法：
① 物理现象（为什么发生）
② 经济动机（为何选择）
③ 伦理评判（是否应该）</li>
<li>数据使用警示：</li>
<li>警惕精确错误＞接受模糊正确</li>
<li>区分因果与相关</li>
</ul>
</li>
<li><p><strong>概念革新</strong></p>

<ul>
<li>经济理性≠日常自私：包含所有可解释行为</li>
<li>歧视合理性：能力证明＞强制平等</li>
</ul>
</li>
</ol>


<h3>六、学科发展批判</h3>

<ol>
<li><strong>理论流派评析</strong>

<ul>
<li>推崇学派：马歇尔局部均衡/弗里德曼货币理论/张五常制度分析</li>
<li>批判对象：</li>
<li>瓦尔拉斯一般均衡（脱离现实）</li>
<li>凯恩斯主义（人为割裂微观宏观）</li>
</ul>
</li>
</ol>


<h3>七、实然问题与应然问题的分析框架</h3>

<p><strong>案例：人从楼上抛掷垃圾</strong><br/>
1. <strong>学科视角划分</strong><br/>
   - <strong>物理学（实然解释）</strong><br/>
     研究现象规律：垃圾下落因地球引力作用<br/>
     → 回答"为什么发生"<br/>
   - <strong>经济学（实然解释）</strong><br/>
     分析行为动机：抛掷垃圾因私人成本＜环境成本（负外部性）<br/>
     → 回答"为何选择"<br/>
   - <strong>伦理学（应然判断）</strong><br/>
     价值评判：破坏公共环境应受谴责<br/>
     → 回答"是否应该"</p>

<ol>
<li><strong>方法论转换</strong>

<ul>
<li>规范命题实证化路径：<br/>
① 明确价值标准（如"社会总福利最大化"）<br/>
② 构建可检验假说（如"禁止抛掷可使空气质量提升X%&ldquo;）<br/>
③ 进行事实验证（污染数据对比/治理成本测算）</li>
<li>关键突破：将道德判断转化为可证伪的成本收益分析</li>
</ul>
</li>
</ol>


<h3>八、其它</h3>

<ol>
<li>统计学的两个问题

<ul>
<li><ol>
<li>错把相关性当因果性。</li>
</ol>
</li>
<li><ol>
<li>迷信数据。数据不一定代表整个状态空间。</li>
</ol>
</li>
</ul>
</li>
<li>弗里德曼对大萧条的解释才是正统的，凯恩斯的解释是非正统的。</li>
<li>不能看到一个犯罪就杀头，这样轻罪重罪都是一样的惩罚，那么重罪比例就会上升。如果一个人犯错了，就会上升到犯重罪。比如陈胜吴广起义，他们是因为犯了轻罪，就要被处死，所以干脆就起义了。</li>
<li>经济学中的自私其实和我们生活中的自私不一样，只要是可解释的，就是自私的。这样说，其实用理性更合适。</li>
<li>自然科学领域科学方法风气好，不用去学习科学方法论，只用随大流就可以。经济学领域科学方法风气不好，需要通过学习科学方法论，来提高自己的辨别能力。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课笔记]]></title>
    <link href="http://hongchaozhang.github.io/blog/2025/01/07/jingying-rike-notes/"/>
    <updated>2025-01-07T23:41:38+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2025/01/07/jingying-rike-notes</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>认知闭合</h2>

<p>认知闭合需求指的是人们需要因果关系的解释和可预测性。</p>

<p>比如讲故事必须传递一个明确的意义。传统音乐和爵士乐在这方面有所不同。</p>

<ul>
<li>传统音乐通常是线性的，有明确的主题和发展，</li>
<li>爵士乐则是开放式的，更注重即兴和变化。</li>
</ul>


<h2>怎样激励10到25岁青少年</h2>

<p>激励10到25岁青少年，要注意避免导师悖论，尽量做到提供“智者的反馈”。</p>

<p>具体来说，可以使用以下策略：</p>

<ol>
<li>告诉他们：“我给你这些评语是因为我有很高的标准，我知道你能达到这些标准。”</li>
<li>询问而不是告知，尊重并承认对方的主观能动性。</li>
<li>共同寻找前进的方向。</li>
<li>只提供建议，不帮他们做决定，让他们自己做决定。</li>
<li>在提出批评建议的时候，要用夸奖三明治等技巧。

<ol>
<li>夸奖三明治：先夸奖，再提出批评，最后再夸奖。</li>
</ol>
</li>
</ol>


<h2>可扩展的事情（Scaling Law）</h2>

<ul>
<li>可扩展的事情值得多投入，而不可扩展的事情则不值得投入更多精力，比如吃好吃的和健身等。</li>
<li>任何事情都不是一直可扩展的，因此我们要寻找一个高上限的事情来做。</li>
</ul>


<h2>智人之上</h2>

<ul>
<li>在真相和秩序之间需要找到平衡。</li>
<li>罗素曾说过：“我不敢让人因为我的理念去死，因为我不确定我的理念是正确的。”这句话体现了政治家和科学家的区别。</li>
</ul>


<h2>挑战还是威胁？</h2>

<ul>
<li>挑战能够促进人的发挥，而威胁则只能限制人的发挥。</li>
<li>奖励第一名是一种挑战，而淘汰最后一名则是一种威胁。</li>
<li>通过控制感可以将威胁转化为挑战。</li>
</ul>


<h2>格拉德威尔</h2>

<ul>
<li>格拉德威尔提出了引爆点和10000小时理论，</li>
<li>强调了超故事、理想叙事和潜规则。</li>
<li>他还提出了三分之一定律，指出群体中的少数人会做更多的事情。</li>
</ul>


<h2>歧视和公平</h2>

<ul>
<li>在汽车尾气检测中，有一种仪器可以在路上精准检测尾气排放量，从而抓到排放不合格的车主。然而，这种方法可能会被认为是对穷人的歧视，因此要求所有人都去做检测。</li>
<li>在新冠疫情中，有更有效的检测办法，比如肥胖和唾液粘稠的人更容易产生空气溶胶，助力病毒传播，但这种方法也可能被认为是对肥胖和唾液粘稠者的歧视。</li>
</ul>


<h2>诺贝尔奖</h2>

<ul>
<li>诺贝尔物理奖得主通常是圈内人，不能闭门造车、两耳不问天下事、一心只读圣贤书。</li>
<li>相反，圈内人并不是腐败，而是因为他们有眼界、知主流，并且有高人指点。</li>
<li>文学奖则不完全是这样。</li>
</ul>


<h2>其它</h2>

<p>心流，及时反馈，产生 “努力-爽-努力-爽” 的节奏感</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[汪诘-科学故事解读]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/10/31/wangjie-kexue-gushi-jiedu/"/>
    <updated>2024-10-31T23:53:57+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/10/31/wangjie-kexue-gushi-jiedu</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>《皇帝的新脑》- 罗杰·彭罗斯</h2>

<p>共10章，前八章都是在讲历史，做铺垫。第9章才入正题。</p>

<p>《皇帝的新脑》是由英国数学物理学家罗杰·彭罗斯（Roger Penrose）所著的一部跨学科的著作，涉及电脑科学、数学、物理学、宇宙学、神经和精神科学以及哲学等多个领域。这本书体现了作者向哲学上最大问题——“精神-身体关系”挑战的大无畏精神，并充满了天才般的猜测，贯穿着探索真理的灵感和激情。</p>

<p>书中广泛讨论了现代物理学中对人类观念最具挑战性的问题，例如人工智能、哥德尔定理、复杂性理论、相对论因果性和决定论、时空弯曲、不确定性原理、量子场论、熵和时间箭头、宇宙论和大爆炸、精神与意识的本质、动物意识、宿命论、人择原理等等。同时，书中还包含了许多能激发想象力的数学物理模型，如图灵机、孟德勒伯洛特集、希尔伯特空间、爱因斯坦-玻多尔斯基-罗逊“矛盾”、薛定谔猫等等。</p>

<h2>四种基本力</h2>

<p>四种基本力的发现顺序如下：</p>

<ol>
<li>万有引力（Gravitational Force）：万有引力是最早被人类认识到的基本力。艾萨克·牛顿在1687年发表了《自然哲学的数学原理》，其中提出了万有引力定律，描述了物体之间的引力作用。</li>
<li>电磁力（Electromagnetic Force）：电磁力的发现稍晚于万有引力。1865年，麦克斯韦提出了描述电磁场的麦克斯韦方程组，统一了电和磁的现象。</li>
<li>强力（Strong Nuclear Force）：强力是维持原子核内部质子和中子结合在一起的力。20世纪30年代，核物理学家开始研究原子核的结合能问题，发现了强力的存在。强力的现代理论是在20世纪60年代和70年代发展起来的量子色动力学（QCD）。</li>
<li>弱力（Weak Nuclear Force）：弱力是四种力中最后被发现的。它负责某些类型的放射性衰变过程。弱力的现代理论是在20世纪60年代和70年代，与电磁力一起被统一在电弱理论中。</li>
</ol>


<h2>人择原理</h2>

<p>说到“人择原理”，我们一般说的是“弱人择原理”：</p>

<ul>
<li>我们存在于这个宇宙中，是因为这个宇宙的物理定律和常数恰好允许我们的存在。换句话说，我们观察到的宇宙特性之所以是这样的，是因为如果不是这样，我们就不会在这里观察它。这个原理强调了观察者存在的事实对宇宙特性的限制。</li>
</ul>


<p>除此之外，还有强人择原理和最终人择原理。</p>

<ul>
<li>强人择原理认为宇宙必须具备允许智慧生命在其某个历史阶段得以在其中发展的那些性质。这个原理认为，宇宙的基本物理常数和定律之所以是这样，是因为它们必须如此，以便能够产生智慧生命。</li>
<li>最终人择原理认为，包含智慧的信息处理过程一定会在宇宙中出现，而且，它一旦出现就不会灭亡。这个原理在某种程度上预言了智慧生命的不可避免性和永恒性。</li>
</ul>


<h2>测不准原理</h2>

<p>测不准原理，说法不合适，更准确的说法是“不确定性原理”。并不是“测不准”，而是客观世界就“不确定”。</p>

<p>根据不确定性原理，拉普拉斯（拉普拉斯妖）是无法精确预测未来的。
虽然我们无法精确预测未来，但是，我们可以预测未来的概率。</p>

<p>量子力学的两道门槛：不连续性，不确定性。
爱因斯坦和薛定谔迈过了第一道门槛，却倒在了第二道门槛上。</p>

<h2>弗里德曼-勒梅特宇宙模型</h2>

<p>弗里德曼-勒梅特宇宙模型基于爱因斯坦的广义相对论，描述了一个均匀各向同性的宇宙。以下是三种主要的宇宙模型，它们预测了宇宙膨胀的不同情况：</p>

<ol>
<li>开放宇宙模型（K=-1）：在这个模型中，宇宙的曲率为负，意味着宇宙是无限且膨胀的。宇宙的膨胀速度快，并且会一直持续下去。这个模型对应于三维双曲空间。</li>
<li>平坦宇宙模型（K=0）：这个模型中，宇宙的曲率为零，意味着宇宙是平坦的。宇宙的膨胀速度较慢，但也会一直持续下去。这个模型对应于三维平直空间，也被称为爱因斯坦-德西特宇宙。</li>
<li>闭合宇宙模型（K=1）：在这个模型中，宇宙的曲率为正，意味着宇宙是有限且膨胀的。宇宙的膨胀会减慢到一定限度后出现胀缩交替情况，对应于三维球面空间。这个模型预测宇宙会经历膨胀和收缩的周期性过程。</li>
</ol>


<h2>其它</h2>

<ul>
<li>哈勃红移的原因不是多普勒效应，而是宇宙膨胀，只是当时还不知道</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[吴国盛-科学简史]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/10/13/wuguosheng-kexuejianshi/"/>
    <updated>2024-10-13T23:28:59+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/10/13/wuguosheng-kexuejianshi</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>引言</h2>

<p>在《科学简史》的课程中，我们探讨了科学与技术的历史分野，以及为何中国古代科技在近代相对落后。这些问题的探讨，不仅涉及科学与技术的定义，还涉及了文化、哲学和历史等多个层面。</p>

<h2>科学与技术的区别</h2>

<p>首先，我们需要明确科学与技术的区别。科学是基于希腊数理实验的系统知识体系，而技术则是具体的应用实践。</p>

<p>中国古代的四大发明（造纸术、印刷术、火药、指南针）虽然在技术上领先世界，但它们更多体现的是技术层面的成就，而非科学。</p>

<h2>科学的定义</h2>

<p>科学可以被分为三种形态：</p>

<ul>
<li>古希腊的纯粹数理逻辑科学。</li>
<li>欧洲结合数理逻辑和宗教的唯命论产生的数理实验科学，即现代科学。

<ul>
<li>唯命论推出以人为本，以人为本成为后来科学发展的基石之一。</li>
</ul>
</li>
<li>博物学和自然志，这在中国文化中有着深厚的根基。

<ul>
<li>nature history，自然志。这里的history没有时间概念。</li>
<li>博物学最伟大的产出是进化论。</li>
</ul>
</li>
</ul>


<h2>科学的数学化过程</h2>

<p>科学的数学化过程是科学发展史上的一个关键转变，它涉及到将自然现象用数学语言描述和分析。以下是从几个关键人物的角度来概述这一过程：</p>

<ol>
<li>毕达哥拉斯（Pythagoras）：
 毕达哥拉斯生活在公元前6世纪，是古希腊哲学家和数学家，他提出了“数即自然，自然皆数”的观点，即认为数字关系是理解宇宙的关键。毕达哥拉斯学派相信宇宙的秩序和和谐可以通过数学关系来解释。这一观点为后来的科学数学化奠定了基础。</li>
<li>阿基米德（Archimedes）：
 阿基米德生活在公元前3世纪，是古希腊的数学家、物理学家和工程师，他在几何学、力学和流体静力学等领域做出了重要贡献。阿基米德的工作展示了如何用数学原理来解决物理问题，比如他通过浮力原理（阿基米德原理）来计算物体的体积和密度，这进一步推动了科学数学化的发展。</li>
<li>托勒密（Ptolemy）：
 托勒密是罗马时期的希腊天文学家和地理学家，生活在公元2世纪，是古希腊的天文学家和地理学家，他的《天文学大成》提出了地心说模型，即认为地球是宇宙的中心，其他天体围绕地球运动。托勒密的模型虽然在科学上不正确，但它尝试用数学方法来描述天体运动，这在数学化天文学方面是一个重要的步骤。</li>
<li>哥白尼（Copernicus）：
 哥白尼是文艺复兴时期的波兰天文学家，生活在15世纪末至16世纪中叶。他提出了日心说，即太阳是宇宙的中心，地球和其他行星围绕太阳运动。哥白尼的模型更接近现代天文学的理解，并且他的工作标志着科学数学化在天文学领域的重大突破。</li>
<li>开普勒（Kepler）：
 开普勒是德国天文学家和数学家，生活在16世纪末至17世纪初。他通过分析第谷·布拉赫的天文观测数据，提出了开普勒行星运动三大定律。这些定律用数学公式精确描述了行星围绕太阳的运动，是科学数学化在天文学领域的又一个里程碑。</li>
<li>伽利略（Galileo）：
 伽利略是意大利的物理学家、数学家、天文学家和哲学家，生活在16世纪末至17世纪中叶，他被认为是现代科学的奠基人之一。伽利略将运动数学化，通过实验和数学分析来研究物体的运动规律。他的工作，如对自由落体的研究，展示了如何用数学方法来描述和预测自然现象，这为后来的物理学奠定了基础。</li>
<li>艾萨克·牛顿（Isaac Newton）
 牛顿是17世纪的英国物理学家、数学家、天文学家、自然哲学家和炼金术士。他在1687年发表的《自然哲学的数学原理》中提出了三大运动定律和万有引力定律，这些定律构成了经典力学的基础。</li>
</ol>


<p>总的来说，科学的数学化过程是一个逐渐发展的过程，从毕达哥拉斯的哲学观点到伽利略的实验科学，每一步都深化了我们对自然现象数学描述的理解。这一过程不仅推动了科学的发展，也改变了我们对世界的认识方式。</p>

<h2>中国古代科学的发展</h2>

<p>中国古代的科技名著，如《本草纲目》、《齐民要术》等，展现了中国古代在博物学领域的深厚积累。然而，由于缺乏对客观规律的承认和对数理逻辑的深入研究，中国古代的科学发展受到了限制。</p>

<h2>科学与文化的关系</h2>

<ol>
<li>实验科学是拷问自然的过程，让自然“说出”自己的规律（相比较而言，艺术则是观察自然。）。实验科学和自然之间是竞争控制关系，希望能通过博物学进行化解。而这，就是中国文化的特点。</li>
<li>美国打仗号召：为自由而战。中国打仗号召：为保家卫国而战。</li>
<li><strong>几何学的证明思维，是中国文化中没有的</strong>。中国的推理，是诗人般的推理：赋比兴。善于用类比做推理。这种类比的推理是不严密的，是不同的人能得出不同的结论的。</li>
<li>中国天文学是政治占星术。中国的天文学是为了政治服务的，而不是为了纯粹的科学研究。</li>
<li>中国没有科学，原因是中国就不承认有客观规律的存在，天人合一，相互影响。中国没有对数理逻辑的深入研究。</li>
</ol>


<h2>时空观</h2>

<p>时间观的历史发展是一个复杂而丰富的过程，它涉及了哲学、物理学、宗教和文化等多个领域。以下是对时间观历史发展的整理：</p>

<ol>
<li>循环时间观：在古代，许多文化中时间被视为循环的。例如，希腊人和印度佛教徒都认为时间是循环的，历史和宇宙以一定的周期重复自身。这种观念在印度教和婆罗门教中表现得尤为明显，他们认为宇宙的结构具有数学的精确性，其基础是圆的形象和有限事物的无限重复性</li>
<li>线性时间观：与循环时间观相对的是线性时间观，这种观念在希伯来文化中尤为突出。基督教继承并改造了这种时间观，将时间视为从创世到末日审判的直线过程，强调了时间的方向性和未来的重要性</li>
<li>牛顿的绝对时间观：在科学领域，牛顿提出了绝对空间和绝对时间的概念，认为时间和空间与物质的运动无关，是独立存在的。牛顿力学中的方程并不包含时间的方向性，这导致了时间在物理定律中似乎是可逆的</li>
<li>热力学时间方向性：热力学的发展为时间观带来了新的理解。热力学第二定律，即熵增定律，指出在孤立系统中熵不会减少，这为时间提供了一个明确的方向性。玻尔兹曼的研究进一步将熵与微观状态的概率联系起来，揭示了热力学第二定律的统计本质</li>
<li>相对论时间观：爱因斯坦的相对论进一步挑战了牛顿的绝对时间观。在相对论中，时间不再是独立的实体，而是与空间结合形成了时空结构。时间在不同的重力场和速度下会有所不同，这表明时间是相对的，而非绝对的</li>
<li>时间的现代理解：随着量子力学和宇宙学的发展，时间的概念继续演变。例如，宇宙学时间箭头指向宇宙膨胀的方向，而热力学时间箭头则与熵增相关。此外，心理学和认知科学也开始探索人类如何感知和理解时间</li>
</ol>


<p>总的来说，时间观的历史发展是一个从宗教和哲学的循环或线性时间观，到科学领域的绝对和相对时间观，再到现代物理学中更为复杂和动态的时间理解的过程。这些不同的时间观反映了人类对时间本质的不断探索和理解。</p>

<h2>决定论与机械论的历史发展</h2>

<ol>
<li>笛卡尔（René Descartes）是17世纪的法国哲学家、数学家和科学家。他提出了“机械论”（mechanism）的观点，认为自然界的运行就像一台机器，可以通过数学和几何来解释。这种机械论的观点对后来的科学发展产生了深远的影响，推动了科学的数学化和实验化。他的这种思想非常超前，以至于跳过了牛顿的阶段，与爱因斯坦的广义相对论有相似之处。</li>
<li>牛顿（Sir Isaac Newton）是17世纪的英国物理学家、数学家和天文学家。牛顿的力学体系是机械决定论的典型代表。牛顿力学认为，知道了物体的初始条件和作用在物体上的力，就可以准确预测物体未来的运动状态。牛顿的万有引力定律进一步强化了这种决定论观点，使得天体运动可以被精确计算和预测。</li>
<li>拉普拉斯（Pierre-Simon Laplace）是18世纪末至19世纪初的法国数学家和天文学家。拉普拉斯提出了著名的拉普拉斯决定论（拉普拉斯妖），他认为如果一个智者能够知道某一时刻宇宙中所有粒子的位置和速度，那么他就能够预测宇宙在任意时刻的状态。这种观点是建立在经典力学可逆过程的基础上的。</li>
</ol>


<p>随着20世纪量子力学的发展，这种严格的决定论受到了挑战，因为量子力学揭示了自然界的随机性和不确定性。尽管如此，机械论和决定论在宏观尺度上仍然具有重要的科学价值。</p>

<h2>其它</h2>

<ul>
<li>希腊的数学不是现代数学。

<ul>
<li>希腊数学是和真实场景绑定，没有进行进一步抽象，所以才说音乐是数学，物理学（比如力学）是数学，天文学是数学。</li>
<li>现代数学专指抽象的数学，是纯粹的数学，目的是为了推广数学的应用范围。音乐物理天文不再称为数学。</li>
</ul>
</li>
<li>李约瑟难题：中国古代科技很发达，为什么近代落后了？

<ul>
<li>这个命题有问题，以技术代科学。</li>
<li>冯友兰，竺可桢的说法更加可信：中国古代为什么没有科学？这才是比较严格的命题和论证。</li>
</ul>
</li>
</ul>


<h2>结语</h2>

<p>通过《科学简史》的学习，我们不仅了解了科学与技术的历史分野，还深入探讨了科学在不同文化和历史背景下的发展。这些知识不仅丰富了我们的历史视野，也为我们理解现代科学提供了深刻的洞见。科学的发展是一个不断进化的过程，它与我们的文化、哲学和历史紧密相连，共同塑造了我们对世界的理解。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[汪诘-科幻世界漫游指南]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/10/12/wangjie-kehuanshijie-manyouzhinan/"/>
    <updated>2024-10-12T22:36:27+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/10/12/wangjie-kehuanshijie-manyouzhinan</id>
    <content type="html"><![CDATA[<!-- more -->


<p>在探索科学的无限可能中，我们总是被那些将想象力与科学原理完美结合的作品所吸引。今天，让我们一同回顾那些在科幻世界中留下深刻印记的作品和概念。</p>

<h2>儒勒·凡尔纳与H.G.威尔斯</h2>

<h3>儒勒·凡尔纳</h3>

<p>凡尔纳是19世纪著名的法国小说家、剧作家及诗人，被誉为“现代科幻小说之父”。凡尔纳以其丰富的想象力和对科学的深刻理解，创作了一系列令人着迷的冒险故事，包括《海底两万里》《八十天环游地球》《地心游记》等。</p>

<h3>H.G.威尔斯</h3>

<p>1898年，威尔斯以其《世界大战》震惊了世界，
1938年，根据《世界大战》改编的广播剧在美国播出时，由于描述过于逼真，甚至引起了公众的恐慌，这一事件也成为了美国历史上的一大离奇笑话。</p>

<h2>黄金年代的科幻巨匠</h2>

<h3>海因莱因</h3>

<p>罗伯特·海因莱因是科幻黄金年代的代表人物之一，他的作品深刻影响了后世的科幻创作。
海因莱因活跃于20世界50年代，曾三次成为世界科幻大会的嘉宾，多次获得雨果奖，并于1975年荣获一级大师星云奖。</p>

<h3>阿瑟·克拉克</h3>

<p>刘慈欣最崇拜的科幻作家。
阿瑟·克拉克以其《2001太空漫游》等作品闻名于世。这本书在1968年被导演斯坦利·库布里克拍摄成同名电影，成为科幻电影的经典名作。<strong>但是星童的设计过于玄幻。</strong></p>

<h3>艾萨克·阿西莫夫</h3>

<p>阿西莫夫活跃于20世界50年代，以其《基地》系列、《机器人》系列和《银河帝国》系列作品著称。基地系列7本(6本半)，机器人系列5本，银河帝国系列3本。</p>

<ol>
<li>在《基地》系列中，他构建了一个放大版的地球——银河帝国，<strong>被人诟病说是放大版的地球。</strong>尽管星际距离的交通方式缺乏科学依据，但晚年的补救解释（超空间，跃迁）使其设定更加自圆其说。</li>
<li>《基地》系列中的骡拥有心理控制术，<strong>太过于玄幻</strong>，但心理史学则是该系列的亮点，借鉴了十九世纪拉普拉斯的决定论。</li>
<li>《盖亚》系列则提出了一个超级生命体的概念，与《阿凡达》中的设定相似，探讨了人类解决终极生存问题的方法。不如此，必将被外星人利用，挑起内斗，导致人类灭亡。这个观点，<strong>正好和三体相反。</strong>三体则把人类这种互相看不透的现象当做和三体作战的最大武器。</li>
</ol>


<h2>卡尔·萨根：科学家与科幻作家</h2>

<p>卡尔·萨根不仅是一个科学家，也是一个科幻作家。他的《宇宙》节目旁白脚本被汇集成册，而他唯一的小说《接触》则探讨了超越数Pi中隐藏的宇宙信息。电影《超时空接触》，删除了小说中超越数相关的部分。</p>

<p>萨根对外星人持乐观态度，认为外星人是友好的，就像接触小说中描写的一样。他的METI行为——Messaging Extraterrestrial Intelligence，主动向地外智慧生命发送信息——引发了科学界的争议。METI国际组织致力于通过发送信息与外星生命进行交流，尽管这种行为存在潜在风险。其METI行为包括：</p>

<ul>
<li>1972年，为先驱者号探测器设计了一块铝板，上面绘制了地球人的形象以及太阳系在银河系中的位置信息。</li>
<li>1974年，用最大的射电望远镜把人类的信息发射到宇宙中。</li>
<li>1977年，将人类信息通过金唱片通过旅行者号飞出太阳系。</li>
</ul>


<h2>赛博朋克</h2>

<p>赛博朋克是科幻文学的一个子类型，以其对未来科技社会的深刻反思而闻名。</p>

<ul>
<li>真名实姓：赛博朋克的先驱之作。（反派大boss邮件人）</li>
<li>神经漫游者：一般人认为是赛博朋克的开山之作，其实更早的是《真名实姓》。</li>
<li>黑客帝国：巅峰之作。</li>
</ul>


<h2>其它</h2>

<p>光速：</p>

<ul>
<li>信息和能量不能超光速，空间膨胀可以。</li>
<li>光速c恒定，光速可能是一个几何常数，而不是一个物理常数。</li>
</ul>


<p>暗物质：不和电磁力发生作用，只和引力发生作用的物质。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[费曼漫谈科学研究]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/07/08/feiman-xiangxiangli/"/>
    <updated>2024-07-08T00:53:34+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/07/08/feiman-xiangxiangli</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>镜子颠倒了什么</h2>

<p>镜子是怎么知道只颠倒左右，不颠倒上下的？即使你躺下侧对着镜子，也是这样。
其实镜子并不对上下左右感兴趣，它只是颠倒了前后，所以产生了那个“左右颠倒，上下不颠倒”的现象。</p>

<h2>热的本质</h2>

<p>热的本质是分子的无规则运动。这一点可以解释很多现象。
试着解释：</p>

<ol>
<li>冰为什么这么滑：压力使冰表面融化</li>
<li>压缩使气体升温：</li>
<li>火</li>
</ol>


<h2>“观察”的本质</h2>

<p>我们周围的世界充满各种波长的波，我们的眼睛有选择的接收其中一部分，来分辨周围的物体以及发生的事情。
水面上角落里的一只昆虫，也在做类似的事情：通过分析水波，来“看到”水面上发生的一切。</p>

<h2>自我安慰</h2>

<p>想想宇宙的浩瀚，顿感人类的渺小。这时候，需要想一想原子的渺小，顿感自己是一个宇宙。我们处于这样一个中间态，是不是还挺幸运的。</p>

<h2>其它</h2>

<ul>
<li>我们应该用基本的力去解释生活中的现象，也不是反过来用生活中的现象去解释基本力。</li>
<li>天文学是需要想象力的领域，因为数据太少了。想象力使我们能够超前做出预测。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS resolution rules and specificity]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/06/17/css-resolution-rules-and-specificity/"/>
    <updated>2024-06-17T11:53:39+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/06/17/css-resolution-rules-and-specificity</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Description</h2>

<p>The css property doesn&rsquo;t take effect in the release build but works fine in the debug build.</p>

<h2>Root cause</h2>

<p>We applied two css classes in one dom node and didn’t specify the priority (have the same css specificity (0,1,0)), thus the CSS class order matters: the latter one will override the previous one.</p>

<p>However, the css class order is not stable between the debug and release builds.</p>

<h2>Solution</h2>

<p>After fixing, the classes are like this:</p>

<p><img src="http://hongchaozhang.github.io/images/css-specificity-1.png" alt="css-specificity-1" /></p>

<p>We can use the scss file helper tools in VS Code:</p>

<p><img src="http://hongchaozhang.github.io/images/css-specificity-2.png" alt="css-specificity-2" /></p>

<p>Caution while nesting &amp; :</p>

<p><img src="http://hongchaozhang.github.io/images/css-specificity-3.png" alt="css-specificity-3" /></p>

<h2><a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance">Cascade</a></h2>

<p>When two rules from the same cascade layer apply and both have equal specificity, the one that is defined last in the stylesheet is the one that will be used.</p>

<p>There are three factors to consider, listed here in increasing order of importance. Later ones overrule earlier ones:</p>

<h3>Source order</h3>

<h3><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity">Specificity</a></h3>

<ul>
<li>one identifier selector has 1-0-0 specificity</li>
<li>one class selector (attribute selector) has 0-1-0 specificity</li>
<li>one element selector has 0-0-1 specificity</li>
<li>The specificity weight of :not/:is/:has comes from the selector parameter in the list of selectors with the highest specificity.</li>
<li>Combinators, such as +, >, ~, &ldquo; &rdquo;, and ||, may make a selector more specific in what is selected but they don&rsquo;t add any value to the specificity weight.</li>
</ul>


<p><img src="http://hongchaozhang.github.io/images/css-specificity-4.png" alt="css-specificity-4" /></p>

<h3>Importance</h3>

<ul>
<li>inline style</li>
<li><code>!important</code>: DO NOT use <code>!important</code>. It makes the CSS hard to maintain and debug.

<ul>
<li>See a demo for <code>!important</code> <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance#!important">here</a>.</li>
</ul>
</li>
</ul>


<h2>Other info</h2>

<p>The VS Code should have issues with “specificity” calculation.</p>

<p><img src="http://hongchaozhang.github.io/images/css-specificity-5.png" alt="css-specificity-5" /></p>

<p>The specificity should be 0-2-0.</p>

<p>More examples can be seen from here: <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity#three-column_comparison">Specificity</a></p>

<p><img src="http://hongchaozhang.github.io/images/css-specificity-6.png" alt="css-specificity-6" /></p>

<p>Some online css specificity calculator can be used for testing:</p>

<p><a href="https://specificity.keegan.st/">Specificity Calculator</a></p>

<h2>How to avoid such issues?</h2>

<ul>
<li>Make sure all the loaded CSSs have different css specificity.</li>
<li>Review the CSS in the developer tool.</li>
<li>For a specific css property, filter out all CSSs which contains it.</li>
<li>Make sure the CSS you want to apply have the highest css specificity.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[how to start a python project]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/05/27/how-to-start-a-python-project/"/>
    <updated>2024-05-27T18:28:33+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/05/27/how-to-start-a-python-project</id>
    <content type="html"><![CDATA[<!-- more -->


<p>venv:</p>

<ul>
<li>venv (built-in): venv is a module in Python 3&rsquo;s standard library used to create lightweight virtual environments.</li>
<li>activate: <code>source venv/bin/activate</code></li>
<li>deactivate: <code>deactivate</code></li>
</ul>


<p>pyenv:</p>

<ul>
<li>python version control. Similar to nvm for node.js.</li>
<li>virtual env management. Similar to venv.</li>
</ul>


<p>pipenv:</p>

<ul>
<li>python package management. Similar to npm for node.js.</li>
<li>activate: pipenv shell</li>
<li>deactivate: exit</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes for Generative AI with LLMs]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/03/26/notes-for-generative-ai-with-llms/"/>
    <updated>2024-03-26T13:10:55+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/03/26/notes-for-generative-ai-with-llms</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="https://github.com/hongchaozhang/Course--Generative-AI-with-LLMs/blob/main/Notes%20for%20Course%20%22Generative%20AI%20with%20Large%20Language%20Models%22.md">Notes for Course &ldquo;Generative AI with Large Language Models</a></li>
<li><a href="https://github.com/hongchaozhang/Course--Generative-AI-with-LLMs/tree/main">github page</a></li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-道可道非常道]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/03/26/jingying-rike-daokedao-feichangdao/"/>
    <updated>2024-03-26T00:25:01+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/03/26/jingying-rike-daokedao-feichangdao</id>
    <content type="html"><![CDATA[<!-- more -->


<p>2023年3月15日，沃尔夫勒姆在自己的网站发表了一篇充满洞见的宝藏文章，展望了AI对人类社会 的影响。理解了沃尔夫勒姆的关键思想，你就会生出一种对未来世界的掌控感。</p>

<p>这篇文章包括三个核心观念：</p>

<ul>
<li>计算不可约性</li>
<li>计算等价原理</li>
<li>人的价值在于历史</li>
</ul>


<h2>计算不可约性</h2>

<h3>概念</h3>

<p>首先说一下什么叫约化。约化是用一个浓缩的陈述——可以说是一个理论、或者一个公式——概括一个现象，是对现实信息的压缩表达。我们的一切自然科学、社会科学理论，各种民间智慧、成语典故，我们总结出来的一切规律，都是对现实世界的某种约化。</p>

<p>你可能希望科技进步能约化一切现象，但现实恰恰相反。数学家早已证明，真正可约化的都要么是简单系统，要么是真实世界的一个简单的近似模型。一切足够复杂的系统都是不可约化的。比如三体问题。</p>

<p>因为计算不可约性，人类对世间万物的理解是不可穷尽的。这意味着不管科技多么进步、AI多么发达，世界上总会有对你和AI来说都是全新的事物出现，你们总会有意外和惊喜。</p>

<p>计算不可约性规定，人活着总有奔头。</p>

<h3>特点</h3>

<p>伴随计算不可约性的一个特点是，<strong>在任何一个不可约化的系统之中，总有无限多个「可约化的口袋 (pockets of computational reducibility)」</strong>。</p>

<p>这就意味着，虽然世界本质上是复杂和不可预测的，但我们总可以在里面做一些科学探索和研究，总结一些规律，说一些话，安排一些事情。绝对的无序之中存在着无数个相对的秩序。</p>

<p>而且既然可约化的口袋有无限多个，科学探索就是一门永远都不会结束的事业。</p>

<h3>意义</h3>

<p>计算不可约性还意味着，我们不可能彻底“管住”AI。</p>

<p>未来AI跟我们真正的关系不是降临、不是拯救也不是幸存，而是「共存」。我们要学习跟AI共 存，AI也要也跟我们、跟别的AI共存。</p>

<p>计算不可约性说明，凡是能写下来的规则都不可能完全限制AI，凡是能发明的操作都不可能穷尽社会 的进步，凡是能总结的规律都不是世界的终极真相。</p>

<p>这就叫「道可道，非常道」。</p>

<h2>计算等价原理</h2>

<p>沃尔夫勒姆的第二个核心观念叫「计算等价原理(Principle of Computational Equivalence)」，意思是所有的复杂系统，不管看起来多复杂，都是<em>同等</em>复杂的，不能说哪个系统比哪个系统<em>更</em>复杂。</p>

<p>每个真有学问的人都应该是一个「<strong>不特殊论者</strong>」。 以前的人以为人是万物之灵长，地球是宇宙的中心，后来发现地球不是宇宙的中心，人类也只是生命演化的产物，我们的存在没有什么本质的特殊之处。</p>

<p>现在AI模型则告诉我们，人的智力，也没有什么特殊之处。任何一个足够复杂的神经网络都是跟人的大脑同等复杂的。不能说人能理解的科学理论就高级，AI识别药物分子的过程就低级。</p>

<p>既然都是平等的，那硅基生命和碳基生命自然也是平等的。那面对AI，我们凭什么认为自己更有价值?</p>

<h3>人的价值在于历史</h3>

<p>这就引出了沃尔夫勒姆的第三个核心观念:人的价值在于历史。</p>

<p>ai和人的根本区别是什么？是历史。人类有历史，并且有由历史确定的价值观。而AI没有历史，没有价值观。AI需要“对齐”人类的价值观。</p>

<h3>习惯让人适应</h3>

<p>快乐需要间隔，痛苦要一气呵成。
因为习惯会让人适应。
快乐我们不希望适应，但是痛苦我们希望适应。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-意识红色胶囊]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/03/25/jingyingrike-yishi-hongse-jiaonang/"/>
    <updated>2024-03-25T00:20:32+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/03/25/jingyingrike-yishi-hongse-jiaonang</id>
    <content type="html"><![CDATA[<!-- more -->


<p>一切感知都是幻觉，是预测，修正，再预测，再修正的过程。</p>

<p>意识讨论的意义：</p>

<ul>
<li>中国本土的正统学说，也就是儒学，到东汉年间就已经陷入了全面内卷，没有什么大学问可做了，大家都在搞细枝末节和预言、算命什么的。后来魏晋嬉皮士发明了玄学，印度又传来佛教，中国人才有了新鲜的思想资源。</li>
<li>我们回头看，玄学和佛教的世界观对不对已经不重要了，重要的是它们提供了逻辑思辨的思维方式，把人的思路打开了，激发了想象力，跳出了内卷。</li>
<li>我想现在关于意识的讨论也是如此，不一定对，但是它也是一个思想资源。</li>
</ul>


<p>物理学的三大基石——广义相对论、量子力学和统计力学——之所以是这样的，是因为我们的意识要求这样。</p>

<p>物理定律之所以是现在这个样子，是自然世界的计算不可约性和人类的计算受限性相互作用的结果。</p>

<ul>
<li>热力学第二定律（熵增定理）可以用计算受限性解释。</li>
<li>我们口中的“随机”也可以这么解释。</li>
<li>朱元璋抱怨中国越来越乱，只不过是因为他理解不了更复杂的社会形态。</li>
</ul>


<p>如果连物理定律都是幻象，那我们大概只能承认《金刚经》说的是对的：「凡所有相，皆是虚妄。」</p>

<p>正如康德说人无法真正认识「物自体」。</p>

<p>而我们现在知道，之所以如此，是因为我们是计算受限的。面对这个计算不可约的世界，任何智能 —— 包括AI和佛陀 —— 都必然是计算受限的。</p>

<ul>
<li>计算受限的原因是光速。是哪个神的力量给我们加了一个这样的约束？</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-别相信直觉]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/03/25/jingying-rike-biexiangxin-zhijue/"/>
    <updated>2024-03-25T00:03:37+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/03/25/jingying-rike-biexiangxin-zhijue</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>如果你想要一个幸福的婚姻，你应该怎样寻找自己的另一半？</h2>

<p>人们在婚恋市场上<strong>实际</strong>追求的东西，和<strong>应该</strong>追求的东西，正好完全是两回事。</p>

<p>寻常的吸引点——长相、身高、职业、个性像不像你什么的都根本不重要。如果要强行挑选，那就找那些拥有好品质的人，包括生活满意度、安全依恋风格、尽责性和成长心态。</p>

<h2>夫妻俩共同的朋友越多，关系越持久吗？不是。</h2>

<p>朋友圈重合度越高的夫妻或者男女朋友，越有可能在一定时间之后宣布再次单身。也就是说，最持久的关系，往往是双方各自有不同的朋友圈。</p>

<h2>确定恋爱关系之前的微妙状态中，怎么增加自己在对方眼中的吸引力？</h2>

<ul>
<li>对男性来说，最好的办法就是接受女性的领导 — 女性讲了笑话，你就笑；如果她谈论某个话题，你就顺着这个话题往下说；如果她说要干什么事情，你要表示支持。这样就能大大增加她对你的好感。</li>
<li>对于女性来说，有什么特别的对话技巧呢？对不起，数据显示女性用不着对话技巧 — 男性最后选择的总是外表好看的。</li>
</ul>


<h2>养育方法不重要，榜样最重要</h2>

<ul>
<li>养育方法对孩子的影响很重要吗？没有。孩子的命运是他自己的，家长能起的作用很小。而基因因素对孩子未来收入的影响比养育方法的影响要高出2.5倍。</li>
<li>选择住在哪里——这一个决定的影响力占到了家长对孩子所有的影响力中的25%。之所以有影响，也不是因为周围的朋友和同学，而是周围的叔叔阿姨。叔叔阿姨会成为它的榜样。优秀成年人，是年轻人的榜样。这个成年人不是父母。因为年轻人对父母有天生的逆反心理。</li>
</ul>


<h2>名校，对学生的能力，到底有没有一个“附加值”的作用呢？没有。</h2>

<p>什么牌子、什么名师、什么校友会，这些名校的光环加持，至少对个人收入来说，没有可观测的效应。牛人到哪里都是牛人。名校并没有“培养”牛人，名校只不过“选择”了牛人。</p>

<h2>成为球迷，一定是更快乐的事吗？不一定。</h2>

<p>成为球迷，会使你的总体快乐更多吗？得不偿失。即使你是一个强队的球迷，也是如此，因为你对结果的预期会调高，这样，赢球带来的快乐会变小，但是一旦失败，会带来更大的痛苦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[樊登读书摘要(2021-2023)]]></title>
    <link href="http://hongchaozhang.github.io/blog/2024/03/20/fandeng-dushu/"/>
    <updated>2024-03-20T00:21:24+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2024/03/20/fandeng-dushu</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>图书阅读</h2>

<ul>
<li>阅读：浪漫之魂，卢梭

<ul>
<li>作者从满激情，用“心”写的一本书，读来酣畅淋漓。</li>
</ul>
</li>
<li>阅读：0802微积分的力量

<ul>
<li>科普著作</li>
</ul>
</li>
<li>阅读：火种，寻找中国复兴之路</li>
<li>阅读：0227 杜甫传</li>
<li>阅读：1015大国大城，城市发展变大的必然性</li>
<li>阅读：0924 升维：不确定时代的决策博弈</li>
<li>阅读：0910 家庭的觉醒</li>
<li>阅读：生命密码，你的第一本基因科普书</li>
<li>阅读：0702八堂自然课</li>
<li>阅读：中国儒学三千年</li>
<li>阅读：社会性动物</li>
<li>阅读：观念的跃升

<ul>
<li>文明发展脉络，概论性质，主要是哲学</li>
</ul>
</li>
<li>阅读：作文六要20220219</li>
</ul>


<h2>摘要</h2>

<ul>
<li>毒，让人疼的毒不会致命，让人致命的毒一般会让人没有感觉，或者麻痹。让你疼的毒，一般是用来驱散你的，没有必要毒死你。真正想毒死你的毒，是不会让你有感觉的，这样才能更好地达到毒死你的目的。</li>
<li>为什么自己的口水从嘴里咽下去不恶心，积累在杯子里面再喝，就会恶心？</li>
<li>外在的坚持：来自家长和老师的压力；内在的坚持：来自内心的喜爱。</li>
<li>基因改造不应该有伦理问题，因为大自然在造更多物种，人类也已经造了很多物种，各种杂交筛选。</li>
<li>焦虑是恐惧，发怒也是恐惧。每次焦虑和发怒，都要想一想：我到底在害怕什么？不能将内心的恐惧投射到身边的人身上。</li>
<li>孩子需要的：被看见，价值感。</li>
<li>辨别臆想和事实。</li>
<li>强迫症类型：

<ul>
<li>洁癖</li>
<li>幻想</li>
<li>信一定要读7遍</li>
</ul>
</li>
<li>鼓励孩子：

<ul>
<li>我看到你昨天做作业的样子很帅。</li>
<li>我相信，你可以做出来。</li>
</ul>
</li>
<li>学习要有知识输出，比如一个项目学习，然后演讲。</li>
<li>知识和技能都不是素质，思维方式是。</li>
<li>0305减法：做减法达到效果和做加法达到效果是两种不同的境界。</li>
<li>概念思考，让你更聪明。学会造概念，推进思考进程。</li>
<li>反时间管理，时间堆叠，同时干很多件事情，是因为有能自动运行的事情。</li>
<li>买椟还珠，买文凭还能力。</li>
</ul>


<h2>记忆</h2>

<p>海马体控制什么信息写入永久记忆区（也就是灰质区域）：生存相关的才能写入。</p>

<p>知识不用写入，因为不是生死相关。那怎样才能更好地记住知识呢？</p>

<ul>
<li>只有反复出现的知识，才会被误认为生存相关，从而被写入灰质。所以，知识的记忆需要遵循艾宾浩斯曲线，反复出现。</li>
<li>好奇心，兴趣：容易进入心流状态。</li>
<li>想象力：通过想象场景，附加个人情感，从而更利于记忆。</li>
<li>排除压力：压力让人更记不住。</li>
<li>狮子记忆法：饿的时候记忆，走动的时候记忆。办公或者学习的时候走动，是有科学依据的。</li>
<li>睡前记忆法：睡前看需要记忆的东西。睡觉的时候会整理知识，更容易记住</li>
</ul>


<h2>好好恋爱</h2>

<p>选择悖论：选项越多，越难选，选项价值会降低。</p>

<p>现在结婚推迟也是这个原因：圈子大了，选项多了。</p>

<p>最大化者：要选最好的。</p>

<p>满足者：看到可以的就选。</p>

<p>乐观生意人看哪都是机会，但是最终签合同的时候非常谨慎。但是，现在的单身者往往是不愿意参加各种活动，一旦认定了一个，不撞南墙不回头。正好和乐观生意人做法相反。</p>

<h2>我有点胆怯，但想和你好好说话</h2>

<p>生气发火，是因为感觉到场面要失控，比如辅导孩子作业，孩子习惯，眼睛近视等。</p>

<p>被拒绝，就会发飙。其实，拒绝的是事情，不是你这个人。</p>

<p>不做传话者，要把他俩都拉到一起。拉到一起之后，不要试图找责任，比如：“你们俩谁先开口骂人的？”要试图让当事人说出感受情绪，说出核心诉求。</p>

<h2>科学营销</h2>

<p>送礼物：对方想要又舍不得买的。典型案例是帮对方清空购物车。</p>

<p>发现细分市场的几个角度：地理，人的分类，收入，爱好。</p>

<p>服务市场，酒店和航空，需要客户的忠诚度，所以有金卡和银卡。</p>

<p>定价模式：</p>

<ul>
<li>先高价定品牌形象，再出廉价版本，特斯拉。</li>
<li>先低价格占领市场，再出奢侈版本，小米，雷克萨斯。</li>
</ul>


<h2>癌症密码</h2>

<p>癌细胞本质是返祖现象，是多细胞生物中负责某个功能的细胞拒绝参与分工协作，返回了单细胞繁殖模式。</p>

<p>致癌物：</p>

<ul>
<li>开水2A级致癌物</li>
<li>黄曲霉素1级致癌物，号称“高温都杀不死”的致癌物。常见于发霉的花生和玉米、发苦的坚果、变质的大米、劣质的芝麻酱和花生油、长时间浸泡的木耳、没洗干净的筷子和砧板中。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[近视的原理和各种预防措施]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/11/25/daguo-huyan-zhice/"/>
    <updated>2023-11-25T23:08:17+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/11/25/daguo-huyan-zhice</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近在樊登读书上听了《大国护眼之策》的作者分享，受用匪浅，特此记录下来。</p>

<p>眼科有些分支发展很成熟，比如白内障，现代手术已经可以实现痊愈，甚至“超越痊愈”，实现“返老还童”，在彻底治愈白内障的同时，治好老花眼。但是，近视，尤其是儿童近视问题，我们刚开始研究，还有很长的路要走。</p>

<p>读完这本书，我感觉，下一代就不会被近视困扰了。这一代，要做的就是防止高度近视。因为高度近视，不仅仅是戴眼镜的问题，会伴随很多眼部疾病。如果度数控制在600度以内：</p>

<ul>
<li>青光眼风险下降67%</li>
<li>白内障风险下降74%</li>
<li>视网膜脱落风险下降98%</li>
<li>近视性黄斑病变风险下降99%</li>
</ul>


<h2>什么是近视</h2>

<h3>近视的状态</h3>

<p>眼睛的“镜头组”（角膜和晶状体）无法把成像调整到视网膜上，如下图所示：</p>

<p><img src="http://hongchaozhang.github.io/images/%E8%BF%91%E8%A7%86%E7%8A%B6%E6%80%81%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="近视状态示意图" /></p>

<h3>近视三要素：</h3>

<p>从眼睛的结构可以看出，屈光度由三要素决定：角膜、晶状体和眼轴。</p>

<ul>
<li>角膜曲率

<ul>
<li>角膜曲率在3岁之后基本稳定，人群平均值43D（4300度），如果你的是46D，就相当于先天近视300度（如下图B所示）。</li>
</ul>
</li>
<li>晶状体曲率调节

<ul>
<li>晶状体变薄，成像后移。如果后移的成像依然在视网膜前面，那么这就是近视。晶状体过厚（如下图C）和角膜曲率带来的近视（如下图B），都是先天近视。</li>
</ul>
</li>
<li>眼轴长度

<ul>
<li>眼轴过长导致的近视（如下图D所示）是后天可以控制的。</li>
<li>我们说的近视度数是指眼轴大小，不是视力好坏。</li>
</ul>
</li>
</ul>


<p><img src="http://hongchaozhang.github.io/images/%E8%BF%91%E8%A7%86%E5%8E%9F%E5%9B%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="近视原因示意图" /></p>

<h3>说说远视储备</h3>

<p>远视储备300度，正常用到16岁。如果8岁开始近视，每年增加50度，16岁的时候是400度，还算正常的眼睛，医生只需要简单的方法就可以让你摘掉眼镜，没有任何问题。</p>

<p>如果每年增加100度（这是平均值），16岁就是800度，属于高度近视，各种眼部疾病风险就来了。如果想摘掉眼镜，就要冒更大的风险。</p>

<h2>为什么会近视</h2>

<p>眼睛是一个追光的器官：</p>

<ul>
<li>如果经过“镜头组”的努力，成像在视网膜后方，那么眼轴就会趋向于变长。</li>
<li>如果经过“镜头组”的努力，成像在视网膜前方，那么眼轴就会趋向于变短。</li>
</ul>


<p><img src="http://hongchaozhang.github.io/images/%E5%85%89%E7%BA%BF%E8%81%9A%E7%84%A6%E4%BD%8D%E7%BD%AE%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="光线聚焦位置示意图" /></p>

<p>自然用眼中，只有凝视远方才能产生成像超前，尤其对于轻度近视的孩子，这是对预防近视的加分选项。</p>

<p>“镜头组”调节力差的孩子，成像会在视网膜之后很远，导致眼轴增长速度加快。</p>

<h2>近视的预防</h2>

<p>预防近视要在小学阶段完成，因为：</p>

<ul>
<li>小学课业不紧张</li>
<li>小学时眼睛更“软”，效果好</li>
</ul>


<h3>近视防控的定量指标</h3>

<h4>为什么选择眼轴，不选择近视度数？</h4>

<ul>
<li>眼轴更容易测量。

<ul>
<li>不像近视度数，需要散瞳。</li>
</ul>
</li>
<li>眼轴测量的精度更高。

<ul>
<li>同一台设备，测量误差小于0.03mm，不同设备之间误差会大一些，一般也只有0.1mm。根据0.01mm对应2.5度估计，眼轴的精度可以达到2.5度，但是眼光的精度是25度，精度相差10倍。</li>
</ul>
</li>
</ul>


<p>3-6个月测一次眼轴，验证预防效果：</p>

<ul>
<li>优秀：0.01mm/月, 近视不增加，因为这是正常的眼轴增长，会被睫状体调节抵消掉。</li>
<li>合格：0.02mm/月, 25-50度/年</li>
<li>不合格：> 0.02mm/月, > 50度/年。0.04mm/月, 100度/年。</li>
</ul>


<h3>近视防控的措施</h3>

<h4>近视的根源</h4>

<ul>
<li>光营养

<ul>
<li>光照（多户外运动）</li>
<li>光谱（屏幕多蓝光，防蓝光还是有用的）</li>
</ul>
</li>
<li>用眼距离

<ul>
<li>看近处的物体。看近处的物体时，成像在视网膜后面，时间长了，眼睛老是收到这个信号，就会调整眼球适应。</li>
<li>所有的近视手段几乎都是为了调整这个成像位置。</li>
</ul>
</li>
</ul>


<h4>各种预防措施及其效果</h4>

<p>某个预防措施打分30分，意思是，如果不预防每年增加100度，采用此方法预防，每年增加70度。</p>

<p>有些措施只是降低减分项，有些却是加分项，可以逆转近视。加分项是能够使成像在视网膜前面的，利用眼球的追光效应，使眼轴减小。</p>

<table>
<thead>
<tr>
<th> 方法 </th>
<th> 效果 </th>
<th> 备注 </th>
</tr>
</thead>
<tbody>
<tr>
<td> 小户外 </td>
<td> 30 </td>
<td> 2小时/天 </td>
</tr>
<tr>
<td> 大户外 </td>
<td> 60-80 </td>
<td> 4-6小时/天 </td>
</tr>
<tr>
<td> OK镜 </td>
<td> 55 </td>
<td> 角膜塑形，周边近视离焦 </td>
</tr>
<tr>
<td> 离焦RGP，离焦软镜 </td>
<td> 45 </td>
<td>  </td>
</tr>
<tr>
<td> 离焦框架镜 </td>
<td> 30-40 </td>
<td> 视野20度之内是正常眼镜，20度之外是微型凸透镜，制造近视离焦效果 </td>
</tr>
<tr>
<td> <strong>红光治疗</strong> </td>
<td> 70-90 </td>
<td> 每天2次，每次3分钟，低水平红激光照射眼底 </td>
</tr>
<tr>
<td> 室内光改造 </td>
<td> 10 </td>
<td> 光谱、照度、色温 </td>
</tr>
<tr>
<td> <strong>远像装置1</strong> </td>
<td> >60 </td>
<td> 同轴自由曲面，远距离读写器，电子远像屏 </td>
</tr>
<tr>
<td> 远像装置2 </td>
<td> 30 </td>
<td> 离轴自由曲面，有形变，不舒服 </td>
</tr>
<tr>
<td> 高浓度阿托品 </td>
<td> 70-80 </td>
<td> 有副作用 </td>
</tr>
<tr>
<td> 低浓度阿托品 </td>
<td> 30-40 </td>
<td> 几乎无副作用 </td>
</tr>
<tr>
<td> 控制距离和用眼时间 </td>
<td> 20 </td>
<td> 一拳一尺一寸，20-20-20法则 </td>
</tr>
<tr>
<td> 调节力训练 </td>
<td> 30 </td>
<td> 凝视远方，VR设备辅助训练 </td>
</tr>
<tr>
<td> 读写镜 </td>
<td> 30 </td>
<td> 低度数凸透镜，回归镜，减负镜。看近处的时候用，帮助调节成像位置靠近视网膜，不会过分使眼轴变长 </td>
</tr>
<tr>
<td> 雾视训练 </td>
<td>  </td>
<td> 低度数凸透镜，看远方时，成像在视网膜前，呈现模糊状态。该状态比较难以坚持 </td>
</tr>
</tbody>
</table>


<p>从效果上讲，只有周边离焦的离焦镜，不如全部离焦的雾视镜，但是，周边离焦几乎无感，易于坚持。</p>

<p>由于红光治疗和远像装置的出现，阿托品已经逐渐退出了第一阵营。</p>

<p>远像装置：</p>

<ul>
<li>同轴自由曲面

<ul>
<li>远距离读写器：根本上解决近距离用眼需求和近视发展之间的矛盾，并且易于坚持。

<ul>
<li>结构简单，可以用于写作业和阅读纸质书。</li>
</ul>
</li>
<li>电子远像屏

<ul>
<li>完美衔接电子产品，实现电子屏幕自由。通过摄像头，也可以实现纸质书的阅读和写作业。真正实现了一边用眼，一边提升视力的目标。</li>
</ul>
</li>
</ul>
</li>
<li><p>离轴自由曲面</p>

<h4>4L疗法总结</h4>

<p>在远视储备还剩75度的时候就可以开始使用4L疗法
4L疗法，近视不增加
OK镜，每年50度
4L疗法：</p></li>
<li><p>Laser：红激光照射眼底</p></li>
<li>Lead：成像超前。配离焦镜（OK镜就是离焦镜的一种）</li>
<li>Light：强度和光谱，户外运动，全光谱灯</li>
<li>Long：拉远距离。

<ul>
<li>手机pad都投屏到电视上面去看</li>
<li>一尺一寸一拳</li>
<li>20-20-20法则：20分钟休息20秒看20尺之外的物体</li>
<li>带肘托的坐姿矫正器</li>
<li>远像光屏：一种桌面屏幕，看着就像看很远的东西，有点像VR眼镜</li>
</ul>
</li>
</ul>


<p>干眼症：睑板腺</p>

<ul>
<li>原因：化妆，隐形眼镜，长时间盯着屏幕不眨眼</li>
<li>方法：热敷</li>
</ul>


<p>白内障：晶状体蛋白质变性
做手术即可。美国平均手术时间10-15分钟，本书作者：100秒。</p>

<p>青光眼：眼压过高</p>

<ul>
<li>原因：受情绪影响</li>
</ul>


<p>激光手术治疗近视</p>

<ul>
<li>激光手术非常安全，而且相比多年前，现在不同的近视度数用不同的疗法，安全性更高。

<h2>《尤玉霞儿童眼健康》</h2>

<h3>阿托品滴眼液</h3></li>
<li>1%浓度的阿托品用来慢速散瞳。</li>
<li>0.01%浓度的阿托品用来延缓近视发展。日本、香港、台湾、新加坡有卖。大陆需要自行用人工泪液稀释，注意无菌环境。</li>
<li>更新：2024年3月11日，国家药监局发布公告，沈阳兴齐眼药硫酸阿托品滴眼液，已于3月5日获批成为目前首个拿到“国药准字”批号的硫酸阿托品滴眼液。</li>
</ul>


<h3>积极佩戴眼镜</h3>

<p>关于眼镜的几种误解：</p>

<ol>
<li>无神，变形：这都是因为周围的人已经习惯了眼镜后面的眼睛，突然摘下来，需要适应。</li>
<li>越戴越近视：戴眼镜，眼睛不用调节，视力会变好。</li>
<li>不戴视力更好：这是因为大脑处理模糊图像的能力提升。</li>
</ol>


<h3>激光手术</h3>

<p>激光手术是安全的，唯一问题就是干眼，可以用人工泪液解决。</p>

<h2>其它</h2>

<ul>
<li>维护眼睛需要18年，近视只需要3个月</li>
</ul>


<p>最后附上图书纲要：</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%A4%A7%E5%9B%BD%E6%8A%A4%E7%9C%BC%E4%B9%8B%E7%AD%96%E7%BA%B2%E8%A6%81.png" alt="大国护眼之策纲要" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课2023（2）]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/10/23/jingying-rike-2023-2/"/>
    <updated>2023-10-23T17:39:43+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/10/23/jingying-rike-2023-2</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>怎样做成大事</h2>

<h3>模块化</h3>

<ul>
<li>模块化是解决大问题的基本思想。能将大事情切割成很多互不影响的小事情的能力，就是领导大项目的能力。
工匠精神和冒险精神</li>
<li>工匠精神

<ul>
<li>悉尼大剧院的设计是个失败，花费是预算的14倍，设计师也被拉黑</li>
</ul>
</li>
<li>冒险精神

<ul>
<li>你不能预测未来的困难，也不能预测未来的创造力

<h3>敢为天下先</h3></li>
</ul>
</li>
<li>不要做第一个做这件事的人。最理想的策略是等前浪死在沙滩上之后，你从他们的经验教训中学习。不敢为天下先才对。</li>
</ul>


<p>做项目和做运营</p>

<p>项目每个都不一样</p>

<p>运营就是按部就班的来就行，之前肯定有项目打底。</p>

<h2>低上限项目和高上限项目</h2>

<ul>
<li>低上限项目，再怎么努力差别也不大，做及格就可以。长寿</li>
<li>高上限项目，努力越大，汇报越大，要精益求精。文学，艺术，体育</li>
</ul>


<h2>为什么大项目总是延期？</h2>

<p>大项目90%都会延期超预算：
* 匆忙commit，下手谬误
* 过度乐观</p>

<p>比如悉尼大剧院，就是失败的设计：花费是预算的14倍，设计师也被拉黑，终生再没有作品。</p>

<p><strong>虽然你不能预测未来的困难，但是，也不能预测未来的创造力。</strong>延期项目中往往会收获一些其他东西。</p>

<ul>
<li>底层需要乐观，决策层需要谨慎。</li>
<li>沉默成本不适用政府主导的大项目，一旦启动，必须成功。</li>
</ul>


<h2>99定价法的心理基础：左位数字偏误</h2>

<ul>
<li>心里价位是17元，应该定价16.99或者17.99</li>
<li>流畅数</li>
</ul>


<h2>活在当下，享受当下</h2>

<ul>
<li>活在当下：事前不担心，事后恢复快。

<ul>
<li>被针扎的试验：提前告诉你，10秒钟之后扎你一下，你会有什么反应？你会很紧张，但是如果你不知道什么时候扎你，你就不会有这种紧张。</li>
</ul>
</li>
<li>享受当下，不提前焦虑未来，更不要后悔过去。</li>
</ul>


<h2>阅读：意识红色胶囊</h2>

<p>一切感知都是幻觉，是预测，修正，预测，修正的过程。</p>

<p>意识讨论的意义：</p>

<ul>
<li>中国本土的正统学说，也就是儒学，到东汉年间就已经陷入了全面内卷，没有什么大学问可做了，大家都在搞细枝末节和预言、算命什么的。后来魏晋嬉皮士发明了玄学，印度又传来佛教，中国人才有了新鲜的思想资源。</li>
<li>我们回头看，玄学和佛教的世界观对不对已经不重要了，重要的是它们提供了逻辑思辨的思维方式，把人的思路打开了，激发了想象力，跳出了内卷。</li>
<li>我想现在关于意识的讨论也是如此，不一定对，但是它也是一个思想资源。</li>
</ul>


<p>物理学的三大基石——广义相对论、量子力学和统计力学——之所以是这样的，是因为我们的意识要求是这样的。</p>

<p>物理定律之所以是现在这个样子，是自然世界的计算不可约性和人类的计算受限性相互作用的结果。</p>

<ul>
<li>热力学第二定律（熵增定理）可以用计算受限性解释。</li>
<li>我们口中的“随机”也可以这么解释。</li>
<li>朱元璋抱怨中国越来越乱，只不过是因为他理解不了更复杂的社会形态。</li>
</ul>


<p>如果连物理定律都是幻象，那我们大概只能承认《金刚经》说的是对的：「凡所有相，皆是虚妄。」正如康德说人无法真正认识「物自体」。而我们现在知道，之所以如此，是因为我们是计算受限的。面对这个计算不可约的世界，任何智能 —— 包括AI和佛陀 —— 都必然是计算受限的。</p>

<ul>
<li>计算受限的原因是光速。是哪个什么的力量给我们加了一个这样的约束？</li>
</ul>


<h2>和见</h2>

<ul>
<li>0630</li>
<li>日本：和见，不同的东西在一起和谐共处。</li>
<li>中国：中庸。</li>
<li>日本谦和的态度是高人口密度下的生存之道。</li>
<li>各种“道”的存在的意义(茶道，花道)：是精神追求，因为只追求实用主义也挺无聊的。</li>
</ul>


<h2>怎么增加信任度</h2>

<ul>
<li>发信号：浪费，贵，没用</li>
<li>增加透明度：比如证明果汁是鲜榨的，标明时间，发现树枝</li>
</ul>


<h2>规模思维，复利</h2>

<p>打临时工（比如家教）没有复利，科研有复利</p>

<h2>如何使用gpt</h2>

<ul>
<li>有没有一个理论讲过…</li>
<li>有没有一句谚语讲过…</li>
<li>模糊搜索，内容搜索，比如模糊记得的一点电影情节</li>
<li>总结一段话或者一段文字，比如提取一段评论的优缺点</li>
<li>心理学理论，描述一个现象</li>
</ul>


<h2>信息稀释效应</h2>

<p>当你试图说服一个人的时候，如果有十个正面观点，一定只选1到2个，砍掉其它的观点。因为其他观点会使你的观点的总体印章更差。受众不是对你的观点求和，而是求平均值。</p>

<p>当你有缺点的时候，也在说比较大的缺点之后，多说一些小缺点，以稀释受众的印象。</p>

<h2>阅读：别相信直觉</h2>

<h3>如果你想要一个幸福的婚姻，你应该怎样寻找自己的另一半？</h3>

<p>人们在婚恋市场上<em>实际</em>追求的东西，和<em>应该</em>追求的东西，正好完全是两回事。</p>

<p>寻常的吸引点——长相、身高、职业、个性像不像你什么的都根本不重要。如果要强行挑选，那就找
那些拥有好品质的人，包括生活满意度、安全依恋风格、尽责性和成长心态。</p>

<h3>夫妻俩共同的朋友越多，关系越持久吗？不是。</h3>

<p>朋友圈重合度越高的夫妻或者男女朋友，越有可能在一定时间之后宣布再次单身。也就是说，最持久
的关系，往往是双方各自有不同的朋友圈。</p>

<h3>确定恋爱关系之前的微妙状态中，怎么增加自己在对方眼中的吸引力？</h3>

<ul>
<li>对男性来说，最好的办法就是接受女性的领导 — 女性讲了笑话，你就笑；如果她谈论某个话题，你就顺着这个话题往下说；如果她说要干什么事情，你要表示支持。这样就能大大增加她对你的好感。</li>
<li>对于女性来说，有什么特别的对话技巧呢？对不起，数据显示女性用不着对话技巧 — 男性最后选择的总是外表好看的。</li>
</ul>


<h3>养育方法不重要，榜样最重要</h3>

<ul>
<li>养育方法对孩子的影响很重要吗？没有。孩子的命运是他自己的，家长能起的作用很小。而基因因素对孩子未来收入的影响比养育方法的影响要高出2.5倍。</li>
<li>选择住在哪里——这一个决定的影响力占到了家长对孩子所有的影响力中的25%。之所以有影响，也不是因为周围的朋友和同学，而是周围的叔叔阿姨。叔叔阿姨会成为它的榜样。优秀成年人，是年轻人的榜样。这个成年人不是父母。因为年轻人对父母有天生的逆反心理。</li>
</ul>


<h3>名校，对学生的能力，到底有没有一个“附加值”的作用呢？没有。</h3>

<p>什么牌子、什么名师、什么校友会，这些名校的光环加持，至少对个人收入来说，没有可观测的效应。牛人到哪里都是牛人。名校并没有“培养”牛人，名校只不过“选择”了牛人。</p>

<h3>成为球迷，一定是更快乐的事吗？不一定。</h3>

<p>成为球迷，会使你的总体快乐更多吗？得不偿失。即使你是一个强队的球迷，也是如此，因为你对结果的预期会调高，这样，赢球带来的快乐会变小，但是一旦失败，会带来更大的痛苦。</p>

<h2>其它</h2>

<ul>
<li>0609，宽松则争奇斗艳，严苛则平庸

<ul>
<li>环境看惹人优点还是缺点</li>
</ul>
</li>
<li>0610自由和责任，自由的管理，需要底层有责任感</li>
<li>看原稿：万维钢20230504

<ul>
<li>计算不可约性</li>
<li>太阳每天从东方升起</li>
<li>混沌现象导致运动不可以预测，天气不可以预测</li>
<li>复杂的gpt永远存在漏洞，补也补不全</li>
<li>同样的道理，gpt也不能完全控制人类，因为人类是一个更复杂的系统</li>
</ul>
</li>
<li>ai和人的根本区别是什么？是历史。人类有历史。</li>
<li>不循规蹈矩，不齐声朗读课文，因为这样会扼杀创造力。现在学校所做的一切都是为了管理上的方便。</li>
<li>两种计算方式：

<ul>
<li>形式逻辑</li>
<li>神经网络</li>
</ul>
</li>
<li>银牌获得者寿命比金牌短4年，比铜牌也短</li>
<li>财富、信息和金钱

<ul>
<li>财富就是知识</li>
<li>信息就是意外</li>
<li>金钱就是时间</li>
</ul>
</li>
<li>提供认知抓手，多个屏幕比一个屏幕效率高，运动中接受的信息，站起来逛逛走走，或者站立办公。</li>
<li>阅读：蓝图</li>
<li>马斯克：悲观者正确，乐观者成功。</li>
<li>年轻人对于老人的忠告：您的忠告一定正确，若不是我们流着年轻的血，一定接受。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课2022-2023]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/09/15/jingying-rike-2022-2023/"/>
    <updated>2023-09-15T18:07:58+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/09/15/jingying-rike-2022-2023</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>系统腐败的动力学</h2>

<ul>
<li>灌溉导致土地盐碱化。因为灌溉水源中的盐分都会留在地里面，越积越多。</li>
<li>朝代更替，是因为政府越来越大，一直到不可控制。</li>
<li>公司过大，老员工势力和做事方式是公司改革的阻力。</li>
</ul>


<h2>风险到底要不要预防？</h2>

<ul>
<li>当“风险损失×发生概率＞预防成本”的时候，就应该预防。</li>
</ul>


<h2>蒙特卡洛方法</h2>

<p>简单说，就是多次重复试验。通过随机噪声，统计一些信息。可能可以降低计算量，并且可以估计一些没有解析解的问题。</p>

<h2>概率很重要</h2>

<ul>
<li>由于馄饨效应，长期天气预报不可能，只能有概率。</li>
<li>ai负责预测概率，人负责拍板。</li>
</ul>


<h2>阅读：费佛的《权利七规则》</h2>

<ul>
<li>追求权力</li>
<li>表达愤怒</li>
<li>不要道歉</li>
<li>刷存在感，在事情发生的时候，大肆宣传，抓住小事情，搞大。不能不说，也不能老说过去的事情。怎么从心里认同这种做法呢？你可以把他认为这是在为属下或者同组的人争取权益。</li>
<li>社交关系，多和自己社交边缘的人打交道。从心里认同社交。方法：1）找人介绍，2）找共同点，比如老乡，大学同学等。</li>
<li>位置比能力重要，上海市委书记与黑龙江省委书记的区别。</li>
</ul>


<h2>决策过程中的三种人</h2>

<ul>
<li>巨婴：只要自己需要的东西。</li>
<li>政客：通过礼仪交换，达到自己的目的。</li>
<li>战略家：从全局出发，寻求最优策略。</li>
</ul>


<h2>说服力</h2>

<ul>
<li>说服理论和说谎。</li>
<li>不能撒谎，但是可以使用说服理论。比如，

<ul>
<li>设计调查问卷的问题，选择调查问卷的对象。</li>
<li>只说优点不说缺点。</li>
</ul>
</li>
<li>当大家都用说服理论的时候，你不得不用。因为别人认为你会使用说服理论，就算你说的是事实，别人也会打个折扣再接受。</li>
<li>囚徒困境，纳什均衡。</li>
</ul>


<h2>阅读：霍夫曼《隐藏的博弈》</h2>

<ul>
<li>传统习惯，初级奖励，刺激奖励</li>
<li>模仿变成信念，信念变成文化。</li>
<li>日常事务的终极解释</li>
<li>什么是奢侈品？小众贵而且没用，才能炫耀。

<ul>
<li>当糖刚出现的时候，只有少数人能吃得起，好的东西必须是甜的。</li>
<li>卡路里，现在卡路里易得，健身才值得炫耀。</li>
</ul>
</li>
<li>肤色，以前崇尚白，白说明我不是体力工作者。现在崇尚黑，黑说明我在办公室工作之余还有资本去海边玩。</li>
<li>复杂的手续和仪式，是入场券，是证明自己是圈内人的资本。</li>
</ul>


<h2>心理学与哲学</h2>

<ul>
<li>心理学是科学，应该描述是什么，不应该讨论应该怎么样。</li>
<li>但是哲学可以讨论应该怎么样。</li>
<li>阿德勒的观点是哲学，不是心理学。</li>
<li>弗洛伊德的观点基本被心理学抛弃。</li>
</ul>


<h2>个人魅力</h2>

<ul>
<li>萨达姆侯赛因感化看守自己的12个士兵。</li>
<li>明朝皇帝被蒙古俘虏之后，感化周围的人，被送回了北京。</li>
</ul>


<h2>考古和古董的区别</h2>

<ul>
<li>考古注重从中发现当时人的生活方式和文化。遗址中吃剩的残羹剩饭有考古价值，但是不是古董，没有收藏价值。</li>
<li>古董注重审美和收藏价值。</li>
</ul>


<h2>事实判断，价值判断</h2>

<ul>
<li>事实多是客观的，有标准，但是价值多是主观的，没有标准。</li>
</ul>


<h2>光伏产业液晶产业和芯片产业的区别</h2>

<p>中国大陆通过砸钱实现超越，但是芯片却没有。为什么美国可以限制中国芯片，却限制不了光伏和液晶产业？还是不屑于限制？知乎文章可以看看。</p>

<h2>什么叫浪费时间</h2>

<ul>
<li>重要题目认真选，不重要题目随便选。</li>
<li>对结果没影响的事情随便做。</li>
<li>几十块钱的东西精挑细选，各种比较，各种优惠券，那就是浪费时间。如果你乐于此道，那就不是浪费时间。“喜欢浪费的时间，就不叫浪费时间”。</li>
<li>抓大放小，不花很多时间琢磨小事情。</li>
<li>要做到这一点，就要扩大视野，扩大见识。</li>
</ul>


<h2>濒死体验和离体体验</h2>

<ul>
<li>可能的解释是脑补，所有“看到”的东西，都是自己脑补出来的。</li>
<li>用生成式系统来类比，濒死体验是在没有输入的情况下的生成式系统，而正常体验是有输入的生成式系统。</li>
</ul>


<h2>视角带来不同的思考，</h2>

<ul>
<li>在太空看地球，不能看到细节，只能区分国家，当你看到朝鲜和韩国在晚上灯光的差距的时候，你思考的只能是国家经济和国家政治的问题。</li>
<li>在月球看地球，看不到国与国的分界，只能看到整个地球，你就不会再想到冷战，而是地球的生存和演化问题。</li>
</ul>


<h2>破除分别观</h2>

<p>很多事物没有本质区别，比如
- 人和动物
- 肉食和素食</p>

<h2>汉隆剃刀</h2>

<p>&ldquo;汉隆剃刀"：能用愚蠢来解释的不要归因于恶意。</p>

<p>&ldquo;汉隆剃刀"的应用可以帮助减少对他人的负面解释和过度怀疑。它提醒我们，人们有时会犯错误，表现出不理智的行为，而不一定是有意的恶意。因此，在与他人互动或解释他人行为时，保持谦虚和理解，考虑到"汉隆剃刀"的原则可以有助于改善人际关系和减少冲突。</p>

<h2>中庸</h2>

<ul>
<li>自律带来自由，你有乱弹琴的自由，但是你没有上台表演的自由。</li>
<li>三思而后行。</li>
<li>不要一根筋走到底。</li>
<li>内心能容纳相反的观点。</li>
</ul>


<h2>其它</h2>

<ul>
<li>每个人都怀念自己年轻时候的时代，因为那个时候自己的身体和心理都是最好的。</li>
<li>改变睡梦中人的软感觉，不能植入硬知识。</li>
<li>不可知论，赫胥黎</li>
<li>区分道德中，哪些是权力哪些是义务。</li>
<li>跳槽是年轻人的特权。学一个势能高的专业，然后跳来跳去，选一个适合自己的工作。比如应用数学，应用物理？</li>
<li>年轻的时候感受到的爱越多，自己对人就越信任，对爱人信任。</li>
<li>能量型英雄与能耐型英雄。在待人接物中，把任何人都看成能量型英雄，尊重对方的荣誉。</li>
<li>啥时候吹牛啥时候不吹牛？熟人社会不能吹牛，陌生人社会可以吹牛。大家都默认你会吹牛，即使你说的是事实，别人也会打个折扣再接受。</li>
<li>上层社会人捧人（圈子），中层社会人比人，下层社会人踩人。</li>
<li>身体的出厂设置是为狩猎采集准备的，所以，多向狩猎采集式的生活靠拢是健康生活方式的原则。</li>
<li>原始世界信念决定三观。</li>
<li>读书

<ul>
<li>《首要怀疑》</li>
<li>《翦商》</li>
<li>《星空信使》</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[卓克聊科技2022]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/09/15/zhuoke-keji-2022/"/>
    <updated>2023-09-15T18:07:03+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/09/15/zhuoke-keji-2022</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>像丧尸一般的朊蛋白（疯牛病）</h2>

<p>疯牛病的病原体是朊蛋白，也叫朊病毒。</p>

<p>这种病毒导致的疾病，叫朊病毒朊病毒病（Prion Disease），是一种致命性神经退行性疾病，致死率高达100.0%。</p>

<p>朊病毒是一种蛋白质病毒，说是病毒，其实它并不符合病毒的定义，甚至并不是严格意义上的生命。因为它并不包含DNA或者RNA等遗传物质，也不能复制自己。朊病毒只是一种特殊的变异的蛋白质，只是折叠方式与其他蛋白质不同，其它方面和正常的蛋白质没有多大区别。</p>

<p>同时，常规药物对朊病毒也无效，即使有能杀灭朊病毒的药物，也同时会杀灭人体正常蛋白质。</p>

<p>朊病毒的感染机制和病毒全然不同，它并不是通过DNA或者RNA信息复制，这种蛋白质病毒其实是没有遗传物质的，而是通过同化宿主的蛋白质进行传播。</p>

<p>听起来就像丧尸。</p>

<h2>关于眼睛的一些知识</h2>

<h3>激光手术</h3>

<p>高度近视是导致失明的重要原因。激光手术通过改变角膜达到纠正视力的功能，并没有改变眼轴长度，和高度近视一样，失明的风险依然很高。但是也不会像有些人说的视网膜脱落什么的，只要不参加一些对眼睛有冲击的运动，就没有任何问题，比如跳水。</p>

<h3>预防近视的方法</h3>

<ol>
<li>户外运动预防近视
户外运动不在于运动，而在于阳光。即使在树荫处，也比室内光照强很多。室内光照度不够，最强也只有室外的十分之一，而且光谱不全</li>
<li>闭眼
眼保健操不在于做操，在于闭眼。</li>
<li>现代医学预防青少年近视

<ol>
<li>OK镜

<ol>
<li>适用于8岁以上，600度以下。</li>
<li>需要戴到18岁，直到眼球固定。</li>
<li>一幅眼镜8000-15000元，保护好的话可以用1-2年。</li>
</ol>
</li>
<li>阿托品

<ol>
<li>4到16岁期间使用。</li>
</ol>
</li>
</ol>
</li>
</ol>


<h2>刺身</h2>

<ul>
<li>寄生虫问题，通过冷冻冻死寄生虫。</li>
<li>咸水鱼刺身：在运输的过程中需要冷冻，顺便就杀死了寄生虫。</li>
<li>淡水鱼刺身：没有冷冻运输的需求，杀死寄生虫靠自觉，难以保证。</li>
<li>醉虾醉蟹不能吃，酒不能杀死体内寄生虫。</li>
</ul>


<h2>最好的运动方式</h2>

<ul>
<li>爬，是最好的运动方式。</li>
<li>爬，膝盖不能着地，用双手双脚着地</li>
<li>有点像平板支撑</li>
<li>锻炼核心力量和协调性</li>
</ul>


<h2>糖</h2>

<ul>
<li>除了饱和脂肪酸，游离糖更不能吃。美国政府贿赂科学家发表吃糖没问题的文章，2016年曝光。</li>
<li>每天游离糖的上限是20到30克，一瓶330的可乐已经超标了。</li>
<li>代糖：甜蜜素，糖精，阿斯巴甜</li>
</ul>


<h2>呼吸机</h2>

<ul>
<li>新冠期间，呼吸机和制氧机是智商税。</li>
<li>家用制氧机压强小，不足以将氧气打入重症患者的肺部。需要3到4个大气压的压强，家用只能提供0.2-0.6个大气压强。</li>
<li>慢阻症适合家庭制氧机。</li>
</ul>


<h2>长寿方法</h2>

<ul>
<li>换血</li>
<li>模仿原始人生活方式，吃不饱，穿不暖，体力劳动，偶尔极限体力劳动。</li>
</ul>


<h2>退烧方法</h2>

<ul>
<li>退烧贴没有作用，感觉上的凉是薄荷等模拟的，不是真的能降温。就像辣椒模拟了烫伤的感觉，实际上并没有。</li>
<li>用水擦身体好一些，但是也不推荐。虽然水蒸发带走的热量足够降低体温，但是体表温度的下降会使得体内温度调节系统将目标温度设置的更高，从而产生更多的热量。除非一直不停的擦，否则，擦半小时停半小时，没有效果。</li>
<li>冰水擦身没必要，相比使水温升高带走的热量，水蒸发带走的热量才是主要的，大约1：20。但是，冰水对身体的刺激，会使得核心目标温度设置的更高。</li>
<li>最有效的就是退烧药，当体温高于38.5，精神萎靡的时候用</li>
</ul>


<h2>保健品</h2>

<ul>
<li>对保健品不要有任何期待，如果必须有一个期待，那就是：不要有什么害处。</li>
<li>吃任何保健品，都不如每天晒晒太阳，吃个鸡蛋，好好睡觉有效。</li>
</ul>


<h2>地面下沉</h2>

<ul>
<li>与其担心海平面上升（2毫米每年），不如担心城市地面下沉（10毫米每年）。过度抽取地下水导致陆地下沉。</li>
<li>雅加达已经由于下沉已经不是印尼的首都啦。</li>
</ul>


<h2>安慰剂效应与反安慰剂效应</h2>

<ul>
<li>安慰剂效应：只要你相信，就有作用。</li>
<li>反安慰剂效应：你相信家具的某种摆放有利于睡眠，但是家里的家具又不是这样摆放的，你的睡眠就会变差。</li>
</ul>


<h2>阴谋论与拉姆斯定律</h2>

<ul>
<li>信息足够多的时候，必定会有部分信息能够关联上，即使当初没有设计它们有关系，这就为阴谋论创造了条件。</li>
<li>解决方法有两个

<ul>
<li>非常小的信息量，不足以让信息之间产生关系。</li>
<li>更多的信息量，让产生阴谋论成为可能的同时，真正有关系的信息也会产生，这种正确的关系必定在未来的发展过程中蚕食阴谋论的市场。</li>
</ul>
</li>
</ul>


<h2>如何面对复杂系统</h2>

<ul>
<li>复杂系统，没有简单的输入输出关系，并且受各种反馈影响。</li>
<li>各种对策应对政策，比如

<ul>
<li>灭眼镜蛇灭鼠的行政命令</li>
<li>经济学上的事与愿违</li>
</ul>
</li>
<li>正确的做法

<ul>
<li>只限定边界，边界内部自由发展</li>
</ul>
</li>
</ul>


<h2>睡眠</h2>

<ul>
<li>控制体温，改善睡眠。降低核心温度能提高20%的睡眠质量。

<ul>
<li>可以通过提高四肢和手脚的温度实现，也可以通过降低室温实现。</li>
</ul>
</li>
<li>长期缺觉，免疫力，杏仁核，前额叶皮质，交感神经

<ul>
<li>蓝光，褪黑激素，睡眠</li>
</ul>
</li>
</ul>


<h2>延迟满足的误解</h2>

<ul>
<li>延迟满足不是能力，不能强行训练。</li>
<li>能否延迟满足主要和两个因素有关系（可以从这两个角度着手训练。）：

<ul>
<li>信任度</li>
<li>见多识广</li>
</ul>
</li>
</ul>


<h2>秩序的形成</h2>

<ul>
<li>自下向上自发形成的秩序是稳定的。</li>
<li>自上而下的顶层设计出来的秩序是不稳定的，需要很大的能量维护。</li>
</ul>


<h2>计算机结构</h2>

<ul>
<li>冯诺依曼结构</li>
<li>存算一体结构</li>
<li>量子计算机</li>
</ul>


<h2>进化论</h2>

<p>最小自由能原理：对外界刺激的预期，外界实际的刺激，两者不一致的时候，要么改变外界，要么改变期望。是不是很像成功学鸡汤？不</p>

<h2>其它</h2>

<ul>
<li>蟹棒没有蟹肉，淀粉和鱼肉</li>
<li>番茄酱有番茄</li>
<li>肯德基的番茄酱的配料表，第一个就是番茄酱。是不是很奇怪。其实是翻译的问题，我们说的番茄酱其实应该叫“调味包”</li>
<li>不要用酒精擦身体降温，因为皮肤会吸收酒精，尤其是孩子的皮肤。</li>
<li>拍频：风扇旋转的时候，会看到一个更慢的旋转，甚至反转</li>
<li>张益唐，黎曼猜想，零点定理，2022.11月公布的</li>
<li>张衡地动仪只有观赏价值，没有实用价值。</li>
<li>AR太难啦：空间建模，空间物体不要乱动，景深层次。VR相比就好很多，不用考虑真实世界</li>
<li>魂类游戏，难度</li>
<li>mcu芯片</li>
<li>奥卡姆剃刀：如非必须勿增实体</li>
<li>欧洲隐私，欧洲刑警组织败诉给数据隐私组织，被迫删除4PB的个人数据。</li>
<li>爱因斯坦：毅力做事情不如爱好做事情，爱好做事情不如追求美做事情。</li>
<li>苹果无损音乐核心竞争力是2002年开始音乐公司上传的母带。其它音乐平台都是假无损，插值得到的。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Learning Note 2023]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/09/15/react-learning-note-2023/"/>
    <updated>2023-09-15T17:33:08+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/09/15/react-learning-note-2023</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#react-state-is-updated-in-a-batch">React state is updated in a “batch”</a></li>
<li><a href="#update-react-state-with-a-new-object-do-not-mute-existing-one">Update react state with a new object, do not mute existing one</a></li>
<li><a href="#declarative-ui">Declarative UI</a></li>
<li><a href="#react-redux">React-redux</a></li>
<li><a href="#hooks">Hooks</a></li>
<li><a href="#react%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F">React中的变量</a></li>
<li><a href="#useeffect">useEffect</a>

<ul>
<li><a href="#clean-up-function">clean up function</a></li>
</ul>
</li>
<li><a href="#usememo">useMemo</a></li>
<li><a href="#two-ways-to-store-previous-props">two ways to store previous props</a>

<ul>
<li><a href="#useref">useRef</a></li>
<li><a href="#usestate">useState</a></li>
</ul>
</li>
<li><a href="#fetch-data%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98">fetch data的两个问题</a>

<ul>
<li><a href="#race-condition">race condition</a></li>
<li><a href="#undo">undo</a></li>
</ul>
</li>
<li><a href="#effect-event">Effect Event</a>

<ul>
<li><a href="#what-is-reactive">what is reactive</a></li>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution:</a></li>
<li><a href="#supress-react-lint-error">Supress react lint error</a></li>
</ul>
</li>
<li><a href="#how-to-review-effect-dependencies">How to review effect dependencies</a>

<ul>
<li><a href="#ways-to-review-and-fix-this">ways to review and fix this</a></li>
</ul>
</li>
<li><a href="#object-and-function-compare">Object and function compare</a></li>
<li><a href="#usememo-and-usecallback">useMemo and useCallback</a></li>
<li><a href="#forwardref">forwardRef</a>

<ul>
<li><a href="#useref-1">useRef</a></li>
<li><a href="#basic-concepts">basic concepts</a></li>
<li><a href="#expose-dom-node">expose dom node</a></li>
<li><a href="#expose-an-object">expose an object</a></li>
</ul>
</li>
<li><a href="#custom-hook">Custom Hook</a></li>
<li><a href="#strict-mode">strict mode</a></li>
<li><a href="#other-rules">Other Rules</a>

<ul>
<li><a href="#data-from-parent-to-child">data from parent to child</a></li>
<li><a href="#usesyncexternalstore">useSyncExternalStore</a></li>
<li><a href="#useeffect-dependencies">useEffect dependencies</a></li>
</ul>
</li>
</ul>


<h2>React state is updated in a “batch”</h2>

<p>This means that you can not get the state immediately after you change it.</p>

<p>number will be 1 after one click:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export default function Counter() {
</span><span class='line'>  const [number, setNumber] = useState(0);
</span><span class='line'>  return (
</span><span class='line'>    &lt;&gt;
</span><span class='line'>      &lt;h1&gt;{number}&lt;/h1&gt;
</span><span class='line'>      &lt;button onClick={() =&gt; {
</span><span class='line'>        setNumber(number + 1);
</span><span class='line'>        setNumber(number + 1);
</span><span class='line'>        setNumber(number + 1);
</span><span class='line'>      }}&gt;+3&lt;/button&gt;
</span><span class='line'>    &lt;/&gt;
</span><span class='line'>  )
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>To make the number to be 3, pass a update function to the setNumber function. An update function will be queued and executed later.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export default function Counter() {
</span><span class='line'>  const [number, setNumber] = useState(0);
</span><span class='line'>  return (
</span><span class='line'>    &lt;&gt;
</span><span class='line'>      &lt;h1&gt;{number}&lt;/h1&gt;
</span><span class='line'>      &lt;button onClick={() =&gt; {
</span><span class='line'>        setNumber(n =&gt; n + 1);
</span><span class='line'>        setNumber(n =&gt; n + 1);
</span><span class='line'>        setNumber(n =&gt; n + 1);
</span><span class='line'>      }}&gt;+3&lt;/button&gt;
</span><span class='line'>    &lt;/&gt;
</span><span class='line'>  )
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>Update react state with a new object, do not mute existing one</h2>

<p>Use <code>…</code> , the object spread operator:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setPerson({
</span><span class='line'>  ...person, // Copy the old fields
</span><span class='line'>  firstName: e.target.value // But override this one
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>Note that spread syntax is shallow: it only copies one level deep. To update nested object:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setPerson({
</span><span class='line'>  ...person, // Copy other fields
</span><span class='line'>  artwork: { // but replace the artwork
</span><span class='line'>    ...person.artwork, // with the same one
</span><span class='line'>    city: 'New Delhi' // but in New Delhi!
</span><span class='line'>  }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>For updating array object:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setArtists([
</span><span class='line'>  { id: nextId++, name: name },
</span><span class='line'>  ...artists // Put old items at the end
</span><span class='line'>]);</span></code></pre></td></tr></table></div></figure>


<p><code>Immer</code> is a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>updatePerson(draft =&gt; {
</span><span class='line'>  draft.artwork.city = 'Lagos';
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>Using <code>Immer</code> for array:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>updateMyTodos(draft =&gt; {
</span><span class='line'>  const artwork = draft.find(a =&gt; a.id === artworkId);
</span><span class='line'>  artwork.seen = nextSeen;
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h2>Declarative UI</h2>

<ul>
<li>Declarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).</li>
<li>When developing a component, Think in declarative UI way:

<ol>
<li>Identify all its visual states.</li>
<li>Determine the human and computer triggers for state changes.</li>
<li>Model the state with useState.</li>
<li>Remove non-essential state to avoid bugs and paradoxes.</li>
<li>Connect the event handlers to set state.</li>
</ol>
</li>
</ul>


<h2>React-redux</h2>

<ul>
<li>useReducer+useContext?</li>
<li>Provider</li>
<li>Context</li>
</ul>


<h2>Hooks</h2>

<ul>
<li>useContext: 跨层传输props，不用一层一层传下去</li>
<li>useEffect: Use them to synchronize your component with a system outside of React.</li>
</ul>


<h2>React中的变量</h2>

<ul>
<li>Props：immutable, 触发rerender，不记忆(retained by component)</li>
<li>State：immutable, 触发rerender，记忆(retained by React)</li>
<li>useRef：mutable, 不触发rerender，记忆(retained by React)</li>
</ul>


<h2>useEffect</h2>

<p>Effects let you specify side effects that are caused by rendering itself, rather than by a particular event.</p>

<p>Effects run at the end of a <em>commit</em> after the screen updates. That is, useEffect “delays” a piece of code from running until that render is reflected on the screen.</p>

<h3>clean up function</h3>

<p>You can use a clean up function to clean up the effect. For example, if you subscribe to an external data source, you can unsubscribe it in the clean up function.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>useEffect(() =&gt; {
</span><span class='line'>  const connection = createConnection();
</span><span class='line'>  connection.connect();
</span><span class='line'>  return () =&gt; {
</span><span class='line'>    connection.disconnect();
</span><span class='line'>  };
</span><span class='line'>}, []);
</span><span class='line'>
</span><span class='line'>useEffect(() =&gt; {
</span><span class='line'>  function handleScroll(e) {
</span><span class='line'>    console.log(window.scrollX, window.scrollY);
</span><span class='line'>  }
</span><span class='line'>  window.addEventListener('scroll', handleScroll);
</span><span class='line'>  return () =&gt; window.removeEventListener('scroll', handleScroll);
</span><span class='line'>}, []);</span></code></pre></td></tr></table></div></figure>


<p><strong>React will call your cleanup function each time before the next Effect runs again, and one final time when the component unmounts (gets removed).</strong>
That is, the cleanup function runs not only during unmount, but before every re-render with changed dependencies.</p>

<h2>useMemo</h2>

<p>useMemo和useEffect都可以加依赖，但是useMemo在render过程起作用，而useEffect在commit之后起作用。
所以，如果是render依赖的变量值，用useMemo，不用useEffect+useState。</p>

<p>不推荐：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function TodoList({ todos, filter }) {
</span><span class='line'>  const [newTodo, setNewTodo] = useState('');
</span><span class='line'>  // 🔴 Avoid: redundant state and unnecessary Effect
</span><span class='line'>  const [visibleTodos, setVisibleTodos] = useState([]);
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    setVisibleTodos(getFilteredTodos(todos, filter));
</span><span class='line'>  }, [todos, filter]);
</span><span class='line'>  // ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>推荐：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import { useMemo, useState } from 'react';
</span><span class='line'>function TodoList({ todos, filter }) {
</span><span class='line'>  const [newTodo, setNewTodo] = useState('');
</span><span class='line'>  const visibleTodos = useMemo(() =&gt; {
</span><span class='line'>    // ✅ Does not re-run unless todos or filter change
</span><span class='line'>    return getFilteredTodos(todos, filter);
</span><span class='line'>  }, [todos, filter]);
</span><span class='line'>  // ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>two ways to store previous props</h2>

<h3>useRef</h3>

<p><code>prevProps</code> updates after render:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  const prevProps = useRef();
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    prevProps.current = props;
</span><span class='line'>  }, [props]);</span></code></pre></td></tr></table></div></figure>


<h3>useState</h3>

<p><code>prevItems</code> is ready when render:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  const [prevItems, setPrevItems] = useState(items);
</span><span class='line'>  if (items !== prevItems) {
</span><span class='line'>    setPrevItems(items);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h2>fetch data的两个问题</h2>

<h3>race condition</h3>

<p>输入特别快的时候，很多search的request连续发出，不能保证回来的顺序，会出问题。
解决方法：给useEffect提供cleanup函数解决</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function SearchResults({ query }) {
</span><span class='line'>  const [results, setResults] = useState([]);
</span><span class='line'>  const [page, setPage] = useState(1);
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    let ignore = false;
</span><span class='line'>    fetchResults(query, page).then(json =&gt; {
</span><span class='line'>      if (!ignore) {
</span><span class='line'>        setResults(json);
</span><span class='line'>      }
</span><span class='line'>    });
</span><span class='line'>    return () =&gt; {
</span><span class='line'>      ignore = true;
</span><span class='line'>    };
</span><span class='line'>  }, [query, page]);
</span><span class='line'>
</span><span class='line'>  function handleNextPageClick() {
</span><span class='line'>    setPage(page + 1);
</span><span class='line'>  }
</span><span class='line'>  // ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>undo</h3>

<p>没看懂：<a href="https://react.dev/learn/you-might-not-need-an-effect#fetching-data">https://react.dev/learn/you-might-not-need-an-effect#fetching-data</a></p>

<h2>Effect Event</h2>

<h3>what is reactive</h3>

<p>variables which can change due to a re-render
* Logic inside event handlers (or Effect Event) is not reactive.
* Logic inside Effects is reactive.</p>

<h3>Problem</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function ChatRoom({ roomId, theme }) {
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection(serverUrl, roomId);
</span><span class='line'>    connection.on('connected', () =&gt; {
</span><span class='line'>      showNotification('Connected!', theme);
</span><span class='line'>    });
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; {
</span><span class='line'>      connection.disconnect()
</span><span class='line'>    };
</span><span class='line'>  }, [roomId, theme]); // ✅ All dependencies declared
</span><span class='line'>  // ...</span></code></pre></td></tr></table></div></figure>


<p>When reconnected, a notification will be shown, and the notificaiton will consider the theme.
But when the theme changes, the notification will also be shown, which is not expected.</p>

<h3>Solution:</h3>

<p>Use Effect Event to separate this non-reactive logic from the reactive Effect around it.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function ChatRoom({ roomId, theme }) {
</span><span class='line'>  const onConnected = useEffectEvent(() =&gt; {
</span><span class='line'>    showNotification('Connected!', theme);
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection(serverUrl, roomId);
</span><span class='line'>    connection.on('connected', () =&gt; {
</span><span class='line'>      onConnected();
</span><span class='line'>    });
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, [roomId]); // ✅ All dependencies declared
</span><span class='line'>  // ...</span></code></pre></td></tr></table></div></figure>


<p>You can think of Effect Events as being very similar to event handlers. The main difference is that event handlers run in response to a user interactions, whereas Effect Events are triggered by you from Effects. Effect Events let you “break the chain” between the reactivity of Effects and code that should not be reactive.</p>

<h3>Supress react lint error</h3>

<p>React linter ask you to add all reactive variables into the Effect dependencies.
Effect Events let you fix many patterns where you might be tempted to suppress the dependency linter.</p>

<h2>How to review effect dependencies</h2>

<p>Every time you adjust the Effect’s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is “no”:</p>

<ul>
<li>You might want to re-execute different parts of your Effect under different conditions.</li>
<li>You might want to only read the latest value of some dependency instead of “reacting” to its changes.</li>
<li>A dependency may change too often unintentionally because it’s an object or a function.</li>
</ul>


<h3>ways to review and fix this</h3>

<ul>
<li>Should this code move to an event handler?</li>
<li>Is your Effect doing several unrelated things?

<ul>
<li>If different parts of your Effect should re-run for different reasons, split it into several Effects.</li>
</ul>
</li>
<li>Are you reading some state to calculate the next state?

<ul>
<li>Use update function. Use <code>setMessages([...messages, receivedMessage])</code> instead of <code>setMessages(msgs =&gt; [...msgs, receivedMessage])</code></li>
</ul>
</li>
<li>In JavaScript, objects and functions are considered different if they were created at different times.</li>
<li>Try to avoid object and function dependencies. Move them outside the component or inside the Effect.

<ul>
<li>Move static objects and functions outside your component</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function createOptions() {
</span><span class='line'>  return {
</span><span class='line'>    serverUrl: 'https://localhost:1234',
</span><span class='line'>    roomId: 'music'
</span><span class='line'>  };
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function ChatRoom() {
</span><span class='line'>  const [message, setMessage] = useState('');
</span><span class='line'>
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const options = createOptions();
</span><span class='line'>    const connection = createConnection();
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, []); // ✅ All dependencies declared
</span><span class='line'>  // ...</span></code></pre></td></tr></table></div></figure>


<pre><code>* Move dynamic objects and functions inside your Effect 
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const serverUrl = 'https://localhost:1234';
</span><span class='line'>
</span><span class='line'>function ChatRoom({ roomId }) {
</span><span class='line'>  const [message, setMessage] = useState('');
</span><span class='line'>
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const options = {
</span><span class='line'>      serverUrl: serverUrl,
</span><span class='line'>      roomId: roomId
</span><span class='line'>    };
</span><span class='line'>    const connection = createConnection(options);
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, [roomId]); // ✅ All dependencies declared
</span><span class='line'>  // ...</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Read primitive values from objects</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function ChatRoom({ options }) {
</span><span class='line'>  const [message, setMessage] = useState('');
</span><span class='line'>
</span><span class='line'>  const { roomId, serverUrl } = options;
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection({
</span><span class='line'>      roomId: roomId,
</span><span class='line'>      serverUrl: serverUrl
</span><span class='line'>    });
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, [roomId, serverUrl]); // ✅ All dependencies declared
</span><span class='line'>  // ...</span></code></pre></td></tr></table></div></figure>


<h2>Object and function compare</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import { useState, useEffect } from 'react';
</span><span class='line'>import { createConnection } from './chat.js';
</span><span class='line'>
</span><span class='line'>const serverUrl = 'https://localhost:1234';
</span><span class='line'>
</span><span class='line'>function ChatRoom({ roomId }) {
</span><span class='line'>  const [message, setMessage] = useState('');
</span><span class='line'>
</span><span class='line'>  // Temporarily disable the linter to demonstrate the problem
</span><span class='line'>  // eslint-disable-next-line react-hooks/exhaustive-deps
</span><span class='line'>  const options = {
</span><span class='line'>    serverUrl: serverUrl,
</span><span class='line'>    roomId: roomId
</span><span class='line'>  };
</span><span class='line'>
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection(options);
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, [options]);
</span><span class='line'>
</span><span class='line'>  return (
</span><span class='line'>    &lt;&gt;
</span><span class='line'>      &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;
</span><span class='line'>      &lt;input value={message} onChange={e =&gt; setMessage(e.target.value)} /&gt;
</span><span class='line'>    &lt;/&gt;
</span><span class='line'>  );
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>export default function App() {
</span><span class='line'>  const [roomId, setRoomId] = useState('general');
</span><span class='line'>  return (
</span><span class='line'>    &lt;&gt;
</span><span class='line'>      &lt;label&gt;
</span><span class='line'>        Choose the chat room:{' '}
</span><span class='line'>        &lt;select
</span><span class='line'>          value={roomId}
</span><span class='line'>          onChange={e =&gt; setRoomId(e.target.value)}
</span><span class='line'>        &gt;
</span><span class='line'>          &lt;option value="general"&gt;general&lt;/option&gt;
</span><span class='line'>          &lt;option value="travel"&gt;travel&lt;/option&gt;
</span><span class='line'>          &lt;option value="music"&gt;music&lt;/option&gt;
</span><span class='line'>        &lt;/select&gt;
</span><span class='line'>      &lt;/label&gt;
</span><span class='line'>      &lt;hr /&gt;
</span><span class='line'>      &lt;ChatRoom roomId={roomId} /&gt;
</span><span class='line'>    &lt;/&gt;
</span><span class='line'>  );
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>In the example above, the input only updates the message state variable. From the user’s perspective, this should not affect the chat connection. However, every time you update the message, your component re-renders. When your component re-renders, the code inside of it runs again from scratch.</p>

<p>A new options object is created from scratch on every re-render of the ChatRoom component. React sees that the options object is a different object from the options object created during the last render. This is why it re-synchronizes your Effect (which depends on options), and the chat re-connects as you type.</p>

<p>This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesn’t matter that the contents inside of them may be the same!</p>

<p>Object and function dependencies can make your Effect re-synchronize more often than you need.</p>

<p>This is why, whenever possible, you should try to avoid objects and functions as your Effect’s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them.</p>

<h2>useMemo and useCallback</h2>

<ul>
<li>useMemo caches the result of calling your function.</li>
<li>useCallback caches the function itself. React will not call your function.</li>
</ul>


<h2>forwardRef</h2>

<p>First, get familar with <code>useRef</code>:</p>

<h3>useRef</h3>

<p>ref.current is set during the <em>commit</em> process, not <em>render</em> process, so do not read or write ref.current during rendering. We can use ref.current in event handler or useEffect.</p>

<h3>basic concepts</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const MyInput = forwardRef(function MyInput(props, ref) {
</span><span class='line'>  return (
</span><span class='line'>    &lt;label&gt;
</span><span class='line'>      {props.label}
</span><span class='line'>      &lt;input ref={ref} /&gt;
</span><span class='line'>    &lt;/label&gt;
</span><span class='line'>  );
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>The ref attribute passed by the parent component. The ref can be an object or a function. You should either
* pass the ref you receive to another component, or
* pass it to useImperativeHandle.</p>

<h3>expose dom node</h3>

<p>The parent <code>Form</code> component accesses the \<input\> DOM node exposed by <code>MyInput</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import { forwardRef } from 'react';
</span><span class='line'>
</span><span class='line'>const MyInput = forwardRef(function MyInput(props, ref) {
</span><span class='line'>  const { label, ...otherProps } = props;
</span><span class='line'>  return (
</span><span class='line'>    &lt;label&gt;
</span><span class='line'>      {label}
</span><span class='line'>      &lt;input {...otherProps} ref={ref} /&gt;
</span><span class='line'>    &lt;/label&gt;
</span><span class='line'>  );
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>function Form() {
</span><span class='line'>  const ref = useRef(null);
</span><span class='line'>
</span><span class='line'>  function handleClick() {
</span><span class='line'>    ref.current.focus();
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return (
</span><span class='line'>    &lt;form&gt;
</span><span class='line'>      &lt;MyInput label="Enter your name:" ref={ref} /&gt;
</span><span class='line'>      &lt;button type="button" onClick={handleClick}&gt;
</span><span class='line'>        Edit
</span><span class='line'>      &lt;/button&gt;
</span><span class='line'>    &lt;/form&gt;
</span><span class='line'>  );
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>expose an object</h3>

<p>Use <code>useImperativeHandle</code> to expose an object referenced by <code>ref</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import { forwardRef, useRef, useImperativeHandle } from 'react';
</span><span class='line'>
</span><span class='line'>const MyInput = forwardRef(function MyInput(props, ref) {
</span><span class='line'>  const inputRef = useRef(null);
</span><span class='line'>
</span><span class='line'>  useImperativeHandle(ref, () =&gt; {
</span><span class='line'>    return {
</span><span class='line'>      focus() {
</span><span class='line'>        inputRef.current.focus();
</span><span class='line'>      },
</span><span class='line'>      scrollIntoView() {
</span><span class='line'>        inputRef.current.scrollIntoView();
</span><span class='line'>      },
</span><span class='line'>    };
</span><span class='line'>  }, []);
</span><span class='line'>
</span><span class='line'>  return &lt;input {...props} ref={inputRef} /&gt;;
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h2>Custom Hook</h2>

<p>You must follow these naming conventions:</p>

<ul>
<li>React component names must start with a capital letter, like StatusBar and SaveButton. React components also need to return something that React knows how to display, like a piece of JSX.</li>
<li>Hook names must start with use followed by a capital letter, like useState (built-in) or useOnlineStatus (custom, like earlier on the page). Hooks may return arbitrary values.</li>
</ul>


<p>This convention guarantees that you can always look at a component and know where its state, Effects, and other React features might “hide”. For example, if you see a getColor() function call inside your component, you can be sure that it can’t possibly contain React state inside because its name doesn’t start with use. However, a function call like useOnlineStatus() will most likely contain calls to other Hooks inside!</p>

<p>If your linter is configured for React, it will enforce this naming convention.</p>

<p>Note that custom Hooks only share stateful logic, not state itself.</p>

<h2>strict mode</h2>

<p><StrictMode> lets you find common bugs in your components early during development.</p>

<p>Strict Mode enables the following development-only behaviors:
* Your components will re-render an extra time to find bugs caused by impure rendering.
* Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.
* Your components will be checked for usage of deprecated APIs.</p>

<h2>Other Rules</h2>

<h3>data from parent to child</h3>

<p>When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, and pass it down to the child.
This is simpler and keeps the data flow predictable: the data flows down from the parent to the child.</p>

<h3>useSyncExternalStore</h3>

<h3>useEffect dependencies</h3>

<p>All variables from the component body used by the Effect should be in the Effect dependency list. However, you could instead “prove” to the linter that these values aren’t reactive values, i.e. that they can’t change as a result of a re-render. For example, if serverUrl and roomId don’t depend on rendering and always have the same values, you can move them outside the component. Now they don’t need to be dependencies:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive
</span><span class='line'>const roomId = 'general'; // roomId is not reactive
</span><span class='line'>
</span><span class='line'>function ChatRoom() {
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection(serverUrl, roomId);
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; {
</span><span class='line'>      connection.disconnect();
</span><span class='line'>    };
</span><span class='line'>  }, []); // ✅ All dependencies declared
</span><span class='line'>  // ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
</feed>
