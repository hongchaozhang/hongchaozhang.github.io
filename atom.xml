<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2023-09-15T23:57:03+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[精英日课2022-2023]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/09/15/jingying-rike-2022-2023/"/>
    <updated>2023-09-15T18:07:58+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/09/15/jingying-rike-2022-2023</id>
    <content type="html"><![CDATA[<!-- more -->


<p>系统腐败的动力学
灌溉导致土地盐碱化
朝代更替，政府越来越大
公司老员工势力和做事方式</p>

<p>原始世界信念
三观</p>

<p>ai负责预测概率，人负责拍板</p>

<p>读书：《首要怀疑》</p>

<p>风险到底要不要预防？
风险损失×发生概率＞预防成本</p>

<p>蒙特卡洛方法，通过随机噪声，统计一些信息。可能可以降低计算量，并且可以估计一些没有解析解的问题。
多次重复试验
由于馄饨效应，长期天气预报不可能，只能有概率</p>

<p>啥时候吹牛啥时候不吹牛？熟人社会</p>

<p>上层社会人捧人（圈子），中层社会人比人，下层社会人踩人</p>

<p>身体出厂设置是为狩猎采集准备的</p>

<p>阅读：费佛的《权利七规则》
追求权力
表达愤怒
不要道歉
刷存在感，在事情发生的时候，大肆宣传，抓住小事情，搞大。不能不说，也不能老说过去的事情。怎么从心里认同这种做法呢？你可以把他认为这是在为属下或者同组的人争取权益。
社交关系，多和自己社交边缘的人打交道。从心里认同社交。方法：1）找人介绍，2）找共同点，比如老乡，大学同学等
位置比能力重要，上海市委书记，黑龙江省委书记</p>

<p>在决策过程中，有三种人：
巨婴：只要自己需要的东西，
政客：通过礼仪交换，达到自己的目的，
战略家：从全局出发，寻求最优策略</p>

<p>阅读，霍夫曼，《隐藏的博弈》</p>

<p>说服理论和说谎，说服力
不能撒谎，但是可以使用说服理论。比如，设计调查问卷的问题，选择调查问卷的对象。只说优点不说缺点。
当大家都用说服理论的时候，你不得不用。因为别人认为你会使用说服理论，就算你说的是事实，别人也会打个折扣再接受。
囚徒困境，纳什均衡</p>

<p>读书《隐藏的博弈》
传统习惯，初级奖励，刺激奖励
模仿变成信念，信念变成文化，文化
日常事务的终极解释
什么是奢侈品？小众贵而且没用，才能炫耀。糖，只有少数人能吃得起，好的东西必须是甜的。
卡路里，现在卡路里易得，健身才值得炫耀。
肤色，以前崇尚白，白说明我不是体力工作者。现在崇尚黑，黑说明我在办公室工作之余还有资本去海边玩。
复杂的手续和仪式，是入场券，是证明自己是圈内人的资本</p>

<p>能量型英雄，能耐型英雄。在待人接物中，把任何人都看成能量型英雄，尊重对方的荣誉。</p>

<p>读书：翦商</p>

<p>心理学是科学，应该描述是什么，不应该讨论应该怎么样。
但是哲学可以讨论应该怎么样
阿德勒的观点也是哲学，不是心理学
弗洛伊德的观点基本被心理学抛弃</p>

<p>读书：星空信使</p>

<p>萨达姆侯赛因感化看守自己的12个士兵。
明朝被蒙古俘虏之后，感化周围的人，被送回了北京。</p>

<p>年轻的时候感受到的爱越多，自己对人就越信任，对爱人信任。</p>

<p>跳槽是年轻人的特权。学一个势能高的专业，然后跳来跳去，选一个适合自己的工作。比如应用数学，应用物理？</p>

<p>考古和古董的区别
考古注重从中发现当时人的生活方式和文化。遗址中吃剩的残羹剩饭有考古价值，但是不是古董，没有收藏价值。
古董注重审美和收藏价值。</p>

<p>事实判断，价值判断。事实多是客观的，有标准，但是价值多是主观的，没有标准。
区分道德中，哪些是权力哪些是义务。</p>

<p>光伏和液晶产业，中国大陆通过砸钱实现超越，但是芯片却没有。为什么美国可以限制中国芯片，却限制不了光伏和液晶产业？还是不屑于限制？知乎文章可以看看</p>

<p>不可知论，赫胥黎</p>

<p>什么叫浪费时间
重要题目认真选，不重要题目随便选。
对结果没影响的事情随便做。
几十块钱的东西精挑细选，各种比较，各种优惠券，那就是浪费时间。如果你乐于此道，那就不是浪费时间。“喜欢浪费的时间，就不叫浪费时间”。
抓大放小，不花很多时间琢磨小事情。
要做到这一点，就要扩大视野，扩大见识。</p>

<p>濒死体验和离体体验，可能的解释是脑补，所有“看到”的东西，都是自己脑补出来的。
用生成式系统来类比，濒死体验是在没有输入的情况下的生成式系统，而正常体验是有输入的生成式系统。</p>

<p>视角带来不同的思考，
在太空看地球，不能看到细节，只能区分国家，当你看到朝鲜和韩国在晚上灯光的差距的时候，你思考的只能是国家经济和国家政治的问题。
在月球看地球，看不到国与国的分界，只能看到整个地球，你就不会再想到冷战，而是地球的生存和演化问题。</p>

<p>破除分别观
很多事物没有本质区别，人和动物，肉食和素食，</p>

<p>汉隆剃刀
奥卡姆剃刀</p>

<p>中庸
自律带来自由，你有乱弹琴的自由，但是你没有上台表演的自由
三思而后行
不要一根筋走到底
内心能容纳相反的观点</p>

<p>每个人都怀念自己年轻时候的时代</p>

<p>改变睡梦中人的软感觉，不能植入硬知识。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[卓克聊科技2022]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/09/15/zhuoke-keji-2022/"/>
    <updated>2023-09-15T18:07:03+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/09/15/zhuoke-keji-2022</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>像丧尸一般的朊蛋白（疯牛病）</h2>

<p>疯牛病的病原体是朊蛋白，也叫朊病毒。</p>

<p>这种病毒导致的疾病，叫朊病毒朊病毒病（Prion Disease），是一种致命性神经退行性疾病，致死率高达100.0%。</p>

<p>朊病毒是一种蛋白质病毒，说是病毒，其实它并不符合病毒的定义，甚至并不是严格意义上的生命。因为它并不包含DNA或者RNA等遗传物质，也不能复制自己。朊病毒只是一种特殊的变异的蛋白质，只是折叠方式与其他蛋白质不同，其它方面和正常的蛋白质没有多大区别。</p>

<p>同时，常规药物对朊病毒也无效，即使有能杀灭朊病毒的药物，也同时会杀灭人体正常蛋白质。</p>

<p>朊病毒的感染机制和病毒全然不同，它并不是通过DNA或者RNA信息复制，这种蛋白质病毒其实是没有遗传物质的，而是通过同化宿主的蛋白质进行传播。</p>

<p>听起来就像丧尸。</p>

<h2>刺身</h2>

<ul>
<li>寄生虫问题，通过冷冻冻死寄生虫。</li>
<li>咸水鱼刺身：在运输的过程中需要冷冻，顺便就杀死了寄生虫。</li>
<li>淡水鱼刺身：没有冷冻运输的需求，杀死寄生虫靠自觉，难以保证。</li>
<li>醉虾醉蟹不能吃，酒不能杀死体内寄生虫。</li>
</ul>


<h2>最好的运动方式</h2>

<ul>
<li>爬，是最好的运动方式。</li>
<li>爬，膝盖不能着地，用双手双脚着地</li>
<li>有点像平板支撑</li>
<li>锻炼核心力量和协调性</li>
</ul>


<h2>糖</h2>

<ul>
<li>除了饱和脂肪酸，游离糖更不能吃。美国政府贿赂科学家发表吃糖没问题的文章，2016年曝光。</li>
<li>每天游离糖的上限是20到30克，一瓶330的可乐已经超标了。</li>
<li>代糖：甜蜜素，糖精，阿斯巴甜</li>
</ul>


<h2>呼吸机</h2>

<ul>
<li>新冠期间，呼吸机和制氧机是智商税。</li>
<li>家用制氧机压强小，不足以将氧气打入重症患者的肺部。需要3到4个大气压的压强，家用只能提供0.2-0.6个大气压强。</li>
<li>慢阻症适合家庭制氧机。</li>
</ul>


<h2>长寿方法</h2>

<ul>
<li>换血</li>
<li>模仿原始人生活方式，吃不饱，穿不暖，体力劳动，偶尔极限体力劳动。</li>
</ul>


<h2>退烧方法</h2>

<ul>
<li>退烧贴没有作用，感觉上的凉是薄荷等模拟的，不是真的能降温。就像辣椒模拟了烫伤的感觉，实际上并没有。</li>
<li>用水擦身体好一些，但是也不推荐。虽然水蒸发带走的热量足够降低体温，但是体表温度的下降会使得体内温度调节系统将目标温度设置的更高，从而产生更多的热量。除非一直不停的擦，否则，擦半小时停半小时，没有效果。</li>
<li>冰水擦身没必要，相比使水温升高带走的热量，水蒸发带走的热量才是主要的，大约1：20。但是，冰水对身体的刺激，会使得核心目标温度设置的更高。</li>
<li>最有效的就是退烧药，当体温高于38.5，精神萎靡的时候用</li>
</ul>


<h2>保健品</h2>

<ul>
<li>对保健品不要有任何期待，如果必须有一个期待，那就是：不要有什么害处。</li>
<li>吃任何保健品，都不如每天晒晒太阳，吃个鸡蛋，好好睡觉有效。</li>
</ul>


<h2>地面下沉</h2>

<ul>
<li>与其担心海平面上升（2毫米每年），不如担心城市地面下沉（10毫米每年）。过度抽取地下水导致陆地下沉。</li>
<li>雅加达已经由于下沉已经不是印尼的首都啦。</li>
</ul>


<h2>安慰剂效应与反安慰剂效应</h2>

<ul>
<li>安慰剂效应：只要你相信，就有作用。</li>
<li>反安慰剂效应：你相信家具的某种摆放有利于睡眠，但是家里的家具又不是这样摆放的，你的睡眠就会变差。</li>
</ul>


<h2>阴谋论与拉姆斯定律</h2>

<ul>
<li>信息足够多的时候，必定会有部分信息能够关联上，即使当初没有设计它们有关系，这就为阴谋论创造了条件。</li>
<li>解决方法有两个

<ul>
<li>非常小的信息量，不足以让信息之间产生关系。</li>
<li>更多的信息量，让产生阴谋论成为可能的同时，真正有关系的信息也会产生，这种正确的关系必定在未来的发展过程中蚕食阴谋论的市场。</li>
</ul>
</li>
</ul>


<h2>如何面对复杂系统</h2>

<ul>
<li>复杂系统，没有简单的输入输出关系，并且受各种反馈影响。</li>
<li>各种对策应对政策，比如

<ul>
<li>灭眼镜蛇灭鼠的行政命令</li>
<li>经济学上的事与愿违</li>
</ul>
</li>
<li>正确的做法

<ul>
<li>只限定边界，边界内部自由发展</li>
</ul>
</li>
</ul>


<h2>睡眠</h2>

<ul>
<li>控制体温，改善睡眠。降低核心温度能提高20%的睡眠质量。

<ul>
<li>可以通过提高四肢和手脚的温度实现，也可以通过降低室温实现。</li>
</ul>
</li>
<li>长期缺觉，免疫力，杏仁核，前额叶皮质，交感神经

<ul>
<li>蓝光，褪黑激素，睡眠</li>
</ul>
</li>
</ul>


<h2>延迟满足的误解</h2>

<ul>
<li>延迟满足不是能力，不能强行训练。</li>
<li>能否延迟满足主要和两个因素有关系（可以从这两个角度着手训练。）：

<ul>
<li>信任度</li>
<li>见多识广</li>
</ul>
</li>
</ul>


<h2>秩序的形成</h2>

<ul>
<li>自下向上自发形成的秩序是稳定的。</li>
<li>自上而下的顶层设计出来的秩序是不稳定的，需要很大的能量维护。</li>
</ul>


<h2>计算机结构</h2>

<ul>
<li>冯诺依曼结构</li>
<li>存算一体结构</li>
<li>量子计算机</li>
</ul>


<h2>进化论</h2>

<p>最小自由能原理：对外界刺激的预期，外界实际的刺激，两者不一致的时候，要么改变外界，要么改变期望。是不是很像成功学鸡汤？不</p>

<h2>其它</h2>

<ul>
<li>蟹棒没有蟹肉，淀粉和鱼肉</li>
<li>番茄酱有番茄</li>
<li>肯德基的番茄酱的配料表，第一个就是番茄酱。是不是很奇怪。其实是翻译的问题，我们说的番茄酱其实应该叫“调味包”</li>
<li>不要用酒精擦身体降温，因为皮肤会吸收酒精，尤其是孩子的皮肤。</li>
<li>拍频：风扇旋转的时候，会看到一个更慢的旋转，甚至反转</li>
<li>张益唐，黎曼猜想，零点定理，2022.11月公布的</li>
<li>张衡地动仪只有观赏价值，没有实用价值。</li>
<li>AR太难啦：空间建模，空间物体不要乱动，景深层次。VR相比就好很多，不用考虑真实世界</li>
<li>魂类游戏，难度</li>
<li>mcu芯片</li>
<li>奥卡姆剃刀：如非必须勿增实体</li>
<li>欧洲隐私，欧洲刑警组织败诉给数据隐私组织，被迫删除4PB的个人数据。</li>
<li>爱因斯坦：毅力做事情不如爱好做事情，爱好做事情不如追求美做事情。</li>
<li>苹果无损音乐核心竞争力是2002年开始音乐公司上传的母带。其它音乐平台都是假无损，插值得到的。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Learning Note 2023]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/09/15/react-learning-note-2023/"/>
    <updated>2023-09-15T17:33:08+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/09/15/react-learning-note-2023</id>
    <content type="html"><![CDATA[<!-- more -->


<ul>
<li><a href="#react-state-is-updated-in-a-batch">React state is updated in a “batch”</a></li>
<li><a href="#update-react-state-with-a-new-object-do-not-mute-existing-one">Update react state with a new object, do not mute existing one</a></li>
<li><a href="#declarative-ui">Declarative UI</a></li>
<li><a href="#react-redux">React-redux</a></li>
<li><a href="#hooks">Hooks</a></li>
<li><a href="#react%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F">React中的变量</a></li>
<li><a href="#useeffect">useEffect</a>

<ul>
<li><a href="#clean-up-function">clean up function</a></li>
</ul>
</li>
<li><a href="#usememo">useMemo</a></li>
<li><a href="#two-ways-to-store-previous-props">two ways to store previous props</a>

<ul>
<li><a href="#useref">useRef</a></li>
<li><a href="#usestate">useState</a></li>
</ul>
</li>
<li><a href="#fetch-data%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98">fetch data的两个问题</a>

<ul>
<li><a href="#race-condition">race condition</a></li>
<li><a href="#undo">undo</a></li>
</ul>
</li>
<li><a href="#effect-event">Effect Event</a>

<ul>
<li><a href="#what-is-reactive">what is reactive</a></li>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution:</a></li>
<li><a href="#supress-react-lint-error">Supress react lint error</a></li>
</ul>
</li>
<li><a href="#how-to-review-effect-dependencies">How to review effect dependencies</a>

<ul>
<li><a href="#ways-to-review-and-fix-this">ways to review and fix this</a></li>
</ul>
</li>
<li><a href="#object-and-function-compare">Object and function compare</a></li>
<li><a href="#usememo-and-usecallback">useMemo and useCallback</a></li>
<li><a href="#forwardref">forwardRef</a>

<ul>
<li><a href="#useref-1">useRef</a></li>
<li><a href="#basic-concepts">basic concepts</a></li>
<li><a href="#expose-dom-node">expose dom node</a></li>
<li><a href="#expose-an-object">expose an object</a></li>
</ul>
</li>
<li><a href="#custom-hook">Custom Hook</a></li>
<li><a href="#strict-mode">strict mode</a></li>
<li><a href="#other-rules">Other Rules</a>

<ul>
<li><a href="#data-from-parent-to-child">data from parent to child</a></li>
<li><a href="#usesyncexternalstore">useSyncExternalStore</a></li>
<li><a href="#useeffect-dependencies">useEffect dependencies</a></li>
</ul>
</li>
</ul>


<h2>React state is updated in a “batch”</h2>

<p>This means that you can not get the state immediately after you change it.</p>

<p>number will be 1 after one click:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export default function Counter() {
</span><span class='line'>  const [number, setNumber] = useState(0);
</span><span class='line'>  return (
</span><span class='line'>    &lt;&gt;
</span><span class='line'>      &lt;h1&gt;{number}&lt;/h1&gt;
</span><span class='line'>      &lt;button onClick={() =&gt; {
</span><span class='line'>        setNumber(number + 1);
</span><span class='line'>        setNumber(number + 1);
</span><span class='line'>        setNumber(number + 1);
</span><span class='line'>      }}&gt;+3&lt;/button&gt;
</span><span class='line'>    &lt;/&gt;
</span><span class='line'>  )
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>To make the number to be 3, pass a update function to the setNumber function. An update function will be queued and executed later.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export default function Counter() {
</span><span class='line'>  const [number, setNumber] = useState(0);
</span><span class='line'>  return (
</span><span class='line'>    &lt;&gt;
</span><span class='line'>      &lt;h1&gt;{number}&lt;/h1&gt;
</span><span class='line'>      &lt;button onClick={() =&gt; {
</span><span class='line'>        setNumber(n =&gt; n + 1);
</span><span class='line'>        setNumber(n =&gt; n + 1);
</span><span class='line'>        setNumber(n =&gt; n + 1);
</span><span class='line'>      }}&gt;+3&lt;/button&gt;
</span><span class='line'>    &lt;/&gt;
</span><span class='line'>  )
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>Update react state with a new object, do not mute existing one</h2>

<p>Use <code>…</code> , the object spread operator:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setPerson({
</span><span class='line'>  ...person, // Copy the old fields
</span><span class='line'>  firstName: e.target.value // But override this one
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>Note that spread syntax is shallow: it only copies one level deep. To update nested object:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setPerson({
</span><span class='line'>  ...person, // Copy other fields
</span><span class='line'>  artwork: { // but replace the artwork
</span><span class='line'>    ...person.artwork, // with the same one
</span><span class='line'>    city: 'New Delhi' // but in New Delhi!
</span><span class='line'>  }
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>For updating array object:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>setArtists([
</span><span class='line'>  { id: nextId++, name: name },
</span><span class='line'>  ...artists // Put old items at the end
</span><span class='line'>]);</span></code></pre></td></tr></table></div></figure>


<p><code>Immer</code> is a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>updatePerson(draft =&gt; {
</span><span class='line'>  draft.artwork.city = 'Lagos';
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>Using <code>Immer</code> for array:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>updateMyTodos(draft =&gt; {
</span><span class='line'>  const artwork = draft.find(a =&gt; a.id === artworkId);
</span><span class='line'>  artwork.seen = nextSeen;
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h2>Declarative UI</h2>

<ul>
<li>Declarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).</li>
<li>When developing a component, Think in declarative UI way:

<ol>
<li>Identify all its visual states.</li>
<li>Determine the human and computer triggers for state changes.</li>
<li>Model the state with useState.</li>
<li>Remove non-essential state to avoid bugs and paradoxes.</li>
<li>Connect the event handlers to set state.</li>
</ol>
</li>
</ul>


<h2>React-redux</h2>

<ul>
<li>useReducer+useContext?</li>
<li>Provider</li>
<li>Context</li>
</ul>


<h2>Hooks</h2>

<ul>
<li>useContext: 跨层传输props，不用一层一层传下去</li>
<li>useEffect: Use them to synchronize your component with a system outside of React.</li>
</ul>


<h2>React中的变量</h2>

<ul>
<li>Props：immutable, 触发rerender，不记忆(retained by component)</li>
<li>State：immutable, 触发rerender，记忆(retained by React)</li>
<li>useRef：mutable, 不触发rerender，记忆(retained by React)</li>
</ul>


<h2>useEffect</h2>

<p>Effects let you specify side effects that are caused by rendering itself, rather than by a particular event.</p>

<p>Effects run at the end of a <em>commit</em> after the screen updates. That is, useEffect “delays” a piece of code from running until that render is reflected on the screen.</p>

<h3>clean up function</h3>

<p>You can use a clean up function to clean up the effect. For example, if you subscribe to an external data source, you can unsubscribe it in the clean up function.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>useEffect(() =&gt; {
</span><span class='line'>  const connection = createConnection();
</span><span class='line'>  connection.connect();
</span><span class='line'>  return () =&gt; {
</span><span class='line'>    connection.disconnect();
</span><span class='line'>  };
</span><span class='line'>}, []);
</span><span class='line'>
</span><span class='line'>useEffect(() =&gt; {
</span><span class='line'>  function handleScroll(e) {
</span><span class='line'>    console.log(window.scrollX, window.scrollY);
</span><span class='line'>  }
</span><span class='line'>  window.addEventListener('scroll', handleScroll);
</span><span class='line'>  return () =&gt; window.removeEventListener('scroll', handleScroll);
</span><span class='line'>}, []);</span></code></pre></td></tr></table></div></figure>


<p><strong>React will call your cleanup function each time before the next Effect runs again, and one final time when the component unmounts (gets removed).</strong>
That is, the cleanup function runs not only during unmount, but before every re-render with changed dependencies.</p>

<h2>useMemo</h2>

<p>useMemo和useEffect都可以加依赖，但是useMemo在render过程起作用，而useEffect在commit之后起作用。
所以，如果是render依赖的变量值，用useMemo，不用useEffect+useState。</p>

<p>不推荐：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function TodoList({ todos, filter }) {
</span><span class='line'>  const [newTodo, setNewTodo] = useState('');
</span><span class='line'>  // 🔴 Avoid: redundant state and unnecessary Effect
</span><span class='line'>  const [visibleTodos, setVisibleTodos] = useState([]);
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    setVisibleTodos(getFilteredTodos(todos, filter));
</span><span class='line'>  }, [todos, filter]);
</span><span class='line'>  // ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>推荐：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import { useMemo, useState } from 'react';
</span><span class='line'>function TodoList({ todos, filter }) {
</span><span class='line'>  const [newTodo, setNewTodo] = useState('');
</span><span class='line'>  const visibleTodos = useMemo(() =&gt; {
</span><span class='line'>    // ✅ Does not re-run unless todos or filter change
</span><span class='line'>    return getFilteredTodos(todos, filter);
</span><span class='line'>  }, [todos, filter]);
</span><span class='line'>  // ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>two ways to store previous props</h2>

<h3>useRef</h3>

<p><code>prevProps</code> updates after render:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  const prevProps = useRef();
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    prevProps.current = props;
</span><span class='line'>  }, [props]);</span></code></pre></td></tr></table></div></figure>


<h3>useState</h3>

<p><code>prevItems</code> is ready when render:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  const [prevItems, setPrevItems] = useState(items);
</span><span class='line'>  if (items !== prevItems) {
</span><span class='line'>    setPrevItems(items);
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h2>fetch data的两个问题</h2>

<h3>race condition</h3>

<p>输入特别快的时候，很多search的request连续发出，不能保证回来的顺序，会出问题。
解决方法：给useEffect提供cleanup函数解决</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function SearchResults({ query }) {
</span><span class='line'>  const [results, setResults] = useState([]);
</span><span class='line'>  const [page, setPage] = useState(1);
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    let ignore = false;
</span><span class='line'>    fetchResults(query, page).then(json =&gt; {
</span><span class='line'>      if (!ignore) {
</span><span class='line'>        setResults(json);
</span><span class='line'>      }
</span><span class='line'>    });
</span><span class='line'>    return () =&gt; {
</span><span class='line'>      ignore = true;
</span><span class='line'>    };
</span><span class='line'>  }, [query, page]);
</span><span class='line'>
</span><span class='line'>  function handleNextPageClick() {
</span><span class='line'>    setPage(page + 1);
</span><span class='line'>  }
</span><span class='line'>  // ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>undo</h3>

<p>没看懂：<a href="https://react.dev/learn/you-might-not-need-an-effect#fetching-data">https://react.dev/learn/you-might-not-need-an-effect#fetching-data</a></p>

<h2>Effect Event</h2>

<h3>what is reactive</h3>

<p>variables which can change due to a re-render
* Logic inside event handlers (or Effect Event) is not reactive.
* Logic inside Effects is reactive.</p>

<h3>Problem</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function ChatRoom({ roomId, theme }) {
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection(serverUrl, roomId);
</span><span class='line'>    connection.on('connected', () =&gt; {
</span><span class='line'>      showNotification('Connected!', theme);
</span><span class='line'>    });
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; {
</span><span class='line'>      connection.disconnect()
</span><span class='line'>    };
</span><span class='line'>  }, [roomId, theme]); // ✅ All dependencies declared
</span><span class='line'>  // ...</span></code></pre></td></tr></table></div></figure>


<p>When reconnected, a notification will be shown, and the notificaiton will consider the theme.
But when the theme changes, the notification will also be shown, which is not expected.</p>

<h3>Solution:</h3>

<p>Use Effect Event to separate this non-reactive logic from the reactive Effect around it.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function ChatRoom({ roomId, theme }) {
</span><span class='line'>  const onConnected = useEffectEvent(() =&gt; {
</span><span class='line'>    showNotification('Connected!', theme);
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection(serverUrl, roomId);
</span><span class='line'>    connection.on('connected', () =&gt; {
</span><span class='line'>      onConnected();
</span><span class='line'>    });
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, [roomId]); // ✅ All dependencies declared
</span><span class='line'>  // ...</span></code></pre></td></tr></table></div></figure>


<p>You can think of Effect Events as being very similar to event handlers. The main difference is that event handlers run in response to a user interactions, whereas Effect Events are triggered by you from Effects. Effect Events let you “break the chain” between the reactivity of Effects and code that should not be reactive.</p>

<h3>Supress react lint error</h3>

<p>React linter ask you to add all reactive variables into the Effect dependencies.
Effect Events let you fix many patterns where you might be tempted to suppress the dependency linter.</p>

<h2>How to review effect dependencies</h2>

<p>Every time you adjust the Effect’s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is “no”:</p>

<ul>
<li>You might want to re-execute different parts of your Effect under different conditions.</li>
<li>You might want to only read the latest value of some dependency instead of “reacting” to its changes.</li>
<li>A dependency may change too often unintentionally because it’s an object or a function.</li>
</ul>


<h3>ways to review and fix this</h3>

<ul>
<li>Should this code move to an event handler?</li>
<li>Is your Effect doing several unrelated things?

<ul>
<li>If different parts of your Effect should re-run for different reasons, split it into several Effects.</li>
</ul>
</li>
<li>Are you reading some state to calculate the next state?

<ul>
<li>Use update function. Use <code>setMessages([...messages, receivedMessage])</code> instead of <code>setMessages(msgs =&gt; [...msgs, receivedMessage])</code></li>
</ul>
</li>
<li>In JavaScript, objects and functions are considered different if they were created at different times.</li>
<li>Try to avoid object and function dependencies. Move them outside the component or inside the Effect.

<ul>
<li>Move static objects and functions outside your component</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function createOptions() {
</span><span class='line'>  return {
</span><span class='line'>    serverUrl: 'https://localhost:1234',
</span><span class='line'>    roomId: 'music'
</span><span class='line'>  };
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function ChatRoom() {
</span><span class='line'>  const [message, setMessage] = useState('');
</span><span class='line'>
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const options = createOptions();
</span><span class='line'>    const connection = createConnection();
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, []); // ✅ All dependencies declared
</span><span class='line'>  // ...</span></code></pre></td></tr></table></div></figure>


<pre><code>* Move dynamic objects and functions inside your Effect 
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const serverUrl = 'https://localhost:1234';
</span><span class='line'>
</span><span class='line'>function ChatRoom({ roomId }) {
</span><span class='line'>  const [message, setMessage] = useState('');
</span><span class='line'>
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const options = {
</span><span class='line'>      serverUrl: serverUrl,
</span><span class='line'>      roomId: roomId
</span><span class='line'>    };
</span><span class='line'>    const connection = createConnection(options);
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, [roomId]); // ✅ All dependencies declared
</span><span class='line'>  // ...</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Read primitive values from objects</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function ChatRoom({ options }) {
</span><span class='line'>  const [message, setMessage] = useState('');
</span><span class='line'>
</span><span class='line'>  const { roomId, serverUrl } = options;
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection({
</span><span class='line'>      roomId: roomId,
</span><span class='line'>      serverUrl: serverUrl
</span><span class='line'>    });
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, [roomId, serverUrl]); // ✅ All dependencies declared
</span><span class='line'>  // ...</span></code></pre></td></tr></table></div></figure>


<h2>Object and function compare</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import { useState, useEffect } from 'react';
</span><span class='line'>import { createConnection } from './chat.js';
</span><span class='line'>
</span><span class='line'>const serverUrl = 'https://localhost:1234';
</span><span class='line'>
</span><span class='line'>function ChatRoom({ roomId }) {
</span><span class='line'>  const [message, setMessage] = useState('');
</span><span class='line'>
</span><span class='line'>  // Temporarily disable the linter to demonstrate the problem
</span><span class='line'>  // eslint-disable-next-line react-hooks/exhaustive-deps
</span><span class='line'>  const options = {
</span><span class='line'>    serverUrl: serverUrl,
</span><span class='line'>    roomId: roomId
</span><span class='line'>  };
</span><span class='line'>
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection(options);
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; connection.disconnect();
</span><span class='line'>  }, [options]);
</span><span class='line'>
</span><span class='line'>  return (
</span><span class='line'>    &lt;&gt;
</span><span class='line'>      &lt;h1&gt;Welcome to the {roomId} room!&lt;/h1&gt;
</span><span class='line'>      &lt;input value={message} onChange={e =&gt; setMessage(e.target.value)} /&gt;
</span><span class='line'>    &lt;/&gt;
</span><span class='line'>  );
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>export default function App() {
</span><span class='line'>  const [roomId, setRoomId] = useState('general');
</span><span class='line'>  return (
</span><span class='line'>    &lt;&gt;
</span><span class='line'>      &lt;label&gt;
</span><span class='line'>        Choose the chat room:{' '}
</span><span class='line'>        &lt;select
</span><span class='line'>          value={roomId}
</span><span class='line'>          onChange={e =&gt; setRoomId(e.target.value)}
</span><span class='line'>        &gt;
</span><span class='line'>          &lt;option value="general"&gt;general&lt;/option&gt;
</span><span class='line'>          &lt;option value="travel"&gt;travel&lt;/option&gt;
</span><span class='line'>          &lt;option value="music"&gt;music&lt;/option&gt;
</span><span class='line'>        &lt;/select&gt;
</span><span class='line'>      &lt;/label&gt;
</span><span class='line'>      &lt;hr /&gt;
</span><span class='line'>      &lt;ChatRoom roomId={roomId} /&gt;
</span><span class='line'>    &lt;/&gt;
</span><span class='line'>  );
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>In the example above, the input only updates the message state variable. From the user’s perspective, this should not affect the chat connection. However, every time you update the message, your component re-renders. When your component re-renders, the code inside of it runs again from scratch.</p>

<p>A new options object is created from scratch on every re-render of the ChatRoom component. React sees that the options object is a different object from the options object created during the last render. This is why it re-synchronizes your Effect (which depends on options), and the chat re-connects as you type.</p>

<p>This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesn’t matter that the contents inside of them may be the same!</p>

<p>Object and function dependencies can make your Effect re-synchronize more often than you need.</p>

<p>This is why, whenever possible, you should try to avoid objects and functions as your Effect’s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them.</p>

<h2>useMemo and useCallback</h2>

<ul>
<li>useMemo caches the result of calling your function.</li>
<li>useCallback caches the function itself. React will not call your function.</li>
</ul>


<h2>forwardRef</h2>

<p>First, get familar with <code>useRef</code>:</p>

<h3>useRef</h3>

<p>ref.current is set during the <em>commit</em> process, not <em>render</em> process, so do not read or write ref.current during rendering. We can use ref.current in event handler or useEffect.</p>

<h3>basic concepts</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const MyInput = forwardRef(function MyInput(props, ref) {
</span><span class='line'>  return (
</span><span class='line'>    &lt;label&gt;
</span><span class='line'>      {props.label}
</span><span class='line'>      &lt;input ref={ref} /&gt;
</span><span class='line'>    &lt;/label&gt;
</span><span class='line'>  );
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p>The ref attribute passed by the parent component. The ref can be an object or a function. You should either
* pass the ref you receive to another component, or
* pass it to useImperativeHandle.</p>

<h3>expose dom node</h3>

<p>The parent <code>Form</code> component accesses the \&lt;input> DOM node exposed by <code>MyInput</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import { forwardRef } from 'react';
</span><span class='line'>
</span><span class='line'>const MyInput = forwardRef(function MyInput(props, ref) {
</span><span class='line'>  const { label, ...otherProps } = props;
</span><span class='line'>  return (
</span><span class='line'>    &lt;label&gt;
</span><span class='line'>      {label}
</span><span class='line'>      &lt;input {...otherProps} ref={ref} /&gt;
</span><span class='line'>    &lt;/label&gt;
</span><span class='line'>  );
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>function Form() {
</span><span class='line'>  const ref = useRef(null);
</span><span class='line'>
</span><span class='line'>  function handleClick() {
</span><span class='line'>    ref.current.focus();
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  return (
</span><span class='line'>    &lt;form&gt;
</span><span class='line'>      &lt;MyInput label="Enter your name:" ref={ref} /&gt;
</span><span class='line'>      &lt;button type="button" onClick={handleClick}&gt;
</span><span class='line'>        Edit
</span><span class='line'>      &lt;/button&gt;
</span><span class='line'>    &lt;/form&gt;
</span><span class='line'>  );
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>expose an object</h3>

<p>Use <code>useImperativeHandle</code> to expose an object referenced by <code>ref</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import { forwardRef, useRef, useImperativeHandle } from 'react';
</span><span class='line'>
</span><span class='line'>const MyInput = forwardRef(function MyInput(props, ref) {
</span><span class='line'>  const inputRef = useRef(null);
</span><span class='line'>
</span><span class='line'>  useImperativeHandle(ref, () =&gt; {
</span><span class='line'>    return {
</span><span class='line'>      focus() {
</span><span class='line'>        inputRef.current.focus();
</span><span class='line'>      },
</span><span class='line'>      scrollIntoView() {
</span><span class='line'>        inputRef.current.scrollIntoView();
</span><span class='line'>      },
</span><span class='line'>    };
</span><span class='line'>  }, []);
</span><span class='line'>
</span><span class='line'>  return &lt;input {...props} ref={inputRef} /&gt;;
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<h2>Custom Hook</h2>

<p>You must follow these naming conventions:</p>

<ul>
<li>React component names must start with a capital letter, like StatusBar and SaveButton. React components also need to return something that React knows how to display, like a piece of JSX.</li>
<li>Hook names must start with use followed by a capital letter, like useState (built-in) or useOnlineStatus (custom, like earlier on the page). Hooks may return arbitrary values.</li>
</ul>


<p>This convention guarantees that you can always look at a component and know where its state, Effects, and other React features might “hide”. For example, if you see a getColor() function call inside your component, you can be sure that it can’t possibly contain React state inside because its name doesn’t start with use. However, a function call like useOnlineStatus() will most likely contain calls to other Hooks inside!</p>

<p>If your linter is configured for React, it will enforce this naming convention.</p>

<p>Note that custom Hooks only share stateful logic, not state itself.</p>

<h2>strict mode</h2>

<p><StrictMode> lets you find common bugs in your components early during development.</p>

<p>Strict Mode enables the following development-only behaviors:
* Your components will re-render an extra time to find bugs caused by impure rendering.
* Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup.
* Your components will be checked for usage of deprecated APIs.</p>

<h2>Other Rules</h2>

<h3>data from parent to child</h3>

<p>When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, and pass it down to the child.
This is simpler and keeps the data flow predictable: the data flows down from the parent to the child.</p>

<h3>useSyncExternalStore</h3>

<h3>useEffect dependencies</h3>

<p>All variables from the component body used by the Effect should be in the Effect dependency list. However, you could instead “prove” to the linter that these values aren’t reactive values, i.e. that they can’t change as a result of a re-render. For example, if serverUrl and roomId don’t depend on rendering and always have the same values, you can move them outside the component. Now they don’t need to be dependencies:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive
</span><span class='line'>const roomId = 'general'; // roomId is not reactive
</span><span class='line'>
</span><span class='line'>function ChatRoom() {
</span><span class='line'>  useEffect(() =&gt; {
</span><span class='line'>    const connection = createConnection(serverUrl, roomId);
</span><span class='line'>    connection.connect();
</span><span class='line'>    return () =&gt; {
</span><span class='line'>      connection.disconnect();
</span><span class='line'>    };
</span><span class='line'>  }, []); // ✅ All dependencies declared
</span><span class='line'>  // ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[事件循环中的Macrotask和Microtask]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/05/25/event-loop-and-macrotask-and-microtask/"/>
    <updated>2023-05-25T22:01:49+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/05/25/event-loop-and-macrotask-and-microtask</id>
    <content type="html"><![CDATA[<!-- more -->


<p>For details, refer to <a href="https://javascript.info/event-loop">Event loop: microtasks and macrotasks</a>.</p>

<h2>Event Loop</h2>

<p>The event loop concept is very simple. There’s an endless loop, where the JavaScript engine waits for tasks, executes them and then sleeps, waiting for more tasks.</p>

<p>For instance, while the engine is busy executing a <code>script</code>, a user may move their mouse causing <code>mousemove</code>, and <code>setTimeout</code> may be due and so on, these tasks form a queue.</p>

<p>Tasks from the queue are processed on “first come – first served” basis. When the engine browser is done with the <code>script</code>, it handles <code>mousemove</code> event, then <code>setTimeout</code> handler, and so on.</p>

<p>So far, quite simple, right?</p>

<p>Two more details:</p>

<ul>
<li>Rendering never happens while the engine executes a task. It doesn’t matter if the task takes a long time. Changes to the DOM are painted only after the task is complete.</li>
<li>If a task takes too long, the browser can’t do other tasks, such as processing user events. So after a time, it raises an alert like “Page Unresponsive”, suggesting killing the task with the whole page. That happens when there are a lot of complex calculations or a programming error leading to an infinite loop.</li>
</ul>


<p>Event Loop应用
Use-case 1: <a href="https://javascript.info/event-loop#use-case-1-splitting-cpu-hungry-tasks">splitting CPU-hungry tasks</a>
Use case 2: <a href="https://javascript.info/event-loop#use-case-1-splitting-cpu-hungry-tasks">progress indication</a>
Use case 3: <a href="https://javascript.info/event-loop#use-case-3-doing-something-after-the-event">doing something after the event</a></p>

<h2>Macrotasks and Microtasks</h2>

<ul>
<li>Macrotask：

<ul>
<li><code>script</code>，<code>mousemove</code>，<code>setTimeout</code></li>
<li>use <code>setTimeout(f)</code> to dispatch a callback as a macrotask</li>
</ul>
</li>
<li>Microtask：

<ul>
<li>They are usually created by promises: an execution of <code>.then/catch/finally</code> handler becomes a microtask.</li>
<li> use <code>queueMicrotask(f)</code> to dispatch a callback as a microtask</li>
</ul>
</li>
</ul>


<p>Event loop workflow with macrotask and microtask:</p>

<p><img src="http://hongchaozhang.github.io/images/eventloopinv8.png" width="300px" alt="event loop and macrotask and microtask" /></p>

<h2>Summary</h2>

<p>A more detailed event loop algorithm (though still simplified compared to the specification):</p>

<pre><code>1. Dequeue and run the oldest task from the macrotask queue (e.g. “script”).
2. Execute all microtasks:
    * While the microtask queue is not empty:
        * Dequeue and run the oldest microtask.
3. Render changes if any.
4. If the macrotask queue is empty, wait till a macrotask appears.
5. Go to step 1.
</code></pre>

<p>If you want a real parallel task execution, use Web Worker. it is running in a separate thread.</p>

<h2>练习</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>console.log(1);
</span><span class='line'>
</span><span class='line'>setTimeout(() =&gt; console.log(2));
</span><span class='line'>
</span><span class='line'>Promise.resolve().then(() =&gt; console.log(3));
</span><span class='line'>
</span><span class='line'>Promise.resolve().then(() =&gt; setTimeout(() =&gt; console.log(4)));
</span><span class='line'>
</span><span class='line'>Promise.resolve().then(() =&gt; console.log(5));
</span><span class='line'>
</span><span class='line'>setTimeout(() =&gt; console.log(6));
</span><span class='line'>
</span><span class='line'>console.log(7);</span></code></pre></td></tr></table></div></figure>


<p>答案：The console output is:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 7 3 5 2 6 4</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Promise以及sync和async]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/05/25/javascript-promise-and-sync-and-async/"/>
    <updated>2023-05-25T21:24:13+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/05/25/javascript-promise-and-sync-and-async</id>
    <content type="html"><![CDATA[<!-- more -->


<p>For details, refer to <a href="https://javascript.info/async">Promises, async/await</a></p>

<h2>Basic usage</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let promise = new Promise(function(resolve, reject) {
</span><span class='line'>  let resolved = true;
</span><span class='line'>  if (resolved) {
</span><span class='line'>  setTimeout(() =&gt; resolve("done!"), 1000);
</span><span class='line'>  } else {
</span><span class='line'>    setTimeout(() =&gt; reject(new Error("Whoops!")), 1000);
</span><span class='line'>  }
</span><span class='line'>});
</span><span class='line'>
</span><span class='line'>// resolve runs the first function in .then
</span><span class='line'>promise
</span><span class='line'>.finally(() =&gt; alert("Promise ready")) // triggers first
</span><span class='line'>.then(
</span><span class='line'>  result =&gt; alert(result), // shows "done!" after 1 second
</span><span class='line'>  error =&gt; alert(error) // doesn't run
</span><span class='line'>);</span></code></pre></td></tr></table></div></figure>


<p>As you can see, the value returned by the first promise is passed through <code>finally</code> to the next <code>then</code>.</p>

<h2>Promise chain</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>new Promise(function(resolve, reject) {
</span><span class='line'>
</span><span class='line'>  setTimeout(() =&gt; resolve(1), 1000); // (*)
</span><span class='line'>
</span><span class='line'>}).then(function(result) { // (**)
</span><span class='line'>
</span><span class='line'>  alert(result); // 1
</span><span class='line'>  return result * 2;
</span><span class='line'>
</span><span class='line'>}).then(function(result) { // (***)
</span><span class='line'>
</span><span class='line'>  alert(result); // 2
</span><span class='line'>  return result * 2;
</span><span class='line'>
</span><span class='line'>}).then(function(result) {
</span><span class='line'>
</span><span class='line'>  alert(result); // 4
</span><span class='line'>  return result * 2;
</span><span class='line'>
</span><span class='line'>});</span></code></pre></td></tr></table></div></figure>


<p><code>then</code> should be a <code>async</code> function, so it can convert any return values to a promise.</p>

<h2>Error handling</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>fetch('/article/promise-chaining/user.json')
</span><span class='line'>  .then(response =&gt; response.json())
</span><span class='line'>  .then(user =&gt; fetch(`https://api.github.com/users/${user.name}`))
</span><span class='line'>  .then(response =&gt; response.json())
</span><span class='line'>  .then(githubUser =&gt; new Promise((resolve, reject) =&gt; {
</span><span class='line'>    let img = document.createElement('img');
</span><span class='line'>    img.src = githubUser.avatar_url;
</span><span class='line'>    img.className = "promise-avatar-example";
</span><span class='line'>    document.body.append(img);
</span><span class='line'>
</span><span class='line'>    setTimeout(() =&gt; {
</span><span class='line'>      img.remove();
</span><span class='line'>      resolve(githubUser);
</span><span class='line'>    }, 3000);
</span><span class='line'>  }))
</span><span class='line'>  .catch(error =&gt; alert(error.message));</span></code></pre></td></tr></table></div></figure>


<p>The code of a promise executor and promise handlers has an &ldquo;invisible&rdquo; <code>try..catch</code> around it. If an exception happens, it gets caught and treated as a rejection.</p>

<p>The &ldquo;invisible&rdquo; <code>try..catch</code> around the executor automatically catches the error and turns it into rejected promise.</p>

<p>More details about the error handling workflow, refers to <a href="https://javascript.info/promise-error-handling">https://javascript.info/promise-error-handling</a></p>

<h2>Promise.all</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let urls = [
</span><span class='line'>  'https://api.github.com/users/iliakan',
</span><span class='line'>  'https://api.github.com/users/remy',
</span><span class='line'>  'https://api.github.com/users/jeresig'
</span><span class='line'>];
</span><span class='line'>
</span><span class='line'>// map every url to the promise of the fetch
</span><span class='line'>let requests = urls.map(url =&gt; fetch(url));
</span><span class='line'>
</span><span class='line'>// Promise.all waits until all jobs are resolved
</span><span class='line'>Promise.all(requests)
</span><span class='line'>  .then(responses =&gt; responses.forEach(
</span><span class='line'>    response =&gt; alert(`${response.url}: ${response.status}`)
</span><span class='line'>  ));</span></code></pre></td></tr></table></div></figure>


<p>The new promise resolves when all listed promises are resolved, and the array of their results becomes its result.</p>

<p>If any of the promises is rejected, the promise returned by <code>Promise.all</code> immediately rejects with that error.</p>

<p>Please note that the order of the resulting array members is the same as in its source promises. Even though the first promise takes the longest time to resolve, it’s still first in the array of results.</p>

<h2>Promisification</h2>

<p>Used for changing callback style to promise style.</p>

<h2>async/await</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>async function f() {
</span><span class='line'>  return 1;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>f().then(alert); // 1</span></code></pre></td></tr></table></div></figure>


<p><code>async</code> ensures that the function returns a promise, and wraps non-promises in it.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>async function f() {
</span><span class='line'>
</span><span class='line'>  let promise = new Promise((resolve, reject) =&gt; {
</span><span class='line'>    setTimeout(() =&gt; resolve("done!"), 1000)
</span><span class='line'>  });
</span><span class='line'>
</span><span class='line'>  let result = await promise; // wait until the promise resolves (*)
</span><span class='line'>
</span><span class='line'>  alert(result); // "done!"
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>f();</span></code></pre></td></tr></table></div></figure>


<p>The function execution “pauses” at the line (*) and resumes when the promise settles, with result becoming its result. So the code above shows “done!” in one second.</p>

<p>Let’s emphasize: <code>await</code> literally suspends the function execution until the promise settles, and then resumes it with the promise result. That doesn’t cost any CPU resources, because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc.</p>

<p>For details, refer to <a href="http://hongchaozhang.github.io/blog/2023/05/25/event-loop-and-macrotask-and-microtask/">macrotask and microtask in event loop</a></p>

<p><code>Async/Sync</code> is just a more elegant syntax of getting the promise result than <code>promise.then</code>. And, it’s easier to read and write.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何在一台机器上使用两个github账号]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/05/24/work-with-two-github-accounts/"/>
    <updated>2023-05-24T21:30:12+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/05/24/work-with-two-github-accounts</id>
    <content type="html"><![CDATA[<!-- more -->


<p>最近公司的github账号从专有域名（github.company.com）迁移到了公共域名（github.com）下，所以我需要在一台机器上同时使用两个github账号。这里记录一下配置过程。</p>

<ol>
<li>生成两个ssh key</li>
<li>将ssh key添加到github账号</li>
<li>配置ssh config

<ol>
<li>如果不想配置config文件，需要手动保证ssh-agent里面每次有你想要的key，这个要不断切换，不方便，推荐使用config文件。</li>
</ol>
</li>
<li>使用特殊的域名进行<code>git clone</code>操作, <code>git clone git@github.com-hongchaozhang:hongchaozhang/deep-learning-specialization.git</code>.</li>
</ol>


<p><code>~/.ssh</code>目录下文件和创建的<code>config</code>文件，内容如下：</p>

<p><img src="http://hongchaozhang.github.io/images/config-two-github-account.jpg" alt="config two github accounts" width="300"></p>

<p>具体步骤细节参考：</p>

<ul>
<li><a href="https://www.freecodecamp.org/news/manage-multiple-github-accounts-the-ssh-way-2dadc30ccaca/#:~:text=If%20it%E2%80%99s%20to%20a%20personal%20Git%20account%20that,do%20a%20Git%20push%20to%20the%20personal%20repository">How to manage multiple GitHub accounts on a single machine with SSH keys</a></li>
<li><a href="https://gist.github.com/rahularity/86da20fe3858e6b311de068201d279e3">How To Work With Multiple Github Accounts on a single Machine</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[迁移Octopress到MacBook（M1）]]></title>
    <link href="http://hongchaozhang.github.io/blog/2023/05/24/migrate-octopress-to-m1-macbook/"/>
    <updated>2023-05-24T01:49:19+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2023/05/24/migrate-octopress-to-m1-macbook</id>
    <content type="html"><![CDATA[<!-- more -->


<p>2020年的<a href="http://hongchaozhang.github.io/blog/2020/02/26/deploy-octopress-in-a-new-machine/">迁移Octopress到新的机器上</a>里面描述的问题依然存在。除此之外，还有一些新的问题。</p>

<h2>不能正常加载(require)pygments.rb</h2>

<p>当运行 <code>rake generate</code> 时，会报错：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>jekyll 2.5.3 | Error:  Pygments can't parse unknown language: javascript.</span></code></pre></td></tr></table></div></figure>


<p>通过运行<code>jekyll build</code>，可以看到报错的详细信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/Users/hozhang/Develop/hongchaozhang.github.io/plugins/pygments_code.rb:1:in `require': cannot load such file -- pygments (LoadError)
</span><span class='line'>...</span></code></pre></td></tr></table></div></figure>


<p>当你写一个简单的rb脚本，使用<code>require 'pygments'</code>，却不会报错。</p>

<p>我们可以通过运行下面的命令来获得当前所有的gems加载路径（<code>require</code>或者<code>load</code>）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>puts $LOAD_PATH</span></code></pre></td></tr></table></div></figure>


<p>可以看出，上面两种情况下，加载路径是不一样的。在<code>rake generate</code>的情况下，加载路径中没有<code>/Library/Ruby/Gems/2.6.0/gems/pygments.rb-2.4.0/lib</code>这个路径，所以会报错。</p>

<blockquote><p><a href="https://medium.com/@connorstack/understanding-ruby-load-require-gems-bundler-and-rails-autoloading-from-the-bottom-up-3b422902ca0">Understanding ruby load, require, gems, bundler and rails auto loading from the bottom up</a>：这篇文章讲解了ruby的依赖加载机制，对于理解这个问题很有帮助，虽然最终还是没有解决问题。</p></blockquote>

<h3>解决方法</h3>

<p>将所有的code片段的语言类型指定都去掉。</p>

<p>原来带语言标记的源文件暂时放在独立的branch里：<code>source_code_with_language_type</code>。等啥时候pygments的问题解决了再弄回来。</p>

<h2>理解octopress</h2>

<p>你自己的github.io那个repo就是一个octopress，每次重新clone之后，就要按照octopress的步骤重新操作一遍：
* <a href="http://octopress.org/docs/setup/">http://octopress.org/docs/setup/</a>
* <a href="http://octopress.org/docs/deploying/github/">http://octopress.org/docs/deploying/github/</a></p>

<h2>在一台机器上同时用两个github账号工作</h2>

<p>参考<a href="http://hongchaozhang.github.io/blog/2023/05/24/work-with-two-github-accounts/">如何在一台机器上使用两个github账号</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-排序不等式]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/12/08/jingyingrike-paixubudengshi/"/>
    <updated>2022-12-08T21:27:01+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/12/08/jingyingrike-paixubudengshi</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>什么是排序不等式</h2>

<p>排序不等式：大数乘大数加上小数乘小数，大于大数乘小数加小数乘大数。</p>

<p>假设:</p>

<ul>
<li>x1>x2>x3>0</li>
<li>y1>y2>y3>0</li>
</ul>


<p>那么：</p>

<ul>
<li>x1*y1 + x2*y2 + x3*y3 > [其它排序乘积相加] > x1*y3 + x2*y2 + x3*y1</li>
</ul>


<p>它能告诉你<strong>效率</strong>和<strong>公平</strong>的本质关系，也正是因为这个不等式，效率和公平是矛盾的。</p>

<p>更关键的是，我们熟悉的那些不等式，比如什么“算数平均值大于几何平均值”、什么“柯西不等式”、什么“车比雪夫不等式”，都可以从排序不等式推导出来。</p>

<h2>排序不等式的应用</h2>

<p>世界上的很多配合不是加法、而是乘法关系。资源和人才往往不是一个加数，而是一个因子：把这个因子扩大一点点，整个这一块都能放大这么高的比例。所以：</p>

<ol>
<li>最好的资源应该用在最赚钱的地方，</li>
<li>最厉害的人员应该放在最关键的岗位，</li>
<li>最好的电影应该乘以最好的导演再乘以最好的演员、然后给最多的院线排期。</li>
</ol>


<p>这就是为什么好东西总爱扎堆，有志向的年轻人非得去大城市。这也是为什么会有马太效应，为什么人人都想跟最好的合作。这也是为什么市场总是让财富分布不平等。</p>

<h3>销售额</h3>

<p>比如你是某个决策者，你现在手里有个大项目，放在哪个地区都能提升当地的经济发展。那请问，你是把它放在经济发达地区呢，还是边远落后地区呢？</p>

<p>只要你关心的是全国经济总量的提升，你想通过这个项目创造更多的税收，你就应该坚决投发达地区。同样是提升1%，发达地区的乘数要大得多。谁都喜欢大数，但是大数最能让大数发挥作用。</p>

<h3>商店促销</h3>

<p>促销要放在周末人多的时候，而不是平时人少的时候。（前提是没有达到销量瓶颈，比如门店承受能力。）</p>

<h3>车间系统</h3>

<p>我们假设你们车间有两条生产线，每条生产线需要两个人先后动作，共同完成一件产品。现在你有四个工人，老张和老李的良品率都是95%，小张和小李的良品率都是75%。那请问，你应该把这四个人怎么分组呢？</p>

<p>直觉的分法，是让老张和小张一组，老李和小李一组，这样两个组的良品率是一样的，都是0.95×0.75=71%。你可能觉得这样分组还能让高手带一带低手，能起到骨干作用。我不知道那个高手“带动”低手的效应能有多大，但是我知道，排序不等式要求你让老张和老李一组，小张和小李一组。你的高手组良品率将是0.95×0.95=90%，低手良品率将是0.75×0.75=56%，而你的总良品率是两组的平均值，也就是73%——高于高低搭配分组的71%。</p>

<h2>排序不等式，是资源配置的“零阶道理”。</h2>

<p>排序不等式，是资源配置的“零阶道理”。</p>

<p>当然，世界是复杂的，事物的发展常常是非线性的，什么东西太多了都会发生边际效应递减。也许这个项目在发达地区的发展空间已经饱和了，也许那个地区暂时落后，以后的发展潜力大，也许大城市生活成本太高了，也许最优秀的导演不会重视你这个剧本，应该找最合适的。</p>

<p>但是，那些都是对零阶道理的一阶、或者高阶修正：零阶道理仍然是零阶道理。我们做决策必须首先考虑零阶道理，只有在证实了零阶道理在这里不行的情况下，我们才应该考虑那些修正。</p>

<h2>不适用排序不等式的场景</h2>

<h3>教育系统</h3>

<p>教育系统有重点大学、重点中学，同一个学校里还会有重点班，重点班的老师是全校最好的。这完全符合排序不等式，教育系统希望培养高水平人才。但是你注意到没有，在任何一个班级里，老师重点关注的，往往不是最好的学生。这是为啥呢？因为<strong>学习成绩有上限</strong>。</p>

<h3>福利系统</h3>

<p>还有一种系统，比如福利系统，则要求各个相加项的大小有一个下限。是，在贫困山区建设通讯基站效率不高，但是贫困山区需要通讯基站。福利系统解决的是<strong>公平问题</strong>。这种系统有时候会把最好的官员排到最贫困的地区去，并不指望他们创造什么效益，只是希望提高那些地区的下限。而既然是为了公平，那就必然牺牲了效率。</p>

<h3>安全系统</h3>

<p>安全系统也强调下限。只要是防守，我们最关心的一定是最薄弱的地方，要把最好的资源和人手放在那个地方。</p>

<h2>如何利用排序不等式</h2>

<p>个人只能做一个乘法因子，管理者要的却是相乘再相加。如果你是一个系统的运行者，你必须清楚判断这是一个不设限系统，还是一个有上限或者下限的系统。</p>

<p>公司在乎的是总收入，本质上是个不设限的系统。排序不等式告诉我们这样的系统应该狠抓“长板”，因为长板最能提高总量。有下限的系统最关心的是短板，而有上限的系统最希望每块板都差不多。</p>

<p>作为个体，如果你认为自己是个大数因子，那你最好不要呆在有上限的系统中。</p>

<p>教育系统搞搞数学竞赛什么的，也算是给好学生一个出路。</p>

<p><strong>搞平均符合直觉，但是违反数学。</strong></p>

<p>我们个人的生活和学习不也是这样的吗？直觉上你可能认为应该把每一件事都做好，每个学科都学好，其实不是。数学要求这是一个长板的世界：你应该把最好的精力、最多的时间用在最能体现你价值的项目上。</p>

<p>设重点、偏科、不均匀、走极端，这才是自然之道。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-思维是平的]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/12/08/jingyingrike-siweishipingde/"/>
    <updated>2022-12-08T21:25:01+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/12/08/jingyingrike-siweishipingde</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>思维是平的</h2>

<h3>脑补</h3>

<p>不仅仅是策略、性格和意义，还有动机、信念、价值、情绪、立场、偏见等等，所有这些代表人的“深层内心世界”的东西，都是我们想象出来的，而且是要用的时候临时编造的。</p>

<p>人只能看到细节局部，你的整体感，根本就是个错觉。哲学家和心理学把这个叫做“全局错觉”。</p>

<p>明明每次看到的都是局部，为什么会有一个整体感呢？因为大脑在不停地做解读。请注意这个解读可不是提炼精髓、只做减法，而是要补充细节，要做加法，要脑补。</p>

<p>读小说的时候，主人翁的形象会在你的大脑中被制造出来。</p>

<p>让有过一段共同经历的两个人同时回忆当时的情况，细节必定对不上。不可能记住所有的细节，但是你<em>以为</em>你记住了那些细节——其实所有的叙述、所有的意义，都是大脑的即兴创作。
人是随时都在发现意义和编造理由，特别善于即兴表演、特别善于创造故事而不自知的戏剧天才。</p>

<p>你的大脑以为你知道老虎是什么样子，其实让你画一下你就露馅啦。当你想到老虎的时候，你的大脑现编的老虎形象让你以为你知道老虎的样子。就像你读小说的时候，主人公形象就是你想象出来的。</p>

<p>人脑一直都在做自动的、默默的、让你意识不到的创作。有些创作素材来自真实记忆和当前现场观察，有些素材是根据逻辑脑补的，有些素材纯粹是胡乱添加的，有些素材则是为了某个主题的需要。</p>

<h3>选择失明</h3>

<p>别人问你为什么做出一个选择的时候，你在现编理由。你不知道，你的选择已经被做实验的人改了。</p>

<p>现在我们想一想这个现象。本来你只是很随意地选择了一张女性照片、一个果酱口味、一只股票基金和一个政治观点。你选的时候没想太多，因为你并不在意这个。但是选了之后——事实上是别人调换了你的选项，是你<em>以为</em>你选了之后——你却变成了这个选择的坚定支持者。</p>

<p>你看这像不像量子力学里的“波函数坍缩”？电子的自旋本来是个叠加态，是向上也行、向下也行——因为实验观测，电子被逼表态之后，它就有了一个坚定的自旋。类似的还有政治立场，对女生是否有好感等。</p>

<p>有一首李健创作、王菲演唱的歌叫《传奇》，说——</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>只因为在人群中多看了你一眼
</span><span class='line'>再也没能忘掉你的容颜
</span><span class='line'>梦想着偶然能有一天再相见
</span><span class='line'>从此我开始孤单地思念
</span><span class='line'>……
</span><span class='line'>宁愿相信我们前世有约
</span><span class='line'>今生的爱情故事不会再改变
</span><span class='line'>……</span></code></pre></td></tr></table></div></figure>


<p>你看这整个不就是一个爱情波函数坍缩事件吗？</p>

<p><strong>了解了大脑的这个性质，我们必须对能引起波函数坍缩的东西多加小心。</strong></p>

<h3>承诺和一致</h3>

<p>罗伯特·西奥迪尼（RobertB.Cialdini）的名著《影响力》这本书里有个专门的说法，叫“承诺和一致（CommitmentandConsistency）”，人在心理上有一种「要与过去的所作所为保持一致的愿望」。</p>

<p>因为这个机制，你要想让人帮你一个大忙，一个好办法是先让他帮你一个小忙。最愿意帮助你的是已经帮助过你的人。</p>

<p>咱们中国人管这个叫“得寸进尺”，心理学家把它总结成了一个影响力技术，叫“一只脚已经在门里（Foot-in-the-doortechnique）”——如果你已经让人的一只脚进门了，你好意思不让他整个人进来吗？</p>

<p>有些流氓调戏女孩也是这个套路。一开始只是请吃顿饭，然后是我一直都梦想有个女生能陪我去网吧打游戏，你能满足我这个梦想吗？……流氓一步步升级，女孩一步步沦陷。</p>

<p>我们平时说的什么“来都来了”、“沉没成本”，其实也都是这个机制。西奥迪尼后来搞的什么“先发影响力”、心理学和行为经济学上的prime效应，用环境和细节默默影响一个人的心态，其实也是这个机制。</p>

<p>一切的一切，都是因为我们想要完成自己想象中的、那个甚至都不知道因何而起的故事。</p>

<h3>如何应用大脑坍缩</h3>

<p>大脑坍缩并不见得不好，可能大多数情况下这都是一件好事。正是因为我们有这个想象，我们才能一心一意地完成那些需要长期努力的项目，哪怕遭遇困难也能挺过去。正是因为各种想象的共同体，一群人才能好好合作。但是正如你前面所见，大脑坍缩有可能会给我们带来麻烦。</p>

<p>那么理解了这个大脑坍缩的机制，我们应该如何对待小事呢？我认为这个原则应该是“<strong>谨慎地开始，正面地影响，果断地结束</strong>”。</p>

<p><strong>如果你对一件事物本来没有强硬立场，那就不要轻易表态。</strong></p>

<p>请问你对全球变暖有什么看法？你没看法。你根本就没研究过，你表什么态站什么队？站队是可能要站到底的。领导都是最后一个表态的，而且最好在事情尘埃落定之前都不表态。</p>

<p><strong>别轻易让你的波函数坍缩</strong>。在事情比较微妙的时刻，可能每个人有不一样的解读。你要说这是冲突吧，也对；你要说不是吧，也真不算——这时候应该怎么办呢？你应该抢先给这件事定性，<strong>让波函数往对你有利的那个方向坍缩。</strong></p>

<p>好在这里面没有量子随机性。女朋友昨天好像有点不高兴，你也说不清到底是不是，这时候你要设法帮助她往高兴的剧情上解读。但是如果你的波函数已经坍缩了，别忘了这一切仅仅是你的想象！你完全可以退出这个故事，换一个新故事。</p>

<p>理解了思维是平的，我们要做的不是放弃想象，而是去寻找更好的想象。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-伯克森悖论]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/12/08/jingyingrike-bokesenbeilun/"/>
    <updated>2022-12-08T21:20:29+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/12/08/jingyingrike-bokesenbeilun</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>什么是伯克森悖论</h2>

<p>先看几个常见的论点：</p>

<ol>
<li>长得帅的男人性格都很差</li>
<li>不善言辞恰恰是智商高的特征</li>
<li>流行的都没啥深度</li>
<li>漂亮的女生都不聪明</li>
<li>颜值高的演员都没演技</li>
<li>有特长的人必定有明显短板</li>
<li>家里条件好的大学生必定不用功</li>
</ol>


<p>伯克森悖论是说，哪怕上面这些人的经验都是真的，他们从经验中总结出来的结论，也很可能是错的。</p>

<p>伯克森悖论的常见形式，就是如果你对两个特性有一个总体的阈值要求——这两个特性哪怕没关系，甚至哪怕原本可能还是正相关——在你考察的那个范围内，也能让你感觉它们有负的相关性。</p>

<h2>伯克森悖论与幸存者偏差</h2>

<p>伯克森悖论和人们熟悉的“幸存者偏差”都属于“选择偏差”，出错的根本原因都是你统计的数据不够全面。在统计研究中，你稍不小心，就会犯伯克森悖论的错误。</p>

<p>有一个真实的例子是这样的。有人统计了因为出车祸而被送进医院急诊室的摩托车手，发现戴头盔的人所受的伤，反而比不戴头盔的人更重。</p>

<p>难道说因为戴头盔的人开车更大胆，所以更容易受重伤吗？不一定。事实是很多戴头盔的人因为头盔的保护，而只受了轻伤，根本就无需进急诊室。</p>

<p>你考察的其实是“身体受到的保护”和“身体受到的伤害”这两个因素——保护必须足够小，伤害必须足够大，才能让这个人进急诊室——这跟“长相+性格”是一个道理，所以你看到了不戴头盔和受重伤的假的负相关。</p>

<p>还有个二战飞机中弹位置统计的例子。</p>

<h2>伯克森悖论的应用</h2>

<p>了解了伯克森悖论，下一次再听说涉及到能力、人品、长相、运气的各种“负相关”论断，你都应该保持戒心。</p>

<p>生活中有很多这样的民间智慧，比如什么“寒门出贵子”，什么“为富不仁”，什么“仗义每从屠狗辈，负心多是读书人”，什么“杀人放火金腰带，修桥铺路无尸骸”，都十分可疑。</p>

<p>平庸的寒门子弟、遵纪守法的富人、没有英雄壮举的屠狗辈、忠诚的读书人和安享晚年的好心人，他们的新闻阈值太低，他们的事迹没有四海传扬。你必须把这些人都统计上，才能得出正确的结论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重学前端-通过window属性了解协议API]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/10/08/chongxueqianduan-tongguo-window-liaojie-protocol-api/"/>
    <updated>2022-10-08T17:18:04+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/10/08/chongxueqianduan-tongguo-window-liaojie-protocol-api</id>
    <content type="html"><![CDATA[<!-- more -->


<p>浏览器的API数目繁多，这一节课，我设计了一个实验，我们一起来给API分分类。</p>

<p>我们按照每个API所在的标准来分类。所以，我们用代码来反射浏览器环境中全局对象的属性，然后我们用JavaScript的filter方法来逐步过滤掉已知的属性。</p>

<p>接下来，我们整理API的方法如下：</p>

<ol>
<li>从Window的属性中，找到API名称；</li>
<li>查阅MDN或者Google，找到API所在的标准；</li>
<li>阅读标准，手工或者用代码整理出标准中包含的API；</li>
<li>用代码在Window的属性中过滤掉标准中涉及的API。</li>
<li>重复这个过程，我们可以找到所有的API对应的标准。</li>
</ol>


<p>原文点击<a href="http://hongchaozhang.github.io/assets/resources/37%E4%B8%A8%E6%B5%8F%E8%A7%88%E5%99%A8API%EF%BC%88%E5%B0%8F%E5%AE%9E%E9%AA%8C%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%89%8B%E6%95%B4%E7%90%86%E5%85%A8%E9%83%A8API.html">这里</a>获取。</p>

<p>从原文整理出来的html文件点击<a href="http://hongchaozhang.github.io/assets/resources/traverseWindows.html">这里</a>获取。</p>

<p>关键js代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function filterOut(names, props) {
</span><span class='line'>    let set = new Set();
</span><span class='line'>    props.forEach(o =&gt; set.add(o));
</span><span class='line'>    return names.filter(e =&gt; !set.has(e));
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>let names = Object.getOwnPropertyNames(window)
</span><span class='line'>console.log(names)
</span><span class='line'>
</span><span class='line'>// 过滤JavaScript 标准规定的属性
</span><span class='line'>let js = new Set();
</span><span class='line'>let objects = ["BigInt", "BigInt64Array", "BigUint64Array", "Infinity", "NaN", "undefined", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "Array", "Date", "RegExp", "Promise", "Proxy", "Map", "WeakMap", "Set", "WeakSet", "Function", "Boolean", "String", "Number", "Symbol", "Object", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray", "Atomics", "JSON", "Math", "Reflect", "escape", "unescape"];
</span><span class='line'>objects.forEach(o =&gt; js.add(o));
</span><span class='line'>names = names.filter(e =&gt; !js.has(e));
</span><span class='line'>console.log('\nnames after filtering JS Standard:')
</span><span class='line'>console.log(names)
</span><span class='line'>
</span><span class='line'>// 接下来我们看看已经讲过的 DOM 部分，DOM 部分包含了 document 属性和一系列的构造器，我们可以用 JavaScript 的 prototype 来过滤构造器。
</span><span class='line'>names = names.filter( e =&gt; {
</span><span class='line'>    try { 
</span><span class='line'>        return !(window[e].prototype instanceof Node)
</span><span class='line'>    } catch(err) {
</span><span class='line'>        return true;
</span><span class='line'>    }
</span><span class='line'>}).filter( e =&gt; e != "Node")
</span><span class='line'>console.log('\nnames after filtering DOM:')
</span><span class='line'>console.log(names)
</span><span class='line'>
</span><span class='line'>// 接下来我们要找到 Window 对象的定义，我们在下面链接中可以找到。https://html.spec.whatwg.org/#window 这里有一个 Window 接口，是使用 WebIDL 定义的，我们手工把其中的函数和属性整理出来
</span><span class='line'>let windowprops = new Set();
</span><span class='line'>objects = ["window", "self", "document", "name", "location", "history", "customElements", "locationbar", "menubar", " personalbar", "scrollbars", "statusbar", "toolbar", "status", "close", "closed", "stop", "focus", " blur", "frames", "length", "top", "opener", "parent", "frameElement", "open", "navigator", "applicationCache", "alert", "confirm", "prompt", "print", "postMessage", "console"];
</span><span class='line'>objects.forEach(o =&gt; windowprops.add(o));
</span><span class='line'>names = names.filter(e =&gt; !windowprops.has(e));
</span><span class='line'>console.log('\nnames after filtering WebIDL:')
</span><span class='line'>console.log(names)
</span><span class='line'>
</span><span class='line'>// 我们还要过滤掉所有的事件，也就是 on 开头的属性。
</span><span class='line'>names = names.filter( e =&gt; !e.match(/^on/))
</span><span class='line'>// webkit 前缀的私有属性我们也过滤掉：
</span><span class='line'>names = names.filter( e =&gt; !e.match(/^webkit/))
</span><span class='line'>// 除此之外，我们在 HTML 标准中还能找到所有的接口，这些我们也过滤掉：
</span><span class='line'>let interfaces = new Set();
</span><span class='line'>objects = ["ApplicationCache", "AudioTrack", "AudioTrackList", "BarProp", "BeforeUnloadEvent", "BroadcastChannel", "CanvasGradient", "CanvasPattern", "CanvasRenderingContext2D", "CloseEvent", "CustomElementRegistry", "DOMStringList", "DOMStringMap", "DataTransfer", "DataTransferItem", "DataTransferItemList", "DedicatedWorkerGlobalScope", "Document", "DragEvent", "ErrorEvent", "EventSource", "External", "FormDataEvent", "HTMLAllCollection", "HashChangeEvent", "History", "ImageBitmap", "ImageBitmapRenderingContext", "ImageData", "Location", "MediaError", "MessageChannel", "MessageEvent", "MessagePort", "MimeType", "MimeTypeArray", "Navigator", "OffscreenCanvas", "OffscreenCanvasRenderingContext2D", "PageTransitionEvent", "Path2D", "Plugin", "PluginArray", "PopStateEvent", "PromiseRejectionEvent", "RadioNodeList", "SharedWorker", "SharedWorkerGlobalScope", "Storage", "StorageEvent", "TextMetrics", "TextTrack", "TextTrackCue", "TextTrackCueList", "TextTrackList", "TimeRanges", "TrackEvent", "ValidityState", "VideoTrack", "VideoTrackList", "WebSocket", "Window", "Worker", "WorkerGlobalScope", "WorkerLocation", "WorkerNavigator"];
</span><span class='line'>objects.forEach(o =&gt; interfaces.add(o));
</span><span class='line'>names = names.filter(e =&gt; !interfaces.has(e));
</span><span class='line'>console.log('\nnames after filtering HTML:')
</span><span class='line'>console.log(names)
</span><span class='line'>
</span><span class='line'>// 过滤i18n api
</span><span class='line'>names = names.filter(e =&gt; e != "Intl")
</span><span class='line'>console.log(names)
</span><span class='line'>
</span><span class='line'>/* Streams 标准
</span><span class='line'>    接下来我看到的属性是： ByteLengthQueuingStrategy。
</span><span class='line'>    同样经过查阅，它来自 WHATWG 的 Streams 标准：
</span><span class='line'>    https://streams.spec.whatwg.org/#blqs-class
</span><span class='line'>*/
</span><span class='line'>names = filterOut(names, ["ReadableStream", "ReadableStreamDefaultReader", "ReadableStreamBYOBReader", "ReadableStreamDefaultController", "ReadableByteStreamController", "ReadableStreamBYOBRequest", "WritableStream", "WritableStreamDefaultWriter", "WritableStreamDefaultController", "TransformStream", "TransformStreamDefaultController", "ByteLengthQueuingStrategy", "CountQueuingStrategy"]);
</span><span class='line'>console.log(names)
</span><span class='line'>
</span><span class='line'>/*
</span><span class='line'>    接下来我看到的属性是：WebGLContext​Event。
</span><span class='line'>    显然，这个属性来自 WebGL 标准：
</span><span class='line'>    https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.15
</span><span class='line'>*/
</span><span class='line'>names = filterOut(names, ["WebGLContextEvent","WebGLObject", "WebGLBuffer", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLShader", "WebGLTexture", "WebGLUniformLocation", "WebGLActiveInfo", "WebGLShaderPrecisionFormat", "WebGLRenderingContext"]);
</span><span class='line'>console.log(names)
</span><span class='line'>
</span><span class='line'>/*
</span><span class='line'>    Web Audio API
</span><span class='line'>    下一个属性是 WaveShaperNode。这个属性名听起来就跟声音有关，这个属性来自 W3C 的 Web Audio API 标准。
</span><span class='line'>    我们来看一下标准：
</span><span class='line'>    https://www.w3.org/TR/webaudio/
</span><span class='line'>*/
</span><span class='line'>names = filterOut(names, ["AudioContext", "AudioNode", "AnalyserNode", "AudioBuffer", "AudioBufferSourceNode", "AudioDestinationNode", "AudioParam", "AudioListener", "AudioWorklet", "AudioWorkletGlobalScope", "AudioWorkletNode", "AudioWorkletProcessor", "BiquadFilterNode", "ChannelMergerNode", "ChannelSplitterNode", "ConstantSourceNode", "ConvolverNode", "DelayNode", "DynamicsCompressorNode", "GainNode", "IIRFilterNode", "MediaElementAudioSourceNode", "MediaStreamAudioSourceNode", "MediaStreamTrackAudioSourceNode", "MediaStreamAudioDestinationNode", "PannerNode", "PeriodicWave", "OscillatorNode", "StereoPannerNode", "WaveShaperNode", "ScriptProcessorNode", "AudioProcessingEvent"]);
</span><span class='line'>console.log(names)
</span><span class='line'>
</span><span class='line'>/*
</span><span class='line'>    Encoding 标准
</span><span class='line'>    在我的环境中，下一个属性是 TextDecoder，经过查阅得知，这个属性也来自一份 WHATWG 的标准，Encoding：
</span><span class='line'>    https://encoding.spec.whatwg.org/#dom-textencoder
</span><span class='line'>*/
</span><span class='line'>names = filterOut(names, ["TextDecoder", "TextEncoder", "TextDecoderStream", "TextEncoderStream"]);
</span><span class='line'>console.log(names)
</span><span class='line'>
</span><span class='line'>/*
</span><span class='line'>    Web Cryptography API
</span><span class='line'>    我们继续看下去，下一个属性是 SubtleCrypto，这个属性来自 Web Cryptography API，也是 W3C 的标准。
</span><span class='line'>    https://www.w3.org/TR/WebCryptoAPI/
</span><span class='line'>    这份标准中规定了三个 Class 和一个 Window 对象的扩展，给 Window 对象添加了一个属性 crypto。
</span><span class='line'>*/
</span><span class='line'>names = filterOut(names, ["CryptoKey", "SubtleCrypto", "Crypto", "crypto"]);
</span><span class='line'>console.log(names)
</span><span class='line'>
</span><span class='line'>/*
</span><span class='line'>    Media Source Extensions
</span><span class='line'>    下一个属性是 SourceBufferList，它来自于：
</span><span class='line'>    https://www.w3.org/TR/media-source/
</span><span class='line'>    这份标准中包含了三个接口，这份标准还扩展了一些接口，但是没有扩展 window。
</span><span class='line'>*/
</span><span class='line'>names = filterOut(names, ["MediaSource", "SourceBuffer", "SourceBufferList"]);
</span><span class='line'>console.log(names)</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-期权思维]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/10/08/jingyingrike-qiquan/"/>
    <updated>2022-10-08T11:40:36+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/10/08/jingyingrike-qiquan</id>
    <content type="html"><![CDATA[<!-- more -->


<p>期货，英文option，你可以选，也可以不选，它是你的权利，不是义务。</p>

<p>可选项的重要性：安眠药放那心里就踏实，已经有一个大学录取你了再去参加高考就不会发挥失常。</p>

<p>期权是没有义务，但是它需要你花钱买：</p>

<ol>
<li>看涨期权call：未来某个时间点，你有权利以某一个价格买入。</li>
<li>看跌期权put：未来某个时间点，你有权利以某一个价格卖出。</li>
</ol>


<p>期权可以用来：</p>

<ol>
<li>投机，当杠杆用。做空</li>
<li>保险：对投资者，而不是投机者，期权其实是一个保险，是一个对冲风险的手段。

<ul>
<li>你可以一边持有一个股票，一边卖call</li>
</ul>
</li>
</ol>


<p>期权定价：</p>

<ol>
<li>股票当前价格</li>
<li>期权的到期时间</li>
<li>期权规定的股票的履约价格</li>
<li>固定的银行利率</li>
<li>股票的波动性：波动性越大，期权价格越高。因为你有权利挑好的，而没有义务负责坏的。

<ul>
<li>如果你有特权，你应该喜欢波动性，喜欢极端，喜欢两极分化。</li>
</ul>
</li>
</ol>


<p>其它：</p>

<ol>
<li>股票思维必须关注下限，考虑止损，而期权思维只关心上限。</li>
<li>自己开公司是股票思维，风险投资是期权思维。</li>
<li>奋斗是股票思维，演化（自然选择）是期权行为</li>
<li>结婚是股票思维，暧昧是期权思维</li>
<li>供给侧是股票思维，需求侧是期权思维</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-问题分类]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/10/08/jingyingrike-kunnandewenti/"/>
    <updated>2022-10-08T11:38:23+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/10/08/jingyingrike-kunnandewenti</id>
    <content type="html"><![CDATA[<!-- more -->


<p>问题可以分三类：</p>

<ul>
<li>单纯问题</li>
<li>两难问题</li>
<li>棘手问题</li>
</ul>


<h3>单纯问题</h3>

<p>高考，有明确的答案，明确的方向和明确的敌人。这个世界最危险的事情，就是某些人认为一切问题都是单纯问题。</p>

<h3>两难问题</h3>

<p>必须在两个选择中做出取舍。</p>

<h3>棘手问题</h3>

<ol>
<li>没有明确定义</li>
<li>没有终极答案</li>
<li>没有对错</li>
<li>采取措施之后不会（立马）得到反馈</li>
<li>没有试错练习的地方</li>
<li>有什么选项都不知道</li>
<li>没有先例</li>
<li>这个问题可能只是表象，背后可能还有更多的问题</li>
<li>多个利益相关方</li>
<li>如果你上手，那么不论什么结果，你都要负责</li>
</ol>


<p>比如贫富差距、全球变暖等问题
当瑞典女中学生指责各国政府对全球变暖应对不力等时候，当围观群众笑话特朗普对时候，其实都有点站着说话不腰疼。
不是我们不够努力，也不是敌人太坏，而是这个问题太棘手。</p>

<p>怎么处理棘手问题？不能解决，只能应对，应该追求管理这个问题。就像我们应对癌细胞一样。</p>

<ol>
<li>利益相关方充分沟通，不求达成共识，但求互相理解，消除一些偏见。</li>
<li>公司决策相关的棘手问题，不妨想想公司的认同感和意义。</li>
<li>行动。摸着石头过河。每次一小步，边做边调整。就这么应对着，跟着问题一起演化。也许一段时间之后，它就被别的问题取代了。</li>
</ol>


<p>单纯的人总希望一劳永逸地解决一个问题。这种理想主义者一旦受挫，又会心灰意冷，成为一个愤世嫉俗的人。他以为别人都自私就他自己真想解决问题，可是他又解决不了问题。</p>

<p>殊不知，那些顶着骂名，从来没有做过一件快意事，小心翼翼不敢用力过猛，明知没有胜利的彼岸还在吭哧吭哧地维持着局面的人，才是真正值得尊敬的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-计算机不能做所有的事情]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/10/08/jingyingrike-jisuanjibunengzuodeshiqing/"/>
    <updated>2022-10-08T11:35:59+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/10/08/jingyingrike-jisuanjibunengzuodeshiqing</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>计算机不能做所有的事情</h2>

<ul>
<li>停机问题： 不存在这样一个程序（算法），它能够计算任何程序（算法）在给定输入上是否会结束（停机）。

<ul>
<li>理发师悖论</li>
<li>全能悖论</li>
<li>说谎者悖论</li>
</ul>
</li>
<li>Y conbinator</li>
<li>哥德尔不完备性定理，击碎了希尔伯特的美好愿景

<ul>
<li>这理论用在人工智能上，则指出有些道理可能是人类能够判别，但机器单纯用一阶公理化系统却无法得知的道理。不过机器可以用非一阶公理化系统，例如实验、经验。</li>
</ul>
</li>
<li>康托尔对角线定理</li>
</ul>


<p>哥德尔的不完备性定理震撼了20世纪数学界的天空，其数学意义颠覆了希尔伯特的形式化数学的宏伟计划，其哲学意义直到21世纪的今天仍然不断被延伸到各个自然学科，深刻影响着人们的思维。图灵为了解决希尔伯特著名的第十问题而提出有效计算模型，进而作出了可计算理论和现代计算机的奠基性工作，著名的停机问题给出了机械计算模型的能力极限，其深刻的意义和漂亮的证明使它成为可计算理论中的标志性定理之一。丘齐，跟图灵同时代的天才，则从另一个抽象角度提出了lambda算子的思想，与图灵机抽象的倾向于硬件性不同，丘齐的lambda算子理论是从数学的角度进行抽象，不关心运算的机械过程而只关心运算的抽象性质，只用最简洁的几条公理便建立起了与图灵机完全等价的计算模型，其体现出来的数学抽象美开出了函数式编程语言这朵奇葩，Lisp、Scheme、Haskell… 这些以抽象性和简洁美为特点的语言至今仍然活跃在计算机科学界，虽然由于其本质上源于lambda算子理论的抽象方式不符合人的思维习惯从而注定无法成为主流的编程语言[2]，然而这仍然无法妨碍它们成为编程理论乃至计算机学科的最佳教本。而诞生于函数式编程语言的神奇的Y combinator至今仍然让人们陷入深沉的震撼和反思当中…</p>

<p>参考：</p>

<ul>
<li><a href="https://www.infzm.com/contents/76948">【专栏】康托尔、哥德尔、图灵——永恒的金色对角线（1）</a></li>
<li>&hellip;</li>
<li><a href="https://www.infzm.com/contents/77590">【专栏】康托尔、哥德尔、图灵——永恒的金色对角线（13）</a></li>
</ul>


<p>用计算模拟真实世界，解释不了很多根本原因，但是不用解释。比如足球比赛，打仗胜败分析。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-杂想]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/10/07/jingyingrike-zaxiang/"/>
    <updated>2022-10-07T23:38:46+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/10/07/jingyingrike-zaxiang</id>
    <content type="html"><![CDATA[<!-- more -->


<h3>基因与开关</h3>

<ol>
<li>基因决定生成什么蛋白，开关决定要不要生成这种蛋白。</li>
<li>基因先天决定，开关环境决定。</li>
<li>基因，基因表达，基因开关，环境影响基因表达，饥饿环境，穷人富人行为</li>
<li>蝌蚪出生时环境决定自己的行为</li>
<li>鸟宝宝</li>
</ol>


<h3>父母类型</h3>

<ul>
<li>权威型父母：高响应，严要求</li>
<li>专制型父母：低响应，严要求</li>
</ul>


<h3>搜索的喜悦</h3>

<ol>
<li>《搜索的喜悦》</li>
<li>google earth</li>
<li>谷歌搜索技巧1008</li>
<li>搜索引擎和淘宝，淘宝不暴露给搜索引擎。一些公司在特定领域瓜分搜索引擎的份额。</li>
</ol>


<h3>路径反噬与路径依赖</h3>

<ul>
<li>路径反噬0830</li>
<li>路径依赖，键盘布局，正反馈，蜜蜂</li>
</ul>


<h3>《模型思考者》</h3>

<ol>
<li>数据->信息->知识->智慧（主观会选模型，敢选模型）</li>
<li>内隐学习，外显学习</li>
<li>股票有效市场，人们的充分分析导致市场趋向于有效，有效市场中分析的作用降低，导致很少人分析，很少人分析导致市场趋向于无效，会有更多的人进行市场分析。</li>
</ol>


<h3>概率分布</h3>

<ol>
<li>什么条件满足正态分布？

<ul>
<li>多个独立随机变量相加</li>
</ul>
</li>
<li>对数正态分布

<ul>
<li>多个独立随机变量相乘</li>
</ul>
</li>
<li>幂律分布

<ul>
<li>更容易出现极端情况</li>
</ul>
</li>
</ol>


<h3>稳态</h3>

<ul>
<li>碗底的小球</li>
<li>急诊拥挤改善没用，因为拥挤是稳态：当改善场地不拥挤的时候，很多不着急的病人也会来看急诊，直到急诊拥挤。当急诊过于拥挤的时候，一些不那么着急的病人就不会来看急诊。</li>
<li>早晚高峰拥挤是稳态，道理和急诊一样。</li>
</ul>


<p>稳态和非稳态
* 稳态（负反馈）
  * 鸽派和鹰派的人口比例
  * 左右手人口比例
  * 重感情和重物质的人口比例
* 非稳态（正反馈）</p>

<h3>极简生活</h3>

<ul>
<li>极简生活，日本，有川真由美</li>
<li>极简生活是奢侈生活，选择多</li>
<li>你敢极简生活，是因为你随时可以不极简生活，有备选方案</li>
<li>有些人不敢极简生活，是因为万一出问题，自己没有其他选择</li>
<li>一个用钱规避风险，一个用物质的备份规避风险</li>
</ul>


<h3>女权主义过头啦</h3>

<p>0702</p>

<h3>5G+VR/AR/MR</h3>

<p>0628</p>

<ul>
<li><p>足球直播
以前的足球直播是摄像机视角，现在可以：</p>

<ol>
<li>360度视角</li>
<li>足球视角：跟着足球走</li>
<li>明星视角：跟着某个明星走</li>
<li>裁判视角：跟着裁判走</li>
</ol>
</li>
<li><p>元宇宙</p>

<ul>
<li>远程控制延伸想象</li>
</ul>
</li>
</ul>


<h3>科学和宗教信仰的区别</h3>

<p>宗教信仰重结论，科学重过程方法，</p>

<h3>厚黑学0625</h3>

<h3>西方文明的道统</h3>

<p>圣经提供意义，古希腊哲学家提供理性</p>

<h3>专才和通才</h3>

<ul>
<li>通才：

<ul>
<li>费德勒：选择网球之前接触过多种运动，11岁才选择网球，16岁开始接受专业训练。纳达尔也是从足球和网球中选择的网球。</li>
</ul>
</li>
<li>专才：

<ul>
<li>老虎伍兹：神童</li>
</ul>
</li>
</ul>


<p>通才的两个有点：</p>

<ol>
<li>容易有内驱力：从小被父母安排的生活总感觉不是自己选择的。</li>
<li>广度能让你更深入</li>
</ol>


<p>专业确定太早，初期成功，后劲不足。基础很重要，大三选专业</p>

<p>功夫在诗外，说的是在牢固基础之上创新所需要的思维和积淀</p>

<p>体育和音乐是童子功，需要年轻的时候出成果。数学也是</p>

<h3>思考问题的两个思路：</h3>

<ol>
<li>完美主义：先考虑做100分（终结问题），不行再考虑90分</li>
<li>实用主义：直接考虑做60分，做到就停</li>
</ol>


<h3>知之者不如好之者，好之者不如乐之者</h3>

<p>乐之者，做前特别期待，做的时候能快速进入心流状态，做成之后有成就感。刻意练习会让人不舒服，只有乐之者才能坚持下去，从而达到优异。</p>

<p>努力做个乐之者。保证工作中百分之二十的事情是乐之的事情，就会开心的工作。</p>

<h3>如何当领导？</h3>

<ul>
<li>定目标的缺点，达标后就放慢，不达标容易违法</li>
<li>目标只是让高层更舒服而已吧</li>
<li>高层提供信息和使命的意义</li>
<li>不给目标给意义，讲哲学</li>
<li>不给计划给信息</li>
<li>夸长处，没有专业技能就说个人感受，比如，我喜欢。夸和指责之间的比例三比一到五比一。夸和指责都应该对事不对人。</li>
</ul>


<h3>马斯洛金字塔</h3>

<ul>
<li>人总是高估自己在金字塔上的层次，低估别人在金字塔上的层次</li>
<li>认为别人物质，自己理想主义，认为别人都是坏人，自己做坏事的时候却总是迫不得已</li>
</ul>


<h3>逻辑与直觉</h3>

<ul>
<li>哥德尔逻辑不完备性</li>
<li>人工智能，纯逻辑？能认知世界吗？</li>
</ul>


<h3>灰度认知</h3>

<ul>
<li>思圆行方，邓小平</li>
<li>灰度认知，黑白决策</li>
<li>灰度认知，灰度决策，黑白执行（模糊数学）</li>
</ul>


<h3>先发优势与后发优势</h3>

<ul>
<li>先发优势：定义产品和服务，占据消费者喜好，申请专利</li>
<li>后发优势：借鉴前人的经验教训</li>
</ul>


<h3>个性化推荐</h3>

<p>个性化推荐，共性推荐
根本就不存在什么个性化推荐。</p>

<h3>怎样提高欢迎度？</h3>

<p>当周围人都对你友好的时候，你也会变得友好。这就是为什么你带着两岁的娃在外的时候，更容易和其他人通过娃拉近距离。</p>

<h3>怎样跟人快速建立亲密关系？</h3>

<ul>
<li>肢体触碰</li>
<li>自爆弱点缺点</li>
</ul>


<h3>怎样对抗进化？</h3>

<p>克制杀戮，阻断害虫抗药性。保证一定数量的没有抗药性的害虫的数量，可以弱化抗药性进化速度。<strong>不灭绝，只控制</strong>，是一种智慧。这不正是中庸之道吗。
禁赌令产生地下赌场，禁酒令产生地下酒交易，禁海令产生海盗和倭寇。试图将事情做绝就会产生副作用。</p>

<h3>对于自己不想回答的问题，怎么不说谎？</h3>

<p>用相关的事实去误导别人。
当别人意识到的时候，同样会生气，会鄙视你的人格，但至少不会鄙视你的智商。</p>

<h3>实在的美国精英</h3>

<p>在一线打拼的人告诉你应该怎么做，而不是结合了儒道佛等玄学之后给你形而上的讲一些大道理，但就是不愿意跟你一起落实到细节上去。</p>

<h3>如何保持快乐</h3>

<p>少见多怪，多见不疑</p>

<p>快乐的两种方式
* 增加时间间隔
* 追求多样性</p>

<p>如何选择这两种方式？
* 浅的东西用间隔，比如好吃的东西不要太频繁吃，也不要吃太多。
* 深的东西自带多样性。</p>

<p>用金钱调节，还是用时间调整。</p>

<h3>解释性框架</h3>

<p>解释性框架，不能通过一两个反例否定，没有固定的实验去验证真伪，比如社会科学，经济学等。</p>

<h3>余闲</h3>

<p>余闲，slack，不是一直处于拼命状态，把时间安排的可丁可卯，那种状态是没时间思考的，是工具人，是奴隶。余闲有选择的余地，有创新的可能，诺贝尔奖的初衷就是给你一笔钱，让你不用为生计发愁，可以自由创新。</p>

<ol>
<li>穷人愈来愈穷，技术差的人愈来愈差</li>
<li>马太效应</li>
<li>正反馈</li>
</ol>


<h3>强人哲学与弱者哲学</h3>

<ul>
<li>阿德勒，强人哲学，所有的性格问题都是自己的选择。</li>
<li>弗洛伊德，弱者哲学，所有的性格问题都是过往经历决定的，决定论。</li>
</ul>


<h3>OpenAI</h3>

<ol>
<li>gpt3: text completion, article generation, conversation</li>
<li>DALL·E: Creating Images from Text</li>
<li>Codex: code completion. (Copilot)</li>
</ol>


<h3>关于量子力学</h3>

<ul>
<li>粒子的波函数能超越时空获得信息，进而影响粒子的行为。</li>
<li>波函数到底是不是客观实在，还是纯数学？</li>
<li>波函数坍缩是瞬时的，退相干是逐渐的。此过程长短取决于粒子数多少。宏观物体有叠加态，只是退相关过程太短，所以察觉不到。这个可以解释薛定谔的猫。

<h3>愿望思维，严重导致确认偏误</h3></li>
<li>吸引力法则： 如果你整天想象自己能得到一个什么东西，那个东西就会自动来找你。这是迷信，是错误的认知。</li>
<li>自证预言：是一个具有普遍意义的现象，是你在明明还有选择的情况下，以为事情是个什么状况，就按照这个状况去做，结果事情就真的被搞成了那个状况。比赛明明还有的打，我以为自己已经输了，结果自暴自弃，最后果然输了。</li>
<li>皮格马利翁效应：是你希望别人是什么样子，你就像他是这个样子一样去对待他，这样他被你影响，慢慢就真的变成了那个样子。</li>
<li>愿望思维：把美好的愿望当作真实。分不清楚“希望”和真实。</li>
<li>确认偏误：（或称确认偏差、证实偏差、肯证偏误、验证偏误、验证性偏见、我方偏见，英语：Confirmation bias）是个人选择性地回忆、搜集有利细节，忽略不利或矛盾的资讯，来支持自己已有的想法或假设的趋势。</li>
</ul>


<p>拿男生追女孩那个例子来说。</p>

<ol>
<li>“自证预言”，是男生稳扎稳打地、但是是符合常规操作地去追求这个女孩。可能先在她面前好好表现，再送花、再请看电影，慢慢再表白……</li>
<li>“皮格马利翁效应”，是男生每天就把这个女孩当做自己的女朋友去相处。不整那些前期的花哨功夫，一上来就天天给送饭，让女孩产生自己早就是她女朋友的错觉。</li>
<li>“吸引力法则”，是男生不敢跟女孩说话，天天躲在宿舍里思念女孩，在脑子里演练跟女孩在一起的点点滴滴，指望通过心灵感应之类的超自然力量得到女孩的爱。</li>
<li>而“愿望思维”，则是男孩说：她肯定喜欢我啊！我那么爱她她怎么可能不喜欢我呢？

<h3>精英日课反对王东岳的递弱代偿理论</h3></li>
</ol>


<p>“递弱代偿”，就是说世间之物，后衍物种的生存强度（生存的顽强程度）总是呈现递减态势，一代比一代弱，于是，要想生存下去，就得不断地寻找更多的支持因素，这个支持因素就是“代偿”。</p>

<p>越原始越低级的物质存在形态存在度反而越高，越高级越进化的物质存在形态或物种存在度越低。</p>

<p>存在度有三项硬指标：
* 其一在宇宙中的空间质量分布越大
* 其二在宇宙中的时间分布越长
* 其三存在状态越稳定。</p>

<h3>第一性原理，改变原来的模式，根本上降低原来的价格</h3>

<h3>辉格史观</h3>

<p>辉格史观是胜利者角度的历史观。与之相对的是：历史现场角度。</p>

<p>辉格史观者相信在历史学中存在演变的逻辑，他们用现在的标准评判过去。用通俗的话语来讲，即辉格史观描述的一切历史都是基于现在为出发点，传达的历史都是为现在做服务。</p>

<h3>0514马歇尔效应罗森效应，高级，势能动能，品牌现金，热寂，逆商</h3>

<h3>汉隆剃刀</h3>

<p>能解释为愚蠢的，就不要解释为恶意。</p>

<h4>恶意循环</h4>

<p>在工作上，同事没有对展示文件的错误进行修改，导致自己做展示的时候被领导发现错误，最后被训话。恶意的循环就是从这里开始的，会不会是同事故意这样做的，想要毁了我的职业生涯。然后两个人就开始互相看不顺眼，互相的使绊子，最后影响到公司的正常运营，两个人都被公司开除了。每一次埋怨都会加深自己的看法，然后导致下一次行动出现问题。不论是怎么样，最后的结果肯定都是以悲剧收场。这就像一个恶意的循环，每循环一次就会加深恶意。</p>

<p>其实第一次可能就是因为同事前一天生病加班给漏掉了。自己也没检查，出现了问题。在聪明的人也会犯错，但区别在于聪明的人会避免重复犯同样的错误。汉隆的剃刀是帮助我们从感性走向理性的绝佳工具，这时候最正确的做法应该是与他人沟通，找到避免下次犯错的方法才是正解。如果陷入了恶意循环，是很难看到问题到底出现在哪里。</p>

<h3>逆火效应</h3>

<p>逆火效应（the backfire effect）是指：当一个错误的信息被更正后，如果更正的信息与人原本的看法相违背，它反而会加深人们对这条（原本）错误的信息的信任。</p>

<h3>其它</h3>

<ul>
<li>世俗的成功驱使着你做事情，世俗的成功也就是别人的认可。别人的认可不应该成为最终目标，而应该只是副产品。</li>
<li>被讨厌的勇气，生活哲学</li>
<li>穷人靠环境，富人靠天赋，因为富人环境优越，天花板取决于天赋，而穷人环境限制了天赋的发挥。轮不到你发挥天* 赋。</li>
<li>0729

<ul>
<li>黑客工具系统</li>
<li>全球目录</li>
</ul>
</li>
<li>高效能人士，本质是把事情交给外部系统或者其他人，付出的可能是金钱</li>
<li>负反馈，囚徒困境，高考刷题，美颜，信用分，搜索引擎排名</li>
<li>kargo网站解决棘手问题，类似于ai领域的？？？</li>
<li>我是谁，我适合做什么？是要在行动中去寻找的。</li>
<li>达芬奇诅咒</li>
<li>思而不学则极端，学而不思则矛盾</li>
<li>蒙台梭利让孩子玩，孩子也可以在家玩，这两种没有区别。只要不学习知识或者技能训练就可以。</li>
<li>学英语，用最重要，突击刻意练习次之，每天二十分钟最差。口音不是问题，比如印度英语。</li>
<li>尽量避免传递坏消息。传递坏消息给国王的信使被射杀，传递坏消息的员工被记恨。</li>
<li>群体选择，好人坏人：群体中的坏人打败好人，好人群体打败坏人群体。</li>
<li>有些特征是物理规律决定的，比如雪花形状，有些特征是演化形成的，比如体型大小，经典的设计产品（手机）等。</li>
<li>正确的人和优异的人</li>
<li>对于别人的诋毁，弱者报复，强者原谅，智者忽略（爱因斯坦）</li>
<li>谈判要逐步深入，逐渐加码，摩尔不破</li>
<li>你的价值取决于你克服了多少不确定性。</li>
<li>远虑包装成近忧，重要包装成紧急，才能获得批准去做。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-反脆弱]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/10/07/jingyingrike-fancuiruo/"/>
    <updated>2022-10-07T23:29:22+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/10/07/jingyingrike-fancuiruo</id>
    <content type="html"><![CDATA[<!-- more -->


<p>好运气，你能把它的效果最大化，坏的危险，你能把它限制在可控的范围之内。这简直就是人生的核心算法。</p>

<p>参考知乎文章：<a href="https://www.zhihu.com/question/269850841/answer/2594292784">脆弱的反面是什么？是坚强吗？ 不！脆弱的反面是“反脆弱”！？</a></p>

<p>反脆弱一书主要讲述三方面的内容：</p>

<ol>
<li>什么系统是反脆弱的？</li>
<li>为什么发达的现代社会让我们变得更加脆弱？</li>
<li>如何构建自己的反脆弱性</li>
</ol>


<h2>什么系统是反脆弱的？</h2>

<blockquote><p>所谓的反脆弱系统，其实就是正反馈系统，比如书中说的感情系统和信息传播系统。其实还有沼泽地，越动下沉的越快。</p></blockquote>

<p>熟悉期权交易的童鞋可能会很了解，long Gamma做多波动率的交易策略就是反脆弱，不过这里会用更通俗的方法来解释这个名词。举个简单的例子，少年少女之间的痴情就是真正的反脆弱，，无论被爱慕的那个人做什么。都会增加爱慕者的爱慕，甚至在极端的痴情案例中，即便被爱慕的人虐待，爱慕者也会因为斯德哥尔摩症更爱他。也就是说，无论被爱慕者对爱慕者关怀备至还是拳打脚踢，都会导致更深的爱。</p>

<p>这种无论怎么波动，都会变的更牢固的痴情，自然是反脆弱的。与此类似的是，粉丝对明星的爱也是反脆弱的。无论自己家爱豆是彬彬有礼还是酒驾闯祸，无论演的好不好，这种感情都会随着偶像的好或者坏的言行而逐渐加深。再举一个感情相关的例子，为什么失恋难以走出来？因为失恋也是真正的反脆弱，无论你想采取什么样的方式让自己走出来：否认之前的感情、给自己找理由、反思自己哪里做的不对，都只能让自己变的更加思念对方，陷的越来越深。当然，具有反脆弱特点的事物远远不限于感情，信息就是另外一个反脆弱的例子，你很难控制信息的走向，你越是封杀信息、攻击信息，信息就传播的越快，假设有人散布关于你的谣言，如果你坐卧不安，到处向别人解释，这些事情都是纯属捏造，一派胡言，那这个谣言很快就会满天飞。还有新闻的热点、假如你成为新闻热点、微博热搜，无论怎么解释，否认或者试图封锁消息，都只能是火上浇油，让热点越烧越旺，最终人尽皆知。再比如说很多禁书，其实没有那么出名，但是被禁之后很快流传开来，塔勒布就提到了自己人生读完的第一本书英国作家格雷姆的《权利与荣耀》，这是一本梵蒂冈的禁书，而塔勒布读这本书的唯一目的就是想搞懂为啥这本书会被封禁。</p>

<p>感情、信息本身就是反脆弱的，但也有一些事物，虽然本身是脆弱的，不过由他们组成的系统却是反脆弱的，餐饮行业就是一个典型的反脆弱的案例，虽然顾客的口味一直在变，但是一旦有一家饭馆因为不符合大众主流口味而倒闭啦！其他餐馆都会意识到问题，改进自己的饭菜口味，从而使得整个餐饮行业更加符合顾客的需求，更加欣欣向荣！但是如果在某个时期，顾客并无法选择餐馆，比如说：人民公社时期的饭馆或者大学食堂，餐馆就无法获得顾客的反馈，从而变的非常脆弱，一旦顾客有了更多的选择，原来的餐馆都会面临更大的风险。与餐饮行业类似，航空业也是一个反脆弱的很好的例子，如果有一架飞机不幸失事了，全世界的航空公司和飞机制造商都会总结原因，吸取教训，改进系统，从而让飞机作为一种出行方式，变的越来越安全。而不同于餐饮、航空业的是，在塔勒布眼里，银行系统则是一个脆弱系统的典型，并且在现在的体制下会越来越脆弱：不同的银行之间联系相对紧密，因此整个银行系统都存在系统性风险。如果一家银行倒闭了，因为系统性风险的存在，为了保持金融稳定，政府只能介入救助不让银行破产，但这却让整个银行系统更脆弱了。从而使得银行抗风险的能力远远不如餐饮业和航空业，一旦遇到金融危机这种黑天鹅事件，就会有灾难性的后果出现。为了更直观地说明脆弱和反脆弱的区别，塔勒布还在书中虚构了约翰和乔治一对兄弟，对比了一下兄弟二人的职业。哥哥约翰是一个人力资源专家，有着稳定的收入，完善的福利。他带着金手表，有着25年工作经验的他每年定期休假25天。在每个月月初，约翰的银行账户里都会稳定的多出3082欧收入，他会拿其中的一部分来还房贷，一部分用来吃吃喝喝，剩下一点点存起来。约翰的弟弟乔治则是一名出租车司机，他的收入则十分的不稳定，有些日子乔治能挣几百欧，但是日子差的时候甚至挣不回油钱，平均下来乔治和约翰差不多，但是乔治却常常抱怨自己的收入太不稳定了，工作不想自己的哥哥那样是个铁饭碗。通常人看起来，人力资源专家约翰的工作是稳定的，因此也更好，但是塔勒布则认为乔治的工作是反脆弱的，这种工作状态才是稳定的，塔勒布在书中写到，人们往往认为波动性就是风险本身，致力于消除波动性，但是波动性能带来信息，经常面对波动性的人能从波动性中获取有效的信息，并不断根据信息来改善自己，提高自己的抗风险能力，从而成为反脆弱的人，即使世事动荡，仍然能茁壮成长。而致力于消除自己生活中波动性的人，则可能因为长时间得不到外界的反馈，没有办法调整自己的能力和知识结构，虽然在一段时间内能过上表面上波澜不惊的生活，但是如果黑天鹅事件发生，突如其来的巨大波动性很可能会瞬间毁灭他的生活并再也无法平复。这也是反脆弱理念的核心。总的来说，面对外界环境的波动，反而会成长的事物，就是反脆弱的，反之则是脆弱的。</p>

<p>那么，如何消灭一个反脆弱的事物呢？说简单也简单，反脆弱的事物是依据波动性成长的，消灭波动性就好了。比如走出失恋最好的方式是删掉一切联系方式，去一个新地方生活，停止接受一切信息；消灭微博热点的最好方式不是去否认它，而是发起另外一个热点。说难也真的挺难的，在这个事物普遍联系，时时都在变化的世界，消灭波动性几乎是不可能。以上就是这本书的第一个要点，反脆弱的定义。从不确定性中受益的事物就是反脆弱。</p>

<h2>为什么发达的现代社会让我们变得更加脆弱？</h2>

<p>现代社会使用一切手段让我们的生活变的更轻松，费尽心思消除社会和我们生活中的不确定性，从央行稳定经济体系，到老师手把手地教学生知识，到稍有不适医生就开一大堆药。这种过度干预反而剥夺了我们成长的机会，让我们变的愈加脆弱，讲完了反脆弱的定义，为什么现代社会为什么会让我们变的脆弱，</p>

<h2>如何构建自己的反脆弱性</h2>

<p>首先，要改变自己的三大认知。</p>

<ol>
<li>放弃任何预测未来的想法，世界是不可被预测的。我们的世界纷繁复杂，普遍联系，存在着各种非线性相关性。预测未来根本不可能。</li>
<li>因为世界是不可被预测的，所以风险是不可能被测量的，但我们能测量出自己是不是脆弱的，因此可以有针对性的提高自己的反脆弱能力，简单来讲，做压力测试就可以了，假设极端情况发生，如果我们的收益曲线是凸性的，二阶导大于0，我们就是反脆弱的，我们的收益曲线是凹性的，二阶导小于0，我们就是脆弱的；</li>
<li>要认识到波动和不确定性并不能消除风险，这样只是把风险隐藏起来罢了，适度拥抱不确定性，适度拥抱风险，能让我们更健康的成长，这也是构建反脆弱性的前提。</li>
</ol>


<p>总结一下，就是我们要有一种认知，我们不必认知世界，不必理解世界，只要构建好自己的反脆弱性，也能过的很好，并且很好地抵御风险。</p>

<p>此外，塔勒布还提出了五种具体构建反脆弱的方法</p>

<ol>
<li>留出足够的冗余。脆弱的系统之所以脆弱，根本原因是他们把效率当头等大事，往往孤注一掷，因此抗风险能力极差。而对于反脆弱的系统，活下来才是头等大事，所以优秀的反脆弱系统都会留有充足的冗余，这样才能有应对风险的底气。大自然就给予我们两个肺、两个肾脏，这样虽然效率不高，但是却是必要的冗余。</li>
<li>给自己适度的压力和挑战，促使自己成长。不要贪图表面安逸的生活，意识到波动和不确定性的信息是非常珍贵的，适度的压力反而能促使我们成长，成为反脆弱的事物。</li>
<li>采用杠铃策略。杠铃策略其实也是塔勒布从债券交易中借鉴过来的概念，杠铃策略是指，在债券交易中不买中等期限的债券，只买超短期的债券和超长期的债券，这样无论利率是上升还是下降，都能从中获益。这种两头大，中间空的策略，神似杠铃，所以叫杠铃策略。塔勒布把这种策略扩展到了生活之中，认为应当抛弃中间路线，要努力构建超低风险加超高风险的组合，超低风险用来守底，超高风险用来博取收益。</li>
<li>多做减法，塔勒布在书中提到，虽然我们很难搞清楚怎么才能构建自己的反脆弱性，但是我们却能很容易地发现，是什么让我们变的更加地脆弱，这时候，只要我们多做减法，去掉这些让我们变的脆弱的东西，我们自然就变的反脆弱了，例如：包括债务、损友、垃圾食品等等。</li>
<li>多给自己一些选择权。这一点是显而易见的，当风险来临的时候，肯定是选择权越多的人越反脆弱，例如：作为一个程序员，你完全可以利用每周多出来的时间进行写作，保持自己写作的良好习惯，当一个斜杠青年；</li>
</ol>


<p>总结一下，我们为了构建反脆弱性。可以运用五种方法：留够冗余、给自己适当的压力、采用杠铃策略、多做减法、多给自己选择权。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/07/27/jingyingrike/"/>
    <updated>2022-07-27T22:29:43+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/07/27/jingyingrike</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>博弈论</h2>

<p><a href="http://hongchaozhang.github.io/blog/2022/07/27/jingyingrike-boyilun/">《精英日课-博弈论》</a></p>

<h2>《反脆弱》（那西姆塔勒布）</h2>

<p><a href="http://hongchaozhang.github.io/blog/2022/10/07/jingyingrike-fancuiruo/">《精英日课-反脆弱》</a></p>

<h2>计算机不能做所有的事情</h2>

<p><a href="http://hongchaozhang.github.io/blog/2022/10/08/jingyingrike-jisuanjibunengzuodeshiqing/">《精英日课-计算机不能做所有的事情</a></p>

<h2>问题的类型</h2>

<p><a href="http://hongchaozhang.github.io/blog/2022/10/08/jingyingrike-kunnandewenti/">《精英日课-问题的类型》</a></p>

<h2>期权思维</h2>

<p><a href="http://hongchaozhang.github.io/blog/2022/10/08/jingyingrike-qiquan/">《精英日课-期权思维》</a></p>

<h2>杂想</h2>

<p><a href="http://hongchaozhang.github.io/blog/2022/10/07/jingyingrike-zaxiang/">《精英日课-杂想》</a></p>

<h2>伯克森悖论</h2>

<p><a href="http://hongchaozhang.github.io/blog/2022/12/08/jingyingrike-bokesenbeilun">《精英日课-博克森悖论》</a></p>

<h2>思维是平的</h2>

<p><a href="http://hongchaozhang.github.io/blog/2022/12/08/jingyingrike-siweishipingde">《精英日课-思维是平的》</a></p>

<h2>排序不等式</h2>

<p><a href="http://hongchaozhang.github.io/blog/2022/12/08/jingyingrike-paixubudengshi">《精英日课-排序不等式》</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精英日课-博弈论]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/07/27/jingyingrike-boyilun/"/>
    <updated>2022-07-27T22:29:10+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/07/27/jingyingrike-boyilun</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>博弈论11 混合策略</h2>

<p>下面是常见的两个博弈论的问题和一般人的想法：</p>

<ul>
<li>踢点球：左右方向各百分之五十。</li>
<li>德州扑克：牌好就加注，牌不好就弃牌。</li>
</ul>


<p>以上都不是最佳策略，因为：</p>

<ul>
<li>踢点球：如果你往左进门概率是60%，往右进门概率是80%，那么守门员只用防右边就好了。</li>
<li>德州扑克：对手看你加注就弃牌。</li>
</ul>


<p>在这种情况下，应该采取<strong>混合策略</strong>：</p>

<ul>
<li>踢点球：应该结合自己左右方向的进球能力调整左右方向的射门概率，让守门员不管往哪个方向扑，你进球的概率都是相同的。也就是说，你的混合概率选择，应该把对手能得到的最大收益最小化。</li>
</ul>


<h3>真随机才是真正的诡道。</h3>

<ul>
<li>打网球是攻击对方正手还是反手？</li>
<li>足球篮球中，多大概率将球交到球星手里才能最大化进球数？</li>
<li>田忌赛马，齐宣王的最好办法就是采用混合策略：真随机地分配出场顺序。</li>
</ul>


<p>混合策略不是阴谋是阳谋：阴谋被识破就失效了，但是阳谋不怕被识破。归根结底，大家都是纳什均衡的奴隶。</p>

<h2>博弈论12 怎样筛选信号</h2>

<h3>如何解决信息不对称，让信息可信？</h3>

<ol>
<li>产品已经很好了，还要请明星代言，天价广告费，没啥用。</li>
<li>大学学习的是那么艰难又不实用的东西，还要花很多时间</li>
<li>公共场合吹捧领导，那么肉麻，有失体面</li>
</ol>


<h3>要让别人相信你说的话（产品好，有实力），你要主动“发信号”。</h3>

<ol>
<li>为了让别人相信你卖的二手车质量好，你可以提供一个保修合同。</li>
<li>天价广告费，沉没成本，做长期生意的决心。</li>
<li>花时间上大学，是为了证明自己的能力</li>
<li>吹捧领导，损失个人形象，是为了证明忠诚。</li>
</ol>


<h3>如果别人没有主动发信号，如何让他发信号？</h3>

<h4>逆向选择和正向选择</h4>

<p>保险公司有个困境：主动来投保的都是急需要保险的，而最需要保险的人却是保险公司最不想要的人。保险公司因此要提高保费，这样，原来不愿意投保的就更不会来了。这就是逆向选择：你选出来的都是你不想要的。
要解决这个问题，有两个方案：</p>

<ol>
<li>全民强制保险</li>
<li>价格歧视</li>
</ol>


<p>例子：</p>

<ul>
<li>申请美国大学要填写复杂的申请表，这个也不是必须的，但是有作用：筛选出自认为有能力同时又有诚意的学生。</li>
<li>保险公司让用户选择不同的保险方案。</li>
</ul>


<h2>其它问题</h2>

<h3>纳什均衡</h3>

<ol>
<li>纳什均衡，其实就是物理里面的稳态(负反馈)</li>
<li>纳什均衡是博弈的终点</li>
<li>有人的对抗和无人的对抗</li>
<li>理性青年追求纳什均衡，完美青年追求帕累托最优</li>
<li>复习补课是纳什均衡</li>
</ol>


<h3>公地悲剧</h3>

<p>如何打破公地悲剧？</p>

<h3>囚徒困境</h3>

<p>如何打破囚徒困境？</p>

<ul>
<li>谁是胆小鬼，汽车相向而行。首先拔掉方向盘，想对方表达自己的决心。</li>
<li>核威慑</li>
<li>事前最优事后最优，“老师，你要是让我不及格，我会报复你”，事前管用，事后不一定管用。</li>
<li>断自己的后路，给对方增加后路，比如孙子兵法要求围师必阙，在包围敌人的时候最好留一个缺口，防止困兽犹斗。</li>
<li>声望好，可以代价很小而取信于人。</li>
<li>价格匹配，保证是全网最低价</li>
</ul>


<h3>其它</h3>

<ul>
<li>博弈，新博弈，更新的博弈，螺旋上升</li>
<li>博弈次数的多少，决定了我用正义策略还是邪恶策略。熟人社会，古代中国，正义策略</li>
<li>文明世界，正确对待博弈的对手和博弈的失败</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[程序员的数学基础课（黄申）]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/05/31/chengxuyuan-shuxue-jichuke/"/>
    <updated>2022-05-31T15:48:14+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/05/31/chengxuyuan-shuxue-jichuke</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>01-开篇词 (1讲)</h2>

<h3>00丨开篇词丨作为程序员，为什么你应该学好数学？</h3>

<h2>02-导读 (1讲)</h2>

<h3>00丨导读：程序员应该怎么学数学？</h3>

<h2>03-基础思想篇 (18讲)</h2>

<h3>01丨二进制：不了解计算机的源头，你学什么编程</h3>

<h3>02丨余数：原来取余操作本身就是个哈希函数</h3>

<h3>03丨迭代法：不用编程语言的自带函数，你会如何计算平方根？</h3>

<h4>迭代法有什么具体应用？</h4>

<p>迭代法在无论是在数学，还是计算机领域都有很广泛的应用。大体上，迭代法可以运用在以下几个方面：</p>

<ol>
<li>求数值的精确或者近似解。典型的方法包括二分法（Bisection method）和牛顿迭代法（Newton’s method）。</li>
<li>在一定范围内查找目标值。典型的方法包括二分查找。</li>
<li>机器学习算法中的迭代。相关的算法或者模型有很多，比如 K- 均值算法（K-means clustering）、PageRank 的马尔科夫链（Markov chain）、梯度下降法（Gradient descent）等等。迭代法之所以在机器学习中有广泛的应用，是因为很多时候机器学习的过程，就是根据已知的数据和一定的假设，求一个局部最优解。而迭代法可以帮助学习算法逐步搜索，直至发现这种解。</li>
</ol>


<h3>04丨数学归纳法：如何用数学归纳提升代码的运行效率？</h3>

<p>数学归纳法的一般步骤是这样的：</p>

<ol>
<li>证明基本情况（通常是<code>n=1</code>的时候）是否成立；</li>
<li>假设<code>n=k−1</code>成立，再证明<code>n=k</code>也是成立的（<code>k</code>为任意大于1的自然数）。</li>
</ol>


<p>和使用迭代法的计算相比，数学归纳法最大的特点就在于“归纳”二字。它已经总结出了规律。只要我们能够证明这个规律是正确的，就没有必要进行逐步的推算，可以节省很多时间和资源。</p>

<p><strong>递归调用的代码和数学归纳法的逻辑是一致的。</strong></p>

<h4>递归和数学归纳法的核心思想</h4>

<p>复杂的问题，每次都解决一点点，并将剩下的任务转化成为更简单的问题等待下次求解，如此反复，直到最简单的形式。</p>

<h3>05丨递归（上）：泛化数学归纳，如何将复杂问题简单化？</h3>

<h3>06丨递归（下）：分而治之，从归并排序到MapReduce</h3>

<p>对于一些复杂问题，我们可以先分析一下，它们是否可以简化为某些更小的、更简单的子问题来解决，这是一般思路。如果可以，那就意味着我们仍然可以使用递归的核心思想，将复杂的问题逐步简化成最基本的情况来求解。</p>

<p>因此，今天我会从归并排序开始，延伸到多台机器的并行处理，详细讲讲递归思想在“分而治之”这个领域的应用。</p>

<h4>归并排序</h4>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%A8%A1%E5%9E%8B.jpeg" alt="20220531归并排序模型.jpeg" /></p>

<p>我们可以在归并排序中引入了分而治之（Divide and Conquer）的思想。分而治之，我们通常简称为分治。它的思想就是，将一个复杂的问题，分解成两个甚至多个规模相同或类似的子问题，然后对这些子问题再进一步细分，直到最后的子问题变得很简单，很容易就能被求解出来，这样这个复杂的问题就求解出来了。</p>

<h4>分布式系统中的分治思想</h4>

<p>分而治之更有趣的应用其实是在分布式系统中。</p>

<p>例如，当需要排序的数组很大（比如达到 1024GB 的时候），我们没法把这些数据都塞入一台普通机器的内存里。该怎么办呢？有一个办法，我们可以把这个超级大的数据集，分解为多个更小的数据集（比如 16GB 或者更小），然后分配到多台机器，让它们并行地处理。</p>

<p>等所有机器处理完后，中央服务器再进行结果的合并。由于多个小任务间不会相互干扰，可以同时处理，这样会大大增加处理的速度，减少等待时间。</p>

<p>在单台机器上实现归并排序的时候，我们只需要在递归函数内，实现数据分组以及合并就行了。而在多个机器之间分配数据的时候，递归函数内除了分组及合并，还要负责把数据分发到某台机器上。</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.jpeg" alt="20220531分而治之分布式系统.jpeg" /></p>

<h3>07丨排列：如何让计算机学会“田忌赛马”？</h3>

<h3>08丨组合：如何让计算机安排世界杯的赛程？</h3>

<h3>09丨动态规划（上）：如何实现基于编辑距离的查询推荐？</h3>

<p>聊聊查询推荐（Query Suggestion）的实现过程，以及它所使用的数学思想，动态规划（Dynamic Programming）。</p>

<h4>编辑距离</h4>

<p>搜索下拉提示和关键词纠错，这两个功能其实就是查询推荐。查询推荐的核心思想其实就是，对于用户的输入，查找相似的关键词并进行返回。而测量拉丁文的文本相似度，最常用的指标是<strong>编辑距离</strong>（Edit Distance）。</p>

<p>编辑距离是指由一个字符串转成另一个字符串所需的最少编辑操作次数。</p>

<h4>状态转移</h4>

<p>我用mouuse和mouse的例子。我把mouuse的字符数组作为表格的行，每一行表示其中一个字母，而mouse的字符数组作为列，每列表示其中一个字母，这样就得到下面这个表格。</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.png" alt="20220531编辑距离状态转移.png" /></p>

<h3>10丨动态规划（下）：如何求得状态转移方程并进行编程实现？</h3>

<h4>状态转移方程</h4>

<p><img src="http://hongchaozhang.github.io/images/20220531%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png" alt="20220531编辑距离状态转移方程.png" /></p>

<p>这里面求最小值的<code>min</code>函数里有三个参数，分别对应我们上节讲的三种情况的编辑距离，分别是：替换、插入和删除字符。在表格的右下角我标出了两个字符串的编辑距离1。</p>

<p>我们假设字符数组<code>A[]</code>和<code>B[]</code>分别表示字符串<code>A</code>和<code>B</code>，<code>A[i]</code>表示字符串<code>A</code>中第<code>i</code>个位置的字符，<code>B[i]</code>表示字符串<code>B</code>中第<code>i</code>个位置的字符。二维数组<code>d[,]</code>表示刚刚用于推导的二维表格，而<code>d[i,j]</code>表示这张表格中第<code>i</code>行、第<code>j</code>列求得的最终编辑距离。函数<code>r(i, j)</code>表示替换时产生的编辑距离。如果<code>A[i]</code>和<code>B[j]</code>相同，函数的返回值为0，否则返回值为1。</p>

<p>有了这些定义，下面我们用迭代来表达上述的推导过程。</p>

<ol>
<li>如果<code>i</code>为0，且<code>j</code>也为0，那么<code>d[i, j]</code>为0。</li>
<li>如果<code>i</code>为0，且<code>j</code>大于0，那么<code>d[i, j]</code>为<code>j</code>。</li>
<li>如果<code>i</code>大于0，且<code>j</code>为0，那么<code>d[i, j]</code>为<code>i</code>。</li>
<li>如果<code>i</code>大于0，且<code>j</code>大于0，那么<code>d[i, j]=min(d[i-1, j] + 1, d[i, j-1] + 1, d[i-1, j-1] + r(i, j))</code>。</li>
</ol>


<p>这里面最关键的一步是<code>d[i, j]=min(d[i-1, j] + 1, d[i, j-1] + 1, d[i-1, j-1] + r(i, j))</code>。这个表达式表示的是动态规划中从上一个状态到下一个状态之间可能存在的一些变化，以及基于这些变化的最终决策结果。我们把这样的表达式称为<strong>状态转移方程</strong>。</p>

<h4>总结</h4>

<p>通过这两节的内容，我讲述了动态规划主要的思想和应用。如果仅仅看这两个案例，也许你觉得动态规划不难理解。不过，在实际应用中，你可能会产生这些疑问：什么时候该用动态规划？这个问题可以用动态规划解决啊，为什么我没想到？我这里就讲一些我个人的经验。</p>

<p>首先，如果一个问题有很多种可能，看上去需要使用排列或组合的思想，但是最终求的只是某种最优解（例如最小值、最大值、最短子串、最长子串等等），那么你不妨试试是否可以使用动态规划。</p>

<p>其次，状态转移方程是个关键。你可以用状态转移表来帮助自己理解整个过程。如果能找到准确的转移方程，那么离最终的代码实现就不远了。</p>

<h3>11丨树的深度优先搜索（上）：如何才能高效率地查字典？</h3>

<h3>12丨树的深度优先搜索（下）：如何才能高效率地查字典？</h3>

<h3>13丨树的广度优先搜索（上）：人际关系的六度理论是真的吗？</h3>

<h3>14丨树的广度优先搜索（下）：为什么双向广度优先搜索的效率更高？</h3>

<h4>如何更高效地求两个用户间的最短路径？</h4>

<p>基本的做法是，从其中一个人出发，进行广度优先搜索，看看另一个人是否在其中。如果不幸的话，两个人相距六度，那么即使是广度优先搜索，同样要达到万亿级的数量。</p>

<p>那究竟该如何更高效地求得两个用户的最短路径呢？我们先看看，影响效率的问题在哪里？很显然，随着社会关系的度数增加，好友数量是呈指数级增长的。所以，如果我们可以控制这种指数级的增长，那么就可以控制潜在好友的数量，达到提升效率的目的。</p>

<p>如何控制这种增长呢？我这里介绍一种“<strong>双向广度优先搜索</strong>”。它巧妙地运用了两个方向的广度优先搜索，大幅降低了搜索的度数。</p>

<h3>15丨从树到图：如何让计算机学会看地图？</h3>

<p>使用Dijkstra算法来查找地图中两点之间的最短路径。</p>

<h3>16丨时间和空间复杂度（上）：优化性能是否只是“纸上谈兵”？</h3>

<h3>17丨时间和空间复杂度（下）：如何使用六个法则进行复杂度分析？</h3>

<h3>18丨总结课：数据结构、编程语句和基础算法体现了哪些数学思想？</h3>

<h2>04-概率统计篇 (14讲)</h2>

<h3>19丨概率和统计：编程为什么需要概率和统计？</h3>

<h3>20丨概率基础（上）：一篇文章帮你理解随机变量、概率分布和期望值</h3>

<h4>随机变量</h4>

<h4>概率分布</h4>

<ol>
<li>离散概率分布：伯努利分布、分类分布、二项分布、泊松分布

<ol>
<li>伯努利分布：二分类分布</li>
<li>分类分布：随机变量的取值空间为<code>n</code>个离散的值，<code>n=2</code>时就是伯努利分布。</li>
</ol>
</li>
<li>连续概率分布：正态分布、均匀分布、指数分布、拉普拉斯分布

<ol>
<li>正态分布：也叫高斯分布，有两个关键参数：均值和方差。</li>
</ol>
</li>
</ol>


<h4>期望值</h4>

<p>均值是期望值的特例，即各个取值的概率相同。</p>

<h3>21丨概率基础（下）：联合概率、条件概率和贝叶斯法则，这些概率公式究竟能做什么？</h3>

<h4>联合概率</h4>

<p>由多个随机变量决定的概率我们就叫联合概率，使用<code>P(x, y)</code>表示。</p>

<h4>边缘概率</h4>

<p>联合概率和单个随机变量的概率之间有什么关联呢？对于离散型随机变量，我们可以通过通过联合概率<code>P(x, y)</code>在<code>y</code>上求和，就可以得到<code>P(x)</code>。对于连续型随机变量，我们可以通过联合概率<code>P(x, y)</code>在<code>y</code>上的积分，推导出概率<code>P(x)</code>。这个时候，我们称<code>P(x)</code>为<strong>边缘概率</strong>。</p>

<h4>条件概率</h4>

<p>条件概率也是由多个随机变量决定，但是和联合概率不同的是，它计算了给定某个（或多个）随机变量的情况下，另一个（或多个）随机变量出现的概率，其概率分布叫做条件概率分布。给定随机变量<code>x</code>，随机变量<code>y</code>的条件概率使用<code>P(y|x)</code>表示。</p>

<h4>贝叶斯法则</h4>

<p>条件概率、联合概率之间的关系如下：
<code>P(x,y) = P(x|y) * P(y)</code></p>

<p>根据上面的关系，可以得到贝叶斯定理如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86.png" alt="20220531贝叶斯定理.png" /></p>

<ol>
<li>先验概率： 我们把<code>P(x)</code>称为先验概率。之所以称为“先验”，是因为它是从数据资料统计得到的，不需要经过贝叶斯定理的推算。</li>
<li>条件概率（似然函数）：<code>P(y|x)</code>是给定<code>x</code>之后<code>y</code>出现的条件概率。在统计学中，我们也把<code>P(y|x)</code>写作似然函数<code>L(x|y)</code>。在数学里，似然函数和概率是有区别的。概率是指已经知道模型的参数来预测结果，而似然函数是根据观测到的结果数据，来预估模型的参数。不过，当<code>y</code>值给定的时候，两者在数值上是相等的，在应用中我们可以不用细究。</li>
<li>边缘概率：我们没有必要事先知道<code>P(y)</code>。<code>P(y)</code>可以通过联合概率<code>P(x,y)</code>计算边缘概率得来，而联合概率<code>P(x,y)</code>可以由<code>P(y|x)</code>*<code>P(x)</code>推出。</li>
<li>后验概率：<code>P(x|y)</code>是根据贝叶斯定理，通过先验概率<code>P(x)</code>、似然函数<code>P(y|x)</code>和边缘概率<code>P(y)</code>推算而来，因此我们把它称作后验概率。</li>
</ol>


<p>如果有一定数量的标注数据，那么通过统计的方法，我们可以很方便地得到先验概率和似然函数，然后推算出后验概率，最后依据后验概率来做预测。这整个过程符合监督式机器学习的模型训练和新数据预测这两个阶段，因此朴素贝叶斯算法被广泛运用在机器学习的分类问题中。</p>

<h4>随机变量之间的独立性</h4>

<p>如果随机变量<code>x</code>和<code>y</code>之间不相互影响，那么我们就说<code>x</code>和<code>y</code>相互独立。此时，有<code>P(x|y)=P(x)</code>，所以<code>P(x,y)=P(x)*P(y)</code>。</p>

<p>变量之间的独立性，可以帮我们简化计算。</p>

<p>举个例子，假设有6个随机变量，而每个变量有10种可能的取值，那么计算它们的联合概率<code>p(x1,x2,x3,x4,x5,x6)</code>，在实际中是非常困难的一件事情。</p>

<p>根据排列，可能的联合取值，会达到10的6次方，也就是100万这么多。那么使用实际的数据进行统计时，我们也至少需要这个数量级的样本，否则的话很多联合概率分布的值就是0，产生了数据稀疏的问题。但是，如果假设这些随机变量都是相互独立的，那么我们就可以将联合概率<code>p(x1,x2,x3,x4,x5,x6)</code>转换为<code>p(x1)*p(x2)*p(x3)*p(x4)*p(x5)*p(x6)</code>。如此一来，我们只需要计算<code>p(x1)</code>到<code>p(x6)</code>就行了。</p>

<h3>22丨朴素贝叶斯：如何让计算机学会自动分类？</h3>

<h4>训练样本</h4>

<p>贝叶斯分类需要的训练样本如下：
<img src="http://hongchaozhang.github.io/images/20220531%E8%AE%AD%E7%BB%83%E6%A0%B7%E6%9C%AC.png" alt="20220531训练样本" /></p>

<h4>训练</h4>

<p>贝叶斯定理的核心思想：<strong>用先验概率和条件概率估计后验概率</strong>。</p>

<p>具体到这里的分类问题，贝叶斯公式可以写成这样：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%85%AC%E5%BC%8F.png" alt="20220531贝叶斯分类公式.png" /></p>

<p>其中<code>c</code>表示一个分类（class）, <code>f</code>表示属性对应的数据字段（field）。如此一来，等号左边的<code>P(c|f)</code>就是待分类样本中，出现属性值<code>f</code>时，样本属于类别<code>c</code>的概率。而等号右边的<code>P(f|c)</code>是根据训练数据统计，得到分类<code>c</code>中出现属性<code>f</code>的概率。<code>P(c)</code>是分类<code>c</code>在训练数据中出现的概率，<code>P(f)</code>是属性<code>f</code>在训练样本中出现的概率。</p>

<p>这里的贝叶斯公式只描述了单个属性值属于某个分类的概率，可是我们要分析的水果每个都有很多属性，<strong>朴素贝叶斯</strong>在这里就要发挥作用了。这是基于一个简单假设建立的一种贝叶斯方法，并<strong>假定数据对象的不同属性对其归类影响时是相互独立的</strong>。此时若数据对象<code>o</code>中同时出现属性<code>fi</code>与<code>fj</code>，则对象<code>o</code>属于类别<code>c</code>的概率就是这样：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%85%AC%E5%BC%8F.png" alt="20220531朴素贝叶斯分类公式.png" /></p>

<p>现在，我们应该已经可以用10个水果的数据，来建立朴素贝叶斯模型了。</p>

<p>比如，苹果的分类中共包含3个数据实例，对于形状而言，出现2次不规则圆、1次圆形和0次椭圆形，因此各自的统计概率为0.67、0.33和0.00。我们将这些值称为，给定一个水果分类时，出现某个属性值的<strong>条件概率</strong>。以此类推，所有的统计结果就是下面这个表格中这样：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E8%B4%9D%E5%8F%B6%E6%96%AF%E8%AE%AD%E7%BB%83%E6%A0%B7%E6%9C%AC%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87.png" alt="20220531贝叶斯训练样本条件概率.png" /></p>

<blockquote><p>对于上表中出现的0.00概率，在做贝叶斯公式中的乘积计算时，会出现结果为0的情况，因此我们通常取一个比这个数据集里最小统计概率还要小的极小值，来代替“零概率”。比如，我们这里取0.01。在填充训练数据中从来没有出现过的属性值的时候，我们就会使用这种技巧，我们给这种技巧起个名字就叫作<strong>平滑</strong>（Smoothing）。</p></blockquote>

<h4>预测</h4>

<p>有了这些条件概率，以及各类水果和各个属性出现的先验概率，我们已经建立起了朴素贝叶斯模型。现在，我们就可以用它进行朴素贝叶斯分类了。</p>

<p>假设我们有一个新的水果，它的形状是圆形，口感是甜的，那么根据朴素贝叶斯，它属于苹果、甜橙和西瓜的概率分别是多少呢？</p>

<p>我们先来计算一下，它属于苹果的概率有多大:</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B%E8%8B%B9%E6%9E%9C%E6%A6%82%E7%8E%87.png" alt="20220531贝叶斯分类预测苹果概率.png" /></p>

<p>其中，<code>apple</code>表示分类为苹果，<code>shape-2</code>表示形状属性的值为<code>2</code>（也就是圆形），<code>taste-2</code>表示口感属性的值为<code>2</code>。以此类推，我们还可计算该水果属于甜橙和西瓜的概率:</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B%E6%A9%99%E5%AD%90%E8%A5%BF%E7%93%9C%E6%A6%82%E7%8E%87.png" alt="20220531贝叶斯分类预测橙子西瓜概率.png" /></p>

<p>比较这三个数值，<code>0.00198&lt;0.00798&lt;0.26934</code>，所以计算机可以得出的结论，该水果属于甜橙的可能性是最大的，或者说，这个水果最有可能是甜橙。</p>

<blockquote><p>这几个公式里的概率乘积通常都非常小，在物品的属性非常多的时候，这个乘积可能就小到计算机无法处理的地步。因此，在实际运用中，我们还会采用一些数学手法进行转换（比如取<code>log</code>将小数转换为绝对值大于<code>1</code>的负数），原理都是一样的。</p></blockquote>

<h4>总结</h4>

<p>总结一次朴素贝叶斯分类的主要步骤：</p>

<ol>
<li>准备数据：针对水果分类这个案例，我们收集了若干水果的实例，并从水果的常见属性入手，将其转化为计算机所能理解的数据。这种数据也被称为<strong>训练样本</strong>。</li>
<li>建立模型：通过手头上水果的实例，我们让计算机统计每种水果、属性出现的先验概率，以及在某个水果分类下某种属性出现的条件概率。这个过程也被称为基于样本的<strong>训练</strong>。</li>
<li>分类新数据：对于一颗新水果的属性数据，计算机根据已经建立的模型进行推导计算，得到该水果属于每个分类的概率，实现了分类的目的。这个过程也被称为<strong>预测</strong>。</li>
</ol>


<h3>23丨文本分类：如何区分特定类型的新闻？</h3>

<p>运用朴素贝叶斯原理，根据词频特征，对文章进行分类。清晰明了，值得一看。</p>

<h3>24丨语言模型：如何使用链式法则和马尔科夫假设简化概率模型？</h3>

<h4>语言模型</h4>

<p>这里说的语言模型指的是基于概率和统计的语言模型。</p>

<h5>链式法则</h5>

<p><img src="http://hongchaozhang.github.io/images/20220531%E9%93%BE%E5%BC%8F%E6%B3%95%E5%88%99.png" alt="20220531链式法则.png" /></p>

<h5>马尔可夫假设</h5>

<p>理解了链式法则，我们再来看看马尔可夫假设。这个假设的内容是：任何一个词<code>wi</code>出现的概率只和它前面的1个或若干个词有关。基于这个假设，我们可以提出多元文法（Ngram）模型。Ngram中的<code>N</code>很重要，它表示任何一个词出现的概率，只和它前面的<code>N-1</code>个词有关。</p>

<p>以二元文法模型为例，按照刚才的说法，二元文法表示，某个单词出现的概率只和它前面的1个单词有关。也就是说，即使某个单词出现在一个很长的句子中，我们也只需要看前面那1个单词。用公式来表示出来就是这样：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BA%8C%E5%85%83%E6%96%87%E6%B3%95%E6%A8%A1%E5%9E%8B.png" alt="20220531二元文法模型.png" /></p>

<p>假设我们有一个统计样本文本<code>d</code>，<code>s</code>表示某个有意义的句子，由一连串按照特定顺序排列的词<code>w1，w2,…,wn</code>组成，这里<code>n</code>是句子里单词的数量。现在，我们想知道根据文档<code>d</code>的统计数据，<code>s</code>在文本中出现的可能性，即<code>P(s|d)</code>，那么我们可以把它表示为<code>P(s|d)=P(w1,w2,…,wn|d)</code>。假设我们这里考虑的都是在集合<code>d</code>的情况下发生的概率，所以可以忽略<code>d</code>，写为<code>P(s)=P(w1,w2,…,wn)</code>。</p>

<p><code>P(w1,w2,…,wn)</code>可以通过上面说的链式法则计算，通过文档集合<code>C</code>，你可以知道<code>P(w1)</code>，<code>P(w2|w1)</code>这种概率。但是，这会带来两个问题：</p>

<ol>
<li>概率为0的问题
 <code>P(w1)</code>大小还好，<code>P(w2|w1)</code>会小一些，再往后看，<code>P(w3|w1,w2)</code>出现概率更低，<code>P(w4|w1,w2,w3)</code>出现的概率就更低了。一直到<code>P(wn|w1,w2,…,wn−1)</code>，基本上又为0了。我们可以使用上一节提到的平滑技巧，减少0概率的出现。不过，如果太多的概率都是通过平滑的方式而得到的，那么模型和真实的数据分布之间的差距就会加大，最终预测的效果也会很差，所以平滑也不是解决0概率的最终办法。</li>
<li>存储空间的问题
 为了统计现有文档集合中<code>P(w1,w2,…,wn)</code>这类值，我们就需要生成很多的计数器。我们假设文档集合中有<code>m</code>个不同的单词，那么从中挑出<code>n</code>个单词的可重复排列，数量就是<code>m^n</code>。此外，还有<code>m^(n−1)</code>,<code>m^(n−2)</code>等等。这也意味着，如果要统计并存储的所有<code>P(w1,w2,…,wn)</code>或<code>P(wn|w1,w2,…,wn−1)</code>这类概率，就需要大量的内存和磁盘空间。当然，你可以做一些简化，不考虑单词出现的顺序，那么问题就变成了可重复组合，但是数量仍然非常巨大。</li>
</ol>


<p>在这两个问题上，马尔科夫假设和多元文法模型就能帮上大忙了。如果我们使用三元文法模型，上述公式可以改写为：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%B8%89%E5%85%83%E6%96%87%E6%B3%95%E6%A8%A1%E5%9E%8B.png" alt="20220531三元文法模型.png" /></p>

<p>这样，系统的复杂度大致在<code>(C(m,1)+C(m,2)+C(m,3))</code>这个数量级，而且<code>P(wn|wn−2,wn−1)</code>为0的概率也会大大低于<code>P(wn|w1,w2,…,wn−1)</code>为0的概率。</p>

<h4>语言模型的应用</h4>

<p>基于概率的语言模型，本身不是新兴的技术。它已经在机器翻译、语音识别和中文分词中得到了成功应用。近几年来，人们也开始在信息检索领域中尝试语言模型。下面我就来讲讲语言模型在信息检索和中文分词这两个方面里是如何发挥作用的。</p>

<h5>信息检索</h5>

<p>信息检索很关心的一个问题就是相关性，也就是说，给定一个查询，哪篇文档是更相关的呢？一种常见的做法是计算<code>P(d|q)</code>，其中<code>q</code>表示一个查询，<code>d</code>表示一篇文档。<code>P(d|q)</code>表示用户输入查询<code>q</code>的情况下，文档<code>d</code>出现的概率是多少？如果这个概率越高，我们就认为<code>q</code>和<code>d</code>之间的相关性越高。</p>

<p>通过我们手头的文档集合，并不能直接获得<code>P(d|q)</code>。好在我们已经学习过了贝叶斯定理，通过这个定理，我们可以将<code>P(d|q)</code>重写如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F.png" alt="20220531信息检索贝叶斯公式.png" /></p>

<p>让<code>k1,k2,…,kn</code>表示查询<code>q</code>里包含的<code>n</code>个关键词，就可以根据链式法则求解出<code>P(q|d)</code>，我们也使用马尔科夫假设和多元文法来提高算法效率。</p>

<p>最终，当用户输入一个查询<code>q</code>之后，对于每一篇文档<code>d</code>，我们都能获得<code>P(d|q)</code>的值。根据每篇文档所获得的<code>P(d|q)</code>这个值，由高到低对所有的文档进行排序。这就是语言模型在信息检索中的常见用法。</p>

<h5>中文分词</h5>

<p>和拉丁语系不同，中文存在分词的问题。比如原句是“兵乓球拍卖完了”，分词结果可能是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. 兵乓球|拍卖|完了
</span><span class='line'>2. 兵乓|球拍|卖完|了
</span><span class='line'>3. ...</span></code></pre></td></tr></table></div></figure>


<p>上面分词的例子，从字面来看都是合理的，所以这种歧义无法通过这句话本身来解决。那么这种情况下，语言模型能为我们做什么呢？我们知道，语言模型是基于大量的语料来统计的，所以我们可以使用这个模型来估算，哪种情况更合理。</p>

<p>假设整个文档集合是<code>D</code>，要分词的句子是<code>s</code>，分词结果为<code>w1,…wn</code>，如果使用三元文法模型，</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E4%B8%89%E5%85%83%E6%96%87%E6%B3%95%E6%A8%A1%E5%9E%8B.png" alt="20220531中文分词三元文法模型.png" /></p>

<blockquote><p>请注意，在信息检索中，我们关心的是每篇文章产生一个句子（也就是查询）的概率，而这里可以是整个文档集合<code>D</code>产生一个句子的概率。</p></blockquote>

<p>语言模型可以帮我们估计某种分词结果，在文档集合中出现的概率。由于不同的分词方法，会导致<code>w1</code>到<code>wn</code>的不同，因此就会产生不同的<code>P(s)</code>。接下来，我们只要取最大的<code>P(s)</code>，并假设这种分词方式是最合理的，就可以在一定程度上解决歧义。</p>

<p>回到“兵乓球拍卖完了”这句话，如果文档集合都是讲述的有关体育用品的销售，而不是拍卖行，那么“兵乓|球拍|卖完|了”这种分词的可能性应该更高。</p>

<h3>25丨马尔科夫模型：从PageRank到语音识别，背后是什么模型在支撑？</h3>

<h4>马尔可夫模型</h4>

<p>在介绍语言模型的时候，我们提到了马尔科夫假设，这个假设是说，每个词出现的概率和之前的一个或若干个词有关。我们换个角度思考就是，<strong>每个词按照一定的概率转移到下一个词</strong>。</p>

<p>如果把词抽象为一个状态，那么我们就可以认为，状态到状态之间是有关联的。前一个状态有一定的概率可以转移到到下一个状态。如果多个状态之间的随机转移满足马尔科夫假设，那么这类随机过程就是一个马尔科夫随机过程。而刻画这类随机过程的统计模型，就是<strong>马尔科夫模型</strong>（Markov Model）。</p>

<p>前面讲多元文法的时候，我提到了二元文法、三元文法。对于二元文法来说，某个词出现的概率只和前一个词有关。对应的，在马尔科夫模型中，如果一个状态出现的概率只和前一个状态有关，那么我们称它为<strong>一阶马尔科夫模型</strong>或者<strong>马尔科夫链</strong>。对应于三元、四元甚至更多元的文法，我们也有二阶、三阶等马尔科夫模型。</p>

<h5>PageRank和马尔可夫链</h5>

<p>Google公司最引以为傲的PageRank链接分析算法，它的核心思想就是基于马尔科夫链。这个算法假设了一个“随机冲浪者”模型，冲浪者从某张网页出发，根据Web图中的链接关系随机访问。在每个步骤中，冲浪者都会从当前网页的链出网页中随机选取一张作为下一步访问的目标。在整个Web图中，绝大部分网页节点都会有链入和链出。那么冲浪者就可以永不停歇地冲浪，持续在图中走下去。我们可以假设每张网页就是一个状态，而网页之间的链接表明了状态转移的方向。这样，我们很自然地就可以使用马尔科夫链来刻画“随机冲浪者”。</p>

<blockquote><ol>
<li>PageRank值：在随机访问的过程中，越是被频繁访问的链接，越是重要。可以看出，每个节点的PageRank值取决于Web图的链接结构。<strong>假如一个页面节点有很多的链入链接，或者是链入的网页有较高的被访问率，那么它也将会有更高的被访问概率</strong>。</li>
<li>PageRank在标准的马尔科夫链上，引入了随机的跳转操作，也就是假设冲浪者不按照Web图的拓扑结构走下去，只是随机挑选了一张网页进行跳转。这样的处理是类比人们打开一张新网页的行为，也是符合实际情况的，避免了信息孤岛的形成。

<h4>隐马尔可夫模型</h4>

<p>马尔可夫模型都是假设每个状态对我们都是已知的，比如在概率语言模型中，一个状态对应了单词“上学”，另一个状态对应了单词“书包”。可是，有没有可能某些状态我们是未知的呢？</p></li>
</ol>
</blockquote>

<p>在某些现实的应用场景中，我们是无法确定马尔科夫过程中某个状态的取值的。这种情况下，最经典的案例就是<strong>语音识别</strong>。使用概率对语音进行识别的过程，和语言模型类似，因此我们可以把每个等待识别的词对应为马尔科夫过程中的一个状态。</p>

<p>计算机只知道某个词的发音，而不知道它具体怎么写，对于这种情况，我们就认为计算机只能观测到每个状态的部分信息，而另外一些信息被“隐藏”了起来。这个时候，我们就需要用隐马尔科夫模型来解决这种问题。隐马尔科夫模型有两层，一层是我们可以观测到的数据，称为“输出层”，另一层则是我们无法直接观测到的状态，称为“隐藏状态层”。如下图：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpeg" alt="20220531隐马尔可夫模型图.jpeg" /></p>

<p>那么在这个两层模型示例中，“隐藏状态层”(x1，x2，x3)产生“输出层”(y1，y2，y3)的概率是:</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%E8%BE%93%E5%87%BA%E5%B1%82%E6%A6%82%E7%8E%87.png" alt="20220531隐马尔可夫模型输出层概率.png" /></p>

<p>语音识别要做的，就是遍历所有可能的状态层，找出最可能产生已知“输出层”的状态层，即为语音识别结果。</p>

<h3>26丨信息熵：如何通过几个问题，测出你对应的武侠人物？</h3>

<p>现在有个小游戏，“测测你是哪个武侠人物”：通过连续的几个问题，确定答题者是武侠人物中的哪一位？</p>

<p>那么，问卷设计者应该如何选择合适的题目，才能在读者回答尽量少的问题的同时，相对准确地测出自己对应于武侠中的哪个人物呢？为了实现这一目的，系统背后需要有这样的一张表格：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BF%A1%E6%81%AF%E7%86%B5%E6%B8%B8%E6%88%8F%E8%A1%A8%E6%A0%BC.png" alt="20220531信息熵游戏表格.png" /></p>

<p>在题目的设计上，我们可能要考虑下面两个问题：
1. 每个问题在人物划分上，是否有着不同的区分能力？
2. 题目的先后顺序会不会直接影响要回答问题的数量？</p>

<h4>问题的区分能力</h4>

<p>每一个问题都会将被测试者划分为不同的人物分组。如果某个问题将属于不同人物分组的被测者，尽可能地划分到了相应的分组，那么我们认为这个问题的区分能力较强。相反，如果某个问题无法将属于不同人物分组的被测者划分开来，那么我们认为这个问题的区分能力较弱。</p>

<p>举个例子，我们先来比较一下“性别”和“智商”这两个属性。</p>

<p>首先，性别属性将武侠人物平均地划分为一半一半，也就是说“男”和“女”出现的先验概率是各 50%。如果我们假设被测试的人群，其男女性别的概率分布也是50%和50%，那么关于性别的测试题，就能将被测者的群体大致等分。</p>

<p>我们再来看智商属性。我们也将武侠人物划分为2个小集合，不过“智商高”的先验概率是 80%，而“智商中等”的先验概率只有 20%。同样，我们假设被测试的人群，其智商的概率分布也是类似地，那么经过关于智商的测试题之后，仍然有 80% 左右的不同人物还是属于同一个集合，并没有被区分开来。因此，我们可以认为关于“智商”的测试题，在对人物进行分组这个问题上，其能力要弱于“性别”的测试题。</p>

<p>这只是对区分能力的一个感性认识，如何对其进行量化呢？这就需要引入<strong>信息量，信息熵，信息增益</strong>等概念。</p>

<h4>信息量</h4>

<p>任何能够减少不确定性的消息，都叫做信息。定性地看，事件的概率越小，不确定性越大，一旦发生带来的信息量也就越大。信息量公式如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BF%A1%E6%81%AF%E9%87%8F%E5%85%AC%E5%BC%8F.svg" alt="20220531信息量公式.svg" /></p>

<h4>信息熵</h4>

<p>一个系统的信息熵是其各种状态的信息量的期望：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BF%A1%E6%81%AF%E7%86%B5%E5%85%AC%E7%A4%BA.svg" alt="20220531信息熵公示.svg" /></p>

<p>这个公式和热力学的熵的本质一样，故也称为熵。从公式可知，当各个符号出现的几率相等，即“不确定性”最高时，信息熵最大。故信息可以视为“不确定性”、“不纯净度”或“选择的自由度”的度量。</p>

<p>从集合和分组的角度来说，如果一个集合里的元素趋向于落在同一分组里，那么告诉你某个元素属于哪个分组的信息量就越小，整个集合的熵也越小，换句话说，整个集合就越“纯净”。相反，如果一个集合里的元素趋向于分散在不同分组里，那么告诉你某个元素属于哪个分组的信息量就越大，整个集合的熵也越大，换句话说，整个集合就越“混乱”。</p>

<p>已经知道单个集合的熵是如何计算的了。那么，如果将一个集合划分成多个更小的集合之后，又该如何根据这些小集合，来计算整体的熵呢？之前我们提到了信息量和熵具有加和的性质，所以对于包含多个集合的更大集合，它的信息量期望值是可以通过每个小集合的信息量期望值来推算的。具体来说，我们可以使用如下公式：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E9%9B%86%E5%90%88%E5%88%92%E5%88%86%E4%BF%A1%E6%81%AF%E7%86%B5%E5%85%AC%E5%BC%8F.png" alt="20220531集合划分信息熵公式.png" /></p>

<p>其中，<code>T</code>表示一种划分，<code>Pv</code>表示划分后其中某个小集合，<code>Entropy(Pv)</code>表示某个小集合的熵， 而<code>|Pv|/|P|</code>表示某个小集合出现的概率。</p>

<h4>信息增益</h4>

<p>一个系统的信息增益是指，由于信息量大增加带来的其信息熵的减少:</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A%E5%85%AC%E5%BC%8F.png" alt="20220531信息增益公式.png" /></p>

<p>其中<code>T</code>表示当前选择的特征，<code>Entropy(P)</code>表示选择特征<code>T</code>之前的熵，<code>Entropy(Pv)</code>表示特征<code>T</code>取值为<code>v</code>分组的熵。减号后面的部分表示选择<code>T</code>做决策之后，各种取值子集合的熵的加权平均（期望）后整体的熵。</p>

<h4>再次回到“武侠人物分类”的小游戏</h4>

<p>我们把这个信息增益的概念放到咱们的小游戏里就是，如果一个测试问题能够将来自不同分组的人物尽量的分开，也就是该划分对应的信息增益越高，那么我们就认为其区分能力越高，提供的信息含量也越多。</p>

<p>我们还是以“性别”和“智商”的两个测试题为例。</p>

<p>在提出任何问题之前，我们无法知道被测者属于哪位武侠人物，因此所有被测者属于同一个集合。假设被测者的概率分布和这10位武侠人物的先验概率分布相同，那么被测者集合的熵为3.32(<code>10*(-1 * 0.1 * log(0.1, 2))</code>)。</p>

<p>通过性别的测试问题对人物进行划分后，我们得到了两个更小的集合，每个小集合都包含5种不同的人物分组，因此每个小集合的熵是2.32(<code>(-1 * 5 * 0.2 * log(0.2, 2))</code>)，两个小集合的整体熵是2.32(<code>0.5 * 2.32 + 0.5 * 2.32</code>)。因此使用性格的测试题后，信息增益是1(<code>3.32 - 2.32</code>)。</p>

<p>而通过智商的测试问题对人物分组后，我们也得到了两个小集合，一个包含了8种人物，另一个包含了2种人物。包含8种人物的小集合其熵是3(<code>(-1* 8 * 0.125 * log(0.125, 2))</code>)，包含<code>2</code>种人物的小集合其熵是1(<code>(-1* 2 * 0.5 * log(0.5, 2))</code>)。两个小集合的整体熵是2.6(<code>0.8 * 3 + 0.2 * 1</code>)。因此使用智商的测试题后，信息增益是0.72(<code>3.32 - 2.6</code>)，低于基于性别的测试。所以，我们可以得出结论，有关性别的测试题比有关智商的测试题更具有区分能力。</p>

<h3>27丨决策树：信息增益、增益比率和基尼指数的运用</h3>

<h4>继续“武侠人物分类”游戏</h4>

<p>还说上面的“武侠人物分类”游戏，被测者们每次回答一道问题，就会被细分到不同的集合，每个细分的集合纯净度就会提高，而熵就会下降。在测试结束的时候，如果所有被测者都被分配到了相应的武侠人物名下，那么每个人物分组都是最纯净的，熵值都为0。于是，测试问卷的过程就转化为“如何将熵从3.32下降到0”的过程。</p>

<p>首先计算各个特征的信息增益：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E6%AD%A6%E4%BE%A0%E4%BA%BA%E7%89%A9%E6%B8%B8%E6%88%8F%E5%90%84%E4%B8%AA%E7%89%B9%E5%BE%81%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A.png" alt="20220531武侠人物游戏各个特征信息增益.png" /></p>

<p>按照信息增益从高到低的顺序选择特征问题：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E6%AD%A6%E4%BE%A0%E4%BA%BA%E7%89%A9%E5%88%86%E7%B1%BB%E5%9B%BE.png" alt="20220531武侠人物分类图.png" /></p>

<p>从这个图可以看出来，对于每种人物的判断，我们至多需要问3个问题，没有必要问全5个问题。比如，对于人物J和C，我们只需要问2个问题。假设读者属于10种武侠人物的概率是均等的，那么我们就可以利用之前介绍的知识，来计算读者需要回答的问题数量之期望值。每种人物出现的概率是0.1，8种人物需要问3个问题，2种人物需要问2个问题，那么回答问题数的期望值是2.8(<code>0.8 * 3 + 0.2 * 2</code>)。</p>

<p>如果我们每次不选熵值最高的问题，而选择熵值最低的问题，那么需要回答的问题的数量期望值为4到5之间。</p>

<h4>决策树</h4>

<p>上述这个过程就体现了训练决策树（Decision Tree）的基本思想。决策树学习属于归纳推理算法之一，适用于分类问题。决定问卷题出现顺序的这个过程，其实就是建立决策树模型的过程，即<strong>训练</strong>过程。</p>

<p>整个构建出来的图就是一个树状结构，这也是“决策树”这个名字的由来。而根据用户对每个问题的答案，从决策树的根节点走到叶子节点，最后来判断其属于何种人物类型，这个过程就是分类新数据的过程，即<strong>预测</strong>过程。</p>

<blockquote><p>有点需要注意的是，问卷案例中的每类武侠人物。都只有一个样本，而在泛化的机器学习问题中，每个类型对应了多个样本。也就是说，我们可以有很多个郭靖，而且每个人的属性并不完全一致，但是它们的分类都是“郭靖”。正是因为这个原因，决策树通常都只能把整体的熵降低到一个比较低的值，而无法完全降到0。这也意味着，训练得到的决策树模型，常常无法完全准确地划分训练样本，只能求到一个近似的解。</p></blockquote>

<h4>几种常见的决策树算法</h4>

<p>采用信息增益来构建决策树的算法被称为<a href="https://zh.wikipedia.org/wiki/ID3%E7%AE%97%E6%B3%95">ID3</a>（Iterative Dichotomiser 3，迭代二叉树3代）。但是这个算法有一个缺点，它一般会优先考虑具有较多取值的特征，因为取值多的特征会有相对较大的信息增益。这是为什么呢？</p>

<p>仔细观察一下信息熵的定义，就能发现背后的原因。更多的取值会把数据样本划分为更多更小的分组，这样熵就会大幅降低，信息增益就会大幅上升。但是这样构建出来的树，很容易导致机器学习中的过拟合现象，不利于决策树对新数据的预测。为了克服这个问题，人们又提出了一个改进版，<a href="https://zh.wikipedia.org/wiki/C4.5%E7%AE%97%E6%B3%95">C4.5算法</a>。</p>

<p>决策树也有不足。这类算法受训练样本的影响很大，比较容易过拟合。在预测阶段，如果新的数据和原来的训练样本差异较大，那么分类效果就会比较差。为此人们也提出了一些优化方案，比如剪枝和随机森林。</p>

<h3>28丨熵、信息增益和卡方：如何寻找关键特征？</h3>

<h4>通过信息增益进行特征选择</h4>

<p>类似于决策树算法。</p>

<h4>通过卡方检验进行特征选择</h4>

<p>在统计学中，我们使用卡方检验来检验两个变量是否相互独立。把它运用到特征选择，我们就可以检验特征与分类这两个变量是否独立。如果两者独立，证明特征和分类没有明显的相关性，特征对于分类来说没有提供足够的信息量。反之，如果两者有较强的相关性，那么特征对于分类来说就是有信息量的，是个好的特征。</p>

<p>为了检验独立性，卡方检验考虑了四种情况的概率：P(fi,cj)、P(fi¯,cj¯)、P(fi,cj¯)和P(fi¯,cj)。</p>

<p>在这四种概率中，P(fi,cj)和P(fi¯,cj¯)表示特征fi和分类cj是正相关的。如果P(fi,cj)很高，表示特征fi的出现意味着属于分类cj的概率更高；如果P(fi¯,cj¯)很高，表示特征fi不出现意味着不属于分类cj的概率更高。</p>

<p>类似地，P(fi,cj¯)和P(fi¯,cj)表示特征fi和分类cj是负相关的。如果P(fi,cj¯)很高，表示特征fi的出现意味着不属于分类cj的概率更高；如果P(fi¯,cj)很高，表示特征fi不出现意味着属于分类cj的概率更高。</p>

<p>如果特征和分类的相关性很高，要么是正向相关值远远大于负向相关值，要么是负向相关值远远大于正向相关值。如果特征和分类相关性很低，那么正向相关值和负向相关的值就会很接近。卡方检验就是利用了正向相关和负向相关的特性。</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C%E8%BF%9B%E8%A1%8C%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9.png" alt="20220531卡方检验进行特征选择.png" /></p>

<p>其中，N表示数据的总个数。通过这个公式，你可以看到，如果一个特征和分类的相关性很高，无论是正向相关还是负向相关，那么正向相关和负向相关的差值就很大，最终计算的值就很高。最后，我们就可以按照卡方检验的值由高到低对特征进行排序，挑选出排列靠前的特征。</p>

<h3>29丨归一化和标准化：各种特征如何综合才是最合理的？</h3>

<p>第一点，为什么有时候需要转换特征值？因为不同类型的特征取值范围不同，分布也不同，相互之间没有可比性。因此在线性回归中，通过这些原始值分析得到的权重，并不能代表每个特征实际的重要性。</p>

<p>我们用Boston Housing 数据集对房价数据进行回归分析，这个数据来自 70 年代美国波斯顿周边地区的房价，是用于机器学习的经典数据集，你可以在<a href="https://www.kaggle.com/c/boston-housing#description">Kaggle的网站</a>下载到它，并查看表格中各列的含义：</p>

<ol>
<li>CRIM：per capita crime rate by town.</li>
<li>ZN：proportion of residential land zoned for lots over 25,000 sq.ft.</li>
<li>INDUS：proportion of non-retail business acres per town.</li>
<li>CHAS：Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).</li>
<li>NOX：nitrogen oxides concentration (parts per 10 million).</li>
<li>RM：average number of rooms per dwelling.</li>
<li>AGE：proportion of owner-occupied units built prior to 1940.</li>
<li>DIS：weighted mean of distances to five Boston employment centres.</li>
<li>RAD：index of accessibility to radial highways.</li>
<li>TAX：full-value property-tax rate per \$10,000.</li>
<li>PTRATIO：pupil-teacher ratio by town.</li>
<li>B：1000(Bk - 0.63)<sup>2</sup> where Bk is the proportion of blacks by town.</li>
<li>LSTAT：lower status of the population (percent).</li>
<li>MEDV：median value of owner-occupied homes in \$1000s.</li>
</ol>


<blockquote><p>Kaggle上面好像不能直接下载啦，可以点击<a href="http://hongchaozhang.github.io/assets/resources/boston_house_price.csv">这里</a>下载。</p></blockquote>

<p>使用下面的python代码实现线性回归分析：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import pandas as pd
</span><span class='line'>from sklearn.linear_model import LinearRegression
</span><span class='line'>
</span><span class='line'>df = pd.read_csv("demo/datasets/boston_house_price.csv")  # 读取 Boston Housing 中的 csv数据
</span><span class='line'>df_features = df.drop(['MEDV'], axis=1)  # Dataframe 中除了最后一列，其余列都是特征，或者说自变量
</span><span class='line'>df_targets = df['MEDV']  # Dataframe 最后一列是目标变量，或者说因变量
</span><span class='line'>#
</span><span class='line'>regression = LinearRegression().fit(df_features, df_targets)  # 使用特征和目标数据，拟合线性回归模型
</span><span class='line'>print(regression.score(df_features, df_targets))  # 拟合程度的好坏
</span><span class='line'>print(regression.coef_)  # 各个特征所对应的系</span></code></pre></td></tr></table></div></figure>


<p>输出结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0.7406426641094095
</span><span class='line'>[-1.08011358e-01  4.64204584e-02  2.05586264e-02  2.68673382e+00
</span><span class='line'> -1.77666112e+01  3.80986521e+00  6.92224640e-04 -1.47556685e+00
</span><span class='line'>  3.06049479e-01 -1.23345939e-02 -9.52747232e-01  9.31168327e-03
</span><span class='line'> -5.24758378e-01]</span></code></pre></td></tr></table></div></figure>


<p>因为不是所有的数据都是可以使用线性回归模型来表示，所以我们需要使用 regression.score 函数，来看拟合的程度。如果完美拟合，这个函数就会输出 1；如果拟合效果很差，这个函数的输出可能就是一个负数。</p>

<p>这里 regression.score 函数的输出大约为 0.74，接近于 1.0。它表示这个数据集使用线性模型拟合的效果还是不错的。</p>

<blockquote><p>注意：下面是原文章中的解释，但是和我下载到的数据跑出的结果匹配不上，但是有关归一化和标准化的作用还是能够看出来的。
原文章中的输出：</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0.735578647853312
</span><span class='line'>[-4.54789253e-03 -5.17062363e-02  4.93344687e-02  5.34084254e-02
</span><span class='line'>  3.78011391e+00 -1.54106687e+01  3.87910457e+00 -9.51042267e-03
</span><span class='line'> -1.60411361e+00  3.61780090e-01 -1.14966409e-02 -8.48538613e-01
</span><span class='line'>  1.18853164e-02 -6.01842329e-01]</span></code></pre></td></tr></table></div></figure>


<p>权重可以帮助我们解释哪个特征对最终房价的中位值有更大的影响。参看 csv 中的数据，你会发现最主要的两个正相关特征是 nox（系数为 3.78011391e+00）和 age（系数为 3.87910457e+00）。其中 nox 表示空气污染浓度，age 表示老房子占比，也就是说空气污染越多、房龄越高，房价中位数越高，这好像不太合乎常理。我们再来看看最主要的负相关特征 rm（系数为 -1.54106687e+01），也就是房间数量。房间数量越多，房价中位数越低，也不合理。</p>

<p>造成这些现象最重要的原因是，不同类型的特征值没有转换到同一个可比较的范围内，所以线性回归后所得到的系数不具有可比性，因此我们无法直接对这些权重加以解释。</p>

<h4>归一化（Normalization）</h4>

<p>简单起见，这里的归一化是指使用特征取值范围中的最大值和最小值，把原始值转换为0到1之间的值。这样处理的好处在于简单易行，便于理解。不过，它的缺点也很明显，由于只考虑了最大最小值，因此很容易受到异常数据点的干扰。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>from sklearn.preprocessing import StandardScaler
</span><span class='line'>from sklearn.preprocessing import MinMaxScaler
</span><span class='line'>
</span><span class='line'>minMaxScaler = MinMaxScaler()  # 基于 min 和 max 值的归一化
</span><span class='line'>
</span><span class='line'>df = pd.read_csv("demo/datasets/boston_house_price.csv")  # 读取 Boston Housing 中的 csv的数据
</span><span class='line'>df_normalized = minMaxScaler.fit_transform(df)  # 对原始数据进行归一化，包括特征值和目标变量
</span><span class='line'>df_features_normalized = df_normalized[:, 0:-1]  # 获取归一化之后的特征值
</span><span class='line'>df_targets_normalized = df_normalized[:, -1]  # 获取归一化之后的目标值
</span><span class='line'>
</span><span class='line'># 再次进行线性回归
</span><span class='line'>regression_normalized = LinearRegression().fit(df_features_normalized, df_targets_normalized)
</span><span class='line'>print(regression_normalized.score(df_features_normalized, df_targets_normalized))
</span><span class='line'>print(regression_normalized.coef_)</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0.7406426641094094
</span><span class='line'>[-0.21355017  0.10315657  0.0124631   0.0597052  -0.1918794   0.4418597
</span><span class='line'>  0.00149367 -0.36059247  0.15642529 -0.14362949 -0.19901831  0.08206283
</span><span class='line'> -0.42260541]</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：下面是原文章中的解释，但是和我下载到的数据跑出的结果匹配不上，但是有关归一化和标准化的作用还是能够看出来的。
原文章中的输出：</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0.7355786478533118
</span><span class='line'>[-0.05103746 -0.08448544  0.10963215  0.03204506  0.08400253 -0.16643522
</span><span class='line'>  0.4451488  -0.01986622 -0.34152292  0.18490982 -0.13361651 -0.16216516
</span><span class='line'>  0.10390408 -0.48468369]</span></code></pre></td></tr></table></div></figure>


<p>你可以看到，表示拟合程度的分数没有变，但是每个特征对应的系数或者说权重，发生了比较大的变化。仔细观察一下，你会发现，这次最主要的正相关特征是 age（0.4451488）和 tax（0.18490982），也就是老房子占比和房产税的税率，其中至少房产税的税率是比较合理的，因为高房价的地区普遍税率也比较高。而最主要的负相关特征是 rad（-0.34152292）和 lstat（-0.48468369），rad 表示高速交通的便利程度，它的值越大表示离高速越远，房价中位数越低。而 lstat 表示低收入人群的占比，这个值越大房价中位数越低，这两点都是合理的。</p>

<h4>标准化（Standardizaiton）</h4>

<p>另一种常见的方法是基于正态分布的 z 分数（z-score）标准化（Standardization）。该方法假设数据呈现标准正态分布。</p>

<p>经过标准化处理之后，每种特征的取值都会变成一个标准正态分布，以0为均值，1为标准差。和归一化相比，标准化使用了数据是正态分布的假设，不容易受到过大或过小值的干扰。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>standardScaler = StandardScaler()  # 基于 Z 分数的标准化
</span><span class='line'>
</span><span class='line'>df = pd.read_csv("demo/datasets/boston_house_price.csv")  # 读取 Boston Housing 中的 csv的数据
</span><span class='line'>print(df)
</span><span class='line'>standardScaler.fit(df)
</span><span class='line'>df_standardized = standardScaler.transform(df)  # 对原始数据进行标准化，包括特征值和目标变量
</span><span class='line'>print(df_standardized)
</span><span class='line'>
</span><span class='line'>df_features_standardized = df_standardized[:, 0:-1]  # 获取标准化之后的特征值
</span><span class='line'>df_targets_standardized = df_standardized[:, -1]  # 获取标准化之后的特征值
</span><span class='line'>
</span><span class='line'># 再次进行线性回归
</span><span class='line'>regression_standardized = LinearRegression().fit(df_features_standardized, df_targets_standardized)
</span><span class='line'>print(regression_standardized.score(df_features_standardized, df_targets_standardized))
</span><span class='line'>print(regression_standardized.coef_)</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0.7406426641094093
</span><span class='line'>[-0.10101708  0.1177152   0.0153352   0.07419883 -0.22384803  0.29105647
</span><span class='line'>  0.00211864 -0.33783635  0.28974905 -0.22603168 -0.22427123  0.09243223
</span><span class='line'> -0.40744693]</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：下面是原文章中的解释，但是和我下载到的数据跑出的结果匹配不上，但是有关归一化和标准化的作用还是能够看出来的。
原文章中的输出：</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0.7355786478533118
</span><span class='line'>[-0.07330367 -0.04144107  0.12194378  0.04074345  0.09805446 -0.19311408
</span><span class='line'>  0.29767387 -0.02916672 -0.34642803  0.34477088 -0.21410757 -0.19904179
</span><span class='line'>  0.11218058 -0.46369483]</span></code></pre></td></tr></table></div></figure>


<p>表示拟合程度的分数任然没有变。再次对比不同特征所对应的系数，你会发现这次最主要的正相关特征还是 age（0.29767387）和 tax（0.34477088），但是相比之前，明显房产税的税率占了更高的权重，更加合理。而最主要的负相关特征还是 rad（-0.34152292）和 lstat（-0.48468369），这两点都是合理的。</p>

<h3>30丨统计意义（上）：如何通过显著性检验，判断你的A-B测试结果是不是巧合？</h3>

<ol>
<li>显著性差异</li>
<li>统计假设检验和显著性检验</li>
<li>P值</li>
</ol>


<h3>31丨统计意义（下）：如何通过显著性检验，判断你的A-B测试结果是不是巧合？</h3>

<p>对于正态分布的数据，可以采用方差分析（Analysis of Variance, ANOVA），也叫F检验。有了F值，我们需要根据F检验值的临界表来查找对应的P值。</p>

<p>对于非正态分布的数据，我们也可以使用非参数的分析。常见的非参数检验包括二项分布检验、K-S 检验、卡方检验等等。</p>

<h3>32丨概率统计篇答疑和总结为什么会有欠拟合和过拟合？</h3>

<h4>什么是欠拟合/过拟合</h4>

<p>在监督式学习过程中，适度拟合、欠拟合和过拟合，这三种状态是逐步演变的。</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E6%AC%A0%E6%8B%9F%E5%90%88%E8%BF%87%E6%8B%9F%E5%90%88.png" alt="20220531欠拟合过拟合.png" /></p>

<h4>如何处理欠拟合和过拟合？</h4>

<h5>欠拟合</h5>

<p>欠拟合问题，产生的主要原因是特征维度过少，拟合的模型不够复杂，无法满足训练样本，最终导致误差较大。因此，我们就可以增加特征维度，让输入的训练样本具有更强的表达能力。</p>

<p>之前讲解朴素贝叶斯的时候，我提到“任何两个变量是相互独立的假设”，这种假设和马尔科夫假设中的一元文法的作用一致，是为了降低数据稀疏程度、节省计算资源所采取的措施。可是，这种假设在现实中往往不成立，所以朴素贝叶斯模型的表达能力是非常有限的。当我们拥有足够的计算资源，而且希望建模效果更好的时候，我们就需要更加精细、更加复杂的模型，我们完全可以放弃朴素贝叶斯中关于变量独立性的假设，而使用二元、三元甚至更大的 N 元文法来处理这些数据。这就是典型的通过增加更多的特征，来提升模型的复杂度，让它从欠拟合阶段往适度拟合阶段靠拢。</p>

<h5>过拟合</h5>

<p>过拟合问题产生的主要原因则是特征维度过多，导致拟合的模型过于完美地符合训练样本，但是无法适应测试样本或者说新的数据。所以我们可以减少特征的维度。</p>

<p>之前在介绍决策树的时候，我提到了这类算法比较容易过拟合，可以使用剪枝和随机森林来缓解这个问题。</p>

<p>剪枝，顾名思义，就是删掉决策树中一些不是很重要的结点及对应的边，这其实就是在减少特征对模型的影响。虽然去掉一些结点和边之后，决策树对训练样本的区分能力变弱，但是可以更好地应对新数据的变化，具有更好的泛化能力。至于去掉哪些结点和边，我们可以使用前面介绍的特征选择方法来进行。</p>

<p>随机森林的构建过程更为复杂一些。“森林”表示有很多决策树，可是训练样本就一套，那这些树都是怎么来的呢？随机森林算法采用了统计里常用的可重复采样法，每次从全部 n 个样本中取出 m 个，然后构建一个决策树。重复这种采样并构建决策树的过程若干次，我们就能获得多个决策树。对于新的数据，每个决策树都会有自己的判断结果，我们取大多数决策树的意见作为最终结果。由于每次采样都是不完整的训练集合，而且有一定的随机性，所以每个决策树的过拟合程度都会降低。</p>

<p>从另一个角度来看，过拟合表示模型太复杂，而相对的训练数据量太少。因此我们也可以增加训练样本的数据量，并尽量保持训练数据和测试数据分布的一致性。如果我们手头上有大量的训练数据，则可以使用交叉验证（Cross Validation）的划分方式来保持训练数据和测试数据的一致性。其核心思想是在每一轮中，拿出大部分数据实例进行建模，然后用建立的模型对留下的小部分实例进行预测，最终对本次预测结果进行评估。这个过程反复进行若干轮，直到所有的标注样本都被预测了一次而且仅一次。如果模型所接受的数据总是在变化，那么我们就需要定期更新训练样本，重新拟合模型。</p>

<h2>05-线性代数篇 (13讲)</h2>

<h3>33丨线性代数：线性代数到底都讲了些什么？</h3>

<h4>标量，向量，向量空间</h4>

<h4>向量运算</h4>

<p>向量运算的几何意义</p>

<h4>矩阵运算</h4>

<p>乘法，转置，单位矩阵，逆矩阵</p>

<h3>34丨向量空间模型：如何让计算机理解现实事物之间的关系？</h3>

<h4>向量空间模型</h4>

<ol>
<li>向量之间的距离</li>
<li>向量的长度</li>
<li>向量之间的夹角，夹角余弦</li>
</ol>


<h4>向量空间模型与机器学习</h4>

<p>由于夹角余弦的取值范围已经在-1到1之间，而且越大表示越相似，所以可以直接作为相似度的取值。相对于夹角余弦，欧氏距离<code>ED</code>的取值范围可能很大，而且和相似度呈现反比关系，所以通常要进行<code>1/(1-ED)</code>这种归一化。</p>

<p>当ED为0的时候，变化后的值就是1，表示相似度为1，完全相同。当ED趋向于无穷大的时候，变化后的值就是0，表示相似度为0，完全不同。所以，这个变化后的值，取值范围是0到1之间，而且和相似度呈现正比关系。</p>

<p>早在上世纪的70年代，人们把向量空间模型运用于信息检索领域。由于向量空间可以很形象地表示数据点之间的相似程度，因此现在我们也常常把这个模型运用在基于相似度的一些机器学习算法中，例如K近邻（KNN）分类、K均值（K-Means)聚类等等。</p>

<h3>35丨文本检索：如何让计算机处理自然语言？</h3>

<h3>36丨文本聚类：如何过滤冗余的新闻？</h3>

<h3>37丨矩阵（上）：如何使用矩阵操作进行PageRank计算？</h3>

<p>我们可以把向量看作一维数组，把矩阵看作二维数组。矩阵的点乘，是由若干个向量的点乘组成的，所以我们可以通过矩阵的点乘操作，挖掘多组向量两两之间的关系。</p>

<p>我们讲了矩阵的点乘操作在PageRank算法中的应用。通过表示网页的邻接二元关系，我们可以使用矩阵来计算PageRank的得分。在这个应用场景下，矩阵点乘体现了多个马尔科夫过程中的状态转移。</p>

<p>矩阵点乘和其他运算操作，还可以运用在很多其他的领域。例如，我在上一节介绍K均值聚类算法时，就提到了需要计算某个数据点向量、其他数据点向量之间的距离或者相似度，以及使用多个数据点向量的平均值来获得质心点的向量，这些都可以通过矩阵操作来完成。</p>

<p>另外，在协同过滤的推荐中，我们可以使用矩阵点乘，来实现多个用户或者物品之间的相似程度，以及聚集后的相似程度所导致的最终推荐结果。下一节，我会使用矩阵来表示用户和物品的二元关系，并通过矩阵来计算协同过滤的结果。</p>

<h3>38丨矩阵（下）：如何使用矩阵操作进行协同过滤推荐？</h3>

<p>矩阵中的二维关系，除了可以表达图的邻接关系，还可以表达推荐系统中用户和物品的关系。这个关系是推荐系统的核心。</p>

<p>我们用矩阵 X 来表示用户对物品喜好程度：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.png" alt="20220531协同过滤推荐系统.png" /></p>

<p>其中第<code>i</code>行是第<code>i</code>个用户的数据，而第<code>j</code>列是用户对第<code>j</code>格物品的喜好程度。我们用<code>xij</code>表示这个数值。这里的喜好程度可以是用户购买商品的次数、对书籍的评分等等。</p>

<p>假设我们用一个0到1之间的小数表示。有了这种矩阵，我们就可以通过矩阵的操作，充分挖掘用户和物品之间的关系。下面，我会使用经典的协同过滤算法，来讲解矩阵在其中的运用。</p>

<h4>基于用户的协同过滤</h4>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7.png" alt="20220531协同过滤基于用户.png" /></p>

<p>根据这张图的访问关系来看，用户A访问了物品A和C，用户B访问了物品B，用户C访问了物品A，C和D。我们计算出来，用户C是A的近邻，而B不是。因此系统会更多地向用户A推荐用户C访问的物品D。</p>

<p>基于用户的协同过滤的核心公式如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E5%85%AC%E5%BC%8F1.png" alt="20220531基于用户协同过滤公式1.png" /></p>

<ol>
<li>第一个公式是计算用户和用户之间的相似度。完成了这一步我们就能找到给定用户的“近邻”。</li>
<li>第二个公式利用第一个公式所计算的用户间相似度，以及用户对物品的喜好度，预测任一个用户对任一个物品的喜好度。其中<code>pij</code>表示第<code>i</code>用户对第<code>j</code>个物品的喜好度。</li>
</ol>


<h4>基于物品的过滤</h4>

<p>基于物品的协同过滤是指利用物品相似度，而不是用户间的相似度来计算预测值。</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%9F%BA%E4%BA%8E%E7%89%A9%E5%93%81%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E5%9B%BE.png" alt="20220531基于物品的协同过滤图.png" /></p>

<p>在这张图中，物品A和C因为都被用户A和B同时访问，因此它们被认为相似度更高。当用户C访问过物品A后，系统会更多地向用户推荐物品C，而不是其他物品。</p>

<p>基于用户的协同过滤同样有两个公式:</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%9F%BA%E4%BA%8E%E7%89%A9%E5%93%81%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E5%85%AC%E5%BC%8F.png" alt="20220531基于物品的协同过滤公式.png" /></p>

<ol>
<li>第一个公式的核心思想是计算物品和物品之间的相似度。</li>
<li>第二个公式利用第一个公式所计算的物品间相似度，和用户对物品的喜好度，预测任一个用户对任一个物品的喜好度。</li>
</ol>


<p>协同过滤的公式（基于用户/物品）都可以用矩阵操作表达。</p>

<h4>总结</h4>

<p>今天我首先简要地介绍了推荐系统的概念和主要思想。为了给用户提供可靠的结果，推荐系统需要充分挖掘历史数据中，用户和物品之间的关系。协同过滤的推荐算法就很好地体现了这一点。</p>

<p>一旦涉及用户和物品的这种二元关系，矩阵就有用武之地了。我通过矩阵来表示用户和物品的关系，并通过矩阵计算来获得协同过滤的结果。协同过滤分为基于用户的过滤和基于物品的过滤两种，它们的核心思想都是相同的，因此矩阵操作也是类似的。在这两个应用场景下，矩阵点乘体现了多个用户或者物品之间的相似程度，以及聚集后的相似程度所导致的最终推荐结果。</p>

<p>当然，基于用户和物品间关系的推荐算法有很多，对矩阵的操作也远远不止点乘、按行求和、元素对应乘除法。我后面会介绍如何使用矩阵的主成分分析或奇异值分解，来进行物品的推荐。</p>

<h3>39丨线性回归（上）：如何使用高斯消元求解线性方程组？</h3>

<h4>高斯消元</h4>

<p>矩阵操作实现高斯消元求解线性方程组。</p>

<p>高斯消元法主要包含了消元和回代两个步骤。这些步骤都可以使用矩阵的操作来进行。从矩阵的角度来说，消元就是把系数矩阵变为上三角矩阵，而回代是把这个上三角矩阵变为单位矩阵。我们可以直接把用于消元和回代的矩阵，用于由系数和因变量值组成的增广矩阵，并获得最终的方程解。</p>

<h4>线性方程组与线性回归分析</h4>

<p>线性方程组的概念，也是线性回归分析的基础。它们有两个最主要的区别。</p>

<ol>
<li>第一个区别是，在线性回归分析中，样本数据会告诉我们自变量和因变量的值，要求的是系数。而在线性方程组中，我们已知系数和因变量的值，要求的是自变量的值。</li>
<li>第二个区别是，在线性回归分析中，方程的数量要远远大于自变量的数量，而且我们不要求每个方程式都是完全成立。这里，不要求完全成立的意思是，拟合出来的因变量值可以和样本数据给定的因变量值存在差异，也就允许模型拟合存在误差。模型拟合的概念我在上一模块的总结篇中重点讲解了，所以你应该能理解，模型的拟合不可能 100% 完美，这和我们求解线性方程组精确解的概念是不同的。</li>
</ol>


<p>正是因为这两点差异，我们无法直接使用消元法来求解线性回归，而是使用最小二乘法来解决线性回归的问题。</p>

<h3>40丨线性回归（中）：如何使用最小二乘法进行直线拟合？</h3>

<h3>41丨线性回归（下）：如何使用最小二乘法进行效果验证？</h3>

<p>从广义上来说，最小二乘法不仅可以用于线性回归，还可以用于非线性的回归。其主要思想还是要确保误差ε最小，但是由于现在的函数是非线性的，所以不能使用求多元方程求解的办法来得到参数估计值，而需要采用迭代的优化算法来求解，比如梯度下降法、随机梯度下降法和牛顿法。</p>

<h3>42丨PCA主成分分析（上）：如何利用协方差矩阵来降维？</h3>

<p>在概率统计模块，我详细讲解了如何使用各种统计指标来进行特征的选择，降低用于监督式学习的特征之维度。接下来的几节，我会阐述两种针对数值型特征，更为通用的降维方法，它们是主成分分析 PCA（Principal Component Analysis）和奇异值分解 SVD（Singular Value Decomposition）。这两种方法是从矩阵分析的角度出发，找出数据分布之间的关系，从而达到降低维度的目的。</p>

<h4>PCA 分析法的主要步骤</h4>

<p>对于m×n维的样本矩阵，其中每一行表示一个样本，而每一列表示一维特征。现在，我们的问题是，能不能通过某种方法，找到一种变换，可以降低这个矩阵的列数，也就是特征的维数，并且尽可能的保留原始数据中有用的信息？</p>

<p>针对这个问题，PCA 分析法提出了一种可行的解决方案。它包括了下面这样几个主要的步骤：</p>

<ol>
<li>标准化样本矩阵中的原始数据；</li>
<li>获取标准化数据的协方差矩阵；</li>
<li>计算协方差矩阵的特征值和特征向量；</li>
<li>依照特征值的大小，挑选主要的特征向量；</li>
<li>生成新的特征。</li>
</ol>


<h4>标准化原始数据</h4>

<p>之前我们已经介绍过特征标准化，这里我们需要进行同样的处理，才能让每维特征的重要性具有可比性。需要注意的是，这里标准化的数据是针对同一种特征，也是在同一个特征维度之内。不同维度的特征不能放在一起进行标准化。</p>

<h4>获取协方差矩阵</h4>

<p>首先，来看一下什么是<a href="https://zh.m.wikipedia.org/zh-sg/%E5%8D%8F%E6%96%B9%E5%B7%AE">协方差</a>（Covariance），以及<a href="https://zh.m.wikipedia.org/zh-sg/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5">协方差矩阵</a>。</p>

<p><strong>协方差</strong>是用于衡量两个变量的总体误差。假设两个变量分别是 x 和 y，而它们的采样数量都是 m，那么协方差的计算公式就是如下这种形式：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%8F%E6%96%B9%E5%B7%AE%E5%85%AC%E5%BC%8F.png" alt="20220531协方差公式.png" /></p>

<p>而当两个变量是相同时，协方差就变成了方差。</p>

<p>对于m×n维的样本矩阵，其<strong>协方差矩阵</strong>（i,j)位置处的值表示第i个特征（列向量）和第j个特征（列向量）之间的协方差，公式如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5ij%E4%BD%8D%E7%BD%AE%E5%85%83%E7%B4%A0.png" alt="20220531协方差矩阵ij位置元素.png" /></p>

<p>所以，样本矩阵的协方差矩阵就可以表示为：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E5%85%AC%E5%BC%8F.png" alt="20220531协方差矩阵公式.png" /></p>

<p>从协方差的定义可以看出，协方差矩阵是个对称矩阵。另外，这个对称矩阵的主对角线上的值就是各维特征的方差。</p>

<h4>计算协方差矩阵的特征值和特征向量</h4>

<p>需要注意的是，这里所说的矩阵的特征向量，和机器学习中的特征向量（Feature Vector）完全是两回事。矩阵的特征值和特征向量是线性代数中两个非常重要的概念。对于一个矩阵X，如果能找到向量v和标量λ，使得下面这个式子成立。</p>

<p><code>Xv=λv</code></p>

<p>那么，我们就说v是矩阵X的特征向量，而λ是矩阵X的特征值。矩阵的特征向量和特征值可能不止一个。说到这里，你可能会好奇，特征向量和特征值表示什么意思呢？我们为什么要关心这两个概念呢？简单的来说，我们可以把向量v左乘一个矩阵X看做对v进行旋转或拉伸，而这种旋转和拉伸都是由于左乘矩阵X后，所产生的“运动”所导致的。特征向量v表示了矩阵X运动的方向，特征值λ表示了运动的幅度，这两者结合就能描述左乘矩阵X所带来的效果，因此被看作矩阵的“特征”。在PCA中的主成分，就是指特征向量，而对应的特征值的大小，就表示这个特征向量或者说主成分的重要程度。特征值越大，重要程度越高，我们要优先现在这个主成分，并利用这个主成分对原始数据进行变换。</p>

<h4>挑选主要的特征向量，转换原始数据</h4>

<p>假设我们获得了k个特征值和对应的特征向量，按照所对应的λ数值的大小，对这k组的特征向量进行排序。排名靠前的特征向量就是最重要的特征向量。</p>

<p>假设我们只取前k1个最重要的特征，那么我们使用这k1个特征向量，组成一个n×k1维的矩阵D。</p>

<p>把包含原始数据的m×n维矩阵X左乘矩阵D，就能重新获得一个m×k1维的矩阵，达到了降维的目的。</p>

<p>有的时候，我们无法确定k1取多少合适。一种常见的做法是，看前k1个特征值的和占所有特征值总和的百分比。假设一共有10个特征值，总和是100，最大的特征值是80，那么第一大特征值占整个特征值之和的80%，我们认为它能表示80%的信息量，还不够多。那我们就继续看第二大的特征值，它是15，前两个特征值之和有95，占比达到了95%，如果我们认为足够了，那么就可以只选前两大特征值，把原始数据的特征维度从10维降到2维。</p>

<h3>43丨PCA主成分分析（下）：为什么要计算协方差矩阵的特征值和特征向量？</h3>

<p>这一部分分析的太到位了，将原文链接放上：<a href="http://hongchaozhang.github.io/assets/resources/43%E4%B8%A8PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%A1%E7%AE%97%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%EF%BC%9F.html">PCA主成分分析（下）：为什么要计算协方差矩阵的特征值和特征向量？</a>。</p>

<h4>基于Python的案例分析</h4>

<p>通过基于Python的案例来一步步计算PCA的各个步骤的中间结果。</p>

<h4>PCA背后的核心思想</h4>

<p><strong>为什么要使用协方差矩阵？</strong></p>

<p>为什么我们要使用样本数据中，各个维度之间的协方差，来构建一个新的协方差矩阵？要弄清楚这一点，首先要回到PCA最终的目标：降维。降维就是要去除那些表达信息量少，或者冗余的维度。</p>

<ol>
<li>我们首先来看如何定义维度的<strong>信息量</strong>大小。这里我们认为样本在某个特征上的差异越大，这个特征包含的信息量就越大，就越重要。很自然，我们就能想到使用某维特征的方差来定义样本在这个特征维度上的差异。</li>
<li>另一方面，我们要看如何发现冗余的信息。如果两种特征是有很高的相关性，那我们可以从一个维度的值推算出另一个维度的值，所表达的信息就是重复的。在实际运用中，我们可以使用皮尔森（Pearson）相关系数，来描述两个变量之间的线性相关程度。这个系数的取值范围是<code>[−1,1]</code>，绝对值越大，说明相关性越高，正数表示正相关，负数表示负相关。在本质上，皮尔森相关系数和数据标准化后的协方差是一致的。</li>
</ol>


<p>考虑到协方差既可以衡量信息量的大小，也可以衡量不同维度之间的相关性，因此我们就使用各个维度之间的协方差所构成的矩阵，作为PCA分析的对象。就如前面说讲述的，这个协方差矩阵主对角线上的元素是各维度上的方差，也就体现了信息量，而其他元素是两两维度间的协方差，也就体现了相关性。</p>

<p>既然协方差矩阵提供了我们所需要的方差和相关性，那么下一步，我们就要考虑对这个矩阵进行怎样的操作了。</p>

<p><strong>为什么要计算协方差矩阵的特征值和特征向量？</strong></p>

<p>关于这点，我们可以从两个角度来理解。</p>

<p>第一个角度是对角矩阵。所谓对角矩阵，就是说只有矩阵主对角线之上的元素有非0值，而其他元素的值都为0。我们刚刚解释了协方差矩阵的主对角线上，都是表示信息量的方差，而其他元素都是表示相关性的协方差。既然我们希望尽可能保留大信息量的维度，而去除相关的维度，那么就意味着我们希望对协方差进行对角化，尽可能地使得矩阵只有主对角线上有非0元素。</p>

<p>假如我们确实可以把矩阵尽可能的对角化，那么对角化之后的矩阵，它的主对角线上元素就是、或者接近矩阵的特征值，而特征值本身又表示了转换后的方差，也就是信息量。而此时，对应的各个特征向量之间是基本正交的，也就是相关性极低甚至没有相关性。</p>

<p>第二个角度是特征值和特征向量的几何意义。在向量空间中，对某个向量左乘一个矩阵，实际上是对这个向量进行了一次变换。在这个变换的过程中，被左乘的向量主要发生旋转和伸缩这两种变化。<strong>如果左乘矩阵对某一个向量或某些向量只发生伸缩变换，不对这些向量产生旋转的效果，那么这些向量就称为这个矩阵的特征向量，而伸缩的比例就是特征值</strong>。换句话来说，某个矩阵的特征向量表示了这个矩阵在空间中的变换方向，这些方向都是趋于正交的，而特征值表示每个方向上伸缩的比例。</p>

<p>如果一个特征值很大，那么说明在对应的特征向量所表示的方向上，伸缩幅度很大。这也是为什么，我们需要使用原始的数据去左乘这个特征向量，来获取降维后的新数据。因为这样做可以帮助我们找到一个方向，让它最大程度地包含原有的信息。需要注意的是，这个新的方向，往往不代表原始的特征，而是多个原始特征的组合和缩放。</p>

<h3>44丨奇异值分解：如何挖掘潜在的语义关系？</h3>

<p>今天，我们来聊另一种降维的方法，SVD奇异值分解（SingularValueDecomposition）。它的核心思路和PCA不同。PCA是通过分析不同纬特征之间的协方差，找到包含最多信息量的特征向量，从而实现降维。而SVD这种方法试图通过样本矩阵本身的分解，找到一些“潜在的因素”，然后通过把原始的特征维度映射到较少的潜在因素之上，达到降维的目的。</p>

<h4>方阵的特征分解</h4>

<ul>
<li>方阵</li>
<li>酉矩阵</li>
<li>方阵的特征分解</li>
</ul>


<p>那么如果X不是方阵，那么应该如何进行矩阵的分解呢？这个时候就需要用到奇异值分解SVD了。</p>

<h4>SVD分解</h4>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3">Wiki SVD分解</a></li>
<li>奇异值</li>
<li>右奇异向量</li>
<li>左奇异向量</li>
</ul>


<h4>潜在语义分析和SVD</h4>

<h3>45丨线性代数篇答疑和总结：矩阵乘法的几何意义是什么？</h3>

<h2>06-综合应用篇 (6讲)</h2>

<h3>46丨缓存系统：如何通过哈希表和队列实现高效访问？</h3>

<p>缓存设计的几个主要考量因素:
1. 硬件性能：高性能做低性能的缓存。
2. 命中率。缓存删除策略：
    1. 最少使用 LFU（Least Frequently Used）策略
    2. 最久未用 LRU（Least Recently Used）策略：使用队列（Queue）表示上次使用时间，刚用过的放在队尾，淘汰的时候直接淘汰队头的即可。
3. 更新周期</p>

<p>我们同时使用了哈希函数和队列，实现了一个最简单的缓存系统。哈希函数确保了查找的高效率，而队列则实现了LRU的淘汰策略。通过这两点，你就能理解缓存设计的基本原理和方法。</p>

<h3>47丨搜索引擎（上）：如何通过倒排索引和向量空间模型，打造一个简单的搜索引擎？</h3>

<p>搜索引擎最重要的核心就是及时性和相关性。及时性确保用户可以快速找到信息，而相关性确保所找到的信息是用户真正需要的。
1. 倒排索引是搜索引擎提升及时性中非常关键的一步。倒排索引非常适合使用哈希表，特别是链地址型的哈希表来实现。
2. 向量空间模型可以作为文本搜索的相关性模型。但是，它的计算需要把查询和所有的文档进行比较，时间复杂度太高，影响了及时性。这个时候，我们可以利用倒排索引，过滤掉绝大部分不包含查询关键词的文档。</p>

<h3>48丨搜索引擎（下）：如何通过查询的分类，让电商平台的搜索结果更相关？</h3>

<p>相关性模型是搜索引擎非常核心的模块，它直接影响了搜索结果是不是满足用户的需求。我们之前讲解的向量空间模型、概率语言模型等常见的模型，逐渐成为了主流的相关性模型。不过这些模型通常适用于普通的文本检索，并没有针对每个应用领域进行优化。</p>

<p>在电商平台上，搜索引擎是帮助用户查找商品的好帮手。可是，直接采用向量空间模型进行排序往往效果不好。这主要是因为索引的标题和属性都很短，我们无法充分利用关键词的词频、逆文档频率等信息。考虑到搜索商品的时候，商品的分类对于用户更为重要，所以我们在设计相关性排序的时候需要考虑这个信息。</p>

<p>为了识别用户对哪类商品更感兴趣，我们可以对用户输入的查询进行分类。用于构建分类器的数据，可以是运营人员发布的商品目录信息，也可以是用户使用之后的行为日志。我们可以根据搜索系统运行的情况，赋予它们不同的权重。</p>

<p>如果我们可以对查询做出更为准确的分类，那么就可以使用这个分类的结果，来对原有搜索结果进行重新排序。现在的开源搜索引擎，例如Elasticsearch，都支持动态修改排序结果，为我们结合分类器和搜索引擎提供了很大的便利。</p>

<h3>49丨推荐系统（上）：如何实现基于相似度的协同过滤？</h3>

<p>原文链接：<a href="http://hongchaozhang.github.io/assets/resources/49%E4%B8%A8%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%EF%BC%9F.html">49丨推荐系统（上）：如何实现基于相似度的协同过滤？.html</a></p>

<p>通过一个常用的实验数据，设计并实现了最简单的基于用户的协同过滤。值得动手练习一下。</p>

<h3>50丨推荐系统（下）：如何通过SVD分析用户和物品的矩阵？</h3>

<p>原文链接：<a href="http://hongchaozhang.github.io/assets/resources/50%E4%B8%A8%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87SVD%E5%88%86%E6%9E%90%E7%94%A8%E6%88%B7%E5%92%8C%E7%89%A9%E5%93%81%E7%9A%84%E7%9F%A9%E9%98%B5%EF%BC%9F.html">50丨推荐系统（下）：如何通过SVD分析用户和物品的矩阵？.html</a></p>

<p>通过Python示例，解释了SVD分解过程中的数学量的物理意义，值得上手一试。</p>

<blockquote><p>在用户对电影评分的应用场景下，SVD分解后的U矩阵、V矩阵和Σ矩阵各自代表的意义，其中Σ矩阵中的奇异值表示了SVD挖掘出来的电影主题，U矩阵中的奇异向量表示用户对这些电影主题的评分，而V矩阵中的奇异向量表示了电影和这些主题的相关程度。</p>

<p>分解之后所得到的奇异值σ对应了一个“主题”，σ值的大小表示这个主题在整个电影集合中的重要程度，而V中的右奇异向量表示每部电影和这些“主题”的关系强弱。</p></blockquote>

<h3>51丨综合应用篇答疑和总结：如何进行个性化用户画像的设计？</h3>

<h2>07-加餐 (3讲)</h2>

<h3>数学专栏课外加餐（一）丨我们为什么需要反码和补码？</h3>

<h3>数学专栏课外加餐（三）：程序员需要读哪些数学书？</h3>

<h3>数学专栏课外加餐（二）丨位操作的三个应用实例</h3>

<h2>08-结束语 (1讲)</h2>

<h3>结束语丨从数学到编程，本身就是一个很长的链条</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[web性能优化]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/03/21/web-xingneng-youhua/"/>
    <updated>2022-03-21T23:30:53+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/03/21/web-xingneng-youhua</id>
    <content type="html"><![CDATA[<!-- more -->


<p>从web渲染全过程分析，从下面几个方面进行性能优化考虑：</p>

<ol>
<li>HTTP请求性能优化</li>
<li>浏览器内渲染性能优化</li>
</ol>


<h2>HTTP(s)请求性能优化</h2>

<ul>
<li>参考极客时间课程《透视HTTP协议》的39和40两节课。</li>
<li>另外，<a href="http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi/">极客时间-罗剑锋-《透视HTTP协议》总结</a>中的章节<a href="http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi/#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">http性能优化</a>，有一个概括性的描述。</li>
<li>相关内容个人总结参考<a href="http://hongchaozhang.github.io/blog/2022/03/08/http-xingneng-youhua/">HTTP(s)请求性能优化</a>。</li>
</ul>


<h2>浏览器内渲染性能优化</h2>

<ul>
<li>参考极客时间课程《让你页面速度飞起来 Web前端性能优化》</li>
<li>相关内容个人总结参考<a href="http://hongchaozhang.github.io/blog/2022/01/04/web-qianduan-xingneng-youhua/">极客时间-Web前端性能优化</a>。</li>
</ul>

]]></content>
  </entry>
  
</feed>
