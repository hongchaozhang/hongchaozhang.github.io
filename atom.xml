<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Reading Space]]></title>
  <link href="http://hongchaozhang.github.io/atom.xml" rel="self"/>
  <link href="http://hongchaozhang.github.io/"/>
  <updated>2022-06-14T23:36:52+08:00</updated>
  <id>http://hongchaozhang.github.io/</id>
  <author>
    <name><![CDATA[Zhang Hongchao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[程序员的数学基础课（黄申）]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/05/31/chengxuyuan-shuxue-jichuke/"/>
    <updated>2022-05-31T15:48:14+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/05/31/chengxuyuan-shuxue-jichuke</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>01-开篇词 (1讲)</h2>

<h3>00丨开篇词丨作为程序员，为什么你应该学好数学？</h3>

<h2>02-导读 (1讲)</h2>

<h3>00丨导读：程序员应该怎么学数学？</h3>

<h2>03-基础思想篇 (18讲)</h2>

<h3>01丨二进制：不了解计算机的源头，你学什么编程</h3>

<h3>02丨余数：原来取余操作本身就是个哈希函数</h3>

<h3>03丨迭代法：不用编程语言的自带函数，你会如何计算平方根？</h3>

<h4>迭代法有什么具体应用？</h4>

<p>迭代法在无论是在数学，还是计算机领域都有很广泛的应用。大体上，迭代法可以运用在以下几个方面：</p>

<ol>
<li>求数值的精确或者近似解。典型的方法包括二分法（Bisection method）和牛顿迭代法（Newton’s method）。</li>
<li>在一定范围内查找目标值。典型的方法包括二分查找。</li>
<li>机器学习算法中的迭代。相关的算法或者模型有很多，比如 K- 均值算法（K-means clustering）、PageRank 的马尔科夫链（Markov chain）、梯度下降法（Gradient descent）等等。迭代法之所以在机器学习中有广泛的应用，是因为很多时候机器学习的过程，就是根据已知的数据和一定的假设，求一个局部最优解。而迭代法可以帮助学习算法逐步搜索，直至发现这种解。</li>
</ol>


<h3>04丨数学归纳法：如何用数学归纳提升代码的运行效率？</h3>

<p>数学归纳法的一般步骤是这样的：</p>

<ol>
<li>证明基本情况（通常是<code>n=1</code>的时候）是否成立；</li>
<li>假设<code>n=k−1</code>成立，再证明<code>n=k</code>也是成立的（<code>k</code>为任意大于1的自然数）。</li>
</ol>


<p>和使用迭代法的计算相比，数学归纳法最大的特点就在于“归纳”二字。它已经总结出了规律。只要我们能够证明这个规律是正确的，就没有必要进行逐步的推算，可以节省很多时间和资源。</p>

<p><strong>递归调用的代码和数学归纳法的逻辑是一致的。</strong></p>

<h4>递归和数学归纳法的核心思想</h4>

<p>复杂的问题，每次都解决一点点，并将剩下的任务转化成为更简单的问题等待下次求解，如此反复，直到最简单的形式。</p>

<h3>05丨递归（上）：泛化数学归纳，如何将复杂问题简单化？</h3>

<h3>06丨递归（下）：分而治之，从归并排序到MapReduce</h3>

<p>对于一些复杂问题，我们可以先分析一下，它们是否可以简化为某些更小的、更简单的子问题来解决，这是一般思路。如果可以，那就意味着我们仍然可以使用递归的核心思想，将复杂的问题逐步简化成最基本的情况来求解。</p>

<p>因此，今天我会从归并排序开始，延伸到多台机器的并行处理，详细讲讲递归思想在“分而治之”这个领域的应用。</p>

<h4>归并排序</h4>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%A8%A1%E5%9E%8B.jpeg" alt="20220531归并排序模型.jpeg" /></p>

<p>我们可以在归并排序中引入了分而治之（Divide and Conquer）的思想。分而治之，我们通常简称为分治。它的思想就是，将一个复杂的问题，分解成两个甚至多个规模相同或类似的子问题，然后对这些子问题再进一步细分，直到最后的子问题变得很简单，很容易就能被求解出来，这样这个复杂的问题就求解出来了。</p>

<h4>分布式系统中的分治思想</h4>

<p>分而治之更有趣的应用其实是在分布式系统中。</p>

<p>例如，当需要排序的数组很大（比如达到 1024GB 的时候），我们没法把这些数据都塞入一台普通机器的内存里。该怎么办呢？有一个办法，我们可以把这个超级大的数据集，分解为多个更小的数据集（比如 16GB 或者更小），然后分配到多台机器，让它们并行地处理。</p>

<p>等所有机器处理完后，中央服务器再进行结果的合并。由于多个小任务间不会相互干扰，可以同时处理，这样会大大增加处理的速度，减少等待时间。</p>

<p>在单台机器上实现归并排序的时候，我们只需要在递归函数内，实现数据分组以及合并就行了。而在多个机器之间分配数据的时候，递归函数内除了分组及合并，还要负责把数据分发到某台机器上。</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.jpeg" alt="20220531分而治之分布式系统.jpeg" /></p>

<h3>07丨排列：如何让计算机学会“田忌赛马”？</h3>

<h3>08丨组合：如何让计算机安排世界杯的赛程？</h3>

<h3>09丨动态规划（上）：如何实现基于编辑距离的查询推荐？</h3>

<p>聊聊查询推荐（Query Suggestion）的实现过程，以及它所使用的数学思想，动态规划（Dynamic Programming）。</p>

<h4>编辑距离</h4>

<p>搜索下拉提示和关键词纠错，这两个功能其实就是查询推荐。查询推荐的核心思想其实就是，对于用户的输入，查找相似的关键词并进行返回。而测量拉丁文的文本相似度，最常用的指标是<strong>编辑距离</strong>（Edit Distance）。</p>

<p>编辑距离是指由一个字符串转成另一个字符串所需的最少编辑操作次数。</p>

<h4>状态转移</h4>

<p>我用mouuse和mouse的例子。我把mouuse的字符数组作为表格的行，每一行表示其中一个字母，而mouse的字符数组作为列，每列表示其中一个字母，这样就得到下面这个表格。</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.png" alt="20220531编辑距离状态转移.png" /></p>

<h3>10丨动态规划（下）：如何求得状态转移方程并进行编程实现？</h3>

<h4>状态转移方程</h4>

<p><img src="http://hongchaozhang.github.io/images/20220531%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B.png" alt="20220531编辑距离状态转移方程.png" /></p>

<p>这里面求最小值的<code>min</code>函数里有三个参数，分别对应我们上节讲的三种情况的编辑距离，分别是：替换、插入和删除字符。在表格的右下角我标出了两个字符串的编辑距离1。</p>

<p>我们假设字符数组<code>A[]</code>和<code>B[]</code>分别表示字符串<code>A</code>和<code>B</code>，<code>A[i]</code>表示字符串<code>A</code>中第<code>i</code>个位置的字符，<code>B[i]</code>表示字符串<code>B</code>中第<code>i</code>个位置的字符。二维数组<code>d[,]</code>表示刚刚用于推导的二维表格，而<code>d[i,j]</code>表示这张表格中第<code>i</code>行、第<code>j</code>列求得的最终编辑距离。函数<code>r(i, j)</code>表示替换时产生的编辑距离。如果<code>A[i]</code>和<code>B[j]</code>相同，函数的返回值为0，否则返回值为1。</p>

<p>有了这些定义，下面我们用迭代来表达上述的推导过程。</p>

<ol>
<li>如果<code>i</code>为0，且<code>j</code>也为0，那么<code>d[i, j]</code>为0。</li>
<li>如果<code>i</code>为0，且<code>j</code>大于0，那么<code>d[i, j]</code>为<code>j</code>。</li>
<li>如果<code>i</code>大于0，且<code>j</code>为0，那么<code>d[i, j]</code>为<code>i</code>。</li>
<li>如果<code>i</code>大于0，且<code>j</code>大于0，那么<code>d[i, j]=min(d[i-1, j] + 1, d[i, j-1] + 1, d[i-1, j-1] + r(i, j))</code>。</li>
</ol>


<p>这里面最关键的一步是<code>d[i, j]=min(d[i-1, j] + 1, d[i, j-1] + 1, d[i-1, j-1] + r(i, j))</code>。这个表达式表示的是动态规划中从上一个状态到下一个状态之间可能存在的一些变化，以及基于这些变化的最终决策结果。我们把这样的表达式称为<strong>状态转移方程</strong>。</p>

<h4>总结</h4>

<p>通过这两节的内容，我讲述了动态规划主要的思想和应用。如果仅仅看这两个案例，也许你觉得动态规划不难理解。不过，在实际应用中，你可能会产生这些疑问：什么时候该用动态规划？这个问题可以用动态规划解决啊，为什么我没想到？我这里就讲一些我个人的经验。</p>

<p>首先，如果一个问题有很多种可能，看上去需要使用排列或组合的思想，但是最终求的只是某种最优解（例如最小值、最大值、最短子串、最长子串等等），那么你不妨试试是否可以使用动态规划。</p>

<p>其次，状态转移方程是个关键。你可以用状态转移表来帮助自己理解整个过程。如果能找到准确的转移方程，那么离最终的代码实现就不远了。</p>

<h3>11丨树的深度优先搜索（上）：如何才能高效率地查字典？</h3>

<h3>12丨树的深度优先搜索（下）：如何才能高效率地查字典？</h3>

<h3>13丨树的广度优先搜索（上）：人际关系的六度理论是真的吗？</h3>

<h3>14丨树的广度优先搜索（下）：为什么双向广度优先搜索的效率更高？</h3>

<h4>如何更高效地求两个用户间的最短路径？</h4>

<p>基本的做法是，从其中一个人出发，进行广度优先搜索，看看另一个人是否在其中。如果不幸的话，两个人相距六度，那么即使是广度优先搜索，同样要达到万亿级的数量。</p>

<p>那究竟该如何更高效地求得两个用户的最短路径呢？我们先看看，影响效率的问题在哪里？很显然，随着社会关系的度数增加，好友数量是呈指数级增长的。所以，如果我们可以控制这种指数级的增长，那么就可以控制潜在好友的数量，达到提升效率的目的。</p>

<p>如何控制这种增长呢？我这里介绍一种“<strong>双向广度优先搜索</strong>”。它巧妙地运用了两个方向的广度优先搜索，大幅降低了搜索的度数。</p>

<h3>15丨从树到图：如何让计算机学会看地图？</h3>

<p>使用Dijkstra算法来查找地图中两点之间的最短路径。</p>

<h3>16丨时间和空间复杂度（上）：优化性能是否只是“纸上谈兵”？</h3>

<h3>17丨时间和空间复杂度（下）：如何使用六个法则进行复杂度分析？</h3>

<h3>18丨总结课：数据结构、编程语句和基础算法体现了哪些数学思想？</h3>

<h2>04-概率统计篇 (14讲)</h2>

<h3>19丨概率和统计：编程为什么需要概率和统计？</h3>

<h3>20丨概率基础（上）：一篇文章帮你理解随机变量、概率分布和期望值</h3>

<h4>随机变量</h4>

<h4>概率分布</h4>

<ol>
<li>离散概率分布：伯努利分布、分类分布、二项分布、泊松分布

<ol>
<li>伯努利分布：二分类分布</li>
<li>分类分布：随机变量的取值空间为<code>n</code>个离散的值，<code>n=2</code>时就是伯努利分布。</li>
</ol>
</li>
<li>连续概率分布：正态分布、均匀分布、指数分布、拉普拉斯分布

<ol>
<li>正态分布：也叫高斯分布，有两个关键参数：均值和方差。</li>
</ol>
</li>
</ol>


<h4>期望值</h4>

<p>均值是期望值的特例，即各个取值的概率相同。</p>

<h3>21丨概率基础（下）：联合概率、条件概率和贝叶斯法则，这些概率公式究竟能做什么？</h3>

<h4>联合概率</h4>

<p>由多个随机变量决定的概率我们就叫联合概率，使用<code>P(x, y)</code>表示。</p>

<h4>边缘概率</h4>

<p>联合概率和单个随机变量的概率之间有什么关联呢？对于离散型随机变量，我们可以通过通过联合概率<code>P(x, y)</code>在<code>y</code>上求和，就可以得到<code>P(x)</code>。对于连续型随机变量，我们可以通过联合概率<code>P(x, y)</code>在<code>y</code>上的积分，推导出概率<code>P(x)</code>。这个时候，我们称<code>P(x)</code>为<strong>边缘概率</strong>。</p>

<h4>条件概率</h4>

<p>条件概率也是由多个随机变量决定，但是和联合概率不同的是，它计算了给定某个（或多个）随机变量的情况下，另一个（或多个）随机变量出现的概率，其概率分布叫做条件概率分布。给定随机变量<code>x</code>，随机变量<code>y</code>的条件概率使用<code>P(y|x)</code>表示。</p>

<h4>贝叶斯法则</h4>

<p>条件概率、联合概率之间的关系如下：
<code>P(x,y) = P(x|y) * P(y)</code></p>

<p>根据上面的关系，可以得到贝叶斯定理如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86.png" alt="20220531贝叶斯定理.png" /></p>

<ol>
<li>先验概率： 我们把<code>P(x)</code>称为先验概率。之所以称为“先验”，是因为它是从数据资料统计得到的，不需要经过贝叶斯定理的推算。</li>
<li>条件概率（似然函数）：<code>P(y|x)</code>是给定<code>x</code>之后<code>y</code>出现的条件概率。在统计学中，我们也把<code>P(y|x)</code>写作似然函数<code>L(x|y)</code>。在数学里，似然函数和概率是有区别的。概率是指已经知道模型的参数来预测结果，而似然函数是根据观测到的结果数据，来预估模型的参数。不过，当<code>y</code>值给定的时候，两者在数值上是相等的，在应用中我们可以不用细究。</li>
<li>边缘概率：我们没有必要事先知道<code>P(y)</code>。<code>P(y)</code>可以通过联合概率<code>P(x,y)</code>计算边缘概率得来，而联合概率<code>P(x,y)</code>可以由<code>P(y|x)</code>*<code>P(x)</code>推出。</li>
<li>后验概率：<code>P(x|y)</code>是根据贝叶斯定理，通过先验概率<code>P(x)</code>、似然函数<code>P(y|x)</code>和边缘概率<code>P(y)</code>推算而来，因此我们把它称作后验概率。</li>
</ol>


<p>如果有一定数量的标注数据，那么通过统计的方法，我们可以很方便地得到先验概率和似然函数，然后推算出后验概率，最后依据后验概率来做预测。这整个过程符合监督式机器学习的模型训练和新数据预测这两个阶段，因此朴素贝叶斯算法被广泛运用在机器学习的分类问题中。</p>

<h4>随机变量之间的独立性</h4>

<p>如果随机变量<code>x</code>和<code>y</code>之间不相互影响，那么我们就说<code>x</code>和<code>y</code>相互独立。此时，有<code>P(x|y)=P(x)</code>，所以<code>P(x,y)=P(x)*P(y)</code>。</p>

<p>变量之间的独立性，可以帮我们简化计算。</p>

<p>举个例子，假设有6个随机变量，而每个变量有10种可能的取值，那么计算它们的联合概率<code>p(x1,x2,x3,x4,x5,x6)</code>，在实际中是非常困难的一件事情。</p>

<p>根据排列，可能的联合取值，会达到10的6次方，也就是100万这么多。那么使用实际的数据进行统计时，我们也至少需要这个数量级的样本，否则的话很多联合概率分布的值就是0，产生了数据稀疏的问题。但是，如果假设这些随机变量都是相互独立的，那么我们就可以将联合概率<code>p(x1,x2,x3,x4,x5,x6)</code>转换为<code>p(x1)*p(x2)*p(x3)*p(x4)*p(x5)*p(x6)</code>。如此一来，我们只需要计算<code>p(x1)</code>到<code>p(x6)</code>就行了。</p>

<h3>22丨朴素贝叶斯：如何让计算机学会自动分类？</h3>

<h4>训练样本</h4>

<p>贝叶斯分类需要的训练样本如下：
<img src="http://hongchaozhang.github.io/images/20220531%E8%AE%AD%E7%BB%83%E6%A0%B7%E6%9C%AC.png" alt="20220531训练样本" /></p>

<h4>训练</h4>

<p>贝叶斯定理的核心思想：<strong>用先验概率和条件概率估计后验概率</strong>。</p>

<p>具体到这里的分类问题，贝叶斯公式可以写成这样：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%85%AC%E5%BC%8F.png" alt="20220531贝叶斯分类公式.png" /></p>

<p>其中<code>c</code>表示一个分类（class）, <code>f</code>表示属性对应的数据字段（field）。如此一来，等号左边的<code>P(c|f)</code>就是待分类样本中，出现属性值<code>f</code>时，样本属于类别<code>c</code>的概率。而等号右边的<code>P(f|c)</code>是根据训练数据统计，得到分类<code>c</code>中出现属性<code>f</code>的概率。<code>P(c)</code>是分类<code>c</code>在训练数据中出现的概率，<code>P(f)</code>是属性<code>f</code>在训练样本中出现的概率。</p>

<p>这里的贝叶斯公式只描述了单个属性值属于某个分类的概率，可是我们要分析的水果每个都有很多属性，<strong>朴素贝叶斯</strong>在这里就要发挥作用了。这是基于一个简单假设建立的一种贝叶斯方法，并<strong>假定数据对象的不同属性对其归类影响时是相互独立的</strong>。此时若数据对象<code>o</code>中同时出现属性<code>fi</code>与<code>fj</code>，则对象<code>o</code>属于类别<code>c</code>的概率就是这样：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%85%AC%E5%BC%8F.png" alt="20220531朴素贝叶斯分类公式.png" /></p>

<p>现在，我们应该已经可以用10个水果的数据，来建立朴素贝叶斯模型了。</p>

<p>比如，苹果的分类中共包含3个数据实例，对于形状而言，出现2次不规则圆、1次圆形和0次椭圆形，因此各自的统计概率为0.67、0.33和0.00。我们将这些值称为，给定一个水果分类时，出现某个属性值的<strong>条件概率</strong>。以此类推，所有的统计结果就是下面这个表格中这样：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E8%B4%9D%E5%8F%B6%E6%96%AF%E8%AE%AD%E7%BB%83%E6%A0%B7%E6%9C%AC%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87.png" alt="20220531贝叶斯训练样本条件概率.png" /></p>

<blockquote><p>对于上表中出现的0.00概率，在做贝叶斯公式中的乘积计算时，会出现结果为0的情况，因此我们通常取一个比这个数据集里最小统计概率还要小的极小值，来代替“零概率”。比如，我们这里取0.01。在填充训练数据中从来没有出现过的属性值的时候，我们就会使用这种技巧，我们给这种技巧起个名字就叫作<strong>平滑</strong>（Smoothing）。</p></blockquote>

<h4>预测</h4>

<p>有了这些条件概率，以及各类水果和各个属性出现的先验概率，我们已经建立起了朴素贝叶斯模型。现在，我们就可以用它进行朴素贝叶斯分类了。</p>

<p>假设我们有一个新的水果，它的形状是圆形，口感是甜的，那么根据朴素贝叶斯，它属于苹果、甜橙和西瓜的概率分别是多少呢？</p>

<p>我们先来计算一下，它属于苹果的概率有多大:</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B%E8%8B%B9%E6%9E%9C%E6%A6%82%E7%8E%87.png" alt="20220531贝叶斯分类预测苹果概率.png" /></p>

<p>其中，<code>apple</code>表示分类为苹果，<code>shape-2</code>表示形状属性的值为<code>2</code>（也就是圆形），<code>taste-2</code>表示口感属性的值为<code>2</code>。以此类推，我们还可计算该水果属于甜橙和西瓜的概率:</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E9%A2%84%E6%B5%8B%E6%A9%99%E5%AD%90%E8%A5%BF%E7%93%9C%E6%A6%82%E7%8E%87.png" alt="20220531贝叶斯分类预测橙子西瓜概率.png" /></p>

<p>比较这三个数值，<code>0.00198&lt;0.00798&lt;0.26934</code>，所以计算机可以得出的结论，该水果属于甜橙的可能性是最大的，或者说，这个水果最有可能是甜橙。</p>

<blockquote><p>这几个公式里的概率乘积通常都非常小，在物品的属性非常多的时候，这个乘积可能就小到计算机无法处理的地步。因此，在实际运用中，我们还会采用一些数学手法进行转换（比如取<code>log</code>将小数转换为绝对值大于<code>1</code>的负数），原理都是一样的。</p></blockquote>

<h4>总结</h4>

<p>总结一次朴素贝叶斯分类的主要步骤：</p>

<ol>
<li>准备数据：针对水果分类这个案例，我们收集了若干水果的实例，并从水果的常见属性入手，将其转化为计算机所能理解的数据。这种数据也被称为<strong>训练样本</strong>。</li>
<li>建立模型：通过手头上水果的实例，我们让计算机统计每种水果、属性出现的先验概率，以及在某个水果分类下某种属性出现的条件概率。这个过程也被称为基于样本的<strong>训练</strong>。</li>
<li>分类新数据：对于一颗新水果的属性数据，计算机根据已经建立的模型进行推导计算，得到该水果属于每个分类的概率，实现了分类的目的。这个过程也被称为<strong>预测</strong>。</li>
</ol>


<h3>23丨文本分类：如何区分特定类型的新闻？</h3>

<p>运用朴素贝叶斯原理，根据词频特征，对文章进行分类。清晰明了，值得一看。</p>

<h3>24丨语言模型：如何使用链式法则和马尔科夫假设简化概率模型？</h3>

<h4>语言模型</h4>

<p>这里说的语言模型指的是基于概率和统计的语言模型。</p>

<h5>链式法则</h5>

<p><img src="http://hongchaozhang.github.io/images/20220531%E9%93%BE%E5%BC%8F%E6%B3%95%E5%88%99.png" alt="20220531链式法则.png" /></p>

<h5>马尔可夫假设</h5>

<p>理解了链式法则，我们再来看看马尔可夫假设。这个假设的内容是：任何一个词<code>wi</code>出现的概率只和它前面的1个或若干个词有关。基于这个假设，我们可以提出多元文法（Ngram）模型。Ngram中的<code>N</code>很重要，它表示任何一个词出现的概率，只和它前面的<code>N-1</code>个词有关。</p>

<p>以二元文法模型为例，按照刚才的说法，二元文法表示，某个单词出现的概率只和它前面的1个单词有关。也就是说，即使某个单词出现在一个很长的句子中，我们也只需要看前面那1个单词。用公式来表示出来就是这样：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BA%8C%E5%85%83%E6%96%87%E6%B3%95%E6%A8%A1%E5%9E%8B.png" alt="20220531二元文法模型.png" /></p>

<p>假设我们有一个统计样本文本<code>d</code>，<code>s</code>表示某个有意义的句子，由一连串按照特定顺序排列的词<code>w1，w2,…,wn</code>组成，这里<code>n</code>是句子里单词的数量。现在，我们想知道根据文档<code>d</code>的统计数据，<code>s</code>在文本中出现的可能性，即<code>P(s|d)</code>，那么我们可以把它表示为<code>P(s|d)=P(w1,w2,…,wn|d)</code>。假设我们这里考虑的都是在集合<code>d</code>的情况下发生的概率，所以可以忽略<code>d</code>，写为<code>P(s)=P(w1,w2,…,wn)</code>。</p>

<p><code>P(w1,w2,…,wn)</code>可以通过上面说的链式法则计算，通过文档集合<code>C</code>，你可以知道<code>P(w1)</code>，<code>P(w2|w1)</code>这种概率。但是，这会带来两个问题：</p>

<ol>
<li>概率为0的问题
 <code>P(w1)</code>大小还好，<code>P(w2|w1)</code>会小一些，再往后看，<code>P(w3|w1,w2)</code>出现概率更低，<code>P(w4|w1,w2,w3)</code>出现的概率就更低了。一直到<code>P(wn|w1,w2,…,wn−1)</code>，基本上又为0了。我们可以使用上一节提到的平滑技巧，减少0概率的出现。不过，如果太多的概率都是通过平滑的方式而得到的，那么模型和真实的数据分布之间的差距就会加大，最终预测的效果也会很差，所以平滑也不是解决0概率的最终办法。</li>
<li>存储空间的问题
 为了统计现有文档集合中<code>P(w1,w2,…,wn)</code>这类值，我们就需要生成很多的计数器。我们假设文档集合中有<code>m</code>个不同的单词，那么从中挑出<code>n</code>个单词的可重复排列，数量就是<code>m^n</code>。此外，还有<code>m^(n−1)</code>,<code>m^(n−2)</code>等等。这也意味着，如果要统计并存储的所有<code>P(w1,w2,…,wn)</code>或<code>P(wn|w1,w2,…,wn−1)</code>这类概率，就需要大量的内存和磁盘空间。当然，你可以做一些简化，不考虑单词出现的顺序，那么问题就变成了可重复组合，但是数量仍然非常巨大。</li>
</ol>


<p>在这两个问题上，马尔科夫假设和多元文法模型就能帮上大忙了。如果我们使用三元文法模型，上述公式可以改写为：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%B8%89%E5%85%83%E6%96%87%E6%B3%95%E6%A8%A1%E5%9E%8B.png" alt="20220531三元文法模型.png" /></p>

<p>这样，系统的复杂度大致在<code>(C(m,1)+C(m,2)+C(m,3))</code>这个数量级，而且<code>P(wn|wn−2,wn−1)</code>为0的概率也会大大低于<code>P(wn|w1,w2,…,wn−1)</code>为0的概率。</p>

<h4>语言模型的应用</h4>

<p>基于概率的语言模型，本身不是新兴的技术。它已经在机器翻译、语音识别和中文分词中得到了成功应用。近几年来，人们也开始在信息检索领域中尝试语言模型。下面我就来讲讲语言模型在信息检索和中文分词这两个方面里是如何发挥作用的。</p>

<h5>信息检索</h5>

<p>信息检索很关心的一个问题就是相关性，也就是说，给定一个查询，哪篇文档是更相关的呢？一种常见的做法是计算<code>P(d|q)</code>，其中<code>q</code>表示一个查询，<code>d</code>表示一篇文档。<code>P(d|q)</code>表示用户输入查询<code>q</code>的情况下，文档<code>d</code>出现的概率是多少？如果这个概率越高，我们就认为<code>q</code>和<code>d</code>之间的相关性越高。</p>

<p>通过我们手头的文档集合，并不能直接获得<code>P(d|q)</code>。好在我们已经学习过了贝叶斯定理，通过这个定理，我们可以将<code>P(d|q)</code>重写如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F.png" alt="20220531信息检索贝叶斯公式.png" /></p>

<p>让<code>k1,k2,…,kn</code>表示查询<code>q</code>里包含的<code>n</code>个关键词，就可以根据链式法则求解出<code>P(q|d)</code>，我们也使用马尔科夫假设和多元文法来提高算法效率。</p>

<p>最终，当用户输入一个查询<code>q</code>之后，对于每一篇文档<code>d</code>，我们都能获得<code>P(d|q)</code>的值。根据每篇文档所获得的<code>P(d|q)</code>这个值，由高到低对所有的文档进行排序。这就是语言模型在信息检索中的常见用法。</p>

<h5>中文分词</h5>

<p>和拉丁语系不同，中文存在分词的问题。比如原句是“兵乓球拍卖完了”，分词结果可能是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1. 兵乓球|拍卖|完了
</span><span class='line'>2. 兵乓|球拍|卖完|了
</span><span class='line'>3. ...</span></code></pre></td></tr></table></div></figure>


<p>上面分词的例子，从字面来看都是合理的，所以这种歧义无法通过这句话本身来解决。那么这种情况下，语言模型能为我们做什么呢？我们知道，语言模型是基于大量的语料来统计的，所以我们可以使用这个模型来估算，哪种情况更合理。</p>

<p>假设整个文档集合是<code>D</code>，要分词的句子是<code>s</code>，分词结果为<code>w1,…wn</code>，如果使用三元文法模型，</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E4%B8%89%E5%85%83%E6%96%87%E6%B3%95%E6%A8%A1%E5%9E%8B.png" alt="20220531中文分词三元文法模型.png" /></p>

<blockquote><p>请注意，在信息检索中，我们关心的是每篇文章产生一个句子（也就是查询）的概率，而这里可以是整个文档集合<code>D</code>产生一个句子的概率。</p></blockquote>

<p>语言模型可以帮我们估计某种分词结果，在文档集合中出现的概率。由于不同的分词方法，会导致<code>w1</code>到<code>wn</code>的不同，因此就会产生不同的<code>P(s)</code>。接下来，我们只要取最大的<code>P(s)</code>，并假设这种分词方式是最合理的，就可以在一定程度上解决歧义。</p>

<p>回到“兵乓球拍卖完了”这句话，如果文档集合都是讲述的有关体育用品的销售，而不是拍卖行，那么“兵乓|球拍|卖完|了”这种分词的可能性应该更高。</p>

<h3>25丨马尔科夫模型：从PageRank到语音识别，背后是什么模型在支撑？</h3>

<h4>马尔可夫模型</h4>

<p>在介绍语言模型的时候，我们提到了马尔科夫假设，这个假设是说，每个词出现的概率和之前的一个或若干个词有关。我们换个角度思考就是，<strong>每个词按照一定的概率转移到下一个词</strong>。</p>

<p>如果把词抽象为一个状态，那么我们就可以认为，状态到状态之间是有关联的。前一个状态有一定的概率可以转移到到下一个状态。如果多个状态之间的随机转移满足马尔科夫假设，那么这类随机过程就是一个马尔科夫随机过程。而刻画这类随机过程的统计模型，就是<strong>马尔科夫模型</strong>（Markov Model）。</p>

<p>前面讲多元文法的时候，我提到了二元文法、三元文法。对于二元文法来说，某个词出现的概率只和前一个词有关。对应的，在马尔科夫模型中，如果一个状态出现的概率只和前一个状态有关，那么我们称它为<strong>一阶马尔科夫模型</strong>或者<strong>马尔科夫链</strong>。对应于三元、四元甚至更多元的文法，我们也有二阶、三阶等马尔科夫模型。</p>

<h5>PageRank和马尔可夫链</h5>

<p>Google公司最引以为傲的PageRank链接分析算法，它的核心思想就是基于马尔科夫链。这个算法假设了一个“随机冲浪者”模型，冲浪者从某张网页出发，根据Web图中的链接关系随机访问。在每个步骤中，冲浪者都会从当前网页的链出网页中随机选取一张作为下一步访问的目标。在整个Web图中，绝大部分网页节点都会有链入和链出。那么冲浪者就可以永不停歇地冲浪，持续在图中走下去。我们可以假设每张网页就是一个状态，而网页之间的链接表明了状态转移的方向。这样，我们很自然地就可以使用马尔科夫链来刻画“随机冲浪者”。</p>

<blockquote><ol>
<li>PageRank值：在随机访问的过程中，越是被频繁访问的链接，越是重要。可以看出，每个节点的PageRank值取决于Web图的链接结构。<strong>假如一个页面节点有很多的链入链接，或者是链入的网页有较高的被访问率，那么它也将会有更高的被访问概率</strong>。</li>
<li>PageRank在标准的马尔科夫链上，引入了随机的跳转操作，也就是假设冲浪者不按照Web图的拓扑结构走下去，只是随机挑选了一张网页进行跳转。这样的处理是类比人们打开一张新网页的行为，也是符合实际情况的，避免了信息孤岛的形成。

<h4>隐马尔可夫模型</h4>

<p>马尔可夫模型都是假设每个状态对我们都是已知的，比如在概率语言模型中，一个状态对应了单词“上学”，另一个状态对应了单词“书包”。可是，有没有可能某些状态我们是未知的呢？</p></li>
</ol>
</blockquote>

<p>在某些现实的应用场景中，我们是无法确定马尔科夫过程中某个状态的取值的。这种情况下，最经典的案例就是<strong>语音识别</strong>。使用概率对语音进行识别的过程，和语言模型类似，因此我们可以把每个等待识别的词对应为马尔科夫过程中的一个状态。</p>

<p>计算机只知道某个词的发音，而不知道它具体怎么写，对于这种情况，我们就认为计算机只能观测到每个状态的部分信息，而另外一些信息被“隐藏”了起来。这个时候，我们就需要用隐马尔科夫模型来解决这种问题。隐马尔科夫模型有两层，一层是我们可以观测到的数据，称为“输出层”，另一层则是我们无法直接观测到的状态，称为“隐藏状态层”。如下图：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%E5%9B%BE.jpeg" alt="20220531隐马尔可夫模型图.jpeg" /></p>

<p>那么在这个两层模型示例中，“隐藏状态层”(x1，x2，x3)产生“输出层”(y1，y2，y3)的概率是:</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B%E8%BE%93%E5%87%BA%E5%B1%82%E6%A6%82%E7%8E%87.png" alt="20220531隐马尔可夫模型输出层概率.png" /></p>

<p>语音识别要做的，就是遍历所有可能的状态层，找出最可能产生已知“输出层”的状态层，即为语音识别结果。</p>

<h3>26丨信息熵：如何通过几个问题，测出你对应的武侠人物？</h3>

<p>现在有个小游戏，“测测你是哪个武侠人物”：通过连续的几个问题，确定答题者是武侠人物中的哪一位？</p>

<p>那么，问卷设计者应该如何选择合适的题目，才能在读者回答尽量少的问题的同时，相对准确地测出自己对应于武侠中的哪个人物呢？为了实现这一目的，系统背后需要有这样的一张表格：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BF%A1%E6%81%AF%E7%86%B5%E6%B8%B8%E6%88%8F%E8%A1%A8%E6%A0%BC.png" alt="20220531信息熵游戏表格.png" /></p>

<p>在题目的设计上，我们可能要考虑下面两个问题：
1. 每个问题在人物划分上，是否有着不同的区分能力？
2. 题目的先后顺序会不会直接影响要回答问题的数量？</p>

<h4>问题的区分能力</h4>

<p>每一个问题都会将被测试者划分为不同的人物分组。如果某个问题将属于不同人物分组的被测者，尽可能地划分到了相应的分组，那么我们认为这个问题的区分能力较强。相反，如果某个问题无法将属于不同人物分组的被测者划分开来，那么我们认为这个问题的区分能力较弱。</p>

<p>举个例子，我们先来比较一下“性别”和“智商”这两个属性。</p>

<p>首先，性别属性将武侠人物平均地划分为一半一半，也就是说“男”和“女”出现的先验概率是各 50%。如果我们假设被测试的人群，其男女性别的概率分布也是50%和50%，那么关于性别的测试题，就能将被测者的群体大致等分。</p>

<p>我们再来看智商属性。我们也将武侠人物划分为2个小集合，不过“智商高”的先验概率是 80%，而“智商中等”的先验概率只有 20%。同样，我们假设被测试的人群，其智商的概率分布也是类似地，那么经过关于智商的测试题之后，仍然有 80% 左右的不同人物还是属于同一个集合，并没有被区分开来。因此，我们可以认为关于“智商”的测试题，在对人物进行分组这个问题上，其能力要弱于“性别”的测试题。</p>

<p>这只是对区分能力的一个感性认识，如何对其进行量化呢？这就需要引入<strong>信息量，信息熵，信息增益</strong>等概念。</p>

<h4>信息量</h4>

<p>任何能够减少不确定性的消息，都叫做信息。定性地看，事件的概率越小，不确定性越大，一旦发生带来的信息量也就越大。信息量公式如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BF%A1%E6%81%AF%E9%87%8F%E5%85%AC%E5%BC%8F.svg" alt="20220531信息量公式.svg" /></p>

<h4>信息熵</h4>

<p>一个系统的信息熵是其各种状态的信息量的期望：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BF%A1%E6%81%AF%E7%86%B5%E5%85%AC%E7%A4%BA.svg" alt="20220531信息熵公示.svg" /></p>

<p>这个公式和热力学的熵的本质一样，故也称为熵。从公式可知，当各个符号出现的几率相等，即“不确定性”最高时，信息熵最大。故信息可以视为“不确定性”、“不纯净度”或“选择的自由度”的度量。</p>

<p>从集合和分组的角度来说，如果一个集合里的元素趋向于落在同一分组里，那么告诉你某个元素属于哪个分组的信息量就越小，整个集合的熵也越小，换句话说，整个集合就越“纯净”。相反，如果一个集合里的元素趋向于分散在不同分组里，那么告诉你某个元素属于哪个分组的信息量就越大，整个集合的熵也越大，换句话说，整个集合就越“混乱”。</p>

<p>已经知道单个集合的熵是如何计算的了。那么，如果将一个集合划分成多个更小的集合之后，又该如何根据这些小集合，来计算整体的熵呢？之前我们提到了信息量和熵具有加和的性质，所以对于包含多个集合的更大集合，它的信息量期望值是可以通过每个小集合的信息量期望值来推算的。具体来说，我们可以使用如下公式：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E9%9B%86%E5%90%88%E5%88%92%E5%88%86%E4%BF%A1%E6%81%AF%E7%86%B5%E5%85%AC%E5%BC%8F.png" alt="20220531集合划分信息熵公式.png" /></p>

<p>其中，<code>T</code>表示一种划分，<code>Pv</code>表示划分后其中某个小集合，<code>Entropy(Pv)</code>表示某个小集合的熵， 而<code>|Pv|/|P|</code>表示某个小集合出现的概率。</p>

<h4>信息增益</h4>

<p>一个系统的信息增益是指，由于信息量大增加带来的其信息熵的减少:</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A%E5%85%AC%E5%BC%8F.png" alt="20220531信息增益公式.png" /></p>

<p>其中<code>T</code>表示当前选择的特征，<code>Entropy(P)</code>表示选择特征<code>T</code>之前的熵，<code>Entropy(Pv)</code>表示特征<code>T</code>取值为<code>v</code>分组的熵。减号后面的部分表示选择<code>T</code>做决策之后，各种取值子集合的熵的加权平均（期望）后整体的熵。</p>

<h4>再次回到“武侠人物分类”的小游戏</h4>

<p>我们把这个信息增益的概念放到咱们的小游戏里就是，如果一个测试问题能够将来自不同分组的人物尽量的分开，也就是该划分对应的信息增益越高，那么我们就认为其区分能力越高，提供的信息含量也越多。</p>

<p>我们还是以“性别”和“智商”的两个测试题为例。</p>

<p>在提出任何问题之前，我们无法知道被测者属于哪位武侠人物，因此所有被测者属于同一个集合。假设被测者的概率分布和这10位武侠人物的先验概率分布相同，那么被测者集合的熵为3.32(<code>10*(-1 * 0.1 * log(0.1, 2))</code>)。</p>

<p>通过性别的测试问题对人物进行划分后，我们得到了两个更小的集合，每个小集合都包含5种不同的人物分组，因此每个小集合的熵是2.32(<code>(-1 * 5 * 0.2 * log(0.2, 2))</code>)，两个小集合的整体熵是2.32(<code>0.5 * 2.32 + 0.5 * 2.32</code>)。因此使用性格的测试题后，信息增益是1(<code>3.32 - 2.32</code>)。</p>

<p>而通过智商的测试问题对人物分组后，我们也得到了两个小集合，一个包含了8种人物，另一个包含了2种人物。包含8种人物的小集合其熵是3(<code>(-1* 8 * 0.125 * log(0.125, 2))</code>)，包含<code>2</code>种人物的小集合其熵是1(<code>(-1* 2 * 0.5 * log(0.5, 2))</code>)。两个小集合的整体熵是2.6(<code>0.8 * 3 + 0.2 * 1</code>)。因此使用智商的测试题后，信息增益是0.72(<code>3.32 - 2.6</code>)，低于基于性别的测试。所以，我们可以得出结论，有关性别的测试题比有关智商的测试题更具有区分能力。</p>

<h3>27丨决策树：信息增益、增益比率和基尼指数的运用</h3>

<h4>继续“武侠人物分类”游戏</h4>

<p>还说上面的“武侠人物分类”游戏，被测者们每次回答一道问题，就会被细分到不同的集合，每个细分的集合纯净度就会提高，而熵就会下降。在测试结束的时候，如果所有被测者都被分配到了相应的武侠人物名下，那么每个人物分组都是最纯净的，熵值都为0。于是，测试问卷的过程就转化为“如何将熵从3.32下降到0”的过程。</p>

<p>首先计算各个特征的信息增益：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E6%AD%A6%E4%BE%A0%E4%BA%BA%E7%89%A9%E6%B8%B8%E6%88%8F%E5%90%84%E4%B8%AA%E7%89%B9%E5%BE%81%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A.png" alt="20220531武侠人物游戏各个特征信息增益.png" /></p>

<p>按照信息增益从高到低的顺序选择特征问题：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E6%AD%A6%E4%BE%A0%E4%BA%BA%E7%89%A9%E5%88%86%E7%B1%BB%E5%9B%BE.png" alt="20220531武侠人物分类图.png" /></p>

<p>从这个图可以看出来，对于每种人物的判断，我们至多需要问3个问题，没有必要问全5个问题。比如，对于人物J和C，我们只需要问2个问题。假设读者属于10种武侠人物的概率是均等的，那么我们就可以利用之前介绍的知识，来计算读者需要回答的问题数量之期望值。每种人物出现的概率是0.1，8种人物需要问3个问题，2种人物需要问2个问题，那么回答问题数的期望值是2.8(<code>0.8 * 3 + 0.2 * 2</code>)。</p>

<p>如果我们每次不选熵值最高的问题，而选择熵值最低的问题，那么需要回答的问题的数量期望值为4到5之间。</p>

<h4>决策树</h4>

<p>上述这个过程就体现了训练决策树（Decision Tree）的基本思想。决策树学习属于归纳推理算法之一，适用于分类问题。决定问卷题出现顺序的这个过程，其实就是建立决策树模型的过程，即<strong>训练</strong>过程。</p>

<p>整个构建出来的图就是一个树状结构，这也是“决策树”这个名字的由来。而根据用户对每个问题的答案，从决策树的根节点走到叶子节点，最后来判断其属于何种人物类型，这个过程就是分类新数据的过程，即<strong>预测</strong>过程。</p>

<blockquote><p>有点需要注意的是，问卷案例中的每类武侠人物。都只有一个样本，而在泛化的机器学习问题中，每个类型对应了多个样本。也就是说，我们可以有很多个郭靖，而且每个人的属性并不完全一致，但是它们的分类都是“郭靖”。正是因为这个原因，决策树通常都只能把整体的熵降低到一个比较低的值，而无法完全降到0。这也意味着，训练得到的决策树模型，常常无法完全准确地划分训练样本，只能求到一个近似的解。</p></blockquote>

<h4>几种常见的决策树算法</h4>

<p>采用信息增益来构建决策树的算法被称为<a href="https://zh.wikipedia.org/wiki/ID3%E7%AE%97%E6%B3%95">ID3</a>（Iterative Dichotomiser 3，迭代二叉树3代）。但是这个算法有一个缺点，它一般会优先考虑具有较多取值的特征，因为取值多的特征会有相对较大的信息增益。这是为什么呢？</p>

<p>仔细观察一下信息熵的定义，就能发现背后的原因。更多的取值会把数据样本划分为更多更小的分组，这样熵就会大幅降低，信息增益就会大幅上升。但是这样构建出来的树，很容易导致机器学习中的过拟合现象，不利于决策树对新数据的预测。为了克服这个问题，人们又提出了一个改进版，<a href="https://zh.wikipedia.org/wiki/C4.5%E7%AE%97%E6%B3%95">C4.5算法</a>。</p>

<p>决策树也有不足。这类算法受训练样本的影响很大，比较容易过拟合。在预测阶段，如果新的数据和原来的训练样本差异较大，那么分类效果就会比较差。为此人们也提出了一些优化方案，比如剪枝和随机森林。</p>

<h3>28丨熵、信息增益和卡方：如何寻找关键特征？</h3>

<h4>通过信息增益进行特征选择</h4>

<p>类似于决策树算法。</p>

<h4>通过卡方检验进行特征选择</h4>

<p>在统计学中，我们使用卡方检验来检验两个变量是否相互独立。把它运用到特征选择，我们就可以检验特征与分类这两个变量是否独立。如果两者独立，证明特征和分类没有明显的相关性，特征对于分类来说没有提供足够的信息量。反之，如果两者有较强的相关性，那么特征对于分类来说就是有信息量的，是个好的特征。</p>

<p>为了检验独立性，卡方检验考虑了四种情况的概率：P(fi,cj)、P(fi¯,cj¯)、P(fi,cj¯)和P(fi¯,cj)。</p>

<p>在这四种概率中，P(fi,cj)和P(fi¯,cj¯)表示特征fi和分类cj是正相关的。如果P(fi,cj)很高，表示特征fi的出现意味着属于分类cj的概率更高；如果P(fi¯,cj¯)很高，表示特征fi不出现意味着不属于分类cj的概率更高。</p>

<p>类似地，P(fi,cj¯)和P(fi¯,cj)表示特征fi和分类cj是负相关的。如果P(fi,cj¯)很高，表示特征fi的出现意味着不属于分类cj的概率更高；如果P(fi¯,cj)很高，表示特征fi不出现意味着属于分类cj的概率更高。</p>

<p>如果特征和分类的相关性很高，要么是正向相关值远远大于负向相关值，要么是负向相关值远远大于正向相关值。如果特征和分类相关性很低，那么正向相关值和负向相关的值就会很接近。卡方检验就是利用了正向相关和负向相关的特性。</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C%E8%BF%9B%E8%A1%8C%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9.png" alt="20220531卡方检验进行特征选择.png" /></p>

<p>其中，N表示数据的总个数。通过这个公式，你可以看到，如果一个特征和分类的相关性很高，无论是正向相关还是负向相关，那么正向相关和负向相关的差值就很大，最终计算的值就很高。最后，我们就可以按照卡方检验的值由高到低对特征进行排序，挑选出排列靠前的特征。</p>

<h3>29丨归一化和标准化：各种特征如何综合才是最合理的？</h3>

<p>第一点，为什么有时候需要转换特征值？因为不同类型的特征取值范围不同，分布也不同，相互之间没有可比性。因此在线性回归中，通过这些原始值分析得到的权重，并不能代表每个特征实际的重要性。</p>

<p>我们用Boston Housing 数据集对房价数据进行回归分析，这个数据来自 70 年代美国波斯顿周边地区的房价，是用于机器学习的经典数据集，你可以在<a href="https://www.kaggle.com/c/boston-housing#description">Kaggle的网站</a>下载到它，并查看表格中各列的含义：</p>

<ol>
<li>CRIM：per capita crime rate by town.</li>
<li>ZN：proportion of residential land zoned for lots over 25,000 sq.ft.</li>
<li>INDUS：proportion of non-retail business acres per town.</li>
<li>CHAS：Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).</li>
<li>NOX：nitrogen oxides concentration (parts per 10 million).</li>
<li>RM：average number of rooms per dwelling.</li>
<li>AGE：proportion of owner-occupied units built prior to 1940.</li>
<li>DIS：weighted mean of distances to five Boston employment centres.</li>
<li>RAD：index of accessibility to radial highways.</li>
<li>TAX：full-value property-tax rate per \$10,000.</li>
<li>PTRATIO：pupil-teacher ratio by town.</li>
<li>B：1000(Bk - 0.63)<sup>2</sup> where Bk is the proportion of blacks by town.</li>
<li>LSTAT：lower status of the population (percent).</li>
<li>MEDV：median value of owner-occupied homes in \$1000s.</li>
</ol>


<blockquote><p>Kaggle上面好像不能直接下载啦，可以点击<a href="http://hongchaozhang.github.io/assets/resources/boston_house_price.csv">这里</a>下载。</p></blockquote>

<p>使用下面的python代码实现线性回归分析：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
</span><span class='line'>
</span><span class='line'><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">&quot;demo/datasets/boston_house_price.csv&quot;</span><span class="p">)</span>  <span class="c"># 读取 Boston Housing 中的 csv数据</span>
</span><span class='line'><span class="n">df_features</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s">&#39;MEDV&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># Dataframe 中除了最后一列，其余列都是特征，或者说自变量</span>
</span><span class='line'><span class="n">df_targets</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">&#39;MEDV&#39;</span><span class="p">]</span>  <span class="c"># Dataframe 最后一列是目标变量，或者说因变量</span>
</span><span class='line'><span class="c">#</span>
</span><span class='line'><span class="n">regression</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df_features</span><span class="p">,</span> <span class="n">df_targets</span><span class="p">)</span>  <span class="c"># 使用特征和目标数据，拟合线性回归模型</span>
</span><span class='line'><span class="k">print</span><span class="p">(</span><span class="n">regression</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">df_features</span><span class="p">,</span> <span class="n">df_targets</span><span class="p">))</span>  <span class="c"># 拟合程度的好坏</span>
</span><span class='line'><span class="k">print</span><span class="p">(</span><span class="n">regression</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>  <span class="c"># 各个特征所对应的系</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="mf">0.7406426641094095</span>
</span><span class='line'><span class="p">[</span><span class="o">-</span><span class="mf">1.08011358e-01</span>  <span class="mf">4.64204584e-02</span>  <span class="mf">2.05586264e-02</span>  <span class="mf">2.68673382e+00</span>
</span><span class='line'> <span class="o">-</span><span class="mf">1.77666112e+01</span>  <span class="mf">3.80986521e+00</span>  <span class="mf">6.92224640e-04</span> <span class="o">-</span><span class="mf">1.47556685e+00</span>
</span><span class='line'>  <span class="mf">3.06049479e-01</span> <span class="o">-</span><span class="mf">1.23345939e-02</span> <span class="o">-</span><span class="mf">9.52747232e-01</span>  <span class="mf">9.31168327e-03</span>
</span><span class='line'> <span class="o">-</span><span class="mf">5.24758378e-01</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为不是所有的数据都是可以使用线性回归模型来表示，所以我们需要使用 regression.score 函数，来看拟合的程度。如果完美拟合，这个函数就会输出 1；如果拟合效果很差，这个函数的输出可能就是一个负数。</p>

<p>这里 regression.score 函数的输出大约为 0.74，接近于 1.0。它表示这个数据集使用线性模型拟合的效果还是不错的。</p>

<blockquote><p>注意：下面是原文章中的解释，但是和我下载到的数据跑出的结果匹配不上，但是有关归一化和标准化的作用还是能够看出来的。
原文章中的输出：</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="mf">0.735578647853312</span>
</span><span class='line'><span class="p">[</span><span class="o">-</span><span class="mf">4.54789253e-03</span> <span class="o">-</span><span class="mf">5.17062363e-02</span>  <span class="mf">4.93344687e-02</span>  <span class="mf">5.34084254e-02</span>
</span><span class='line'>  <span class="mf">3.78011391e+00</span> <span class="o">-</span><span class="mf">1.54106687e+01</span>  <span class="mf">3.87910457e+00</span> <span class="o">-</span><span class="mf">9.51042267e-03</span>
</span><span class='line'> <span class="o">-</span><span class="mf">1.60411361e+00</span>  <span class="mf">3.61780090e-01</span> <span class="o">-</span><span class="mf">1.14966409e-02</span> <span class="o">-</span><span class="mf">8.48538613e-01</span>
</span><span class='line'>  <span class="mf">1.18853164e-02</span> <span class="o">-</span><span class="mf">6.01842329e-01</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>权重可以帮助我们解释哪个特征对最终房价的中位值有更大的影响。参看 csv 中的数据，你会发现最主要的两个正相关特征是 nox（系数为 3.78011391e+00）和 age（系数为 3.87910457e+00）。其中 nox 表示空气污染浓度，age 表示老房子占比，也就是说空气污染越多、房龄越高，房价中位数越高，这好像不太合乎常理。我们再来看看最主要的负相关特征 rm（系数为 -1.54106687e+01），也就是房间数量。房间数量越多，房价中位数越低，也不合理。</p>

<p>造成这些现象最重要的原因是，不同类型的特征值没有转换到同一个可比较的范围内，所以线性回归后所得到的系数不具有可比性，因此我们无法直接对这些权重加以解释。</p>

<h4>归一化（Normalization）</h4>

<p>简单起见，这里的归一化是指使用特征取值范围中的最大值和最小值，把原始值转换为0到1之间的值。这样处理的好处在于简单易行，便于理解。不过，它的缺点也很明显，由于只考虑了最大最小值，因此很容易受到异常数据点的干扰。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>
</span><span class='line'>
</span><span class='line'><span class="n">minMaxScaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>  <span class="c"># 基于 min 和 max 值的归一化</span>
</span><span class='line'>
</span><span class='line'><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">&quot;demo/datasets/boston_house_price.csv&quot;</span><span class="p">)</span>  <span class="c"># 读取 Boston Housing 中的 csv的数据</span>
</span><span class='line'><span class="n">df_normalized</span> <span class="o">=</span> <span class="n">minMaxScaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>  <span class="c"># 对原始数据进行归一化，包括特征值和目标变量</span>
</span><span class='line'><span class="n">df_features_normalized</span> <span class="o">=</span> <span class="n">df_normalized</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># 获取归一化之后的特征值</span>
</span><span class='line'><span class="n">df_targets_normalized</span> <span class="o">=</span> <span class="n">df_normalized</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># 获取归一化之后的目标值</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 再次进行线性回归</span>
</span><span class='line'><span class="n">regression_normalized</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df_features_normalized</span><span class="p">,</span> <span class="n">df_targets_normalized</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span><span class="p">(</span><span class="n">regression_normalized</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">df_features_normalized</span><span class="p">,</span> <span class="n">df_targets_normalized</span><span class="p">))</span>
</span><span class='line'><span class="k">print</span><span class="p">(</span><span class="n">regression_normalized</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="mf">0.7406426641094094</span>
</span><span class='line'><span class="p">[</span><span class="o">-</span><span class="mf">0.21355017</span>  <span class="mf">0.10315657</span>  <span class="mf">0.0124631</span>   <span class="mf">0.0597052</span>  <span class="o">-</span><span class="mf">0.1918794</span>   <span class="mf">0.4418597</span>
</span><span class='line'>  <span class="mf">0.00149367</span> <span class="o">-</span><span class="mf">0.36059247</span>  <span class="mf">0.15642529</span> <span class="o">-</span><span class="mf">0.14362949</span> <span class="o">-</span><span class="mf">0.19901831</span>  <span class="mf">0.08206283</span>
</span><span class='line'> <span class="o">-</span><span class="mf">0.42260541</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：下面是原文章中的解释，但是和我下载到的数据跑出的结果匹配不上，但是有关归一化和标准化的作用还是能够看出来的。
原文章中的输出：</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="mf">0.7355786478533118</span>
</span><span class='line'><span class="p">[</span><span class="o">-</span><span class="mf">0.05103746</span> <span class="o">-</span><span class="mf">0.08448544</span>  <span class="mf">0.10963215</span>  <span class="mf">0.03204506</span>  <span class="mf">0.08400253</span> <span class="o">-</span><span class="mf">0.16643522</span>
</span><span class='line'>  <span class="mf">0.4451488</span>  <span class="o">-</span><span class="mf">0.01986622</span> <span class="o">-</span><span class="mf">0.34152292</span>  <span class="mf">0.18490982</span> <span class="o">-</span><span class="mf">0.13361651</span> <span class="o">-</span><span class="mf">0.16216516</span>
</span><span class='line'>  <span class="mf">0.10390408</span> <span class="o">-</span><span class="mf">0.48468369</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可以看到，表示拟合程度的分数没有变，但是每个特征对应的系数或者说权重，发生了比较大的变化。仔细观察一下，你会发现，这次最主要的正相关特征是 age（0.4451488）和 tax（0.18490982），也就是老房子占比和房产税的税率，其中至少房产税的税率是比较合理的，因为高房价的地区普遍税率也比较高。而最主要的负相关特征是 rad（-0.34152292）和 lstat（-0.48468369），rad 表示高速交通的便利程度，它的值越大表示离高速越远，房价中位数越低。而 lstat 表示低收入人群的占比，这个值越大房价中位数越低，这两点都是合理的。</p>

<h4>标准化（Standardizaiton）</h4>

<p>另一种常见的方法是基于正态分布的 z 分数（z-score）标准化（Standardization）。该方法假设数据呈现标准正态分布。</p>

<p>经过标准化处理之后，每种特征的取值都会变成一个标准正态分布，以0为均值，1为标准差。和归一化相比，标准化使用了数据是正态分布的假设，不容易受到过大或过小值的干扰。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">standardScaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>  <span class="c"># 基于 Z 分数的标准化</span>
</span><span class='line'>
</span><span class='line'><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">&quot;demo/datasets/boston_house_price.csv&quot;</span><span class="p">)</span>  <span class="c"># 读取 Boston Housing 中的 csv的数据</span>
</span><span class='line'><span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</span><span class='line'><span class="n">standardScaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</span><span class='line'><span class="n">df_standardized</span> <span class="o">=</span> <span class="n">standardScaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>  <span class="c"># 对原始数据进行标准化，包括特征值和目标变量</span>
</span><span class='line'><span class="k">print</span><span class="p">(</span><span class="n">df_standardized</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">df_features_standardized</span> <span class="o">=</span> <span class="n">df_standardized</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># 获取标准化之后的特征值</span>
</span><span class='line'><span class="n">df_targets_standardized</span> <span class="o">=</span> <span class="n">df_standardized</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># 获取标准化之后的特征值</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 再次进行线性回归</span>
</span><span class='line'><span class="n">regression_standardized</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df_features_standardized</span><span class="p">,</span> <span class="n">df_targets_standardized</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span><span class="p">(</span><span class="n">regression_standardized</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">df_features_standardized</span><span class="p">,</span> <span class="n">df_targets_standardized</span><span class="p">))</span>
</span><span class='line'><span class="k">print</span><span class="p">(</span><span class="n">regression_standardized</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="mf">0.7406426641094093</span>
</span><span class='line'><span class="p">[</span><span class="o">-</span><span class="mf">0.10101708</span>  <span class="mf">0.1177152</span>   <span class="mf">0.0153352</span>   <span class="mf">0.07419883</span> <span class="o">-</span><span class="mf">0.22384803</span>  <span class="mf">0.29105647</span>
</span><span class='line'>  <span class="mf">0.00211864</span> <span class="o">-</span><span class="mf">0.33783635</span>  <span class="mf">0.28974905</span> <span class="o">-</span><span class="mf">0.22603168</span> <span class="o">-</span><span class="mf">0.22427123</span>  <span class="mf">0.09243223</span>
</span><span class='line'> <span class="o">-</span><span class="mf">0.40744693</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：下面是原文章中的解释，但是和我下载到的数据跑出的结果匹配不上，但是有关归一化和标准化的作用还是能够看出来的。
原文章中的输出：</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="mf">0.7355786478533118</span>
</span><span class='line'><span class="p">[</span><span class="o">-</span><span class="mf">0.07330367</span> <span class="o">-</span><span class="mf">0.04144107</span>  <span class="mf">0.12194378</span>  <span class="mf">0.04074345</span>  <span class="mf">0.09805446</span> <span class="o">-</span><span class="mf">0.19311408</span>
</span><span class='line'>  <span class="mf">0.29767387</span> <span class="o">-</span><span class="mf">0.02916672</span> <span class="o">-</span><span class="mf">0.34642803</span>  <span class="mf">0.34477088</span> <span class="o">-</span><span class="mf">0.21410757</span> <span class="o">-</span><span class="mf">0.19904179</span>
</span><span class='line'>  <span class="mf">0.11218058</span> <span class="o">-</span><span class="mf">0.46369483</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>表示拟合程度的分数任然没有变。再次对比不同特征所对应的系数，你会发现这次最主要的正相关特征还是 age（0.29767387）和 tax（0.34477088），但是相比之前，明显房产税的税率占了更高的权重，更加合理。而最主要的负相关特征还是 rad（-0.34152292）和 lstat（-0.48468369），这两点都是合理的。</p>

<h3>30丨统计意义（上）：如何通过显著性检验，判断你的A-B测试结果是不是巧合？</h3>

<ol>
<li>显著性差异</li>
<li>统计假设检验和显著性检验</li>
<li>P值</li>
</ol>


<h3>31丨统计意义（下）：如何通过显著性检验，判断你的A-B测试结果是不是巧合？</h3>

<p>对于正态分布的数据，可以采用方差分析（Analysis of Variance, ANOVA），也叫F检验。有了F值，我们需要根据F检验值的临界表来查找对应的P值。</p>

<p>对于非正态分布的数据，我们也可以使用非参数的分析。常见的非参数检验包括二项分布检验、K-S 检验、卡方检验等等。</p>

<h3>32丨概率统计篇答疑和总结为什么会有欠拟合和过拟合？</h3>

<h4>什么是欠拟合/过拟合</h4>

<p>在监督式学习过程中，适度拟合、欠拟合和过拟合，这三种状态是逐步演变的。</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E6%AC%A0%E6%8B%9F%E5%90%88%E8%BF%87%E6%8B%9F%E5%90%88.png" alt="20220531欠拟合过拟合.png" /></p>

<h4>如何处理欠拟合和过拟合？</h4>

<h5>欠拟合</h5>

<p>欠拟合问题，产生的主要原因是特征维度过少，拟合的模型不够复杂，无法满足训练样本，最终导致误差较大。因此，我们就可以增加特征维度，让输入的训练样本具有更强的表达能力。</p>

<p>之前讲解朴素贝叶斯的时候，我提到“任何两个变量是相互独立的假设”，这种假设和马尔科夫假设中的一元文法的作用一致，是为了降低数据稀疏程度、节省计算资源所采取的措施。可是，这种假设在现实中往往不成立，所以朴素贝叶斯模型的表达能力是非常有限的。当我们拥有足够的计算资源，而且希望建模效果更好的时候，我们就需要更加精细、更加复杂的模型，我们完全可以放弃朴素贝叶斯中关于变量独立性的假设，而使用二元、三元甚至更大的 N 元文法来处理这些数据。这就是典型的通过增加更多的特征，来提升模型的复杂度，让它从欠拟合阶段往适度拟合阶段靠拢。</p>

<h5>过拟合</h5>

<p>过拟合问题产生的主要原因则是特征维度过多，导致拟合的模型过于完美地符合训练样本，但是无法适应测试样本或者说新的数据。所以我们可以减少特征的维度。</p>

<p>之前在介绍决策树的时候，我提到了这类算法比较容易过拟合，可以使用剪枝和随机森林来缓解这个问题。</p>

<p>剪枝，顾名思义，就是删掉决策树中一些不是很重要的结点及对应的边，这其实就是在减少特征对模型的影响。虽然去掉一些结点和边之后，决策树对训练样本的区分能力变弱，但是可以更好地应对新数据的变化，具有更好的泛化能力。至于去掉哪些结点和边，我们可以使用前面介绍的特征选择方法来进行。</p>

<p>随机森林的构建过程更为复杂一些。“森林”表示有很多决策树，可是训练样本就一套，那这些树都是怎么来的呢？随机森林算法采用了统计里常用的可重复采样法，每次从全部 n 个样本中取出 m 个，然后构建一个决策树。重复这种采样并构建决策树的过程若干次，我们就能获得多个决策树。对于新的数据，每个决策树都会有自己的判断结果，我们取大多数决策树的意见作为最终结果。由于每次采样都是不完整的训练集合，而且有一定的随机性，所以每个决策树的过拟合程度都会降低。</p>

<p>从另一个角度来看，过拟合表示模型太复杂，而相对的训练数据量太少。因此我们也可以增加训练样本的数据量，并尽量保持训练数据和测试数据分布的一致性。如果我们手头上有大量的训练数据，则可以使用交叉验证（Cross Validation）的划分方式来保持训练数据和测试数据的一致性。其核心思想是在每一轮中，拿出大部分数据实例进行建模，然后用建立的模型对留下的小部分实例进行预测，最终对本次预测结果进行评估。这个过程反复进行若干轮，直到所有的标注样本都被预测了一次而且仅一次。如果模型所接受的数据总是在变化，那么我们就需要定期更新训练样本，重新拟合模型。</p>

<h2>05-线性代数篇 (13讲)</h2>

<h3>33丨线性代数：线性代数到底都讲了些什么？</h3>

<h4>标量，向量，向量空间</h4>

<h4>向量运算</h4>

<p>向量运算的几何意义</p>

<h4>矩阵运算</h4>

<p>乘法，转置，单位矩阵，逆矩阵</p>

<h3>34丨向量空间模型：如何让计算机理解现实事物之间的关系？</h3>

<h4>向量空间模型</h4>

<ol>
<li>向量之间的距离</li>
<li>向量的长度</li>
<li>向量之间的夹角，夹角余弦</li>
</ol>


<h4>向量空间模型与机器学习</h4>

<p>由于夹角余弦的取值范围已经在-1到1之间，而且越大表示越相似，所以可以直接作为相似度的取值。相对于夹角余弦，欧氏距离<code>ED</code>的取值范围可能很大，而且和相似度呈现反比关系，所以通常要进行<code>1/(1-ED)</code>这种归一化。</p>

<p>当ED为0的时候，变化后的值就是1，表示相似度为1，完全相同。当ED趋向于无穷大的时候，变化后的值就是0，表示相似度为0，完全不同。所以，这个变化后的值，取值范围是0到1之间，而且和相似度呈现正比关系。</p>

<p>早在上世纪的70年代，人们把向量空间模型运用于信息检索领域。由于向量空间可以很形象地表示数据点之间的相似程度，因此现在我们也常常把这个模型运用在基于相似度的一些机器学习算法中，例如K近邻（KNN）分类、K均值（K-Means)聚类等等。</p>

<h3>35丨文本检索：如何让计算机处理自然语言？</h3>

<h3>36丨文本聚类：如何过滤冗余的新闻？</h3>

<h3>37丨矩阵（上）：如何使用矩阵操作进行PageRank计算？</h3>

<p>我们可以把向量看作一维数组，把矩阵看作二维数组。矩阵的点乘，是由若干个向量的点乘组成的，所以我们可以通过矩阵的点乘操作，挖掘多组向量两两之间的关系。</p>

<p>我们讲了矩阵的点乘操作在PageRank算法中的应用。通过表示网页的邻接二元关系，我们可以使用矩阵来计算PageRank的得分。在这个应用场景下，矩阵点乘体现了多个马尔科夫过程中的状态转移。</p>

<p>矩阵点乘和其他运算操作，还可以运用在很多其他的领域。例如，我在上一节介绍K均值聚类算法时，就提到了需要计算某个数据点向量、其他数据点向量之间的距离或者相似度，以及使用多个数据点向量的平均值来获得质心点的向量，这些都可以通过矩阵操作来完成。</p>

<p>另外，在协同过滤的推荐中，我们可以使用矩阵点乘，来实现多个用户或者物品之间的相似程度，以及聚集后的相似程度所导致的最终推荐结果。下一节，我会使用矩阵来表示用户和物品的二元关系，并通过矩阵来计算协同过滤的结果。</p>

<h3>38丨矩阵（下）：如何使用矩阵操作进行协同过滤推荐？</h3>

<p>矩阵中的二维关系，除了可以表达图的邻接关系，还可以表达推荐系统中用户和物品的关系。这个关系是推荐系统的核心。</p>

<p>我们用矩阵 X 来表示用户对物品喜好程度：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.png" alt="20220531协同过滤推荐系统.png" /></p>

<p>其中第<code>i</code>行是第<code>i</code>个用户的数据，而第<code>j</code>列是用户对第<code>j</code>格物品的喜好程度。我们用<code>xij</code>表示这个数值。这里的喜好程度可以是用户购买商品的次数、对书籍的评分等等。</p>

<p>假设我们用一个0到1之间的小数表示。有了这种矩阵，我们就可以通过矩阵的操作，充分挖掘用户和物品之间的关系。下面，我会使用经典的协同过滤算法，来讲解矩阵在其中的运用。</p>

<h4>基于用户的协同过滤</h4>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7.png" alt="20220531协同过滤基于用户.png" /></p>

<p>根据这张图的访问关系来看，用户A访问了物品A和C，用户B访问了物品B，用户C访问了物品A，C和D。我们计算出来，用户C是A的近邻，而B不是。因此系统会更多地向用户A推荐用户C访问的物品D。</p>

<p>基于用户的协同过滤的核心公式如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%9F%BA%E4%BA%8E%E7%94%A8%E6%88%B7%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E5%85%AC%E5%BC%8F1.png" alt="20220531基于用户协同过滤公式1.png" /></p>

<ol>
<li>第一个公式是计算用户和用户之间的相似度。完成了这一步我们就能找到给定用户的“近邻”。</li>
<li>第二个公式利用第一个公式所计算的用户间相似度，以及用户对物品的喜好度，预测任一个用户对任一个物品的喜好度。其中<code>pij</code>表示第<code>i</code>用户对第<code>j</code>个物品的喜好度。</li>
</ol>


<h4>基于物品的过滤</h4>

<p>基于物品的协同过滤是指利用物品相似度，而不是用户间的相似度来计算预测值。</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%9F%BA%E4%BA%8E%E7%89%A9%E5%93%81%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E5%9B%BE.png" alt="20220531基于物品的协同过滤图.png" /></p>

<p>在这张图中，物品A和C因为都被用户A和B同时访问，因此它们被认为相似度更高。当用户C访问过物品A后，系统会更多地向用户推荐物品C，而不是其他物品。</p>

<p>基于用户的协同过滤同样有两个公式:</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%9F%BA%E4%BA%8E%E7%89%A9%E5%93%81%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E5%85%AC%E5%BC%8F.png" alt="20220531基于物品的协同过滤公式.png" /></p>

<ol>
<li>第一个公式的核心思想是计算物品和物品之间的相似度。</li>
<li>第二个公式利用第一个公式所计算的物品间相似度，和用户对物品的喜好度，预测任一个用户对任一个物品的喜好度。</li>
</ol>


<p>协同过滤的公式（基于用户/物品）都可以用矩阵操作表达。</p>

<h4>总结</h4>

<p>今天我首先简要地介绍了推荐系统的概念和主要思想。为了给用户提供可靠的结果，推荐系统需要充分挖掘历史数据中，用户和物品之间的关系。协同过滤的推荐算法就很好地体现了这一点。</p>

<p>一旦涉及用户和物品的这种二元关系，矩阵就有用武之地了。我通过矩阵来表示用户和物品的关系，并通过矩阵计算来获得协同过滤的结果。协同过滤分为基于用户的过滤和基于物品的过滤两种，它们的核心思想都是相同的，因此矩阵操作也是类似的。在这两个应用场景下，矩阵点乘体现了多个用户或者物品之间的相似程度，以及聚集后的相似程度所导致的最终推荐结果。</p>

<p>当然，基于用户和物品间关系的推荐算法有很多，对矩阵的操作也远远不止点乘、按行求和、元素对应乘除法。我后面会介绍如何使用矩阵的主成分分析或奇异值分解，来进行物品的推荐。</p>

<h3>39丨线性回归（上）：如何使用高斯消元求解线性方程组？</h3>

<h4>高斯消元</h4>

<p>矩阵操作实现高斯消元求解线性方程组。</p>

<p>高斯消元法主要包含了消元和回代两个步骤。这些步骤都可以使用矩阵的操作来进行。从矩阵的角度来说，消元就是把系数矩阵变为上三角矩阵，而回代是把这个上三角矩阵变为单位矩阵。我们可以直接把用于消元和回代的矩阵，用于由系数和因变量值组成的增广矩阵，并获得最终的方程解。</p>

<h4>线性方程组与线性回归分析</h4>

<p>线性方程组的概念，也是线性回归分析的基础。它们有两个最主要的区别。</p>

<ol>
<li>第一个区别是，在线性回归分析中，样本数据会告诉我们自变量和因变量的值，要求的是系数。而在线性方程组中，我们已知系数和因变量的值，要求的是自变量的值。</li>
<li>第二个区别是，在线性回归分析中，方程的数量要远远大于自变量的数量，而且我们不要求每个方程式都是完全成立。这里，不要求完全成立的意思是，拟合出来的因变量值可以和样本数据给定的因变量值存在差异，也就允许模型拟合存在误差。模型拟合的概念我在上一模块的总结篇中重点讲解了，所以你应该能理解，模型的拟合不可能 100% 完美，这和我们求解线性方程组精确解的概念是不同的。</li>
</ol>


<p>正是因为这两点差异，我们无法直接使用消元法来求解线性回归，而是使用最小二乘法来解决线性回归的问题。</p>

<h3>40丨线性回归（中）：如何使用最小二乘法进行直线拟合？</h3>

<h3>41丨线性回归（下）：如何使用最小二乘法进行效果验证？</h3>

<p>从广义上来说，最小二乘法不仅可以用于线性回归，还可以用于非线性的回归。其主要思想还是要确保误差ε最小，但是由于现在的函数是非线性的，所以不能使用求多元方程求解的办法来得到参数估计值，而需要采用迭代的优化算法来求解，比如梯度下降法、随机梯度下降法和牛顿法。</p>

<h3>42丨PCA主成分分析（上）：如何利用协方差矩阵来降维？</h3>

<p>在概率统计模块，我详细讲解了如何使用各种统计指标来进行特征的选择，降低用于监督式学习的特征之维度。接下来的几节，我会阐述两种针对数值型特征，更为通用的降维方法，它们是主成分分析 PCA（Principal Component Analysis）和奇异值分解 SVD（Singular Value Decomposition）。这两种方法是从矩阵分析的角度出发，找出数据分布之间的关系，从而达到降低维度的目的。</p>

<h4>PCA 分析法的主要步骤</h4>

<p>对于m×n维的样本矩阵，其中每一行表示一个样本，而每一列表示一维特征。现在，我们的问题是，能不能通过某种方法，找到一种变换，可以降低这个矩阵的列数，也就是特征的维数，并且尽可能的保留原始数据中有用的信息？</p>

<p>针对这个问题，PCA 分析法提出了一种可行的解决方案。它包括了下面这样几个主要的步骤：</p>

<ol>
<li>标准化样本矩阵中的原始数据；</li>
<li>获取标准化数据的协方差矩阵；</li>
<li>计算协方差矩阵的特征值和特征向量；</li>
<li>依照特征值的大小，挑选主要的特征向量；</li>
<li>生成新的特征。</li>
</ol>


<h4>标准化原始数据</h4>

<p>之前我们已经介绍过特征标准化，这里我们需要进行同样的处理，才能让每维特征的重要性具有可比性。需要注意的是，这里标准化的数据是针对同一种特征，也是在同一个特征维度之内。不同维度的特征不能放在一起进行标准化。</p>

<h4>获取协方差矩阵</h4>

<p>首先，来看一下什么是<a href="https://zh.m.wikipedia.org/zh-sg/%E5%8D%8F%E6%96%B9%E5%B7%AE">协方差</a>（Covariance），以及<a href="https://zh.m.wikipedia.org/zh-sg/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5">协方差矩阵</a>。</p>

<p><strong>协方差</strong>是用于衡量两个变量的总体误差。假设两个变量分别是 x 和 y，而它们的采样数量都是 m，那么协方差的计算公式就是如下这种形式：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%8F%E6%96%B9%E5%B7%AE%E5%85%AC%E5%BC%8F.png" alt="20220531协方差公式.png" /></p>

<p>而当两个变量是相同时，协方差就变成了方差。</p>

<p>对于m×n维的样本矩阵，其<strong>协方差矩阵</strong>（i,j)位置处的值表示第i个特征（列向量）和第j个特征（列向量）之间的协方差，公式如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5ij%E4%BD%8D%E7%BD%AE%E5%85%83%E7%B4%A0.png" alt="20220531协方差矩阵ij位置元素.png" /></p>

<p>所以，样本矩阵的协方差矩阵就可以表示为：</p>

<p><img src="http://hongchaozhang.github.io/images/20220531%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E5%85%AC%E5%BC%8F.png" alt="20220531协方差矩阵公式.png" /></p>

<p>从协方差的定义可以看出，协方差矩阵是个对称矩阵。另外，这个对称矩阵的主对角线上的值就是各维特征的方差。</p>

<h4>计算协方差矩阵的特征值和特征向量</h4>

<p>需要注意的是，这里所说的矩阵的特征向量，和机器学习中的特征向量（Feature Vector）完全是两回事。矩阵的特征值和特征向量是线性代数中两个非常重要的概念。对于一个矩阵X，如果能找到向量v和标量λ，使得下面这个式子成立。</p>

<p><code>Xv=λv</code></p>

<p>那么，我们就说v是矩阵X的特征向量，而λ是矩阵X的特征值。矩阵的特征向量和特征值可能不止一个。说到这里，你可能会好奇，特征向量和特征值表示什么意思呢？我们为什么要关心这两个概念呢？简单的来说，我们可以把向量v左乘一个矩阵X看做对v进行旋转或拉伸，而这种旋转和拉伸都是由于左乘矩阵X后，所产生的“运动”所导致的。特征向量v表示了矩阵X运动的方向，特征值λ表示了运动的幅度，这两者结合就能描述左乘矩阵X所带来的效果，因此被看作矩阵的“特征”。在PCA中的主成分，就是指特征向量，而对应的特征值的大小，就表示这个特征向量或者说主成分的重要程度。特征值越大，重要程度越高，我们要优先现在这个主成分，并利用这个主成分对原始数据进行变换。</p>

<h4>挑选主要的特征向量，转换原始数据</h4>

<p>假设我们获得了k个特征值和对应的特征向量，按照所对应的λ数值的大小，对这k组的特征向量进行排序。排名靠前的特征向量就是最重要的特征向量。</p>

<p>假设我们只取前k1个最重要的特征，那么我们使用这k1个特征向量，组成一个n×k1维的矩阵D。</p>

<p>把包含原始数据的m×n维矩阵X左乘矩阵D，就能重新获得一个m×k1维的矩阵，达到了降维的目的。</p>

<p>有的时候，我们无法确定k1取多少合适。一种常见的做法是，看前k1个特征值的和占所有特征值总和的百分比。假设一共有10个特征值，总和是100，最大的特征值是80，那么第一大特征值占整个特征值之和的80%，我们认为它能表示80%的信息量，还不够多。那我们就继续看第二大的特征值，它是15，前两个特征值之和有95，占比达到了95%，如果我们认为足够了，那么就可以只选前两大特征值，把原始数据的特征维度从10维降到2维。</p>

<h3>43丨PCA主成分分析（下）：为什么要计算协方差矩阵的特征值和特征向量？</h3>

<p>这一部分分析的太到位了，将原文链接放上：<a href="http://hongchaozhang.github.io/assets/resources/43%E4%B8%A8PCA%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%A1%E7%AE%97%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%EF%BC%9F.html">PCA主成分分析（下）：为什么要计算协方差矩阵的特征值和特征向量？</a>。</p>

<h4>基于Python的案例分析</h4>

<p>通过基于Python的案例来一步步计算PCA的各个步骤的中间结果。</p>

<h4>PCA背后的核心思想</h4>

<p><strong>为什么要使用协方差矩阵？</strong></p>

<p>为什么我们要使用样本数据中，各个维度之间的协方差，来构建一个新的协方差矩阵？要弄清楚这一点，首先要回到PCA最终的目标：降维。降维就是要去除那些表达信息量少，或者冗余的维度。</p>

<ol>
<li>我们首先来看如何定义维度的<strong>信息量</strong>大小。这里我们认为样本在某个特征上的差异越大，这个特征包含的信息量就越大，就越重要。很自然，我们就能想到使用某维特征的方差来定义样本在这个特征维度上的差异。</li>
<li>另一方面，我们要看如何发现冗余的信息。如果两种特征是有很高的相关性，那我们可以从一个维度的值推算出另一个维度的值，所表达的信息就是重复的。在实际运用中，我们可以使用皮尔森（Pearson）相关系数，来描述两个变量之间的线性相关程度。这个系数的取值范围是<code>[−1,1]</code>，绝对值越大，说明相关性越高，正数表示正相关，负数表示负相关。在本质上，皮尔森相关系数和数据标准化后的协方差是一致的。</li>
</ol>


<p>考虑到协方差既可以衡量信息量的大小，也可以衡量不同维度之间的相关性，因此我们就使用各个维度之间的协方差所构成的矩阵，作为PCA分析的对象。就如前面说讲述的，这个协方差矩阵主对角线上的元素是各维度上的方差，也就体现了信息量，而其他元素是两两维度间的协方差，也就体现了相关性。</p>

<p>既然协方差矩阵提供了我们所需要的方差和相关性，那么下一步，我们就要考虑对这个矩阵进行怎样的操作了。</p>

<p><strong>为什么要计算协方差矩阵的特征值和特征向量？</strong></p>

<p>关于这点，我们可以从两个角度来理解。</p>

<p>第一个角度是对角矩阵。所谓对角矩阵，就是说只有矩阵主对角线之上的元素有非0值，而其他元素的值都为0。我们刚刚解释了协方差矩阵的主对角线上，都是表示信息量的方差，而其他元素都是表示相关性的协方差。既然我们希望尽可能保留大信息量的维度，而去除相关的维度，那么就意味着我们希望对协方差进行对角化，尽可能地使得矩阵只有主对角线上有非0元素。</p>

<p>假如我们确实可以把矩阵尽可能的对角化，那么对角化之后的矩阵，它的主对角线上元素就是、或者接近矩阵的特征值，而特征值本身又表示了转换后的方差，也就是信息量。而此时，对应的各个特征向量之间是基本正交的，也就是相关性极低甚至没有相关性。</p>

<p>第二个角度是特征值和特征向量的几何意义。在向量空间中，对某个向量左乘一个矩阵，实际上是对这个向量进行了一次变换。在这个变换的过程中，被左乘的向量主要发生旋转和伸缩这两种变化。<strong>如果左乘矩阵对某一个向量或某些向量只发生伸缩变换，不对这些向量产生旋转的效果，那么这些向量就称为这个矩阵的特征向量，而伸缩的比例就是特征值</strong>。换句话来说，某个矩阵的特征向量表示了这个矩阵在空间中的变换方向，这些方向都是趋于正交的，而特征值表示每个方向上伸缩的比例。</p>

<p>如果一个特征值很大，那么说明在对应的特征向量所表示的方向上，伸缩幅度很大。这也是为什么，我们需要使用原始的数据去左乘这个特征向量，来获取降维后的新数据。因为这样做可以帮助我们找到一个方向，让它最大程度地包含原有的信息。需要注意的是，这个新的方向，往往不代表原始的特征，而是多个原始特征的组合和缩放。</p>

<h3>44丨奇异值分解：如何挖掘潜在的语义关系？</h3>

<p>今天，我们来聊另一种降维的方法，SVD奇异值分解（SingularValueDecomposition）。它的核心思路和PCA不同。PCA是通过分析不同纬特征之间的协方差，找到包含最多信息量的特征向量，从而实现降维。而SVD这种方法试图通过样本矩阵本身的分解，找到一些“潜在的因素”，然后通过把原始的特征维度映射到较少的潜在因素之上，达到降维的目的。</p>

<h4>方阵的特征分解</h4>

<ul>
<li>方阵</li>
<li>酉矩阵</li>
<li>方阵的特征分解</li>
</ul>


<p>那么如果X不是方阵，那么应该如何进行矩阵的分解呢？这个时候就需要用到奇异值分解SVD了。</p>

<h4>SVD分解</h4>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3">Wiki SVD分解</a></li>
<li>奇异值</li>
<li>右奇异向量</li>
<li>左奇异向量</li>
</ul>


<h4>潜在语义分析和SVD</h4>

<h3>45丨线性代数篇答疑和总结：矩阵乘法的几何意义是什么？</h3>

<h2>06-综合应用篇 (6讲)</h2>

<h3>46丨缓存系统：如何通过哈希表和队列实现高效访问？</h3>

<p>缓存设计的几个主要考量因素:
1. 硬件性能：高性能做低性能的缓存。
2. 命中率。缓存删除策略：
    1. 最少使用 LFU（Least Frequently Used）策略
    2. 最久未用 LRU（Least Recently Used）策略：使用队列（Queue）表示上次使用时间，刚用过的放在队尾，淘汰的时候直接淘汰队头的即可。
3. 更新周期</p>

<p>我们同时使用了哈希函数和队列，实现了一个最简单的缓存系统。哈希函数确保了查找的高效率，而队列则实现了 LRU 的淘汰策略。通过这两点，你就能理解缓存设计的基本原理和方法。</p>

<h3>47丨搜索引擎（上）：如何通过倒排索引和向量空间模型，打造一个简单的搜索引擎？</h3>

<p>搜索引擎最重要的核心就是及时性和相关性。及时性确保用户可以快速找到信息，而相关性确保所找到的信息是用户真正需要的。
1. 倒排索引是搜索引擎提升及时性中非常关键的一步。倒排索引非常适合使用哈希表，特别是链地址型的哈希表来实现。
2. 向量空间模型可以作为文本搜索的相关性模型。但是，它的计算需要把查询和所有的文档进行比较，时间复杂度太高，影响了及时性。这个时候，我们可以利用倒排索引，过滤掉绝大部分不包含查询关键词的文档。</p>

<h3>48丨搜索引擎（下）：如何通过查询的分类，让电商平台的搜索结果更相关？</h3>

<p>相关性模型是搜索引擎非常核心的模块，它直接影响了搜索结果是不是满足用户的需求。我们之前讲解的向量空间模型、概率语言模型等常见的模型，逐渐成为了主流的相关性模型。不过这些模型通常适用于普通的文本检索，并没有针对每个应用领域进行优化。</p>

<p>在电商平台上，搜索引擎是帮助用户查找商品的好帮手。可是，直接采用向量空间模型进行排序往往效果不好。这主要是因为索引的标题和属性都很短，我们无法充分利用关键词的词频、逆文档频率等信息。考虑到搜索商品的时候，商品的分类对于用户更为重要，所以我们在设计相关性排序的时候需要考虑这个信息。</p>

<p>为了识别用户对哪类商品更感兴趣，我们可以对用户输入的查询进行分类。用于构建分类器的数据，可以是运营人员发布的商品目录信息，也可以是用户使用之后的行为日志。我们可以根据搜索系统运行的情况，赋予它们不同的权重。</p>

<p>如果我们可以对查询做出更为准确的分类，那么就可以使用这个分类的结果，来对原有搜索结果进行重新排序。现在的开源搜索引擎，例如 Elasticsearch，都支持动态修改排序结果，为我们结合分类器和搜索引擎提供了很大的便利。</p>

<h3>49丨推荐系统（上）：如何实现基于相似度的协同过滤？</h3>

<p>原文链接：<a href="http://hongchaozhang.github.io/assets/resources/49%E4%B8%A8%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%9A%84%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%EF%BC%9F.html">49丨推荐系统（上）：如何实现基于相似度的协同过滤？.html</a></p>

<p>通过一个常用的实验数据，设计并实现了最简单的基于用户的协同过滤。值得动手练习一下。</p>

<h3>50丨推荐系统（下）：如何通过SVD分析用户和物品的矩阵？</h3>

<p>原文链接：<a href="http://hongchaozhang.github.io/assets/resources/50%E4%B8%A8%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87SVD%E5%88%86%E6%9E%90%E7%94%A8%E6%88%B7%E5%92%8C%E7%89%A9%E5%93%81%E7%9A%84%E7%9F%A9%E9%98%B5%EF%BC%9F.html">50丨推荐系统（下）：如何通过SVD分析用户和物品的矩阵？.html</a></p>

<p>通过Python示例，解释了SVD分解过程中的数学量的物理意义，值得上手一试。</p>

<blockquote><p>在用户对电影评分的应用场景下，SVD 分解后的 U 矩阵、V 矩阵和 Σ 矩阵各自代表的意义，其中 Σ 矩阵中的奇异值表示了 SVD 挖掘出来的电影主题，U 矩阵中的奇异向量表示用户对这些电影主题的评分，而 V 矩阵中的奇异向量表示了电影和这些主题的相关程度。</p></blockquote>

<h3>51丨综合应用篇答疑和总结：如何进行个性化用户画像的设计？</h3>

<h2>07-加餐 (3讲)</h2>

<h3>数学专栏课外加餐（一）丨我们为什么需要反码和补码？</h3>

<h3>数学专栏课外加餐（三）：程序员需要读哪些数学书？</h3>

<h3>数学专栏课外加餐（二）丨位操作的三个应用实例</h3>

<h2>08-结束语 (1讲)</h2>

<h3>结束语丨从数学到编程，本身就是一个很长的链条</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[web性能优化]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/03/21/web-xingneng-youhua/"/>
    <updated>2022-03-21T23:30:53+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/03/21/web-xingneng-youhua</id>
    <content type="html"><![CDATA[<!-- more -->


<p>从web渲染全过程分析，从下面几个方面进行性能优化考虑：</p>

<ol>
<li>HTTP请求性能优化</li>
<li>浏览器内渲染性能优化</li>
</ol>


<h2>HTTP(s)请求性能优化</h2>

<ul>
<li>参考极客时间课程《透视HTTP协议》的39和40两节课。</li>
<li>另外，<a href="http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi/">极客时间-罗剑锋-《透视HTTP协议》总结</a>中的章节<a href="http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi/#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">http性能优化</a>，有一个概括性的描述。</li>
<li>相关内容个人总结参考<a href="http://hongchaozhang.github.io/blog/2022/03/08/http-xingneng-youhua/">HTTP(s)请求性能优化</a>。</li>
</ul>


<h2>浏览器内渲染性能优化</h2>

<ul>
<li>参考极客时间课程《让你页面速度飞起来 Web前端性能优化》</li>
<li>相关内容个人总结参考<a href="http://hongchaozhang.github.io/blog/2022/01/04/web-qianduan-xingneng-youhua/">极客时间-Web前端性能优化</a>。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从Terminal切换到iTerm2，从Bash切换到Zsh]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/03/08/change-from-bash-to-zsh/"/>
    <updated>2022-03-08T16:45:12+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/03/08/change-from-bash-to-zsh</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>安装iTerm2 + Oh My Zsh</h2>

<p><a href="https://segmentfault.com/a/1190000014992947">iTerm2 + Oh My Zsh 打造舒适终端体验</a></p>

<h4>我的主题和插件</h4>

<p>OhMyZsh的主题：ZSH_THEME=&ldquo;af-magic&rdquo;</p>

<p>OhMyZsh的插件：plugins=(git zsh-syntax-highlighting zsh-autosuggestions)</p>

<h2>Zsh配置文件加载顺序</h2>

<p>最重要的是下面两个文件：</p>

<ul>
<li>.zshenv：.zshenv总是被读取,所以通常把$PATH, $EDITOR等变量写在这里,这样无论是在shell交互,或者运行程序都会读取此文件</li>
<li>.zshrc：.zshrc主要用在交互shell,所以主要是为shell服务的,比如对shell做的一些个性化设置都可以在这里写入</li>
</ul>


<p>更多配置文件，参考<a href="https://unix.stackexchange.com/questions/71253/what-should-shouldnt-go-in-zshenv-zshrc-zlogin-zprofile-zlogout">What should/shouldn&rsquo;t go in .zshenv, .zshrc, .zlogin, .zprofile, .zlogout?</a>，或者这一篇中文<a href="http://blog.xsudo.com/2019/04/12/1445/">zsh的环境变量的加载.zprofile .zlogin .zshrc .zshenv</a></p>

<h2>Zsh问题</h2>

<h3>Octopress在zsh下无法新建博客的问题</h3>

<p>执行：</p>

<pre><code>$ rake new_post["new post name"]
</code></pre>

<p>报错：</p>

<pre><code>zsh: no matches found: new_post[new post name]
</code></pre>

<p>原因：
zsh中若出现‘*’, ‘(’, ‘|’, ‘&lt;’, ‘[’, 或者 ‘?’符号，则将其识别为查找文件名的通配符。</p>

<p>解决方法一：</p>

<p>遇到上面的特殊字符，使用转义字符代替。比如：</p>

<pre><code>$ rake new_post\["new post name"\]
</code></pre>

<p>解决方法二：</p>

<p>取消zsh的通配(GLOB), 在.zshrc中加入</p>

<pre><code>alias rake="noglob rake"
</code></pre>

<p>并且执行：</p>

<pre><code>source ./zshrc
</code></pre>

<p>PS: git操作也有类似的问题。</p>

<p>在 git 回滚操作</p>

<pre><code>git reset --soft HEAD^
</code></pre>

<p>出现报错：</p>

<pre><code>zsh: no matches found HEAD^
</code></pre>

<p>也为同样原因，因为^也为正则中的符号， 需要转义为</p>

<pre><code>git reset --soft HEAD\^
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP(s)请求性能优化]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/03/08/http-xingneng-youhua/"/>
    <updated>2022-03-08T16:44:40+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/03/08/http-xingneng-youhua</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7">性能测试工具</a></li>
<li><a href="#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">HTTP性能优化</a>

<ul>
<li><a href="#%E5%BC%80%E6%BA%90">开源</a></li>
<li><a href="#%E8%8A%82%E6%B5%81">节流</a></li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="#%E5%8D%87%E7%BA%A7%E5%88%B0http2">升级到HTTP/2</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E8%B5%84%E6%BA%90%E5%90%88%E5%B9%B6">关于资源合并</a></li>
</ul>
</li>
<li><a href="#https%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">HTTPs性能优化</a>

<ul>
<li><a href="#1-%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96cpussl%E5%8A%A0%E9%80%9F%E5%8D%A1ssl%E5%8A%A0%E9%80%9F%E6%9C%8D%E5%8A%A1%E5%99%A8">1. 硬件优化：CPU，SSL加速卡，SSL加速服务器</a></li>
<li><a href="#2-%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96">2. 软件优化：</a></li>
</ul>
</li>
</ul>


<!-- /TOC -->


<p><a id="markdown-性能测试工具" name="性能测试工具"></a></p>

<h2>性能测试工具</h2>

<ol>
<li><p>在 Linux 上，最常用的性能测试工具可能就是 ab（Apache Bench）了，比如，下面的命令指定了并发数 100，总共发送 10000 个请求：</p>

<pre><code class="`"> ab -c 100 -n 10000 'http://www.xxx.com'
</code></pre></li>
<li><p>系统资源监控方面，Linux 自带的工具也非常多，常用的有 uptime、top、vmstat、netstat、sar 等等，可能你比我还要熟悉，我就列几个简单的例子吧：</p>

<pre><code class="`"> top             # 查看 CPU 和内存占用情况
 vmstat  2       # 每 2 秒检查一次系统状态
 sar -n DEV 2    # 看所有网卡的流量，定时 2 秒检查
</code></pre></li>
<li>之前讲 HTTPS 时介绍过一个专门的网站<a href="https://www.ssllabs.com/">SSLLabs</a>，而对于 HTTP 性能优化，也有一个专门的测试网站<a href="https://www.webpagetest.org/">WebPageTest</a>。它的特点是在世界各地建立了很多的测试点，可以任意选择地理位置、机型、操作系统和浏览器发起测试，非常方便，用法也很简单。网站测试的最终结果是一个直观的“瀑布图”（Waterfall Chart），清晰地列出了页面中所有资源加载的先后顺序和时间消耗。</li>
<li>Chrome 等浏览器自带的开发者工具也可以很好地观察客户端延迟指标，面板左边有每个 URI 具体消耗的时间，面板的右边也有瀑布图。</li>
</ol>


<p><a id="markdown-http性能优化" name="http性能优化"></a></p>

<h2>HTTP性能优化</h2>

<p><a id="markdown-开源" name="开源"></a></p>

<h3>开源</h3>

<ul>
<li>Nginx及相关配置</li>
<li>HTTP启用长连接
<a id="markdown-节流" name="节流"></a></li>
</ul>


<h3>节流</h3>

<ul>
<li>数据压缩：图片，json等</li>
<li>html/css/js的minify</li>
<li>去除不必要的Header属性</li>
<li>减少域名数量和重定向次数
<a id="markdown-缓存" name="缓存"></a></li>
</ul>


<h3>缓存</h3>

<ul>
<li>服务器缓存：Redis</li>
<li>CDN缓存
<a id="markdown-升级到http2" name="升级到http2"></a></li>
</ul>


<h3>升级到HTTP/2</h3>

<ul>
<li>消除了应用层的队头阻塞，拥有头部压缩、二进制帧、多路复用、流量控制、服务器推送等许多新特性，大幅度提升了 HTTP 的传输效率。
<a id="markdown-关于资源合并" name="关于资源合并"></a></li>
</ul>


<h3>关于资源合并</h3>

<ul>
<li>“资源合并”在 HTTP/1 里减少了多次请求的成本，但在 HTTP/2 里因为有头部压缩和多路复用，传输小文件的成本很低，所以合并就失去了意义。而且“资源合并”还有一个缺点，就是降低了缓存的可用性，只要一个小文件更新，整个缓存就完全失效，必须重新下载。</li>
<li>所以在现在的大带宽和 CDN 应用场景下，应当尽量少用资源合并（JS、CSS 图片合并，数据内嵌），让资源的粒度尽可能地小，才能更好地发挥缓存的作用。</li>
</ul>


<p><a id="markdown-https性能优化" name="https性能优化"></a></p>

<h2>HTTPs性能优化</h2>

<p><a id="markdown-1-硬件优化cpussl加速卡ssl加速服务器" name="1-硬件优化cpussl加速卡ssl加速服务器"></a></p>

<h3>1. 硬件优化：CPU，SSL加速卡，SSL加速服务器</h3>

<p><a id="markdown-2-软件优化" name="2-软件优化"></a></p>

<h3>2. 软件优化：</h3>

<ol>
<li>软件升级：Linux内核，Nginx，OpenSSL</li>
<li>协议优化：

<ul>
<li>TLS1.3</li>
<li>密钥交换协议尽量选用椭圆曲线ECDHE算法，能够把握手的消息往返由 2-RTT 减少到 1-RTT，达到与 TLS1.3 类似的效果。</li>
<li>Nginx配置密码套件和椭圆曲线，将优先使用的放在前面。</li>
</ul>
</li>
<li>证书优化：

<ul>
<li>CRL（Certificate revocation list，证书吊销列表）由 CA 定期发布，里面是所有被撤销信任的证书序号，查询这个列表就可以知道证书是否有效。</li>
<li>现在 CRL 基本上不用了，取而代之的是 OCSP（在线证书状态协议，Online Certificate Status Protocol），向 CA 发送查询请求，让 CA 返回证书的有效状态。</li>
<li>“OCSP Stapling”（OCSP 装订），它可以让服务器预先访问 CA 获取 OCSP 响应，然后在握手时随着证书一起发给客户端，免去了客户端连接 CA 服务器查询的时间。</li>
</ul>
</li>
<li>会话复用：

<ul>
<li>我们再回想一下 HTTPS 建立连接的过程：先是 TCP 三次握手，然后是 TLS 一次握手。这后一次握手的重点是算出主密钥“Master Secret”，而主密钥每次连接都要重新计算，未免有点太浪费了，如果能够把“辛辛苦苦”算出来的主密钥缓存一下“重用”，不就可以免去了握手和计算的成本了吗？</li>
<li>这种做法就叫“会话复用”（TLS session resumption），和 HTTP Cache 一样，也是提高 HTTPS 性能的“大杀器”，被浏览器和服务器广泛应用。</li>
<li>会话复用分两种

<ul>
<li>第一种叫“Session ID”：“Session ID”是最早出现的会话复用技术，也是应用最广的，但它也有缺点，服务器必须保存每一个客户端的会话数据，对于拥有百万、千万级别用户的网站来说存储量就成了大问题，加重了服务器的负担。</li>
<li>第二种叫“Session Ticket”：它有点类似 HTTP 的 Cookie，存储的责任由服务器转移到了客户端</li>
</ul>
</li>
<li>预共享密钥：

<ul>
<li>在发送 Ticket 的同时会带上应用数据（Early Data），免去了 1.2 里的服务器确认步骤，这种方式叫“Pre-shared Key”，简称为“PSK”。</li>
</ul>
</li>
</ul>
</li>
</ol>


<p>上面的内容来自极客时间的《透视HTTP协议》课程的39和40两节课。
另外，<a href="http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi/">极客时间-罗剑锋-《透视HTTP协议》总结</a>中的章节<a href="http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi/#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">http性能优化</a>，有一个概括性的描述。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何调试NodeJs源码]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/01/12/how-to-debug-nodejs/"/>
    <updated>2022-01-12T15:57:01+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/01/12/how-to-debug-nodejs</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>调试javascript代码</h2>

<p>通过添加<code>--inspect</code>参数启动nodejs服务，看到下面的消息，表明成功启动调试模式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HANM10610:nodePlayground hozhang$ node --inspect sightReading.js
</span><span class='line'>Debugger listening on ws://127.0.0.1:9229/c8620553-2cf2-4fac-bab8-d18e98c3d777
</span><span class='line'>For help, see: https://nodejs.org/en/docs/inspector</span></code></pre></td></tr></table></div></figure>


<p>可以通过很多种方式连接到调试环境，比如Chrome Developer Tools, VS Code等，详细信息参考官方文档<a href="https://nodejs.org/en/docs/guides/debugging-getting-started/">Debugging Guide</a>。下面以Chrome Developer Tools说明。</p>

<p>在chrome://inspect/#devices找到启动的target，打开，搜索打开你的文件或者相关的库文件，就可以打断点开始调试了。</p>

<p><img src="http://hongchaozhang.github.io/images/debug%E6%9F%A5%E7%9C%8B%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B.jpg" alt="debug查看参数类型.jpg" /></p>

<p><img src="http://hongchaozhang.github.io/images/%E8%B0%83%E8%AF%95readFileSync.jpg" alt="调试readFileSync.jpg" /></p>

<h2>调试C/C++代码</h2>

<p>参考<a href="https://www.tripfe.cn/node-js-four-postures-of-source-code-debugging/">Node.js源代码调试的4种姿势</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[极客时间-Web前端性能优化]]></title>
    <link href="http://hongchaozhang.github.io/blog/2022/01/04/web-qianduan-xingneng-youhua/"/>
    <updated>2022-01-04T18:06:29+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2022/01/04/web-qianduan-xingneng-youhua</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E8%B5%84%E6%BA%90%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%90%88%E5%B9%B6">资源压缩与合并</a>

<ul>
<li><a href="#%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96">图片优化</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E9%A2%84%E5%8A%A0%E8%BD%BD">图片的懒加载预加载</a>

<ul>
<li><a href="#%E6%87%92%E5%8A%A0%E8%BD%BD">懒加载：</a></li>
<li><a href="#%E9%A2%84%E5%8A%A0%E8%BD%BD">预加载：</a></li>
</ul>
</li>
<li><a href="#html%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B">HTML渲染过程</a></li>
<li><a href="#%E9%87%8D%E7%BB%98%E5%A4%96%E8%A7%82%E4%B8%8E%E5%9B%9E%E6%B5%81%E5%B8%83%E5%B1%80redrawreflow">重绘（外观）与回流（布局）redraw/reflow</a>

<ul>
<li><a href="#top-and-translate">top and translate</a></li>
<li><a href="#opacity%E6%9B%BF%E6%8D%A2visibility"><code>opacity</code>替换<code>visibility</code></a></li>
<li><a href="#css%E7%9A%84class%E6%9B%BF%E4%BB%A3style">css的class替代style</a></li>
<li><a href="#displaynone"><code>display:none</code></a></li>
<li><a href="#%E6%85%8E%E7%94%A8clientwidth">慎用<code>clientWidth</code></a></li>
<li><a href="#%E5%B0%91%E7%94%A8table%E5%B8%83%E5%B1%80">少用table布局。</a></li>
<li><a href="#%E5%8A%A8%E7%94%BB%E7%9A%84%E5%88%B7%E6%96%B0%E7%8E%87%E5%92%8C%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E5%B9%B3%E8%A1%A1">动画的刷新率和页面性能平衡</a></li>
<li><a href="#%E5%B0%86gif%E5%9B%BE%E5%8D%95%E7%8B%AC%E6%88%90%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%B1%82">将gif图单独成一个图层</a></li>
<li><a href="#%E5%90%AF%E7%94%A8gpu%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F">启用GPU硬件加速</a></li>
</ul>
</li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8">浏览器存储</a></li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93">服务器端渲染</a></li>
</ul>


<!-- /TOC -->


<p>总结极客时间课程《让你页面速度飞起来 Web前端性能优化》</p>

<p><a id="markdown-资源压缩与合并" name="资源压缩与合并"></a></p>

<h2>资源压缩与合并</h2>

<p>资源合并会减少请求次数，总体上降低请求时间。但是，也不能不加考虑地都合并到一起，这样会影响首页渲染速度。</p>

<p><a id="markdown-图片优化" name="图片优化"></a></p>

<h3>图片优化</h3>

<ol>
<li>图片<strong>雪碧图</strong>，不能太大，太大影响首屏渲染性能。一个页面的小图放在一起，生成一张雪碧图即可。</li>
<li><strong>inline image</strong>，inline image内嵌在html里面，作为html的一部分和html一起加载。当图片大小小于8KB时，考虑使用inline image。</li>
<li><strong>使用webp格式图片</strong>，webp格式图片由google推出，android平台支持好，apple safari浏览器有兼容性问题（2020年Mac OS Big Sur中的Safari 14已经支持WebP格式。）</li>
<li><strong>jpg</strong>、<strong>png</strong>、<strong>svg</strong>等图片格式各有其特点和应用场合。</li>
</ol>


<p>另附上两个工具软件：</p>

<ol>
<li><a href="https://tinypng.com">图片压缩网站</a></li>
<li><a href="www.spritecow.com">雪碧图生成网站</a></li>
</ol>


<p><a id="markdown-图片的懒加载预加载" name="图片的懒加载预加载"></a></p>

<h2>图片的懒加载预加载</h2>

<p><a id="markdown-懒加载" name="懒加载"></a></p>

<h3>懒加载：</h3>

<p>通过图片进入可视区域的时候再设置img的src属性，进行请求。或者通过库实现。</p>

<p><a id="markdown-预加载" name="预加载"></a></p>

<h3>预加载：</h3>

<ol>
<li>使用<code>image</code>标签引入，先设置<code>display:none</code>。需要显示的时候再通过设置<code>display</code>属性将其显示出来。</li>
<li>在js中<code>new image</code>，并且设置<code>image</code>的<code>src</code>，进行图片下载，保存在js的变量中，但是不显示，需要的时候直接拿过来显示即可。</li>
<li>使用<code>XMLHttpRequest</code>，可以清楚知道请求的过程，但是存在跨域的问题。</li>
<li>或者通过库实现：preloader.js</li>
</ol>


<p><a id="markdown-html渲染过程" name="html渲染过程"></a></p>

<h2>HTML渲染过程</h2>

<ol>
<li>顺序执行，并发加载：为了让资源并发加载，可以部署多个CDN，以突破浏览器对单个域名并发加载数量的限制（4-6个）。

<ol>
<li><a href="https://juejin.cn/post/6844904035628089357">突破浏览器域名并发限制的解决方案</a></li>
<li>浏览器为什么要有这个限制，针对这个限制我们在开发的时候怎么优化？参考<a href="https://segmentfault.com/a/1190000039157302">前端性能优化篇——浏览器同域名并发请求对限制</a></li>
</ol>
</li>
<li>css加载延迟，页面先显示出没有样式的内容，原因是：css没有在header中引入，而是通过其他方式加载，比如在js中加载css。但是在header中通过link加载css也有缺点：阻塞页面渲染和js执行，但是不阻塞外部脚本的加载（得益于webkit的预扫描功能），但是阻塞执行。</li>
<li><code>script</code>和<code>import</code>引入方式：<code>script</code>引入js是同步的，阻塞页面渲染。结合<code>differ</code>和<code>sync</code>标签影响js引入过程。不阻塞资源的加载（得益于webkit的预扫描功能）。</li>
<li>SPA：单页应用，动态加载，路由到相关页面再加载相关的资源。</li>
</ol>


<p><a id="markdown-重绘外观与回流布局redrawreflow" name="重绘外观与回流布局redrawreflow"></a></p>

<h2>重绘（外观）与回流（布局）redraw/reflow</h2>

<p>css性能让js变慢：css影响layout，进而产生重绘与回流。多次的重绘与回流使得UI线程多次工作，而UI线程的启动会阻塞js线程的执行。</p>

<p>下面是一些有关<strong>回流与重绘</strong>实战演练。通过观察Chrome的Performance调试工具分析渲染过程和性能瓶颈。截图如下：</p>

<p><img src="http://hongchaozhang.github.io/images/chrome_performance_demo.jpg" alt="chrome_performance_demo.jpg" /></p>

<p><a id="markdown-top-and-translate" name="top-and-translate"></a></p>

<h3>top and translate</h3>

<p>相比于<code>top</code>，<code>translate</code>没有回流的过程，对于dom结构复杂的页面，性能提升比较明显。</p>

<p><details>
  <summary>Code using <code>top</code></summary></p>

<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;style&gt;
        #rect {
            position: relative;
            top: 0;
            width: 100px;
            height: 100px;
            background: blue;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="rect"&gt;&lt;/div&gt;
    &lt;script&gt;
        setTimeout(() =&gt; {
            document.getElementById("rect").style.top = "100px";
        }, 2000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p></details></p>

<p><details>
  <summary>Code using <code>transform</code></summary></p>

<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;style&gt;
        #rect {
            position: relative;
            transform: translateY(0);
            width: 100px;
            height: 100px;

            background: blue;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="rect"&gt;&lt;/div&gt;
    &lt;script&gt;
        setTimeout(() =&gt; {
            document.getElementById("rect").style.transform = "translateY(100px)";
        }, 2000);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p></details></p>

<p><a id="markdown-opacity替换visibility" name="opacity替换visibility"></a></p>

<h3><code>opacity</code>替换<code>visibility</code></h3>

<p><code>opaciy</code>：如果被修改的dom元素自己是一个图层，不触发回流和重绘（试验结果：没有回流，但是有重绘）；否则，触发回流和重绘。
<code>visibility</code>：不触发回流，只触发重绘。</p>

<p><a id="markdown-css的class替代style" name="css的class替代style"></a></p>

<h3>css的class替代style</h3>

<p>多个dom样式通过class一次改动多条style属性，减少回流和重绘的次数</p>

<p><a id="markdown-displaynone" name="displaynone"></a></p>

<h3><code>display:none</code></h3>

<p>先设置<code>display</code>为<code>none</code>，再修改各种属性，再将<code>display</code>设回来。</p>

<p><a id="markdown-慎用clientwidth" name="慎用clientwidth"></a></p>

<h3>慎用<code>clientWidth</code></h3>

<p>不要在循环中获取dom的<code>clientWidth</code>，否则会flash掉浏览器的缓冲区，使浏览器性能下降。</p>

<p>缓冲区是浏览器的优化机制，将多个改动合并成一次改动，以便提高效率。</p>

<p><a id="markdown-少用table布局" name="少用table布局"></a></p>

<h3>少用table布局。</h3>

<p>修改某一<code>td</code>的宽度，会使得所有<code>td</code>进行回流。</p>

<p><a id="markdown-动画的刷新率和页面性能平衡" name="动画的刷新率和页面性能平衡"></a></p>

<h3>动画的刷新率和页面性能平衡</h3>

<p><a id="markdown-将gif图单独成一个图层" name="将gif图单独成一个图层"></a></p>

<h3>将gif图单独成一个图层</h3>

<p>通过设置某些css属性，将某个dom做成一个图层：</p>

<ol>
<li><code>will-change</code></li>
<li><code>transform: translateZ(0)</code></li>
<li><code>translate3d(0,0,0)</code></li>
</ol>


<p><a id="markdown-启用gpu硬件加速" name="启用gpu硬件加速"></a></p>

<h3>启用GPU硬件加速</h3>

<p>启用GPU加速，会减少重绘的时间，但是图层增多，图层合并的时间会增加，这里也有个平衡需要把握。</p>

<p>细节参考<a href="https://lz5z.com/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-CSS3%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/">Web 性能优化-CSS3 硬件加速(GPU 加速)</a></p>

<p><a id="markdown-浏览器存储" name="浏览器存储"></a></p>

<h2>浏览器存储</h2>

<ol>
<li>cdn域名和主站域名区分开，防止获取静态资源携带cookie，浪费带宽。</li>
<li>通过service worker开启另一个线程，和主页通过<code>postMessage</code>互相通信。</li>
<li>通过浏览器performance profile查看性能瓶颈和改进效果。</li>
<li>增加图层是减少的重绘与回流的时间与增加的图层合并时间的增加之间的平衡。比如通过设置translate3d开启GPU加速。</li>
<li>获取offsetHeight为什么会降低效率？使缓冲区域失效，因为要得到一个真实的尺寸。缓冲区域是浏览器的一个优化机制，通过将多次更改dom综合起来一次更新，提高效率。</li>
</ol>


<p><a id="markdown-缓存" name="缓存"></a></p>

<h2>缓存</h2>

<p><strong>强缓存</strong>
如果命中，不需要发请求到服务器。</p>

<ol>
<li>cache-control: max-age, s-max-age</li>
<li>expires:</li>
</ol>


<p><strong>协商缓存（弱缓存）</strong>
需要发请求到服务器询问本地缓存是否可用。如果可用，服务器返回304，不携带具体内容，具体内容从本地缓存中读取。如果不可用，服务器直接返回内容。</p>

<ol>
<li>last-modified:</li>
<li>if-modified-since: 304</li>
<li>e-tag:</li>
<li>if-none-match:</li>
</ol>


<p>浏览器缓存流程如下：</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="浏览器缓存流程图.png" /></p>

<p>关于缓存，下面两篇文章介绍的很清楚：</p>

<ol>
<li><a href="https://www.jiqizhixin.com/articles/2020-07-24-12">Web 缓存介绍</a></li>
<li><a href="https://segmentfault.com/a/1190000010787023">HTTP 缓存之浏览器刷新行为</a>: disable cache setting in the developper tool</li>
</ol>


<p><a id="markdown-服务器端渲染" name="服务器端渲染"></a></p>

<h2>服务器端渲染</h2>

<ol>
<li>vue-ssr (server-side-rendering)</li>
<li>react-ssr</li>
<li>代价：需要一个universal的code base，保证其在服务器端和浏览器端都能运行。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[极客时间-深入浅出云计算]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/12/06/shenru-qianchu-yunjisuan/"/>
    <updated>2021-12-06T10:21:06+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/12/06/shenru-qianchu-yunjisuan</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#01--%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%8F%AF%E7%94%A8%E5%8C%BA%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E4%BA%91%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83">01 | 区域和可用区：欢迎来到云端数据中心</a></li>
<li><a href="#02--%E4%BA%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%80%E4%BA%91%E7%AB%AF%E6%94%92%E6%9C%BA%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%B9%E6%98%93%E5%BF%BD%E8%A7%86%E7%9A%84%E8%A6%81%E7%82%B9">02 | 云虚拟机（一）：云端“攒机”，有哪些容易忽视的要点?</a></li>
<li><a href="#03-%E4%B8%A8%E4%BA%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BA%8C%E7%9C%BC%E8%8A%B1%E7%BC%AD%E4%B9%B1%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9E%8B%E5%8F%B7%E6%88%91%E8%AF%A5%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">03 丨云虚拟机（二）：眼花缭乱的虚拟机型号，我该如何选择？</a></li>
<li><a href="#04-%E4%B8%A8%E4%BA%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%89%E8%80%81%E6%9D%BF%E8%A6%81%E6%B1%82%E7%9C%81%E7%9C%81%E7%9C%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A6%99%E6%8B%9B">04 丨云虚拟机（三）：老板要求省省省，有哪些妙招？</a></li>
<li><a href="#05--%E4%BA%91%E7%A1%AC%E7%9B%98%E4%BA%91%E4%B8%8Aio%E5%88%B0%E5%BA%95%E7%BB%99%E4%B8%8D%E7%BB%99%E5%8A%9B">05 | 云硬盘：云上IO到底给不给力？</a></li>
<li><a href="#06--%E4%BA%91%E4%B8%8A%E8%99%9A%E6%8B%9F%E7%BD%91%E7%BB%9C%E5%BC%80%E5%90%88%E6%9C%89%E5%BA%A6%E7%BC%96%E7%BB%87%E6%97%A0%E5%BD%A2%E4%B9%8B%E7%BD%91">06 | 云上虚拟网络：开合有度，编织无形之网</a>

<ul>
<li><a href="#%E5%BC%B9%E6%80%A7%E7%BD%91%E5%8D%A1">弹性网卡</a></li>
<li><a href="#%E5%85%AC%E7%BD%91ip%E5%92%8C%E5%BC%B9%E6%80%A7ip">公网IP和弹性IP</a></li>
</ul>
</li>
<li><a href="#07--%E4%BA%91%E7%AB%AF%E6%9E%B6%E6%9E%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%95%85%E9%9A%9C%E5%90%8C%E8%88%9E%E4%B8%8E%E4%BC%B8%E7%BC%A9%E5%85%B1%E7%94%9F">07 | 云端架构最佳实践：与故障同舞，与伸缩共生</a></li>
<li><a href="#08-%E4%B8%A8%E4%BA%91%E4%B8%8A%E8%BF%90%E7%BB%B4%E4%BA%91%E7%AB%AF%E7%A9%B6%E7%AB%9F%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81%E8%BF%90%E7%BB%B4%E9%9C%80%E8%A6%81%E6%80%8E%E6%A0%B7%E7%9A%84%E8%BF%90%E7%BB%B4">08 丨云上运维：云端究竟需不需要运维？需要怎样的运维？</a></li>
<li><a href="#09--%E4%BB%80%E4%B9%88%E6%98%AFpaas%E6%80%8E%E6%A0%B7%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%92%8C%E8%AF%84%E4%BC%B0paas">09 | 什么是PaaS？怎样深入理解和评估PaaS？</a></li>
<li><a href="#10--%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9C%8B%E4%BC%BC%E7%AE%80%E5%8D%95%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8E%84%E6%9C%BA">10 | 对象存储：看似简单的存储服务都有哪些玄机？</a>

<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7">对象存储的高级特性</a></li>
</ul>
</li>
<li><a href="#11--%E5%BA%94%E7%94%A8%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1web%E5%BA%94%E7%94%A8%E6%80%8E%E6%A0%B7%E5%9C%A8%E4%BA%91%E4%B8%8A%E5%AE%89%E5%AE%B6">11 | 应用托管服务：Web应用怎样在云上安家？</a></li>
<li><a href="#12--%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E6%AD%8C%E7%8C%9B%E8%BF%9B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B0%E8%B4%B5">12 | 云数据库：高歌猛进的数据库“新贵”</a>

<ul>
<li><a href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E5%BA%93">云原生数据库</a></li>
</ul>
</li>
<li><a href="#13--%E4%BA%91%E4%B8%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BA%91%E8%AE%A1%E7%AE%97%E9%81%87%E4%B8%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A0%AA%E7%A7%B0%E5%A4%A9%E4%BD%9C%E4%B9%8B%E5%90%88">13 | 云上大数据：云计算遇上大数据，为什么堪称天作之合？</a></li>
<li><a href="#14--%E4%BA%91%E4%B8%8A%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%E4%BB%8Edocker%E5%88%B0kubernetes%E8%BF%8E%E6%8E%A5%E4%BA%91%E5%8E%9F%E7%94%9F%E6%B5%AA%E6%BD%AE">14 | 云上容器服务：从Docker到Kubernetes，迎接云原生浪潮</a></li>
<li><a href="#15--%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%A1%E7%AE%97%E8%BF%BD%E6%B1%82%E6%9E%81%E8%87%B4%E6%95%88%E7%8E%87%E7%9A%84%E5%A4%9A%E9%9D%A2%E6%89%8B">15 | 无服务器计算：追求极致效率的多面手</a></li>
<li><a href="#16--%E4%BA%91%E4%B8%8Aai%E6%9C%8D%E5%8A%A1%E4%BA%91ai%E8%83%BD%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E5%B8%AE%E5%8A%A9%E6%9E%84%E5%BB%BA%E6%99%BA%E8%83%BD%E5%BA%94%E7%94%A8">16 | 云上AI服务：云AI能从哪些方面帮助构建智能应用？</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-01--区域和可用区欢迎来到云端数据中心" name="01--区域和可用区欢迎来到云端数据中心"></a></p>

<h2>01 | 区域和可用区：欢迎来到云端数据中心</h2>

<p><a id="markdown-02--云虚拟机一云端攒机有哪些容易忽视的要点" name="02--云虚拟机一云端攒机有哪些容易忽视的要点"></a></p>

<h2>02 | 云虚拟机（一）：云端“攒机”，有哪些容易忽视的要点?</h2>

<p>传统的虚拟化（虚拟机），往往是对单一物理机器资源的纵向切割，计算、存储、网络等各方面的能力都是一台物理机的子集。因此，从可伸缩性的角度来说，传统虚拟机存在较大的局限，当物理机的局部出现故障时，也很容易影响到里面的虚拟机。</p>

<p>得益于云端大规模的专属硬件以及高速的内部网络，云虚拟机的组成则有所不同。除了核心的 CPU 与内存部分仍属于一台宿主机外，它的网络、硬盘等其他部分，则可以超脱于宿主机之外，享受云端其他基础设施的能力。大致架构如下图所示：</p>

<p><img src="http://hongchaozhang.github.io/images/%E4%BA%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B5%84%E6%BA%90%E6%9E%84%E6%88%90.jpeg" alt="云虚拟机资源构成" /></p>

<p>所以，云虚拟机，与其说是由一台宿主机虚拟而成的，不如说是云数据中心中的不同部分一起协作，“拼凑”而成的一台机器。这样虚拟出来的机器，我们在使用感受上其实与传统服务器并无不同，但在可扩展性和故障隔离方面，它就具有很大的优势了。</p>

<p><a id="markdown-03-丨云虚拟机二眼花缭乱的虚拟机型号我该如何选择" name="03-丨云虚拟机二眼花缭乱的虚拟机型号我该如何选择"></a></p>

<h2>03丨云虚拟机（二）：眼花缭乱的虚拟机型号，我该如何选择？</h2>

<p><a id="markdown-04-丨云虚拟机三老板要求省省省有哪些妙招" name="04-丨云虚拟机三老板要求省省省有哪些妙招"></a></p>

<h2>04丨云虚拟机（三）：老板要求省省省，有哪些妙招？</h2>

<p><a id="markdown-05--云硬盘云上io到底给不给力" name="05--云硬盘云上io到底给不给力"></a></p>

<h2>05 | 云硬盘：云上IO到底给不给力？</h2>

<p>云厂商对于云盘，一般会帮你在存储端同步和保留至少三份副本的数据。所以说，云硬盘的冗余度和可用性是非常之高的，一般极少发生云硬盘数据丢失的情况，你大可放心地使用。</p>

<p>云盘性能指标：</p>

<ul>
<li>IOPS</li>
<li>吞吐量</li>
<li>访问延时</li>
</ul>


<p>云硬盘与传统磁盘的真正差异在于，绝大多数的云硬盘都是<strong>远程</strong>的。</p>

<p>我们都知道，在经典计算机的体系结构中，硬盘是通过本地机器内部主板的高速总线，与 CPU、内存等部件相连接；而在云端，你的硬盘则很可能并不在宿主机上，而是在专用的磁盘服务器阵列中，两者是通过数据中心内部的特有IO线路进行连接的。</p>

<p>理解了这样的一个结构，你就能明白，有些云上的“IO优化实例”（AWS 上称为 EBS-Optimized）是指什么了。它就是指云虚拟机与云硬盘之间的网络传输，进行了软硬件层面的优化，这样可以充分地发挥所挂载磁盘的性能。现在较新型号、较强性能的云虚拟机，一般都自动启用了这个优化。</p>

<p>云存储的性能级别：</p>

<p><img src="http://hongchaozhang.github.io/images/%E4%BA%91%E5%AD%98%E5%82%A8%E7%9A%84%E7%BA%A7%E5%88%AB.jpeg" alt="云存储的级别" /></p>

<p>除了云盘性能等级，还有一个指标也是影响云盘性能的重要指标：云盘容量。不论是哪种磁盘类型，它的容量大小几乎都与性能正向相关。同等的性能等级下，云硬盘的容量越大，一般来说它的性能就越高，直到达到这个等级的上限。这是由云上磁盘能力共享的底层设计所决定的。</p>

<p>所以在某些时候，你可能需要刻意地增大所申请的云硬盘的容量，以获取更高的性能，即便这些额外的空间不一定能被用上。</p>

<p><a id="markdown-06--云上虚拟网络开合有度编织无形之网" name="06--云上虚拟网络开合有度编织无形之网"></a></p>

<h2>06 | 云上虚拟网络：开合有度，编织无形之网</h2>

<p>虚拟私有网络（Virtual Private Cloud，简称 VPC），是云计算网络端最重要的概念之一，它是指构建在云上的、相互隔离的、用户可以自主控制的私有网络环境。虚拟私有网络有时也称为专有网络（阿里云）或虚拟网络（Virtual Network 或 VNet，Azure 的叫法）。</p>

<p>上面的概念解释也许不太好理解，其实用通俗的话来讲，私有网络就是一张属于你自己的内网。内网之内的服务器和设备，可以比较自由地互相通信，与外界默认是隔离的。如果外部互联网，或者其他虚拟网络需要连接，则需要额外的配置。</p>

<p>所以说，虚拟私有网络，就是你在云上的保护网，能够有效地保护网内的各种设施。有的时候，你可能还要同时创建多个虚拟网络，让它们各司其职，实现更精细的隔离。</p>

<p><a id="markdown-弹性网卡" name="弹性网卡"></a></p>

<h3>弹性网卡</h3>

<p>云上的网卡，之所以被称为“弹性”网卡，是因为它具备以下特征：</p>

<ol>
<li>一个虚拟机可以绑定多块网卡，有主网卡和辅助网卡之分；</li>
<li>一块网卡隶属于一个子网，可以配置同一子网内的多个私有 IP；</li>
<li>辅助网卡可以动态解绑，还能够绑定到另一台虚拟机上。</li>
</ol>


<p><a id="markdown-公网ip和弹性ip" name="公网ip和弹性ip"></a></p>

<h3>公网IP和弹性IP</h3>

<p>在绝大多数的云上，创建虚拟机时都会有一个选项，问你“是否同时为虚拟机分配一个公网 IP 地址”。如果你选择“是”，这样机器启动后，就会拥有一个自动分配的公网地址，便于你从自己的电脑连接到这个实例。这在很多时候都是最方便的选择。</p>

<p>但对于生产环境，我的推荐是，尽量不要使用和依赖这个自动生成的公有 IP。因为它本质上是一个从公有云的 IP 池中临时租用给你的 IP。如果你的机器关闭或重启，下次获得的 IP 可能就完全不同了。</p>

<p>这时，我们真正应该用到的是弹性 IP（Elastic IP），有些云称为 eIP。弹性 IP 一旦生成，它所对应的 IP 是固定、不会变化的，而且完全属于你所有。这非常适合需要稳定 IP 的生产环境。</p>

<p>请不要被它的名字迷惑，它所谓的弹性，其实是指可以非常自由地解绑和再次绑定到任意目标。你本质上是买下了这个 IP 的所有权，将这个 IP 赋予谁，是你的权利，而且你还可以动态按需切换。</p>

<p><a id="markdown-07--云端架构最佳实践与故障同舞与伸缩共生" name="07--云端架构最佳实践与故障同舞与伸缩共生"></a></p>

<h2>07 | 云端架构最佳实践：与故障同舞，与伸缩共生</h2>

<p>云上架构最需要注意什么呢？就像我在标题所描述的那样，云端架构一方面需要处理和应对可能出现的<strong>故障</strong>，保证架构和服务的可用性；另一方面则是需要充分利用好云端的<strong>弹性</strong>，要能够根据负载进行灵活的伸缩。</p>

<p>那么，云上可能出现哪些不同层面的故障？相应的故障范围和应对措施又会是怎样的呢？</p>

<p><strong>第一种故障是在宿主机的级别，这也是从概率上来说最常见的一种故障。</strong>当宿主机出现硬件故障等问题后，毫无疑问将影响位于同一宿主机上的多个虚拟机。为了避免产生这样的影响，当我们承载重要业务时，就需要创建多台虚拟机组成的集群，共同来进行支撑。这样，当一台虚拟机出现故障时，还有其他几台机器能够保证在线。</p>

<p>这里需要注意的是，<strong>我们需要保证多个虚拟机不在同一台宿主机上，甚至不处于同一个机架上，以免这些虚拟机一起受到局部事故的影响。</strong></p>

<p><strong>第二种规模更大的故障，是在数据中心，也就是可用区的层面。</strong>要应对这类故障，我们就需要<strong>多可用区的实例部署</strong>。</p>

<p><strong>第三种更严重的故障，就是整个区域级别的事故了。</strong>当然这种一般非常少见，只有地震等不可抗力因素，或者人为过失引发出的一系列连锁反应，才有可能造成这么大的影响。区域级别的事故一般都难免会对业务造成影响了。这时能够进行补救的，主要看<strong>多区域架构层面是否有相关的预案</strong>。</p>

<p>再更进一步的万全之策，就需要考虑<strong>多云</strong>了。也就是同时选用多家云厂商的公有云，一起来服务业务。虽然集成多个异构的云会带来额外的成本，但这能够最大限度地降低服务风险，因为两家云厂商同时出问题的概率实在是太低了。更何况，多云还能带来避免厂商锁定的好处，现在其实也越来越多见了。</p>

<p>当然，盲目地追求可用性也不可取。<strong>根据业务需求，在成本投入与可用性之间获得一个最佳的平衡，才是你应该追求的目标。</strong></p>

<p><a id="markdown-08-丨云上运维云端究竟需不需要运维需要怎样的运维" name="08-丨云上运维云端究竟需不需要运维需要怎样的运维"></a></p>

<h2>08丨云上运维：云端究竟需不需要运维？需要怎样的运维？</h2>

<p><a id="markdown-09--什么是paas怎样深入理解和评估paas" name="09--什么是paas怎样深入理解和评估paas"></a></p>

<h2>09 | 什么是PaaS？怎样深入理解和评估PaaS？</h2>

<p>PaaS 是在 IaaS 的基础上又做了许多工作，构建了很多关键抽象和可复用的单元，让我们用户能够在更上层进行应用的构建，把更多精力放在业务逻辑上。</p>

<p>所以 PaaS 服务的优势，就在于生产力，在于效率，尤其是在搭建和运维层面。</p>

<p><a id="markdown-10--对象存储看似简单的存储服务都有哪些玄机" name="10--对象存储看似简单的存储服务都有哪些玄机"></a></p>

<h2>10 | 对象存储：看似简单的存储服务都有哪些玄机？</h2>

<p>同样是存储服务，对象存储和前面我们 IaaS 部分讲过的云硬盘存储有什么区别呢？</p>

<p>第一个主要区别，在于<strong>访问的接口与形式</strong>。</p>

<p>云硬盘其实是挂载到虚拟机的虚拟硬盘，它是通过实现操作系统级别的底层接口，作为虚拟机的块存储设备而存在。我们也必须连接到相关的虚拟机，才能访问它里面的数据。</p>

<p>而对象存储，本质是一个网络化的服务，调用方主要通过高层的 API 和 SDK 来和它进行交互。不管是面向外部公开互联网服务，还是和内部应用程序对接，对象存储都是通过提供像 HTTP 这样的网络接口来实现的。所以它的独立性很强，不需要依赖其他组件就可以运作。</p>

<p>第二个主要区别，也是对象存储的一大特征，就是对象存储内本身不存在一个真正的文件系统，而是更接近一个<strong>键值</strong>（Key-Value）形式的存储服务。</p>

<p>键值系统和云硬盘上经典文件系统的<strong>核心差异</strong>，就在于文件系统保存了更多的元数据，尤其是实现了目录结构和目录操作。而键值系统中，所谓的目录其实是多个对象共享的路径前缀，可以说是用前缀模拟出了目录。</p>

<p>第三个主要区别，在于对象存储的<strong>据大容量</strong>。</p>

<p><a id="markdown-对象存储的高级特性" name="对象存储的高级特性"></a></p>

<h3>对象存储的高级特性</h3>

<p>第一个重要特性，是<strong>存储分层</strong>。</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E5%88%86%E5%B1%82.jpeg" alt="对象存储分层" /></p>

<p>存储分层的存在，让原本价格低廉的云上存储更加具有成本竞争力。给你举个例子，现在归档层的存储费用，在典型情况下大约是每 GB 每月 1 分钱左右，是不是低得惊人？所以，很多用户上云的一个应用场景就是，把原本占用大量传统磁盘的备份文件，利用对象存储的归档能力长期保存。</p>

<p>第二个值得称道的特性，是<strong>生命周期管理</strong>。可以对存储对象设置过期规则。</p>

<p>第三个特性，则是对象的<strong>版本管理</strong>。</p>

<p><a id="markdown-11--应用托管服务web应用怎样在云上安家" name="11--应用托管服务web应用怎样在云上安家"></a></p>

<h2>11 | 应用托管服务：Web应用怎样在云上安家？</h2>

<p>你可以使用虚拟机和其他 IaaS 组件来搭建你的网站。但用 IaaS，你需要操心的事情比较多，包括虚拟机的创建、运行环境的搭建和依赖安装、高可用性和水平扩展的架构等等。而且一旦应用的规模大了，每次应用的更新升级也会是件麻烦事，另外你还要操心 Web 漏洞的弥补修复。</p>

<p>那么，能不能有一个平台服务，来帮助我们解决所有这些基础架构问题，让我们只需要专注于应用构建本身就好了呢？当然是有的，这就是云上应用托管 PaaS 服务的由来。</p>

<p><a id="markdown-12--云数据库高歌猛进的数据库新贵" name="12--云数据库高歌猛进的数据库新贵"></a></p>

<h2>12 | 云数据库：高歌猛进的数据库“新贵”</h2>

<p>而近年来随着云计算的兴起，云数据库作为一支新生力量，一路高歌猛进，打破了数据库市场的原有格局，也进入了越来越多开发者的视野当中。这类 PaaS 服务的朴素思想就是，将数据库服务搬到云上，让用户更方便轻松地使用、管理和维护数据库。</p>

<p><a id="markdown-云原生数据库" name="云原生数据库"></a></p>

<h3>云原生数据库</h3>

<p>云原生数据库：完全为云设计、能够充分发挥云的特点和优势的数据库。</p>

<p>出于生态发展和降低学习难度的需要，绝大多数的云原生数据库仍然保留了 SQL 等常见接口（有的还支持不同 SQL 方言的选择），但除此以外，云原生数据库大都进行了全面革新和重新设计，有的云会大刀阔斧地改造开源代码，有的甚至脱离了现有包袱，完全重新构建。</p>

<p>这样的尝试取得了巨大的成功，业界也逐渐形成了一系列不同领域的云原生数据库矩阵，大大拓展了云上数据库的范畴和影响力。</p>

<p>我这里也为你整理了一张表格，按照厂商和云数据库的类型进行了梳理和比较。其中，标红的部分是相当值得你关注的自研云原生数据库。</p>

<p><img src="http://hongchaozhang.github.io/images/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E5%BA%93.jpeg" alt="云原生数据库" /></p>

<p><a id="markdown-13--云上大数据云计算遇上大数据为什么堪称天作之合" name="13--云上大数据云计算遇上大数据为什么堪称天作之合"></a></p>

<h2>13 | 云上大数据：云计算遇上大数据，为什么堪称天作之合？</h2>

<p><a id="markdown-14--云上容器服务从docker到kubernetes迎接云原生浪潮" name="14--云上容器服务从docker到kubernetes迎接云原生浪潮"></a></p>

<h2>14 | 云上容器服务：从Docker到Kubernetes，迎接云原生浪潮</h2>

<p><a id="markdown-15--无服务器计算追求极致效率的多面手" name="15--无服务器计算追求极致效率的多面手"></a></p>

<h2>15 | 无服务器计算：追求极致效率的多面手</h2>

<p>无服务器（Serverless）完全屏蔽了计算资源，它是在真正地引导你不再去关心底层环境，你只要遵循标准方式来直接编写业务代码就可以了。其中一个具体应用就是函数即服务（FaaS，Function as a service)。</p>

<p>各大云厂商现在都已经推出了各自的无服务器计算服务，比如 AWS 的 <strong>Lambda</strong>，阿里云的<strong>函数计算</strong>，微软Azure的<strong>Azure Function</strong>，微信的<strong>云函数</strong>。</p>

<p>为了让这个云函数能够对外服务，我们接下来就需要为它添加一个 <strong>API网关触发器</strong>，这样当 API 被外界访问时，这个云函数就会被触发执行并返回结果给网关。</p>

<p>API 网关是一个独立的 PaaS 服务，它可以和云函数联动使用。它的作用是为外界访问提供一个端点，并引流到我们的后台计算服务。</p>

<p>无服务器计算灵活轻量，便于迭代。但是，我们还是要记得恪守冷静客观的原则。一定不要忽略了 Serverless 服务的限制，毕竟它的本质是受限的环境。<strong>冷启动的延时、内存的限制、云函数的运行时长、并发数上限</strong>等等，这些都是你大规模深入应用之前需要评估考虑的问题。虽然云厂商一直在改进，这些客观限制在当下对于你的场景是否造成了实质性障碍，也是你目前是否选择 Serverless 计算的一个重要依据。</p>

<p><a id="markdown-16--云上ai服务云ai能从哪些方面帮助构建智能应用" name="16--云上ai服务云ai能从哪些方面帮助构建智能应用"></a></p>

<h2>16 | 云上AI服务：云AI能从哪些方面帮助构建智能应用？</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[极客时间-徐文浩-《深入浅出计算机组成原理》]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/11/11/jisuanji-zucheng-yuanli/"/>
    <updated>2021-11-11T12:43:31+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/11/11/jisuanji-zucheng-yuanli</id>
    <content type="html"><![CDATA[<!-- more -->


<p><a href="https://time.geekbang.org/column/intro/100026001">深入浅出计算机组成原理》</a></p>

<p>零散笔记，不成体系。</p>

<h2>浮点数和定点数</h2>

<h2>GPU/TPU/FPGA</h2>

<h2>CPU</h2>

<p>CPU、缓存和内存的关系：
<img src="http://hongchaozhang.github.io/images/cpu%E5%92%8C%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB%E7%B1%BB%E6%AF%94.png" alt="cpu和内存的关系类比.png" /></p>

<ul>
<li>cache line （64KB）</li>
<li>cache和内存地址映射</li>
<li>缓存读取</li>
<li>缓存写入</li>
<li>缓存一致性：比分布式系统的数据一致性简单，因为不用考虑网络传输延迟和异常。

<ul>
<li>写传播</li>
<li>事务串行化

<ul>
<li>总线嗅探</li>
<li>MESI协议</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>参考
* <a href="https://coolshell.cn/articles/20793.html">与程序员相关的CPU缓存知识</a>。
* Github上的一个代码库 <a href="https://github.com/Kobzol/hardware-effects">hardware-effects</a> 里面有受CPU影响的程序的演示。
    > This repository demonstrates various hardware effects that can degrade application performance in surprising ways and that may be very hard to explain without knowledge of the low-level CPU and OS architecture.</p>

<h2>内存</h2>

<ul>
<li>虚拟内存地址</li>
<li>物理内存地址</li>
<li>页表

<ul>
<li>简单页表</li>
<li>多级页表：时间换空间，树形结构</li>
</ul>
</li>
<li>加速地址转换（TLB）：通过在CPU中放置cache可以快速进行虚拟内存地址到物理内存地址的转换。</li>
<li>内存保护

<ul>
<li>可执行空间保护</li>
<li>地址空间布局随机化

<h2>CPU架构</h2>

<h3>CISC和RISC</h3></li>
</ul>
</li>
<li>复杂指令集（Complex Instruction Set Computing，简称 CISC）</li>
<li>精简指令集（Reduced Instruction Set Computing，简称 RISC）</li>
</ul>


<p>当时，UC Berkeley的大卫·帕特森（David Patterson）教授发现，实际在CPU运行的程序里，80%的时间都是在使用20%的简单指令。于是，他就提出了RISC的理念。自此之后，RISC类型的CPU开始快速蓬勃发展。</p>

<p>在RISC架构里面，CPU选择把指令“精简”到20%的简单指令。而原先的复杂指令，则通过用简单指令组合起来来实现，让软件来实现硬件的功能。这样，CPU的整个硬件设计就会变得更简单了，在硬件层面提升性能也会变得更容易了。</p>

<p>RISC的CPU里完成指令的电路变得简单了，于是也就腾出了更多的空间。这个空间，常常被拿来放通用寄存器。因为RISC完成同样的功能，执行的指令数量要比CISC多，所以，如果需要反复从内存里面读取指令或者数据到寄存器里来，那么很多时间就会花在访问内存上。于是，RISC架构的CPU往往就有更多的通用寄存器。</p>

<h3>ARM和RISC-V：CPU的现在与未来</h3>

<p>2017年，ARM公司的CEO Simon Segards宣布，ARM累积销售的芯片数量超过了1000亿。作为一个从12个人起步，在80年代想要获取Intel的80286架构授权来制造CPU的公司，ARM是如何在移动端把自己的芯片塑造成了最终的霸主呢？</p>

<p>ARM这个名字现在的含义，是“Advanced RISC Machines”。你从名字就能够看出来，ARM的芯片是基于RISC架构的。不过，ARM能够在移动端战胜Intel，并不是因为RISC架构。</p>

<p>到了21世纪的今天，CISC和RISC架构的分界已经没有那么明显了。Intel和AMD的CPU也都是采用译码成RISC风格的微指令来运行。而ARM的芯片，一条指令同样需要多个时钟周期，有乱序执行和多发射。我甚至看到过这样的评价，“ARM和RISC的关系，只有在名字上”。</p>

<p>ARM真正能够战胜Intel，我觉得主要是因为下面这两点原因。</p>

<ul>
<li><p>第一点是功耗优先的设计。一个4核的Intel i7的CPU，设计的时候功率就是130W。而一块ARM A8的单个核心的CPU，设计功率只有2W。两者之间差出了100倍。在移动设备上，功耗是一个远比性能更重要的指标，毕竟我们不能随时在身上带个发电机。ARM的CPU，主频更低，晶体管更少，高速缓存更小，乱序执行的能力更弱。所有这些，都是为了功耗所做的妥协。</p></li>
<li><p>第二点则是低价。ARM并没有自己垄断CPU的生产和制造，只是进行CPU设计，然后把对应的知识产权授权出去，让其他的厂商来生产ARM架构的CPU。它甚至还允许这些厂商可以基于ARM的架构和指令集，设计属于自己的CPU。像苹果、三星、华为，它们都是拿到了基于ARM体系架构设计和制造CPU的授权。ARM自己只是收取对应的专利授权费用。多个厂商之间的竞争，使得ARM的芯片在市场上价格很便宜。所以，尽管ARM的芯片的出货量远大于Intel，但是收入和利润却比不上Intel。</p></li>
</ul>


<p>不过，ARM并不是开源的。所以，在ARM架构逐渐垄断移动端芯片市场的时候，“开源硬件”也慢慢发展起来了。一方面，MIPS在2019年宣布开源；另一方面，从UC Berkeley发起的RISC-V项目也越来越受到大家的关注。而RISC概念的发明人，图灵奖的得主大卫·帕特森教授从伯克利退休之后，成了RISC-V国际开源实验室的负责人，开始推动RISC-V这个“CPU届的Linux”的开发。可以想见，未来的开源CPU，也多半会像Linux一样，逐渐成为一个业界的主流选择。如果想要“打造一个属于自己CPU”，不可不关注这个项目。</p>

<h2>FPGA和ASIC</h2>

<p>FPGA，也就是现场可编程门阵列（Field-Programmable Gate Array）。看到这个名字，你可能要说了，这里面每个单词单独我都认识，放到一起就不知道是什么意思了。</p>

<p>没关系，我们就从FPGA里面的每一个字符，一个一个来看看它到底是什么意思。</p>

<ul>
<li>P代表Programmable，这个很容易理解。也就是说这是一个可以通过编程来控制的硬件。</li>
<li>G代表Gate也很容易理解，它就代表芯片里面的门电路。我们能够去进行编程组合的就是这样一个一个门电路。</li>
<li>A代表的Array，叫作阵列，说的是在一块FPGA上，密密麻麻列了大量Gate这样的门电路。</li>
<li>最后一个F，不太容易理解。它其实是说，一块FPGA这样的板子，可以进行在“现场”多次地进行编程。它不像PAL（Programmable Array Logic，可编程阵列逻辑）这样更古老的硬件设备，只能“编程”一次，把预先写好的程序一次性烧录到硬件里面，之后就不能再修改了。</li>
</ul>


<p>ASIC（Application-Specific Integrated Circuit），也就是专用集成电路。比如，现在手机里就有专门用在摄像头里的芯片；录音笔里会有专门处理音频的芯片，都是ASIC。</p>

<p>那么，我们能不能用刚才说的FPGA来做ASIC的事情呢？当然是可以的。我们对FPGA进行“编程”，其实就是把FPGA的电路变成了一个ASIC。这样的芯片，往往在成本和功耗上优于需要做通用计算的CPU和GPU。但是，FPGA一样有缺点，那就是它的硬件上有点儿“浪费”。为了实现通用性，FPGA有很多荣誉的硬件。</p>

<h2>HDD和SSD</h2>

<p>硬盘接口：</p>

<ul>
<li>SATA3.0：带宽6Gb/s，理论传输上线768MB/s。</li>
<li>PCI Express接口</li>
</ul>


<p>PCI Express接口上的SSD硬盘性能测试：</p>

<p><img src="http://hongchaozhang.github.io/images/SSD%E6%80%A7%E8%83%BD.png" alt="SSD性能.png" /></p>

<ul>
<li>Seq：顺序读写数据可以达到1GB-2GB/s。</li>
<li>4K：4K大小的随机读写速度只有每秒几十MB，可以算出该硬盘每秒随机读取次数可以达到1万次左右（40M/4K），随机写入可以达到每秒2万次左右。这个每秒读写的次数，我们称之为IOPS。相比较而言，HDD硬盘的IOPS通常也就在100左右（可以通过机械硬盘的转速计算出来。）。</li>
<li>Acc.time</li>
</ul>


<p>无论是顺序读写还是随机读写，SSD都远胜于HDD。但是在使用寿命上，SSD却非常差，这是受它的擦除次数限制。</p>

<p>对于SSD硬盘来说，数据的写入叫作Program。写入不能像机械硬盘一样，通过覆写（Overwrite）来进行的，而是要先去擦除（Erase），然后再写入。</p>

<p>SSD的读取和写入的基本单位，不是一个比特（bit）或者一个字节（byte），而是一个页（Page）。SSD 的擦除单位就更夸张了，我们不仅不能按照比特或者字节来擦除，连按照页来擦除都不行，我们必须按照块来擦除。对SSD来说，最好的存储介质也只有十万次的擦出次数，差一些的只有几千次。</p>

<h3>FTL闪存转换层</h3>

<p>为了提高SSD的使用寿命，我们要的就是想一个办法，让SSD硬盘各个块的擦除次数，均匀分摊到各个块上。这个策略呢，就叫作<strong>磨损均衡</strong>（Wear-Leveling）。实现这个技术的核心办法，和我们前面讲过的虚拟内存一样，就是添加一个间接层，就是FTL这个<strong>闪存转换层</strong>。</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%97%AA%E5%AD%98%E8%BD%AC%E6%8D%A2%E5%B1%82.jpeg" alt="闪存转换层.jpeg" /></p>

<p>当SSD硬盘的存储空间被占用得越来越多，每一次写入新数据，我们都可能没有足够的空白。我们可能不得不去进行垃圾回收，合并一些块里面的页，然后再擦除掉一些页，才能匀出一些空间来。</p>

<p>这个时候，从应用层或者操作系统层面来看，我们可能只是写入了一个4KB或者4MB的数据。但是，实际通过FTL之后，我们可能要去搬运8MB、16MB甚至更多的数据。</p>

<p>我们通过“实际的闪存写入的数据量/系统通过FTL写入的数据量”定义写入放大。可以得到，写入放大的倍数越多，意味着实际的SSD性能也就越差，会远远比不上实际SSD硬盘标称的指标。而解决写入放大的方法：</p>

<ul>
<li>需要我们在后台定时进行垃圾回收，在硬盘比较空闲的时候，就把搬运数据、擦除数据、留出空白的块的工作做完，而不是等实际数据写入的时候，再进行这样的操作。AeroSpike在某个“块”有超过50%的数据碎片时就进行垃圾回收。</li>
<li>不要存储的太满。AeroSpike数据库建议预留50%的空间。</li>
</ul>


<h2>直接内存访问（DMA）</h2>

<p>无论I/O速度如何提升，比起CPU，总还是太慢。SSD硬盘的IOPS可以到2万、4万，但是我们CPU的主频有2GHz以上，也就意味着每秒会有20亿次的操作。</p>

<p>如果我们对于I/O的操作，都是由CPU发出对应的指令，然后等待I/O设备完成操作之后返回，那CPU有大量的时间其实都是在等待I/O设备完成操作。</p>

<p>因此，计算机工程师们，就发明了DMA技术，也就是直接内存访问（Direct Memory Access）技术，来减少CPU等待的时间。</p>

<p>本质上，DMA技术就是我们在主板上放一块独立的芯片。在进行内存和I/O设备的数据传输的时候，我们不再通过CPU来控制数据传输，而直接通过DMA控制器（DMA Controller，简称DMAC）。这块芯片，我们可以认为它其实就是一个协处理器（Co-Processor）。</p>

<p>比如说，我们用千兆网卡或者硬盘传输大量数据的时候，如果都用CPU来搬运的话，肯定忙不过来，所以可以选择DMAC。而当数据传输很慢的时候，DMAC可以等数据到齐了，再发送信号，给到CPU去处理，而不是让CPU在那里忙等待。</p>

<p>今天，各种I/O设备越来越多，数据传输的需求越来越复杂，使用的场景各不相同。加之显示器、网卡、硬盘对于数据传输的需求都不一样，所以各个设备里面都有自己的DMAC芯片了。</p>

<h3>为什么那么快？一起来看Kafka的实现原理</h3>

<p>Kafka是一个用来处理实时数据的管道，我们常常用它来做一个消息队列，或者用来收集和落地海量的日志。作为一个处理实时数据和日志的管道，瓶颈自然也在I/O层面。</p>

<p>Kafka里面会有两种常见的海量数据传输的情况。一种是从网络中接收上游的数据，然后需要落地到本地的磁盘上，确保数据不丢失。另一种情况呢，则是从本地磁盘上读取出来，通过网络发送出去。</p>

<p>Kafka做的事情就是，把这个数据搬运的次数，从上面的四次，变成了两次，并且只有DMA来进行数据搬运，而不需要CPU。</p>

<h2>校验</h2>

<ul>
<li>奇偶校验和校验位</li>
<li>纠错码</li>
<li>纠删码</li>
</ul>


<p>7-4海明码是海明吗的一种：这里的“7”指的是实际有效的数据，一共是7位（Bit）。而这里的“4”，指的是我们额外存储了4位数据，用来纠错。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Nodejs-Express-MongoDB搭建服务器]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/10/27/mean-with-nodejs-express-mongodb/"/>
    <updated>2021-10-27T15:47:25+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/10/27/mean-with-nodejs-express-mongodb</id>
    <content type="html"><![CDATA[<!-- more -->


<p>Demo source code on the github: <a href="https://github.com/hongchaozhang/nodejs-express-mongodb">Github demo source code</a>.</p>

<h2>Steps to start the server:</h2>

<ol>
<li>Clone the <a href="https://github.com/hongchaozhang/nodejs-express-mongodb">Github demo source code</a>.</li>
<li>install MongoDB with the steps from <a href="https://cloud.tencent.com/developer/article/1770288">Mac OSX 平台 MongoDB 的安装及管理</a>.</li>
<li>Config MongoDB and start it with <code>mongod --dbpath /usr/local/var/mongodb --logpath /usr/local/var/log/mongodb/mongo.log --fork</code>.</li>
<li>Start the server by running <code>node server.js</code>.</li>
<li>Test the APIs by curl or Postman (recommended).</li>
</ol>


<h3>Note</h3>

<h4>nodejs version</h4>

<p>If you meet the following error while running <code>node server.js</code>, check your nodejs version to make sure you are using 12 and above. <code>14.17.6</code> is tested. The error is:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/Users/hozhang/Develop/PracticeProjects/nodejs-express-mongodb/node_modules/whatwg-url/lib/encoding.js:2
</span><span class='line'>const utf8Encoder = new TextEncoder();
</span><span class='line'>ReferenceError: TextEncoder is not defined</span></code></pre></td></tr></table></div></figure>


<h4>How to start/shutdown MongoDB</h4>

<ol>
<li>After correctly configuring your MongoDB, use the following command to start it:
 <code>mongod --dbpath /usr/local/var/mongodb --logpath /usr/local/var/log/mongodb/mongo.log --fork</code></li>
<li>After enter the mongo environment by running <code>mongo</code>, use the following command to shutdown the MongoDB:
 ```

<blockquote><p>use admin;
db.shutdownServer();
 ```</p></blockquote></li>
</ol>


<h4>MongoDB Compass</h4>

<p>Use the official UI tool to manage your MongoDB data: MongoDB Compass.</p>

<h4>Postman</h4>

<p>Use the Postman to act as a client. It is convenient to config/manage the request.</p>

<h2>code explanation</h2>

<p>Refer to <a href="https://www.bezkoder.com/node-express-mongodb-crud-rest-api/">Node.js, Express &amp; MongoDb: Build a CRUD Rest Api example</a> for detailed code explanation.</p>

<h2>References</h2>

<ul>
<li><a href="https://cloud.tencent.com/developer/article/1770288">Mac OSX 平台 MongoDB 的安装及管理</a></li>
<li><a href="https://www.bezkoder.com/node-express-mongodb-crud-rest-api/">Node.js, Express &amp; MongoDb: Build a CRUD Rest Api example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[刘慈欣《三体》总结]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/10/07/summarise-of-santi/"/>
    <updated>2021-10-07T22:34:15+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/10/07/summarise-of-santi</id>
    <content type="html"><![CDATA[<!-- more -->


<p>一些散点，不成体系。</p>

<h2>雪地工程</h2>

<p>原来是为了检测水滴，用来逃亡。之所以不马上逃亡，是因为现在逃亡时机还不成熟，舆论不允许，到时候大家都绝望了，也许可以被允许逃亡以便保留人类文明。氢弹安装了推进器，可以自主移动，说是为了攻击飞船后来被罗辑用来发射咒语。</p>

<h2>浪漫</h2>

<ul>
<li>能感受大自然美的人都是善良的。</li>
<li>朝霞晚霞：朝霞过后是无情的现实，和工作，晚霞过后是星空是月亮，是无尽的想象。</li>
<li>别说现在在哪？知道在哪就不好玩啦。</li>
<li>喜欢春天还是秋天？</li>
<li>对爱情的理解，每个人爱的都是心中自己想象出来的对象，现实中的她只是一个模具，如果能适应这种差异，就能继续走下去。</li>
<li>壁炉火旁边的她</li>
</ul>


<h2>三体文明</h2>

<h3>思想交流，不会撒谎</h3>

<h3>不能有七情六欲</h3>

<p>理智和冷静才能生存。追求艺术感情和美的三体人生存时间都比较短。</p>

<h3>三体在进军地球之前的计划</h3>

<ul>
<li>染色计划，科学副作用导致环境污染，使人反感科学</li>
<li>神迹计划，通过神迹形成宗教信仰，缺点是技术输出，有玩火自焚的风险</li>
<li>智子计划，封锁基础物理，进而封锁整个科学发展。</li>
</ul>


<h3>智子</h3>

<p>智子，质子，十一维结构二维展开。
智子和智子之间，量子效应，可以跨星系无延迟通讯。
智子能光速移动，所以能够监听监视地球上任何一个角落发生的事情和谈话。
智子能光速移动，所以可以干扰、改变人类粒子加速器的试验结果，从而锁定人类科技，让人类的基础物理无法突破。</p>

<h2>人类的计划和行动</h2>

<h3>思想钢印</h3>

<ul>
<li>可以用于宗教信仰。</li>
<li>思想钢印与思想控制是五十步笑百步吗？各种政治教育何尝不是呢？</li>
</ul>


<h3>古筝行动</h3>

<p>用纳米材料做成的细丝切割船。</p>

<h3>摇篮计划</h3>

<p>摇篮计划，很形象，摇篮一停，婴儿就醒。其实是个反触发系统。</p>

<h3>引力波发射器</h3>

<h3>面壁计划</h3>

<ul>
<li>泰勒：宏原子，球状闪电，量子幽灵。</li>
<li>西恩斯：思想钢印，人类必败，逃亡主义。</li>
<li>罗辑：黑暗森林法则。</li>
</ul>


<p>当你被破壁人揭穿，你承认的时候，大家也认为你在演戏。其实，无论面壁人在做什么，全世界的人都认为他在演戏。怎么证明我们正常人不是这样呢？</p>

<h2>黑暗森林法则</h2>

<ul>
<li>第一句：文明的第一需求是生存；</li>
<li>第二句：文明不断扩张，但是宇宙的物质总量不变。</li>
<li>关键词：猜疑链和技术爆炸。</li>
</ul>


<h3>黑暗森林法则</h3>

<p>叶文洁的意思是：狼多肉少。随着一个文明的发展，资源总是不够的。但是整个宇宙，物质就那么多，不够分，只能互相抢。弱肉强食，任何外星文明，都是自己潜在的敌人。所以不能暴露自己的存在和位置。技术发展不是平滑的，而是有爆炸式节点。谁也不知道别的文明什么时候爆炸，也许他现在看着像虫子，说不定一转脸就能超过自己了。所以如果遇到了外星文明，不管他发展到什么水平，如果能灭了他，最好先灭了。为了不被灭，就要隐藏自己；为了不被灭，就要先发制人。大家都静悄悄的躲着，谁冒出来，群起而攻之。就像一个黑暗的森林，貌似寂静，其实遍布豺狼虎豹。</p>

<h2>虚假繁荣</h2>

<p>虽然智子封锁了人类的科学，但是技术还是在一定范围内蓬勃发展。</p>

<ul>
<li>合成粮食，利用核聚变能量生产粮食。基因工程使得小麦只生长麦穗。</li>
<li>无线充电，用电设备永远不用充电，也可以说是随时在充电。</li>
<li>各处都是屏幕，广告都是针对个人推送的，每个人看到的内容都不一样。</li>
<li>所有的东西都能联网。</li>
<li>谋杀软件，控制周围一切接入网络的设备，杀一个指定的人。</li>
<li>磁力超导腰带</li>
</ul>


<p>大低谷，怀里的孩子和人类文明那个重要？管那么多，还是过好眼前生活吧。于是有了第二次启蒙运动，第二次文艺复兴，还有第二次人文主义，产生了东郭派，圣母派，希望和三体人在地球上和平共处。</p>

<h3>罗辑测试黑暗森林法则</h3>

<p>罗辑要先试试自己的理论，就随便找了个倒霉恒星，把它的坐标用大喇叭（恒星级功率放大器）满宇宙的喊。但是宇宙的反射弧其实很长。因为宇宙太大了嘛，罗辑发布的坐标信号，不知要走几百年，才能被几百光年外的其它文明收到。罗辑说，我去睡一睡先，有结果了叫醒我。于是就冬眠了。</p>

<h3>人类获得了空前的自信</h3>

<p>罗辑一睡就是100多年。醒来后发现 …… 自己被下岗了。因为这100多年，地球果然发生了传说中的技术大爆炸，战斗力指数翻着番儿的往上蹿，有了自己的太空舰队，士气高昂，无比乐观。曾经的面壁计划啊，已经早被放弃了。因为不怕三体了嘛，可以跟丫正面死磕了啊。听说三体舰队有个先头小部队已经提前飞到了太阳系，还特别高兴，争着抢着要去立头功，最后地球舰队倾巢而出，迎战来敌。</p>

<h2>水滴</h2>

<p>水滴有卡车大小，表面绝对零度，因为分子被固定在固定的位置，不能动。绝对光滑，1000万倍还是光滑，这个点就跟黑色石碑一样傲娇：绝对的1：3：9。</p>

<h3>人类对水滴的猜测</h3>

<ul>
<li>探测器</li>
<li>和平使者，因为美和善良相伴。用去功能化和美的外观表达一种和平的信号，是三体送给人类的礼物。</li>
<li>水滴的美给人类带来了很多艺术文学作品。</li>
</ul>


<h3>水滴攻击人类舰队</h3>

<ul>
<li>以每秒30公里，一分20秒击穿一个队列100艘恒星级战舰。</li>
<li>加速过程，尾部两三次每秒的光环由小变大然后消失。以第三宇宙速度30度瞬间折返。在这种加速度下，传统的金属* 内部结构会被压成薄膜。这是一种超越地球认知的驱动方式。</li>
<li>舰队在被毁的过程中，人类甚至没有办法确定攻击来源。</li>
<li>舰队上的计算机是基于地球知识设计的，无法自动分析水滴。</li>
</ul>


<h2>执剑人</h2>

<p>在地球文明陷入恐慌，就要崩盘的时候，宇宙的反馈回来了：倒霉恒星被爆了，轰至渣，灰飞烟灭。消息传来，罗辑坐地成神，拯救地球。最终，罗辑成功了，他拿到了比核按钮更牛逼的发射按钮：一按下去，整个三体星系和地球都会被轰成渣。</p>

<p>做执剑人期间，罗辑面对着空无一物的墙壁，眼神坚定犀利，三体人不敢轻举妄动。当罗辑将控制器交到程心手中之后，他犀利的目光瞬间变得像落日晚霞般宁静。</p>

<h3>关于威慑系统的思考</h3>

<p>威慑系统为什么不改成这样：一键切换成反触发系统。一直是反触发太危险，万一意外死亡咋办？但是正触发系统太考验执剑人意志力了。想一想，即使改成这样，切换成反触发系统之后，执剑人将面对相同的问题：要不要自杀？程心肯定没有勇气自杀，倒不是怜惜自己，而是怜悯人类。</p>

<p>或者改成，按下按钮，一段时间（水滴摧毁发射器之前）之后再自动发射。想一想，这样同样不行：如果不能取消，问题和前面一样，如果能取消，程心一定会在最后时刻取消。</p>

<h2>阶梯计划</h2>

<p>阶梯计划的设计过程：送探测器，送活人，送死人（程心），送大脑（托马斯韦德）。</p>

<p>云天明送程心星星，程心却让云天明去死，去黑暗恐怖的太空流浪，被三体捕获，接受各种痛苦输入，并且没法自杀。</p>

<h2>圣母程心</h2>

<p>有老流氓罗辑在，三体乖乖滴一动不动，还不断倒贴，输送科技。地球人日子过得相当滋润，舒服久了，就想折腾折腾。搞搞人事斗争，把罗辑搞下去。各方利益谈谈情扯扯淡，最后，真善美派的圣母程心胜出，接任执剑人。三体人虽然不撒谎，但是不傻，也知道程心是个圣母。在程心接过发射按钮的第一秒，隐伏在地球周边的水滴们便开始全力加速冲向地球。程心是圣母嘛，当然不能做毁灭两个文明的事情对不对？所以她简单的纠结了一下，就放弃了。几十秒钟后，三体水滴摧毁了所有发射装置。人类再无还手之力。地球文明被占领。全体人类被智子和水滴强制驱逐到澳洲大陆。悲剧了。</p>

<h2>光速飞船</h2>

<p>万有引力号发射三体星系的坐标，很快，三体星系被轰成了渣。三体人还是挺讲究的，没有因此对地球上的人类报复。他们离开了地球，开始星际流浪。地球陷入了死局，三体那么牛都没辙，地球被轰成渣，迟早的事儿啊。</p>

<p>怎么办呢？</p>

<ol>
<li>针对光粒攻击修筑了防御工事。</li>
<li>云天明在三体文明里混得风生水起，居然在三体舰队离开地球前，得到了一次和他的梦中情人程心视频聊天的机会，并且在这次吃聊天中传达了一个信息：用曲率驱动的方式制造光速飞船。</li>
</ol>


<p>人类担心试飞的航迹会让地球看起来更危险，加速打击的到来，虽然这是早晚的事儿，但还是顺应民意，立法禁止曲率驱动技术的研制。维德决定和政府硬干，武装对抗。关键时刻，圣母再次驾到，成功滴阻止了维德，停止了光速飞船计划，毁掉了人类的最后希望。</p>

<h2>降维打击</h2>

<p>三体星系受到的是光粒攻击恒星，太阳系受到的是降维打击：二向箔。</p>

<p>宇宙本来有11个维度，但是在战争中，不断地降维。地球的三维文明，已然是战争链的底端。
当整个宇宙都降至0维时，也许就是一切的终点。</p>

<h2>爱与生存</h2>

<h2>彩蛋</h2>

<p>圣母和她的闺蜜飞出太阳系，去找云天明。一不留神，陷入了两个时空，闺蜜和云天明度过了幸福的一生。</p>

<h2>一些人物</h2>

<ul>
<li>罗辑：玩世不恭的大学教授，贪污科研经费。</li>
<li>庄严：刚来到罗辑身边就知道五年后要走，所以她带着忧伤。就是因为一直带着忧伤，所以罗辑没有注意到。</li>
<li>阿富汗恐怖组织，仇恨是恐怖组织存在的根本，其次才是金钱和武器。</li>
<li>丁仪：第一个接触水滴的人，被瞬间气化。

<ul>
<li>最后一句话：“孩子们，快跑啊！”</li>
<li>不像探测器，像艺术品。</li>
<li>思考问题从美学出发，大舰队和小水滴不对称，不好。</li>
<li>生死关头，谈笑风生，缓解气氛。</li>
</ul>
</li>
</ul>


<h2>思考</h2>

<ul>
<li>其实想想书中那几千万年的光阴，也不过是一梦一醒之间，我们的所拥有的时间，真的不过是寥寥而已。既然如此，有梦就痛快去做吧，有爱就无所顾忌的去追吧。我始终觉得，遗憾终归是有的，任你怎么做，做的再好，也还是会有，遗憾这个东西，它绝对属于墨菲定律的范畴。但是如果遗憾有一个比较级，那么<strong>比起你做过什么，你没做过什么而产生的遗憾会更加的难以释怀。</strong></li>
<li>难道物质的本原真的是无规律吗？难道世界的稳定和秩序，只是宇宙某个角落短暂的动态平衡？只是混乱的湍流中一个短命的旋涡？很多事情就看你在什么尺度上看，从很小的尺度去看，波浪线可以是直的。</li>
<li>宇宙是高位截瘫的病人，光速限制，永远到达不了宇宙另一边，因为宇宙边缘在以超光速膨胀（这了可以超光速和空间膨胀有关系，宇宙边缘也是空间膨胀的边缘），这样宇宙一边永远无法知道另一边的存在，就像高位截瘫的病人的大脑不知道四肢的存在一样。</li>
<li>宇宙另一个问题是只有三个维度，但是根据弦论，宇宙应该有11个维度（这个可以用降维打击来解释）。</li>
<li>黑色的太空孕育出黑色的新人类和新道德，所以他们不会下地狱，后来的人类会以正常的眼光看待他们。一边蓝色空间号获得了另外四艘飞船的资源，包括章北海的自然选择号。另一边青铜时代号攻击了量子号。</li>
<li>第一颗水滴为什么不直接到地球上杀死罗辑？一直等到蓝色空间号消灭四艘飞船还没有。来啦，只是能量消耗，加速变慢，还没到地球。水滴来到地球是封锁太阳的，这样人类就没有办法向宇宙广播。</li>
<li>基础理论决定上层建筑，技术的发展只是回光返照。章北海逃亡计划来自未来史学派。未来史派预测过大低谷，也预测过第二次人文主义，都成功了，他们也预测了三体战争中人类必败。</li>
<li>全息，部分是整体的全息。人类文明也许如此。</li>
<li>星舰地球是一个小社会，五千多人，光速的百分之十五。专制社会？人文社会？</li>
<li>看比较暗的星星，不要正对着使劲看，用余光试试</li>
<li>联合舰队基地在木星。</li>
<li>能不能发明一种交流方式，人类能够理解，智子理解不了？来自卢浮宫艺术的想法。</li>
</ul>


<h2>参考</h2>

<ul>
<li>知乎问答里面<a href="https://www.zhihu.com/question/34998482">樊昌的回答</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/136771698">《三体》故事简介及读后感</a>: 故事总结和感想都不错.</li>
<li><a href="https://zhuanlan.zhihu.com/p/36239044">关于未来的未来——《三体》系列读后感</a>: 关于“浪漫”的总结真是太棒了！"给岁月以文明，而不是给文明以岁月"。其实，全文写的都很好，可以看出是用心在写的一篇文章。</li>
<li><a href="https://zhuanlan.zhihu.com/p/397302462">笔记：小说《三体》所有人物整理</a>: 人物列表及简介</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[极客时间-罗剑锋-《透视HTTP协议》总结]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi/"/>
    <updated>2021-05-26T18:32:49+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/05/26/toushi-http-xieyi</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82">协议分层</a></li>
<li><a href="#dns">DNS</a>

<ul>
<li><a href="#dns%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B">DNS访问过程</a></li>
<li><a href="#dns%E7%9A%84%E7%BC%93%E5%AD%98">DNS的缓存</a></li>
<li><a href="#dns%E6%96%B0%E7%8E%A9%E6%B3%95">DNS新玩法</a></li>
</ul>
</li>
<li><a href="#%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%86%8D%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E9%9D%A2%E7%A9%B6%E7%AB%9F%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">键入网址再按下回车，后面究竟发生了什么？</a></li>
<li><a href="#tls%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B">TLS握手过程</a></li>
<li><a href="#http%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">http性能优化</a></li>
<li><a href="#%E8%AF%95%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac">试验环境搭建（Mac）</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-协议分层" name="协议分层"></a></p>

<h2>协议分层</h2>

<p>TCP/IP的四层模型和OSI的七层模型之间的对应关系：</p>

<p><img src="http://hongchaozhang.github.io/images/20200526%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="20200526四层协议和七层协议的对应关系.png" /></p>

<p>详细说一下TCP/IP的四层模型：</p>

<ul>
<li>第一层叫“<strong>链接层</strong>”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</li>
<li>第二层叫“<strong>网际层</strong>”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</li>
<li>第三层叫“<strong>传输层</strong>”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</li>
<li>协议栈的第四层叫“<strong>应用层</strong>”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。</li>
</ul>


<p>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p>

<p>有了上面的概念，才可能理解下面的术语：</p>

<ul>
<li>四层负载均衡：指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</li>
<li>七层负载均衡：指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</li>
</ul>


<p>下面以TCP/IP的四层模型来说明请求数据的发送和接收过程：</p>

<p><img src="http://hongchaozhang.github.io/images/20200526%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="20200526四层模型工作过程模型.png" /></p>

<p>发送过程就是一层一层包裹的过程，接收的过程就是一层一层拨开的过程。</p>

<p><a id="markdown-dns" name="dns"></a></p>

<h2>DNS</h2>

<p><a id="markdown-dns访问过程" name="dns访问过程"></a></p>

<h3>DNS访问过程</h3>

<p>域名必须转换成IP才能进行网络访问。这个过程需要DNS（Domain Name System）。</p>

<p>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</p>

<ol>
<li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li>
<li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li>
<li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。</li>
</ol>


<p>DNS三层结构示意图如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20200526%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84.png" alt="20200526域名服务器层级结构.png" /></p>

<p>有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。</p>

<p>例如，你要访问“www.apple.com”，就要进行下面的三次查询：</p>

<ol>
<li>访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</li>
<li>访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</li>
<li>最后访问“apple.com”域名服务器，就得到了“www.apple.com”的地址。</li>
</ol>


<p><a id="markdown-dns的缓存" name="dns的缓存"></a></p>

<h3>DNS的缓存</h3>

<p>虽然核心的 DNS 系统遍布全球，服务能力很强也很稳定，但如果全世界的网民都往这个系统里挤，即使不挤瘫痪了，访问速度也会很慢。</p>

<p>所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“<strong>缓存</strong>”。</p>

<p><strong>首先</strong>，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。</p>

<p>这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。</p>

<p><strong>其次</strong>，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到 DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</p>

<p><strong>另外</strong>，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</p>

<p><a id="markdown-dns新玩法" name="dns新玩法"></a></p>

<h3>DNS新玩法</h3>

<p>除了解析得到IP地址，DNS还可以用来做一些其他事情。</p>

<ol>
<li>第一种，也是最简单的，“重定向”。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。实现停机维护期间服务不中断。</li>
<li>第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名，而且这种方式也兼具了第一种“玩法”的优势。</li>
<li>第三种“玩法”包含了前两种，也就是基于域名实现的负载均衡。在计算IP的时候考虑哪台主机资源充足，更适合提供服务，就返回哪台服务器的IP地址。</li>
</ol>


<p><a id="markdown-键入网址再按下回车后面究竟发生了什么" name="键入网址再按下回车后面究竟发生了什么"></a></p>

<h2>键入网址再按下回车，后面究竟发生了什么？</h2>

<p>当用户在浏览器地址栏输入<a href="">http://127.0.0.1/</a>，并按下回车之后，浏览器和服务器之间的行为如下：</p>

<p><img src="http://hongchaozhang.github.io/images/20200526http%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B.png" width="400" alt="20200526http请求全过程.png" /></p>

<ol>
<li>首先是TCP连接的建立：经过 SYN、SYN/ACK、ACK 的三个包之后，浏览器与服务器的 TCP 连接就建立起来了。</li>
<li>有了可靠的 TCP 连接通道后，HTTP 协议就可以开始工作了。于是，浏览器按照 HTTP 协议规定的格式，通过 TCP 发送了一个“GET / HTTP/1.1”请求报文，也就是 Wireshark 里的第四个包。</li>
<li>随后，Web 服务器回复了第五个包，在 TCP 协议层面确认：“刚才的报文我已经收到了”，不过这个 TCP 包 HTTP 协议是看不见的。</li>
<li>Web 服务器收到报文后在内部就要处理这个请求。同样也是依据 HTTP 协议的规定，解析报文，看看浏览器发送这个请求想要干什么。它一看，原来是要求获取根目录下的默认文件，好吧，那我就从磁盘上把那个文件全读出来，再拼成符合 HTTP 格式的报文，发回去吧。这就是第六个包“HTTP/1.1 200 OK”，底层走的还是 TCP 协议。</li>
<li>同样的，浏览器也要给服务器回复一个 TCP 的 ACK 确认，“你的响应报文收到了，多谢。”，即第七个包。</li>
<li>这时浏览器就收到了响应数据，但里面是什么呢？所以也要解析报文。一看，服务器给我的是个 HTML 文件，好，那我就调用排版引擎、JavaScript 引擎等等处理一下，然后在浏览器窗口里展现出了欢迎页面。</li>
<li>这之后还有两个来回，共四个包，重复了相同的步骤。这是浏览器自动请求了作为网站图标的“favicon.ico”文件，与我们输入的网址无关。但因为我们的实验环境没有这个文件，所以服务器在硬盘上找不到，返回了一个“404 Not Found”。</li>
<li>最后是TCP关闭连接的“四次挥手”。但是当你通过抓包软件抓包的时候可能看不到这几个包，因为HTTP/1.1 长连接特性，默认不会立即关闭连接。</li>
</ol>


<p>至此，“键入网址再按下回车”的全过程就结束了。</p>

<p>当然，上面只是一个极简网络模型。真实世界中的应用复杂很多。</p>

<ol>
<li>上面是直接输入了IP地址，如果输入的是域名，那么在上面所有步骤之前还有DNS解析过程。</li>
<li>如果用的是https通信协议，在TCP连接建立之后还要有TLS连接的建立。</li>
<li>别忘了互联网上还有另外一个重要的角色 CDN，它也会在 DNS 的解析过程中“插上一脚”。DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。</li>
<li>如果你的请求跳过CDN，到达目标服务器，这时发生的事情如下：目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如四层的 LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群。</li>
<li>负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存 Varnish，它们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力。</li>
<li>如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang 等等。它们又会再访问后面的 MySQL、PostgreSQL、MongoDB 等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份。</li>
<li>应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。</li>
<li>最后网站的响应数据回到了你的设备，它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。</li>
</ol>


<p>综合考虑上面的因素，整体的workflow可以表示如下：</p>

<p><img src="http://hongchaozhang.github.io/images/NetworkRequestWorkflow.svg" alt="NetworkRequestWorkflow.svg" /></p>

<p><a id="markdown-tls握手过程" name="tls握手过程"></a></p>

<h2>TLS握手过程</h2>

<p>关于“TLS如何保证安全”这个话题，参考<a href="https://www.zhihu.com/question/52493697">知乎回答</a>。上面这篇文中的“编程指北”的回答最清晰。身份认证可以直接看3.5和3.6小节。真正申请一个SSL证书需要知道的常识：<a href="https://www.cnblogs.com/mafly/p/ssl.html">一篇文章让你搞懂 SSL 证书</a>。</p>

<p>简要过程图：</p>

<p><img src="http://hongchaozhang.github.io/images/20200526TLS%E9%93%BE%E6%8E%A5%E7%AE%80%E8%A6%81%E8%BF%87%E7%A8%8B.png" width="400" alt="20200526TLS链接简要过程.png" /></p>

<p>详细过程图：</p>

<p><img src="http://hongchaozhang.github.io/images/20200526TLS%E9%93%BE%E6%8E%A5%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.png" width="400" alt="20200526TLS链接详细过程.png" /></p>

<p>详细的分析解说参考原文：<a href="http://hongchaozhang.github.io/assets/resources/26%E4%B8%A8%E4%BF%A1%E4%BB%BB%E5%A7%8B%E4%BA%8E%E6%8F%A1%E6%89%8B%EF%BC%9ATLS1.2%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.html">26丨信任始于握手：TLS1.2连接过程解析.html</a></p>

<p><a id="markdown-http性能优化" name="http性能优化"></a></p>

<h2>http性能优化</h2>

<p>关于http性能优化更详细的介绍，参见<a href="http://hongchaozhang.github.io/blog/2022/03/08/http-xingneng-youhua/">Web性能优化综述</a>的章节<a href="http://hongchaozhang.github.io/blog/2022/03/08/http-xingneng-youhua/#https%E8%AF%B7%E6%B1%82%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">https请求性能优化</a>。</p>

<p><strong>HTTP性能优化面面观（上）</strong></p>

<ol>
<li>性能优化是一个复杂的概念，在 HTTP 里可以分解为服务器性能优化、客户端性能优化和传输链路优化；</li>
<li>服务器有三个主要的性能指标：吞吐量、并发数和响应时间，此外还需要考虑资源利用率；</li>
<li>客户端的基本性能指标是延迟，影响因素有地理距离、带宽、DNS 查询、TCP 握手等；</li>
<li>从服务器到客户端的传输链路可以分为三个部分，我们能够优化的是前两个部分，也就是“第一公里”和“中间一公里”；</li>
<li>有很多工具可以测量这些指标，服务器端有 ab、top、sar 等，客户端可以使用测试网站，浏览器的开发者工具。</li>
</ol>


<p><strong>HTTP性能优化面面观（下）</strong></p>

<ol>
<li>花钱购买硬件、软件或者服务可以直接提升网站的服务能力，其中最有价值的是 CDN；</li>
<li>不花钱也可以优化 HTTP，三个关键词是“开源”“节流”和“缓存”；</li>
<li>后端应该选用高性能的 Web 服务器，开启长连接，提升 TCP 的传输效率；</li>
<li>前端应该启用 gzip、br 压缩，减小文本、图片的体积，尽量少传不必要的头字段；</li>
<li>缓存是无论何时都不能忘记的性能优化利器，应该总使用 Etag 或 Last-modified 字段标记资源；</li>
<li>升级到 HTTP/2 能够直接获得许多方面的性能提升，但要留意一些 HTTP/1 的“反模式”。</li>
</ol>


<p><a id="markdown-试验环境搭建mac" name="试验环境搭建mac"></a></p>

<h2>试验环境搭建（Mac）</h2>

<ol>
<li>安装homebrew</li>
<li>使用homebrew安装OpenResty
<code>brew install openresty/brew/openresty</code></li>
<li>clone项目源码
<code>git clone https://github.com/chronolaw/http_study</code></li>
<li>启动项目

<ul>
<li><code>cd http_study/www/</code> 脚本必须在www目录下运行，才能找到nginx.conf</li>
<li><code>./run.sh start</code> 启动实验环境</li>
<li><code>./run.sh list</code> 列出实验环境的Nginx进程</li>
<li><code>./run.sh reload</code> 重启实验环境</li>
<li><code>./run.sh stop</code> 停止实验环境</li>
</ul>
</li>
<li>启动 OpenResty 之后，就可以用浏览器或者 curl 来验证课程里的各个测试 URI，但之前不要忘记修改“/etc/hosts”添加域名解析。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[薛兆丰经济学整理]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/03/01/xuezhaofeng-jingjixue/"/>
    <updated>2021-03-01T18:18:19+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/03/01/xuezhaofeng-jingjixue</id>
    <content type="html"><![CDATA[<!-- more -->


<p>零碎的总结，不成体系。</p>

<p>最低零售价: 锁定价格，提高服务竞争，因为这个商品不仅仅是卖商品（比如耳机），要让客户认同分区销售，地区总代理才能有积极性在地区内推广，做广告等，前提是地区之间不能窜货。</p>

<p>最高定价：限制最高价格（比如报纸），保证销量，进而保证广告收入，对于报纸来说，报纸的销售额不是收入的主要来源，广告才是。虽然报纸销售商想提高报纸销量，但是报社不希望这样。</p>

<p>垄断的判断：不看数量，看潜在的竞争者进去市场时有没有行政阻碍。</p>

<p>相关性不等于因果性：比如红酒和健康，长头发和艺术家。具有相关性的两个现象可能都是另一个现象导致的结果，比如收入（同时导致红酒和健康）和特立独行的性格（同时导致长发和艺术家）。当然，收入和特立独行的性格也有他们形成的原因。</p>

<p>波普尔，证伪才是科学，能解释一切的理论不是科学，因为没法证伪。</p>

<blockquote><p>比如进化论就给我这种感觉：能解释一切，没有反例。</p></blockquote>

<p>追求公正往往比追求真实更重要，因为追求真实成本可能很大。这就是现代司法的宗旨。</p>

<p>枪炮病菌病毒：地理决定论</p>

<p>隐私信息的暴露使人更可信：比如现在的私人租房业务，房东不需要你做抵押，就把房子给你住。因为他相信，如果你乱来，他能通过某些方式找到你。</p>

<p>加里贝克：人的兴趣是不变的，人愿意付出的代价是变化的，流行音乐人和古典音乐人愿意付出的代价不同。</p>

<p>事前监管/事后惩罚：取决于事前有没有办法监管，或者事后有没有办法赔付。</p>

<p>科斯：企业的存在，是交易城本和企业管理成本的平衡。
企业存在的另一个理由，团队产生个体不能产生的东西。</p>

<p>垄断控诉双方找替代品的努力，垄断方努力找替代品，证明市场大，自己的份额少。</p>

<p>IBM的大型机器租用费用很低，但是打孔纸特别贵，降低准入门槛（租金便宜，维护费用转嫁到打孔纸上，用的多，多交钱），区别定价。</p>

<p>经济学基础是稀缺，不是人的自私和理性。经济学认为稀缺是必然的是不会消失的，因为人的欲望是无限的。</p>

<p>成本是你失去东西的最大代价，由你失去的东西决定，沉默成本，边际成本，边际收益。</p>

<p>寻租：竞争消耗资源，比如乞丐比惨，企业争取政府红利等。</p>

<p>科斯定律：资源应该属于能用好它的人，或者说在交易费用为零的情况下，资源最终会属于能用好它的人，因为这样代价最小。</p>

<p>科斯定律，醉驾，规定，风俗，资源分配，法院风俗存在的道理</p>

<p>交易费用的总和称为制度费用。</p>

<p>书先读薄，再读厚，反复几次，才能称得上理解。</p>

<p>随大流，节省交易费用。</p>

<p>中国式过马路，行人聚集多了，就不顾红灯过马路，是等红灯的代价太大了</p>

<p>需求三定律：</p>

<ol>
<li>需求第一定律，价格升高，需求降低</li>
<li>需求第二定律，价格决定弹性，法律无效定律</li>
<li>需求第三定律，好东西运到远方去定律</li>
</ol>


<p>社会的测不准原理：预测的对象对预测本身有反应。</p>

<p>投资是时间维度上的平衡消费。</p>

<p>预期只受新知识新消息的影响。</p>

<p>有效市场假说：所有的消息和知识都被人们消化，并且反应在了经济当中。包括秘密的信息，私人的信息，也已经反应到了经济当中。</p>

<p>期货是风险的重新分配，和保险类似，和赌博不同，赌博是产生风险，期货是重新分配已经存在的风险。</p>

<p>投资加速器：长期的订单增加，才需要增加固定资产投资。通货膨胀刺激经济增长。高频信息，低频信息之间的错位。</p>

<p>合同的不对等，表面上的不对等，背后是另一种相反的不对等，已达到平衡，达成交易。比如加盟店的合同，基本上都是有利于总店的。合同上的强者是现实生活中的弱者，合同是用来平衡这种强弱关系的。</p>

<p>价格歧视，交叉补偿，各取所需。</p>

<p>分工与垂直整合的标准是物品是不是更容易进行质量检测，否则就要垂直整合。</p>

<p>本来是商品的东西，如果没有被当做商品，就会产生价格之外的竞争，进而产生很多问题，造成资源浪费。</p>

<p>规则一旦明确，就会被利用。这也许就是中国式管理的理论基础。</p>

<p>有效违约，节约社会资源。</p>

<p>一妻多夫，父子关系的确定有问题，进而财产继承权的确定。
一夫一妻是对成功男人的限购。</p>

<p>合同，意会，meeting of the minds。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SightReading(视奏)应用开发知识点总结]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/03/01/summarize-of-sight-reading-app-developping/"/>
    <updated>2021-03-01T14:39:00+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/03/01/summarize-of-sight-reading-app-developping</id>
    <content type="html"><![CDATA[<!-- more -->




<!-- TOC -->


<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96">数据持久化</a>

<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%9D%E5%AD%98%E5%92%8C%E8%AF%BB%E5%8F%96">文件的保存和读取</a></li>
<li><a href="#nsdefault%E4%BF%9D%E5%AD%98%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF">NSDefault：保存标签信息</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
<li><a href="#%E6%92%AD%E6%94%BE%E8%8A%82%E6%8B%8D%E5%99%A8%E5%A3%B0%E9%9F%B3">播放节拍器声音</a>

<ul>
<li><a href="#%E9%80%9A%E8%BF%87avfoundation%E6%92%AD%E6%94%BE%E5%A3%B0%E9%9F%B3">通过AVFoundation播放声音</a></li>
<li><a href="#%E8%8A%82%E6%8B%8D%E5%99%A8%E9%9F%B3%E9%87%8F%E8%B0%83%E8%8A%82">节拍器音量调节</a></li>
</ul>
</li>
<li><a href="#navigationcontroller%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E9%80%92">navigationController的使用和数据的传递</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
<li><a href="#photokit%E7%9A%84%E4%BD%BF%E7%94%A8">PhotoKit的使用</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
<li><a href="#alert-view">Alert View</a></li>
<li><a href="#uiimage">UIImage</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
<li><a href="#%E5%8F%AF%E7%BC%96%E8%BE%91%E7%9A%84uitableview">可编辑的UITableView</a></li>
<li><a href="#calayer--cashapelayer--core-graphics">CALayer &amp; CAShapeLayer &amp; Core Graphics</a></li>
<li><a href="#%E9%9F%B3%E4%B9%90%E6%9C%AF%E8%AF%AD%E8%8B%B1%E8%AF%AD">音乐术语英语</a></li>
<li><a href="#swift%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95designatedconvenience">swift中构造方法designated，convenience</a>

<ul>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</li>
<li><a href="#%E7%AC%94%E8%AE%B0%E7%BB%98%E5%88%B6%E5%8A%9F%E8%83%BD">笔记绘制功能</a></li>
</ul>


<!-- /TOC -->


<p><a id="markdown-数据持久化" name="数据持久化"></a></p>

<h2>数据持久化</h2>

<p><a id="markdown-文件的保存和读取" name="文件的保存和读取"></a></p>

<h3>文件的保存和读取</h3>

<ul>
<li>Json文件：每个乐谱页对应一个Json文件。文件保存乐谱每小节的大小和位置信息，以及乐谱的基本信息，包括每小节节拍数和用户设置的速度和Mask偏移量。</li>
<li>png文件：每个乐谱都有一个乐谱图片，如果用户做了笔记，还有一个笔记图片。</li>
</ul>


<p>保存文件的代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">getRootPath</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NSSearchPathForDirectoriesInDomains</span><span class="p">(.</span><span class="n">documentDirectory</span><span class="p">,</span> <span class="p">.</span><span class="n">userDomainMask</span><span class="p">,</span> <span class="nb">true</span><span class="p">).</span><span class="n">first</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">saveImageFile</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="k">let</span> <span class="n">rootPath</span> <span class="o">=</span> <span class="n">Utility</span><span class="p">.</span><span class="n">getRootPath</span><span class="p">(),</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">imageName</span> <span class="o">=</span> <span class="n">getFileName</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">imagePath</span> <span class="o">=</span> <span class="s">&quot;\(rootPath)/\(imageName).png&quot;</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;image path: \(imagePath)&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="k">let</span> <span class="n">image</span> <span class="o">=</span> <span class="n">imageView</span><span class="p">.</span><span class="n">image</span><span class="p">,</span> <span class="k">let</span> <span class="n">imageData</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">pngData</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">FileManager</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">createFile</span><span class="p">(</span><span class="nl">atPath</span><span class="p">:</span> <span class="n">imagePath</span><span class="p">,</span> <span class="nl">contents</span><span class="p">:</span> <span class="n">imageData</span><span class="p">,</span> <span class="nl">attributes</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="nf">saveJsonFile</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="k">let</span> <span class="n">rootPath</span> <span class="o">=</span> <span class="n">Utility</span><span class="p">.</span><span class="n">getRootPath</span><span class="p">(),</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">jsonFileName</span> <span class="o">=</span> <span class="n">getFileName</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">jsonPath</span> <span class="o">=</span> <span class="s">&quot;\(rootPath)/\(jsonFileName).json&quot;</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;image path: \(jsonPath)&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">let</span> <span class="nl">jsonDic</span><span class="p">:</span> <span class="p">[</span><span class="nl">String</span><span class="p">:</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nl">basicInfoKey</span><span class="p">:</span> <span class="p">[</span><span class="nl">String</span><span class="p">:</span> <span class="n">String</span><span class="p">](),</span> <span class="nl">barFramesKey</span><span class="p">:</span> <span class="n">barFrames</span><span class="p">]</span>
</span><span class='line'>        <span class="k">if</span> <span class="k">let</span> <span class="n">jsonData</span> <span class="o">=</span> <span class="n">try</span><span class="o">?</span> <span class="bp">NSKeyedArchiver</span><span class="p">.</span><span class="n">archivedData</span><span class="p">(</span><span class="nl">withRootObject</span><span class="p">:</span> <span class="n">jsonDic</span><span class="p">,</span> <span class="nl">requiringSecureCoding</span><span class="p">:</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">FileManager</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">createFile</span><span class="p">(</span><span class="nl">atPath</span><span class="p">:</span> <span class="n">jsonPath</span><span class="p">,</span> <span class="nl">contents</span><span class="p">:</span> <span class="n">jsonData</span><span class="p">,</span> <span class="nl">attributes</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>读取文件的代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">loadJsonFile</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="k">let</span> <span class="n">rootPath</span> <span class="o">=</span> <span class="n">Utility</span><span class="p">.</span><span class="n">getRootPath</span><span class="p">(),</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">jsonName</span> <span class="o">=</span> <span class="n">navigationItem</span><span class="p">.</span><span class="n">title</span><span class="p">,</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">jsonData</span> <span class="o">=</span> <span class="n">FileManager</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">contents</span><span class="p">(</span><span class="nl">atPath</span><span class="p">:</span> <span class="s">&quot;\(rootPath)/\(jsonName).json&quot;</span><span class="p">),</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">jsonObjectAny</span> <span class="o">=</span> <span class="bp">NSKeyedUnarchiver</span><span class="p">.</span><span class="n">unarchiveObject</span><span class="p">(</span><span class="nl">with</span><span class="p">:</span> <span class="n">jsonData</span><span class="p">),</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">jsonObject</span> <span class="o">=</span> <span class="n">jsonObjectAny</span> <span class="kt">as</span><span class="o">?</span> <span class="p">[</span><span class="nl">String</span><span class="p">:</span> <span class="n">Any</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="k">let</span> <span class="n">sheetBasicInfo</span> <span class="o">=</span> <span class="n">jsonObject</span><span class="p">[</span><span class="n">basicInfoKey</span><span class="p">]</span> <span class="kt">as</span><span class="o">?</span> <span class="p">[</span><span class="nl">String</span><span class="p">:</span> <span class="n">String</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">sheetBasicInfo</span> <span class="o">=</span> <span class="n">sheetBasicInfo</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="k">let</span> <span class="n">barFrames</span> <span class="o">=</span> <span class="n">jsonObject</span><span class="p">[</span><span class="n">barFramesKey</span><span class="p">]</span> <span class="kt">as</span><span class="o">?</span> <span class="p">[</span><span class="nl">Int</span><span class="p">:</span> <span class="bp">CGRect</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">barFrames</span> <span class="o">=</span>  <span class="n">barFrames</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="nf">loadSheetImage</span><span class="p">(</span><span class="n">with</span> <span class="nl">imageName</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="k">let</span> <span class="n">rootPath</span> <span class="o">=</span> <span class="n">Utility</span><span class="p">.</span><span class="n">getRootPath</span><span class="p">(),</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">sheetImage</span> <span class="o">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="nl">contentsOfFile</span><span class="p">:</span> <span class="s">&quot;\(rootPath)/\(imageName).png&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">sheetImageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">sheetImage</span>
</span><span class='line'>        <span class="n">noteImageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="nl">contentsOfFile</span><span class="p">:</span> <span class="s">&quot;\(rootPath)/\(imageName)\(noteImageSubfix).png&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">layoutImageView</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a id="markdown-nsdefault保存标签信息" name="nsdefault保存标签信息"></a></p>

<h3>NSDefault：保存标签信息</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">UserDefaults</span><span class="p">.</span><span class="n">standard</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">allTags</span><span class="p">,</span> <span class="nl">forKey</span><span class="p">:</span> <span class="n">allTagsKey</span><span class="p">)</span>
</span><span class='line'><span class="k">let</span> <span class="n">allTags</span> <span class="o">=</span> <span class="n">UserDefaults</span><span class="p">.</span><span class="n">standard</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="nl">forKey</span><span class="p">:</span> <span class="n">allTagsKey</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><a id="markdown-参考" name="参考"></a></p>

<h3>参考</h3>

<ul>
<li><a href="https://www.jianshu.com/p/d1c621631f7e">iOS数据本地持久化方法总结</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1129341">iOS应用数据存储（数据持久化）的常用方式</a></li>
<li><a href="https://www.jianshu.com/p/fad66bae5484">iOS 将对象序列化成json，写入本地文件</a></li>
</ul>


<p><a id="markdown-播放节拍器声音" name="播放节拍器声音"></a></p>

<h2>播放节拍器声音</h2>

<p><a id="markdown-通过avfoundation播放声音" name="通过avfoundation播放声音"></a></p>

<h3>通过AVFoundation播放声音</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">audioUrl</span> <span class="o">=</span> <span class="n">Bundle</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">url</span><span class="p">(</span><span class="nl">forResource</span><span class="p">:</span> <span class="s">&quot;FirstMeter&quot;</span><span class="p">,</span> <span class="nl">withExtension</span><span class="p">:</span> <span class="s">&quot;wav&quot;</span><span class="p">,</span> <span class="nl">subdirectory</span><span class="p">:</span> <span class="s">&quot;Resource.bundle&quot;</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>    <span class="n">AudioServicesCreateSystemSoundID</span><span class="p">(</span><span class="n">audioUrl</span> <span class="kt">as</span> <span class="n">CFURL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">firstMeterId</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">AudioServicesPlaySystemSound</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">firstMeterId</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><a id="markdown-节拍器音量调节" name="节拍器音量调节"></a></p>

<h3>节拍器音量调节</h3>

<p>在设置中，如果“声音->铃声和警报”下面的“跟随按钮”没有打开，那么通过<code>AudioServicesPlaySystemSound()</code>播放的声音就会始终用一个固定的音量播放，其它声音API播放的声音（比如<code>AVAudioPlayer</code>）会跟随系统音量变化音量大小。</p>

<blockquote><p>In Settings app, Sounds->RINGER AND ALERTS, if &lsquo;Change with Buttons&rsquo; is set to Off, then sounds using AudioServicesPlaySystemSound() will always be played at a fixed volume (yet other sound API&rsquo;s such as AVAudioPlayer will respect the volume of the device).</p></blockquote>

<p><a id="markdown-navigationcontroller的使用和数据的传递" name="navigationcontroller的使用和数据的传递"></a></p>

<h2>navigationController的使用和数据的传递</h2>

<p>通过下面两种方法进行ViewController的弹出</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">playVC</span> <span class="o">=</span> <span class="n">storyBoard</span><span class="p">.</span><span class="n">instantiateViewController</span><span class="p">(</span><span class="nl">identifier</span><span class="p">:</span> <span class="s">&quot;Play&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">playVC</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">filtedFileNames</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>
</span><span class='line'><span class="n">navigationController</span><span class="o">?</span><span class="p">.</span><span class="n">pushViewController</span><span class="p">(</span><span class="n">playVC</span><span class="p">,</span> <span class="nl">animated</span><span class="p">:</span> <span class="nb">true</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">colorPickerVC</span> <span class="o">=</span> <span class="n">UIColorPickerViewController</span><span class="p">()</span>
</span><span class='line'><span class="n">colorPickerVC</span><span class="p">.</span><span class="n">selectedColor</span> <span class="o">=</span> <span class="n">brushColorButton</span><span class="p">.</span><span class="n">selectedColor</span>
</span><span class='line'><span class="n">colorPickerVC</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span>
</span><span class='line'><span class="n">present</span><span class="p">(</span><span class="n">colorPickerVC</span><span class="p">,</span> <span class="nl">animated</span><span class="p">:</span> <span class="nb">true</span><span class="p">,</span> <span class="nl">completion</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过delegate进行目标ViewController到源ViewController的方法调用和数据传递，源ViewControler可以直接设置目标ViewController的属性进行数据传递。</p>

<p><a id="markdown-参考" name="参考"></a></p>

<h3>参考</h3>

<ul>
<li><a href="https://stackoverflow.com/questions/30618172/how-to-send-data-back-by-popviewcontrolleranimated-for-swift">How to send data back by popViewControllerAnimated for Swift?</a></li>
<li><a href="https://www.jianshu.com/p/319cbc53f0ba">iOS导航控制器——UINavigationController使用详解</a></li>
<li><a href="https://blog.csdn.net/liuyinghui523/article/details/62036465">一篇较为详细的 Storyboard使用方法 总结</a></li>
</ul>


<p><a id="markdown-photokit的使用" name="photokit的使用"></a></p>

<h2>PhotoKit的使用</h2>

<p>需要在info.plist里面设置<code>NSPhotoLibraryUsageDescription</code>属性，设置在获取权限的时候显示给用户的弹窗中显示的内容。</p>

<p>检查权限状态：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">private</span> <span class="k">func</span> <span class="nf">requestPrivilegeAndLoadPhotos</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">status</span> <span class="o">=</span> <span class="n">PHPhotoLibrary</span><span class="p">.</span><span class="n">authorizationStatus</span><span class="p">()</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="p">.</span><span class="n">authorized</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">loadPhotos</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">PHPhotoLibrary</span><span class="p">.</span><span class="n">requestAuthorization</span> <span class="p">{</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="k">in</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="p">.</span><span class="n">authorized</span> <span class="p">{</span>
</span><span class='line'>                <span class="nb">self</span><span class="p">.</span><span class="n">loadPhotos</span><span class="p">()</span>
</span><span class='line'>                <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">async</span> <span class="p">{</span>
</span><span class='line'>                    <span class="nb">self</span><span class="p">.</span><span class="n">collection</span><span class="p">.</span><span class="n">reloadData</span><span class="p">()</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// use not grant the privilege</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果用户给了访问相册的权限，通过下面的方法加载所有图片信息：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">private</span> <span class="k">func</span> <span class="nf">loadPhotos</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">allPhotosOptions</span> <span class="o">=</span> <span class="n">PHFetchOptions</span><span class="p">()</span>
</span><span class='line'>    <span class="n">allPhotosOptions</span><span class="p">.</span><span class="n">sortDescriptors</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSSortDescriptor</span><span class="p">(</span><span class="nl">key</span><span class="p">:</span> <span class="s">&quot;creationDate&quot;</span><span class="p">,</span> <span class="nl">ascending</span><span class="p">:</span> <span class="nb">true</span><span class="p">)]</span>
</span><span class='line'>    <span class="n">allPhotos</span> <span class="o">=</span> <span class="n">PHAsset</span><span class="p">.</span><span class="n">fetchAssets</span><span class="p">(</span><span class="nl">with</span><span class="p">:</span> <span class="p">.</span><span class="n">image</span><span class="p">,</span> <span class="nl">options</span><span class="p">:</span> <span class="n">allPhotosOptions</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过下面方法将所有图片信息显示在collection列表中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">collectionView</span><span class="p">(</span><span class="n">_</span> <span class="nl">collectionView</span><span class="p">:</span> <span class="bp">UICollectionView</span><span class="p">,</span> <span class="n">numberOfItemsInSection</span> <span class="nl">section</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">allPhotos</span><span class="p">.</span><span class="n">count</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">func</span> <span class="n">collectionView</span><span class="p">(</span><span class="n">_</span> <span class="nl">collectionView</span><span class="p">:</span> <span class="bp">UICollectionView</span><span class="p">,</span> <span class="n">cellForItemAt</span> <span class="nl">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">UICollectionViewCell</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="k">let</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">collection</span><span class="p">.</span><span class="n">dequeueReusableCell</span><span class="p">(</span><span class="nl">withReuseIdentifier</span><span class="p">:</span> <span class="n">cellIdentifier</span><span class="p">,</span> <span class="k">for</span><span class="o">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="kt">as</span><span class="o">?</span> <span class="n">PhotoCollectionCell</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">let</span> <span class="n">assert</span> <span class="o">=</span> <span class="n">allPhotos</span><span class="p">.</span><span class="n">object</span><span class="p">(</span><span class="nl">at</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">.</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>        <span class="n">PHImageManager</span><span class="p">.</span><span class="k">default</span><span class="p">().</span><span class="n">requestImage</span><span class="p">(</span><span class="k">for</span><span class="o">:</span> <span class="n">assert</span><span class="p">,</span> <span class="nl">targetSize</span><span class="p">:</span> <span class="bp">CGSize</span><span class="p">(</span><span class="nl">width</span><span class="p">:</span> <span class="n">photoCollectionWH</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="n">photoCollectionWH</span><span class="p">),</span> <span class="nl">contentMode</span><span class="p">:</span> <span class="p">.</span><span class="n">aspectFill</span><span class="p">,</span> <span class="nl">options</span><span class="p">:</span> <span class="p">.</span><span class="kr">none</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">dic</span><span class="p">)</span> <span class="k">in</span>
</span><span class='line'>            <span class="k">if</span> <span class="k">let</span> <span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">cell</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">cell</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">collection</span><span class="p">.</span><span class="n">dequeueReusableCell</span><span class="p">(</span><span class="nl">withReuseIdentifier</span><span class="p">:</span> <span class="n">cellIdentifier</span><span class="p">,</span> <span class="k">for</span><span class="o">:</span> <span class="n">indexPath</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过下面方法，将用户选择的图片传给delegate处理（delegate可以是源ViewController）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">collectionView</span><span class="p">(</span><span class="n">_</span> <span class="nl">collectionView</span><span class="p">:</span> <span class="bp">UICollectionView</span><span class="p">,</span> <span class="n">didSelectItemAt</span> <span class="nl">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;item: \(indexPath.item)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">assert</span> <span class="o">=</span> <span class="n">allPhotos</span><span class="p">.</span><span class="n">object</span><span class="p">(</span><span class="nl">at</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">.</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>    <span class="n">PHImageManager</span><span class="p">.</span><span class="k">default</span><span class="p">().</span><span class="n">requestImage</span><span class="p">(</span><span class="k">for</span><span class="o">:</span> <span class="n">assert</span><span class="p">,</span> <span class="nl">targetSize</span><span class="p">:</span> <span class="bp">CGSize</span><span class="p">(</span><span class="nl">width</span><span class="p">:</span> <span class="n">assert</span><span class="p">.</span><span class="n">pixelWidth</span><span class="p">,</span> <span class="nl">height</span><span class="p">:</span> <span class="n">assert</span><span class="p">.</span><span class="n">pixelHeight</span><span class="p">),</span> <span class="nl">contentMode</span><span class="p">:</span> <span class="p">.</span><span class="n">aspectFill</span><span class="p">,</span> <span class="nl">options</span><span class="p">:</span> <span class="p">.</span><span class="kr">none</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">dic</span><span class="p">)</span> <span class="k">in</span>
</span><span class='line'>        <span class="k">if</span> <span class="k">let</span> <span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="p">{</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">delegate</span><span class="o">?</span><span class="p">.</span><span class="kr">set</span><span class="p">(</span><span class="nl">image</span><span class="p">:</span> <span class="n">image</span><span class="p">,</span> <span class="nl">and</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a id="markdown-参考" name="参考"></a></p>

<h3>参考</h3>

<ul>
<li><a href="https://developer.apple.com/documentation/photokit">官方文档：PhotoKit</a></li>
<li><a href="https://www.raywenderlich.com/11764166-getting-started-with-photokit">Getting Started with PhotoKit</a></li>
</ul>


<p><a id="markdown-alert-view" name="alert-view"></a></p>

<h2>Alert View</h2>

<p><a href="https://learnappmaking.com/uialertcontroller-alerts-swift-how-to/">Displaying Alerts with UIAlertController in Swift</a></p>

<p><a id="markdown-uiimage" name="uiimage"></a></p>

<h2>UIImage</h2>

<p>下面两个图片加载方法对cache的运用是不一样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="bp">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">imageNamed:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">name</span><span class="o">:</span> <span class="n">use</span> <span class="n">cached</span> <span class="n">images</span>
</span><span class='line'><span class="o">+</span> <span class="p">(</span><span class="bp">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nl">imageWithContentsOfFile</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nl">path</span><span class="p">:</span> <span class="n">skip</span> <span class="n">cached</span> <span class="n">images</span> <span class="n">and</span> <span class="n">read</span> <span class="n">data</span> <span class="n">directly</span> <span class="n">from</span> <span class="n">file</span>
</span></code></pre></td></tr></table></div></figure>


<p><a id="markdown-参考" name="参考"></a></p>

<h3>参考</h3>

<p><a href="https://medium.com/@maximbilan/ios-uiimage-cache-92563c3ae3c2">iOS UIImage Cache</a></p>

<p><a id="markdown-可编辑的uitableview" name="可编辑的uitableview"></a></p>

<h2>可编辑的UITableView</h2>

<p>通过实现下面方法保证每个cell支持左滑操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="n">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nl">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">canEditRowAt</span> <span class="nl">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">true</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过实现下面的方法，左滑之后显示两个按钮: Edit Tags和Delete</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="n">_</span> <span class="nl">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">editActionsForRowAt</span> <span class="nl">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">UITableViewRowAction</span><span class="p">]</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">deleteAction</span> <span class="o">=</span> <span class="n">UITableViewRowAction</span><span class="p">(</span><span class="nl">style</span><span class="p">:</span> <span class="p">.</span><span class="n">destructive</span><span class="p">,</span> <span class="nl">title</span><span class="p">:</span> <span class="s">&quot;Delete&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">in</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">deleteItem</span><span class="p">(</span><span class="nl">at</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">editAction</span> <span class="o">=</span> <span class="n">UITableViewRowAction</span><span class="p">(</span><span class="nl">style</span><span class="p">:</span> <span class="p">.</span><span class="k">default</span><span class="p">,</span> <span class="nl">title</span><span class="p">:</span> <span class="s">&quot;Edit Tags&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">in</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">editTags</span><span class="p">(</span><span class="k">for</span><span class="o">:</span> <span class="n">indexPath</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">editAction</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="bp">UIColor</span><span class="p">(</span><span class="nl">displayP3Red</span><span class="p">:</span> <span class="mi">60</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="nl">green</span><span class="p">:</span> <span class="mi">148</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="nl">blue</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nl">alpha</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">deleteAction</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">.</span><span class="n">red</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">deleteAction</span><span class="p">,</span> <span class="n">editAction</span><span class="p">]</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a id="markdown-calayer--cashapelayer--core-graphics" name="calayer--cashapelayer--core-graphics"></a></p>

<h2>CALayer &amp; CAShapeLayer &amp; Core Graphics</h2>

<p>这一块的内容太多，希望有时间可以单独总结一下。</p>

<p><a id="markdown-音乐术语英语" name="音乐术语英语"></a></p>

<h2>音乐术语英语</h2>

<p><a href="https://zhuanlan.zhihu.com/p/35999407">音乐术语英文名称汇总</a></p>

<p><a id="markdown-swift中构造方法designatedconvenience" name="swift中构造方法designatedconvenience"></a></p>

<h2>swift中构造方法designated，convenience</h2>

<p>官方文档中有如下描述：</p>

<ol>
<li>子类designated构造方法中必须调用父类的designated构造方法。</li>
<li>convenience构造方法中必须调用当前类的构造方法。</li>
<li>convenience构造方法归根结底要调用到designated构造方法。</li>
</ol>


<p><img src="http://hongchaozhang.github.io/images/swift_init_method.webp" alt="swift init methods" /></p>

<p><a id="markdown-参考" name="参考"></a></p>

<h3>参考</h3>

<ul>
<li><a href="https://www.jianshu.com/p/e2cce123a5af">Swift之init构造方法</a></li>
</ul>


<p><a id="markdown-笔记绘制功能" name="笔记绘制功能"></a></p>

<h2>笔记绘制功能</h2>

<p>通过第三方库<a href="https://github.com/e7711bbear/ATSketchKit">STSketchKit</a>实现笔记功能支持Undo/Redo操作。官方介绍如下：</p>

<blockquote><p>ATSketchKit is a drawing / sketching framework for iOS written in Swift.</p>

<p>It can be used as the foundation for an artistic app, a simple signature feature or more inteligent graph designing app.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[帮助练习钢琴视奏的应用SightReading]]></title>
    <link href="http://hongchaozhang.github.io/blog/2021/02/26/an-app-to-help-piano-sight-reading/"/>
    <updated>2021-02-26T14:47:28+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2021/02/26/an-app-to-help-piano-sight-reading</id>
    <content type="html"><![CDATA[<!-- more -->


<p>参考<a href="https://github.com/hongchaozhang/SightReading">SightReading</a>获取应用代码和详细使用方法。</p>

<h2>类图和数据结构</h2>

<p><img src="http://hongchaozhang.github.io/images/SightReadingClassDiagram.jpg" alt="SightReadingClassDiagram" /></p>

<p>标签保存在UserDefault里面，数据格式如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;ALL_TAGS&quot;</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;tag1&quot;</span><span class="p">,</span> <span class="s2">&quot;tag2&quot;</span><span class="p">,</span> <span class="s2">&quot;tag3&quot;</span><span class="p">],</span>
</span><span class='line'>    <span class="nt">&quot;天空之城1&quot;</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;tag1&quot;</span><span class="p">,</span> <span class="s2">&quot;tag2&quot;</span><span class="p">],</span>
</span><span class='line'>    <span class="nt">&quot;天空之城2&quot;</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;tag2&quot;</span><span class="p">,</span> <span class="s2">&quot;tag3&quot;</span><span class="p">],</span>
</span><span class='line'>    <span class="nt">&quot;巴赫小步舞曲&quot;</span> <span class="p">:</span> <span class="p">[</span><span class="s2">&quot;tag1&quot;</span><span class="p">]</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于乐谱“天空之城1”，保存的文件名如下：</p>

<ol>
<li>乐谱图片：天空之城1.png</li>
<li>笔记图片：天空之城1&amp;-note.png</li>
<li>每小节位置和大小文件：天空之城1.json</li>
</ol>


<p>其中json文件格式如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;basic info&quot;</span> <span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;tempo&quot;</span> <span class="p">:</span> <span class="s2">&quot;90&quot;</span><span class="p">,</span> <span class="err">//</span> <span class="err">每分钟节拍数</span>
</span><span class='line'>        <span class="nt">&quot;meter&quot;</span> <span class="p">:</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="err">//</span> <span class="err">每小节节拍数</span>
</span><span class='line'>        <span class="nt">&quot;maskOffset&quot;</span> <span class="p">:</span> <span class="s2">&quot;1&quot;</span> <span class="err">//</span> <span class="err">Mask偏移</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="nt">&quot;bar frames&quot;</span> <span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="err">1</span> <span class="err">:</span> <span class="err">CGRect(0.01,</span> <span class="err">0.02,</span> <span class="err">0.11,</span> <span class="err">0.12),</span> <span class="err">//</span> <span class="err">小节序号和小节位置大小（是一个比例值，相对于整个乐谱图片的大小），最终显示的时候需要根据实际显示的乐谱的大小算出每个小节的位置和大小</span>
</span><span class='line'>        <span class="err">2</span> <span class="err">:</span> <span class="err">CGRect(0.13,</span> <span class="err">0.03,</span> <span class="err">0.12,</span> <span class="err">0.11),</span>
</span><span class='line'>        <span class="err">.</span>
</span><span class='line'>        <span class="err">.</span>
</span><span class='line'>        <span class="err">.</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>数据备份</h3>

<ol>
<li>百度云盘下载（<em>/MyDocument/歌谱简谱五线谱/SightReading应用数据备份20211207/mstr.SightReading.2021-12-07.xcappdata.zip</em>）</li>
<li>解压得到<em>.xcappdata</em>文件，Mac右键“Show Package Content”。</li>
<li><em>/App/Data/Documents/</em>目录下保存着上面说的图片和json文件，<em>/App/Library/Preferences/</em>目录下保存着UserDefault对应的plist文件。</li>
<li>xcode连接ipad，点击<em>window->Devices and  Simulators</em>，选中iPad和SightReading应用。</li>
<li>点击下面的齿轮按钮，选择<em>Replace container&hellip;</em>，将解压出来的<em>.xcappdata</em>文件替换一下就可以了。</li>
</ol>


<h2>一些其它问题</h2>

<h3>移动Mask时换页的逻辑</h3>

<p>在前一页最后一些节需要显示Mask的时候直接换页到下一页，因为这个时候演奏者已经看完了前一页的最后一小节，并且需要预读下一页的第一小节。</p>

<h2>TODOs</h2>

<ol>
<li>笔记页面不能改变图片大小，比如转屏、全屏等，因为绘制等path坐标没有做相应的更改，会错位。</li>
<li>笔记页面的橡皮擦功能还不支持。现在的橡皮擦功能实际上就是不同颜色的画笔功能，需要真正实现橡皮擦功能，需要对所有的<code>ATShapeLayer</code>进行修改，添加一个完全透明的橡皮擦的path。</li>
<li>标签本身不支持编辑功能，比如修改标签名称、删除标签。</li>
<li>界面只支持英文，需要翻译成中文。</li>
<li>对于变节拍的乐曲还不支持。如果某些小节拍数会变化，那么节拍器和Mask显示逻辑需要重新考虑。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android内存分析工具]]></title>
    <link href="http://hongchaozhang.github.io/blog/2020/10/29/tools-for-profiling-android-memory/"/>
    <updated>2020-10-29T17:29:30+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2020/10/29/tools-for-profiling-android-memory</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>使用Android Studio自带的Profile工具</h2>

<p>必看的两篇官方文档：</p>

<ul>
<li>View the Java Heap and Memory Allocations with Memory Profiler： <a href="https://developer.android.com/studio/profile/memory-profiler">https://developer.android.com/studio/profile/memory-profiler</a></li>
<li>Manage your app&rsquo;s memory： <a href="https://developer.android.com/topic/performance/memory">https://developer.android.com/topic/performance/memory</a></li>
</ul>


<p>选看的一篇官方文档：</p>

<ul>
<li>Overview of memory management：<a href="https://developer.android.com/topic/performance/memory-overview">https://developer.android.com/topic/performance/memory-overview</a></li>
</ul>


<h2>Use MAT for profiling Android memory</h2>

<p>参考：<a href="https://stackoverflow.com/questions/24547555/how-to-analyze-memory-using-android-studio">How to analyze memory using android studio</a></p>

<ol>
<li>First, you have install <strong>MAT</strong> ( <a href="https://www.eclipse.org/mat/downloads.php">download</a> )</li>
<li>In Android Studio open Android Device Monitor or DDMS.</li>
<li>Select your process &ldquo;com.example.etc..&rdquo;</li>
<li>Click Update Heap above the process list.</li>
<li>In the right-side panel, select the Heap tab.</li>
<li>Click in Cause GC.</li>
<li>Click Dump HPROF file above the process list.</li>
<li>When we downloaded the file HPROF, we have to open the Terminal and run this command to generate the file to open it with MAT.</li>
<li>Open terminal and run this command “./hprof-conv path/file.hprof exitPath/1. heap-converted.hprof”. The command &ldquo;hprof-conv&rdquo; is in the platform-tools 1. folder of the sdk.</li>
<li>And ready and MAT can open and open the converted file ( heap-converted.hprof ) .</li>
</ol>


<h2>如何在Android Studio 3.0里面打开DDMS？</h2>

<p>自从Android Studio进入3.0，DDMS就被偷偷的隐藏起来了。参考下面的文章看如何打开DDMS。</p>

<p>Android Studio启动DDMS <a href="https://blog.csdn.net/llfjfz/article/details/70213723">https://blog.csdn.net/llfjfz/article/details/70213723</a>
注意：需要关闭Android Studio。</p>

<h2>在Android Studio中保存hprof文档</h2>

<p>在Android Studio将DDMS偷偷隐藏起来的同时，DDMS的一些工具已经集成到Android Studio里面了。比如这个获取hprof文件的方法。</p>

<p>该方法不需要打开DDMS，直接用Android Studio的Profile工具即可。</p>

<p><a href="https://developer.android.com/studio/profile/memory-profiler#save_the_heap_dump_as_hprof">https://developer.android.com/studio/profile/memory-profiler#save_the_heap_dump_as_hprof</a></p>

<h2>Mat启动报错</h2>

<p>下载的Mat在打开的时候会报错。错误信息如下：</p>

<p>java.lang.IllegalStateException: The platform metadata area could not be written: /private/var/folders/7b/3wj5jwnd1yg98w2yzmn36qwr0000gq/T/AppTranslocation/C98006F4-54ED-44FB-9F3E-AC7C1EB9519B/d/mat.app/Contents/MacOS/workspace/.metadata.  By default the platform writes its content under the current working directory when the platform is launched.  Use the -data parameter to specify a different content area for the platform.</p>

<p>解决方案参考这片文章：<a href="https://www.jianshu.com/p/9bbbe3c4cc8b">Eclipse Memory Analyzer在Mac启动报错</a></p>

<p>注意：右键打开Mat package，可以找到上面说的MemoryAnalyzer.ini文件</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[薛兆峰-少年经济学]]></title>
    <link href="http://hongchaozhang.github.io/blog/2020/10/18/shaonianjingjixue/"/>
    <updated>2020-10-18T13:37:17+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2020/10/18/shaonianjingjixue</id>
    <content type="html"><![CDATA[<!-- more -->


<h1>需求</h1>

<h3>01 谁是隐藏在你身边的隐形玩家？（认识经济学）</h3>

<h3>02 人是自私的，还是无私的？（亚当斯密的人性观）</h3>

<p>亚当·斯密认为人本来是自私的，但同时他们也有同情心，也能爱别人，但爱心是随着人与人之间的距离增大而减少的。
当爱心不够的时候，人与人之间又需要大量的扶持、帮助和协调。那该怎么办呢？我们就只能依靠市场的力量，市场是陌生人和陌生人之间互相合作、互相帮助、互相协调的场所，所以<strong>小圈子讲爱心，大圈子讲规则</strong>，不要混淆了。</p>

<h3>03 从留声机到MP4，谁在推动进步？（稀缺与需求无限）</h3>

<p>当人们的需求被满足的时候，新的需求又会产生。比如房子，没有房子的时候，我们觉得要有个地方住就好了；有地方住了，你又想住得大一点；空间够大了，你又会想室内的布置要更有品位一点，家里的设施要更全面一点、更现代化一点、更美观一点；都有了，你又想你家的位置要更方便一点；到市中心够方便了，你又想闹中取静。总之，你对居住的需求是不会满足的。这就产生了稀缺。</p>

<p><strong>稀缺是一个基本的事实，它源于人们的需求，人的需求是无止境的、不断升级的，这就造成了稀缺。</strong></p>

<h3>04 东西越便宜，卖得越好吗？（需求第一定律）</h3>

<h4>需求第一定律</h4>

<p>对同一件商品而言，当价格提高的时候，人们对它的需求量就会减少；当价格降低的时候，人们对它的需求量就会增加。</p>

<p>这背后的原因是，人们总会在乎他们为了享受一种服务、得到一件商品所需要付出的代价，而在乎代价是基本的人性。所以说需求第一定律是对人性的一种基本描述。</p>

<h3>05 谁让乘客变成了司机？（需求第一定律）</h3>

<p>当价格比较低的时候，人们是需求者。当价格高到一定程度的时候，人们就会从需求者变成供给者。所以，<strong>需求和供应之间并没有绝对的区分，它们之间的转换取决于商品或服务的市场价格。</strong></p>

<h3>06 买赔买赚，谁说了算？（需求第一定律）</h3>

<h4>剩余</h4>

<p>剩余，通常是在买家和卖家之间瓜分的，谁得多一点，谁得少一点，并不存在客观的、不可改变的标准，所以我们既不应该把这个剩余叫做消费者剩余，也不应该把这个剩余叫做生产者剩余，更合适的叫法应该是<strong>交易剩余</strong>。</p>

<p>因为交易买卖双方都占了便宜，都得到了好处，都觉得值得。只要自己能享受到剩余，这交易就是值得的，我们应该以这样的平常心来对待日常生活中我们所做的交易。</p>

<h3>07 如何分辨奢侈品和必需品？（需求第二定律）</h3>

<h4>弹性</h4>

<p>弹性这个概念对咱们理解需求第二定律是非常重要的，简单地说，<strong>弹性就是价格的变动对需求量变动所产生的影响。</strong></p>

<ol>
<li>弹性指的是价格的变动对需求量的变动所产生的影响，影响越大，弹性就越大；影响越小，弹性就越小。</li>
<li>弹性大的商品是奢侈品，弹性小的商品是必需品。</li>
<li>同样一件商品在不同的价位上弹性也是不一样的，价位越高弹性就越高，它就越有可能被看作是奢侈品；价位越低弹性越低，它就越有可能被认为是必需品。</li>
</ol>


<p>你现在能够理解为什么平时比较贵的进口零食，忽然打折的时候你去购买的欲望就会变得特别强烈了。</p>

<h3>08 有不可替代的商品吗？（需求第二定律）</h3>

<h4>需求第二定律</h4>

<p>当价格发生变动以后，人们会去寻找一些更好的替代方案，而时间越长，找到替代方案的机会也越大，换句话说，需求弹性也变得越来越大了。</p>

<p>这就是<strong>需求第二定律</strong>的核心含义——<strong>每当情况发生变化，而时间越长，人们针对这种变化所做的调整也就会越来越充分。</strong></p>

<p>让我再举一个例子。比如说我们来看石油价格和汽车车型之间的关系。</p>

<p>石油价格刚刚上涨的时候，人们对汽油的需求量可能并没有减少，那是因为人们已经买车了，车的型号改不了了，它的耗油量固定了。</p>

<p>但是随着时间的推移，如果汽油价格还是居高不下的话，人们在原来的汽车用旧了得重新再买汽车的时候，就会选择那些耗油比较少的车型，这时候人们针对汽油价格上涨所做的反应也就越来越充分了。</p>

<p>这就是需求第二定律所要讲的道理。</p>

<h3>09 快递费该谁出？（需求第二定律）</h3>

<h4>法律无效定律</h4>

<p>交易税费到底是由谁承担的，并不取决于法律规定是由谁承担的，而取决于买卖双方谁更迫切地想要完成交易。那些更迫切想要完成交易的一方，会通过这样那样的办法主动地去承担税费。</p>

<p>在经济学里，这个规律有一个有趣的名字，叫法律无效定律（The Law of the Irrelevance of the Law）。</p>

<p>法律无效定律是需求第二定律的一个重要应用。</p>

<h3>10 特产当地买最好吗？（需求第三定律）</h3>

<h4>需求第三定律</h4>

<p>附加成本使得好东西更划算</p>

<p>需求第三定律要说的是，如果你在买东西的时候，还要支付一笔附加的费用，比如说运输费、税费、人力成本费等等，而这笔附加的费用越高，咱们就越是应该去选择那些品质更高、价格更高的商品，原因在于：反正都是要支付这笔附加费了，这时候买品质高一点、价格也因此高一点的产品会更合算。</p>

<h4>需求第三定律应用</h4>

<p><strong>音乐会</strong></p>

<p>假如今天晚上有两场音乐会，一场是由当地的乐团演出的，而另外一场是由远道而来的外国乐团演出的。那你觉得这两场音乐会哪一场会更精彩呢？</p>

<p>根据今天我们讲的需求第三定律，我们反过来可以推测，那当然是来自国外乐团的演出更精彩了，因为他们远道而来，会发生许多的交通、住宿、生活、保险费用，加起来肯定是一笔昂贵的附加费。</p>

<p>这笔附加费越贵，远道而来的乐团质量就应该越高，只有高质量的乐团才配得上这样的附加费，否则就亏了。</p>

<p><strong>印刷</strong></p>

<p>我再给你举一个例子，在200多年前，要印一本书可不容易了，成本可高了， 那时候一般的家庭可能根本没什么藏书可言，买得起一两本书就算得是奢侈品，就不错了。而正是由于印刷的费用特别高，所以那时候只有内容特别好的书才值得被印刷、被销售、被传阅、被保留。</p>

<p>那是些什么书呢？那是一些经典之作。</p>

<p>而今天，印刷成本已经大幅下降了，出一本书成本不算高了，所以今天各种出版物的质量也就参差不齐了。</p>

<p>在过去印刷成本非常高，所以出版物的平均质量也非常高，但这不是好事儿，因为人们的选择太少了。而今天印刷的费用急剧下降，出版物的平均质量因此也下降了，但这是好事儿，因为人们的选择比以前多多了。</p>

<h1>边际</h1>

<h3>11 表扬越多越有用吗？（边际效用递减）</h3>

<h4>边际</h4>

<p>边际指的是新增带来的新增。</p>

<p>边际成本就是每新增一个单位的产品所要新增的成本；边际收入就是多卖一个产品，你所能够获得的额外的收入；边际产量是你多增加一份投入以后，你所能够获得的新增的产量；而边际效用是你多消耗一个单位的产品所能够获得的新增的享受。</p>

<p>而我们说这种新增带来的新增，无论是产量、收入还是享受，总有一个递减的过程。</p>

<p>学完了这一节以后，下次当你特别想吃冰激凌的时候，你就知道应该吃到什么程度就停下来了，否则的话，享受冰激淋的边际效用就会不断递减，甚至成为负数，也就是变成折磨了。</p>

<h3>12 死磕优势学科，效果好吗？（边际平衡）</h3>

<h4>边际平衡</h4>

<p>通过这一节死磕英语的故事，你明白了一个关键的原理叫边际平衡。</p>

<p>就是说当你要追求多个目标的时候，你应该把自己有限的资源，分配到那些能够给你带来最大边际收益的活动上面去，最终使得你付出的每一份资源，在不同的活动当中所取得的边际收益相等，而这个时候你能够获得的总收益就能够达到最大。</p>

<p>根据这个原则，你就能够把自己有限的时间、精力、金钱，分配到不同的活动、不同的项目、不同的目标上去，从而使自己得到的总收益达到最大。</p>

<h1>成本</h1>

<h3>13 评选优秀学生是歧视？（选择与歧视）</h3>

<p>歧视是不可避免的，凡是有选择的地方，我们就必须采用某些标准，而无论这个标准怎么定，都会被别人说成是具有歧视的成分。不被人批评为歧视的选择标准是不存在的，那是因为歧视本来的含义就是区别对待。</p>

<p>人们之所以要进行区别对待，最根本的原因就在于有价值的经济资源都是稀缺的，都是被人们所争夺的。而要确定谁能得到，谁不能得到，咱们就必须做出区别对待。</p>

<p>歧视是有代价的。你选择歧视，同时承担歧视带来的代价就好了。</p>

<h3>14 歧视别人，你失去了什么？（竞争与歧视）</h3>

<p>越是竞争激烈的地方，歧视的代价越大，歧视就越少见；相反，在一些落后的地方，歧视的代价很小，歧视就会非常严重。</p>

<p>这个观点也有助于理解为什么在那些竞争非常激烈的行业里面，员工的行为举止、穿着打扮往往都是比较随意的了。</p>

<h3>15 改变特征（歧视与成长）</h3>

<p>人们有时候会因为某些特征受到别人的歧视。如果改变这些特征需要花费太大的代价的话，那么他们就不如另谋出路，在自己擅长的领域求发展，从而弥补自己受到歧视所带来的损失，这样才是更积极的人生态度。</p>

<h3>16 没有中间商，买东西更划算？（成本）</h3>

<p>在做决策的时候，你要权衡的是全部成本，而不仅仅是货币成本。而在大多数的情况下，中间商是在帮我们减少成本，而不是增加成本的。</p>

<h3>17 投入了那么多就不该放弃？（沉没成本）</h3>

<p>沉没成本指的是那些已经付出了的、没有办法再收回的投入。</p>

<p>关于沉没成本我要告诉你一种说法，叫做<strong>沉没成本不是成本</strong>。</p>

<p>它的意思是如果你为了某个目标已经做出了投入，而这些投入是没有办法再收回的，那你在决定是否继续追加投入的时候，就不应该考虑这一部分已经做出了投入，而且没有办法收回的投入。</p>

<p>我们不应该让这一部分沉没成本，影响我们对未来的决策，所以我们说沉没成本不是成本。</p>

<h3>18 为什么火车上的盒饭卖得贵？（供需决定论）</h3>

<p>价格不由成本决定，由需求决定</p>

<p>经济学认为，不是商品的成本决定了商品的最终价格，而是最终商品的供应和需求情况决定了产品的价格，而这个价格再反过来进一步决定了生产这种商品的原材料成本。</p>

<h3>19 小组作业怎么分工最合理？（比较优势）</h3>

<p>人们在合作的时候应该考虑到比较优势，那就是按照每个人自己的特长，自己跟自己相比的优势。</p>

<p>如果每个人都把有限的时间和精力专注在自己擅长的工作上，然后进行合作和交易，这样整个社会的效益都能得到提高，而每个人的处境都会得到改善。</p>

<h3>20 贸易顺差、逆差无所谓？（贸易顺差与逆差）</h3>

<p>在一个高度分工合作的社会里，任何交易的双方哪怕长期保持贸易顺差或者贸易逆差的关系都是极其正常的事情。</p>

<p>长期而言，整体而言，每一个国家、每一个个人都是能够保持收支平衡的。</p>

<h3>21 贸易报复值得吗？（贸易报复）</h3>

<p>贸易报复其实是不必要的，因为它会进一步增加了自己所蒙受的伤害。经济学的观点认为，只要贸易有好处咱们就应该进行贸易。</p>

<h3>22 为什么不能随便拿别人的东西？（公平与效率）</h3>

<h4>马粪的故事</h4>

<p>原告将路上的马粪辛苦地堆积起来，放在一起，然后回家拉车去了。被告看到堆积好的马粪，就用车拉走了。</p>

<p>如果你是法官，你会把马粪判给谁呢？</p>

<p>当然，要是很较真的话，你会说这马粪的真正主人是马，马粪是马拉的，或者说第二个主人是马的主人。</p>

<p>在这个案子里面这点确实是辩论过的。他们双方原告和被告都认为，马粪的第一个主人就是马的主人，但是马的主人显然已经放弃了对马粪的拥有权，他把马粪丢在路上了，他已经走了。</p>

<p>于是原告说是他自己派两个帮工把马粪堆起来的，他们付出了劳动，所以马粪应该属于他。</p>

<p>但被告说不对，这马粪掉到地上，它就是属于地上的一部分，这块地是公家的，所以不属于原告。原告让帮工把马粪堆起来，只是改变了马粪所在的位置，并没有改变它们原来的所有权，所以马粪不归原告所有。</p>

<p>其实这堆马粪究竟归谁所有并不是太重要，重要的是<strong>这个判决本身对以后的社会会产生什么样的影响。</strong></p>

<p>我们不妨先来设想一下，这个世界有两个村子发生同样的案子。唯一的不同是在第一个村子里面，法官把马粪判给了原告，也就是堆积马粪的人；而在第二个村子里，法官把马粪判给了那个看见马粪就把马粪拿走的人。如果是这么分别做出判决的话，那么再过50年，再过100年，这两个村子会发生什么样的变化？</p>

<p>你想想看，在第一个村子里面，由于把马粪判给了创造财富的人，那么生长在这个村子里的人就会知道，凡是集聚了人类劳动的财富，你就不能随便拿走它，你就要预想它应该是有主人的，你应该尊重别人的财富，不能看见好东西就拿走。
所以这个村子里的人就用不着把所有的力气都放在保护财产上面，人们会安心地、积极地去创造财富、积累财富，于是这个村子不仅能够活下来，而且会活得越来越好。</p>

<p>但在另外一个村子里，堆积起来的马粪判给了看见马粪就拿走的人。有了这个判决，村里的人都会想，你只要看见别人的东西没人看管，你就可以把它拿走。这样下去人们就总在担心自己的东西会被别人拿走，所以他们就会花大量的时间精力，用在保护自己的财产上面，整天琢磨着怎么才能防止别人抢夺自己的财富。在这样的村子里大家就缺乏积极性去创造财富、积累财富了，或者说他们所积累的财富也会被他们保护财富的努力所抵消。50年、100年后，这个村子就可能消失了。</p>

<h4>公平与效率</h4>

<p>我们社会当中有许多关于公正的标准，它们的背后其实都是有关于效率的考虑做支撑的。</p>

<p>我们在讲公平的时候其实也是在讲效率。公平背后是效率的考量，当然这不是单个人效率的考量，而是整体社会长远发展的效率的考量。</p>

<h3>23 乞丐的施舍是白拿的吗？（寻租）</h3>

<p>寻租，指的是企业为了争取政府的优惠政策，而采取的各种竞争性的活动。这些活动不仅不会对社会带来什么好处，反而会损耗社会资源。</p>

<p>经济学认为，社会当中总会存在竞争，有竞争就会消耗资源。当人们为了争取政府的优惠政策或者权利的时候，有时候消耗的资源是值得的，但有时候消耗的资源就是不值得的。</p>

<h4>小偷对社会的损害</h4>

<p>我们从经济的角度看，贼偷东西并没有减少资源的总量，他只不过是把资源从一个人的口袋转到另外一个人的口袋而已。</p>

<p>图洛克指出贼之所以对社会有害处，最重要的原因是<strong>由于贼的存在，人们增加了防盗的成本。</strong></p>

<p>社会为了防范这些贼得消耗资源，得去做更结实的门，得去做防盗网，得去做锁，而这才是贼的真正害处，这才是贼对社会造成的净损失。</p>

<h1>价格</h1>

<h3>24 一个人能生产出铅笔吗？（市场与分工）</h3>

<p>世界上哪怕是像铅笔这么简单的商品，都从来没有任何一个人能够完全掌握制造它所需要的全部知识。一支铅笔是通过成千上万人的共同努力而制造出来的，而在这个过程中参与制造的人不仅不需要互相认识，而且不需要有统一的行动，不需要有共同的理想，只需要通过市场的协调，铅笔就能够自然而然地造出来了。</p>

<p>而消费者只要付出很小的努力，就能够换取这些由成千上万人的共同努力而生产出来的产品，这是市场最神奇的地方，也是只有人类社会才会有的独特现象。</p>

<p>学完了这一节，你就能够明白我们为什么要强调市场的神奇作用了。</p>

<h3>25 理发的价格为什么差这么多？（价格三作用）</h3>

<p>价格的三个作用：
1. 价格能够非常有效、非常节俭，目标非常明确地传递出某件商品稀缺程度的信息，或者说人们对它的争夺程度的信息。
2. 价格能够指导人们进行生产，指导人们选择不同的生产方式。
3. 价格能够解决奖惩的问题，解决分配的问题，解决谁应该得到什么、得到多少的问题。</p>

<h3>26 最有效的竞争规则是什么？（竞争规则）</h3>

<p>经济学关于竞争的两个结论：</p>

<h4>1. 没有任何一个竞争规则是比别的竞争规则更公平的。</h4>

<p>要讨论哪种方式更公平，可能永远都不会有结果。
因为在不同的规则下面，不同的人就有不同的潜能，在竞争当中胜出的机会就不同。人们在选择一种竞争规则的时候，就已经预见到了谁更可能赢、谁更可能输了。</p>

<h4>2. 不论人们选择哪种规则，规则一旦定下来，人们就会展开各种各样的竞争，而这些竞争本身是带有成本的，是要消耗真实的时间、精力和资源的。</h4>

<p>如果选用的规则是先到先得，那就得浪费排队的时间；</p>

<p>如果选择的规则是学籍，那就要花费很多的时间考取这所大学；</p>

<p>如果分配的规则是跟厨房的师傅处好关系，那可能就得额外去做勤工俭学的工作；</p>

<p>如果分配的规则是要找到这所大学里面的熟人，那维持人际关系也不是没有成本的，也挺费时费力的。</p>

<p>但是如果食堂把馒头的价格开放，价高者得，不愿意付款的就离开，这样对买馒头的人的身份限制就会被解除掉。</p>

<p>这样的话不仅更干脆利落，愿意付费的人就能马上吃到这所学校食堂的馒头，更重要的是人们努力的方向、人们竞争的方向也发生了改变。</p>

<p>他们不再花时间去排队、拉关系，做不必要的勤工俭学，到校园网上寻找了。他们直接努力去挣钱或者省钱就可以了。而在他们努力去挣钱的过程中，他们必然会对社会其他人提供有价值的服务。这时候整个竞争的过程就不仅仅是消耗时间、精力和资源的了，而是能够创造出更多对社会其他人有价值的产品了。</p>

<p>所以按价格的高低来竞争的这种办法，一下子就和其他的竞争办法区分开来了。</p>

<p>它不一定比别的竞争方式更公平，但这种竞争方式是最有效率的，它带来的时间、精力和资源上的损失是最低的。
而同时它带来的效用，也就是因为竞争而额外制造出来的商品和服务又是最多的。</p>

<p>所以我们说按出价的高低来竞争，它的损失最小、产出最大，对整个社会资源的积累最有帮助。</p>

<h3>27 起步价过低，对乘客好吗？（短缺）</h3>

<p>当一件商品的价格被限制住了，价格过低的时候人们就不得不展开价格以外的竞争方式来争夺他们所需要的商品，这时候就会出现短缺。</p>

<p>短缺不是供应的减少，而是商品的价格受到抑制的结果，人们不能仅仅通过出价的方式去竞争，还得依靠其他非价格的方式去竞争，这种现象就叫短缺。</p>

<p>而其它方式相比价格，都是低效的，比如排队。那些根据排队来分配商品的社会总是不那么富裕，因为大家要排队就得浪费时间，而这每一个人排队所浪费的时间，对社会其他人而言都是没有意义的、没有价值的。所以哪怕排队解决了商品分配的问题，但排队本身却造成了时间的浪费。人人都花很多时间来排队，整个社会就是低效的，也就会导致贫穷。</p>

<h3>28 限制房租，能帮助到穷人吗？（价格管制）</h3>

<h3>29 春运火车票难买，怎么办？（价格管制的代价）</h3>

<p>让火车票按照机票的方式自由浮动价格，让大家能够根据自己需求的强烈来进行选择。只要大家都能够自由地选择，就可以不把宝贵的时间和资源浪费在一些不能够创造更多社会价值的事情上了。</p>

<h3>30 健身房为什么要推出各种卡？（价格歧视）</h3>

<p>价格歧视会促进交易。</p>

<h1>时间</h1>

<h3>31 为什么要付利息？（耐心与利率）</h3>

<p>“<strong>不耐</strong>”就是急不可耐的意思。在经济学里，它指的是人们对消费有一种时间上的偏好。
在消费的时候，人都有一种自然的倾向，那就是在其他条件不变的情况下，人们总会觉得，早一点消费总比晚一点消费更好。</p>

<p>如果要劝说别人推迟消费的话，那我们就得把时间因素考虑在内，给对方一定的补偿，弥补别人在时间和风险上做出的牺牲。</p>

<p>影响不耐的因素：
1. 年龄。
2. 想象力。比如我们在人类社会当中有许多伟大的工程：长城、金字塔、大运河，这些工程往往要消耗几代人的努力。
由于工程费时特别长，参与建造的人，他们甚至不能够看见工程竣工的那一天。那他们为什么愿意放弃眼前的消费、眼前的娱乐、眼前的休闲，去参与这么长远的项目呢？
原因当然有很多，但很重要的一点，是想象力。
他们的想象力越强，对未来的憧憬越逼真，他们放弃眼前的消费，克服不耐这种心理惯性，为长远的未来工作的积极性就越强。
3. 时局。在兵荒马乱的年代，大家会觉得，未来特别地不确定。所谓朝不保夕、变幻莫测。在这种情况下，他们的不耐就会更强一点。</p>

<h3>32 放长线为什么能钓大鱼？（利率与现值）</h3>

<h4>贴现率</h4>

<p>贴现率的意思是，未来的价值在今天看来打折的程度。</p>

<p>怎么理解这句话呢？比如我说明年给你100块钱，这100块钱你今天看来值多少钱呢？</p>

<p>这个问题就跟贴现率有关了。如果你把未来看得很不确定，你觉得明年的东西可能都很贵了，或者明年你已经转学到别的地方，很难再找到我了，不确定性很强了。如果是这样，你就会觉得，这100块钱在今天看来不是那么值钱。那这时候，明年的100块钱，它在今天的价值，打折的程度就比较高，也就是贴现率比较高。明年的100块钱折算成今天的价值，就没那么多。</p>

<p>当然，反过来，如果未来很确定，你很有信心拿到这笔钱，你也不在乎当中等待的时间，这时候打折的程度就比较低，贴现率就比较低，那明年的100块钱在今天看来的价值就比较接近那100块钱。</p>

<p>这就是贴现率的概念，也就是在今天看来的未来价值打折的程度。</p>

<p><strong>对未来的预期影响今天的决定。</strong></p>

<h3>33 知识产权保护越长越好？（年金）</h3>

<h4>专利和版权年限</h4>

<p>专利和版权其实是政府对知识产权实施的一种保护，它的目的是为了鼓励发明者做出更多的贡献。</p>

<p>但问题的另外一面是，知识产权的保护期越长，它就越不容易被公众免费地使用，它能带来的经济效益就很难达到最大化。
所以，版权保护期也应该适可而止，让知识产权为全人类所共同拥有，共同免费地使用，这也能促进公众的最大利益。</p>

<p>所以，权衡利弊，关键的问题是，知识产权的保护期应该设置多长才是合适的呢？</p>

<h4>年金</h4>

<p>要回答上面这个问题，我们就要用到经济学里面关于年金的概念。</p>

<p>年金指的是持续多期的收入。</p>

<p>我今年赚1块钱，明年赚1块钱，后年我还是赚1块钱，每一年都赚1块钱，这些持续多期的收入加起来，就称为年金。
一份年金是多期的收入，它的总价值，也就是今天价值的总和，跟两个因素有关。</p>

<p>第一，是期数。你收多少期，10期，20期，还是永久。</p>

<p>第二，是我们上一节课介绍过的贴现率。也就是未来价值折算成今天价值的转化率，折扣率。</p>

<p><strong>一份年金的当前价值，大部分是由离现在比较近的收入所构成的。</strong>而离现在比较远的收入，哪怕总的期数很多，它对年金现值的贡献也是比较少的。</p>

<p>举个例子说，如果有人答应你，每年给你1块钱，今年1块钱，明年1块钱，后年1块钱，永远地给下去。而在10%的贴现率下，这一个每年给你1块钱的承诺，它今天的价值就刚好等于10块钱，这10块钱虽然是未来无限期的收入所构成的，但这份永久年金前50年的收入就已经占据了10块钱当中的9块9毛钱之多。</p>

<h4>从年金的角度看待米奇老鼠版权的无限延长</h4>

<p>明白了年金这个道理，我们就能够更好地理解，为什么经济学家反对迪士尼公司不断地把米老鼠的版权期限延长又延长了。</p>

<p>那是因为，之所以要保护米奇老鼠的版权，是为了鼓励当时的发明者，而当时的发明者已经早就去世了，这后来的收入对当时的发明者来说是微不足道的。</p>

<p>通过版权保护来鼓励发明创造的功能，已经发挥完毕了，剩下来的知识产权本来就应该进入公共领域，被全人类所免费使用，这样才能够发挥知识产权对社会的最大作用。</p>

<h3>34 你是哪种风险偏好？（保险与储蓄）</h3>

<p>人们用来抵御风险、未雨绸缪的两种基本方式，那就是储蓄和买保险。不愿意为自己医疗费用买保险的人，他们其实是在赌自己不会生病，不会因为生病而支付巨大的医疗费用。<strong>不爱买保险的人其实就是爱冒险的人。</strong></p>

<h3>35 股价可以预测吗？（信息与股价）</h3>

<p>股价由消息决定。
股票系统消化一条消息的时间只需要几毫秒，再晚一点，那就算完全晚了。
所以你想想，一个普通人，再快，他可能是第一个知道消息的人吗？他可能是第一个做出反应的人吗？这简直不可能。</p>

<h3>36 经济学家如何破解氢弹秘籍？（有效市场假说）</h3>

<p>有效市场假说认为：商品或资产的价格其实已经反映了关于这个商品或资产价值的所有信息。</p>

<p>每当事情发生了新的变化，形成了新的消息，这个新的消息就会被人们接受，并且消化，然后迅速地体现在对资产价值的重新估算和调整上面。</p>

<p>根据传播和消化新消息的顺畅程度的不同，有效市场假说也分为三个不同的版本。</p>

<ol>
<li>第一个最弱的版本是说，市场上所有跟价格相关的数字，基本上都被人们消化了。你不用再去研究了，研究了也没多大价值。</li>
<li>第二个更强一点的版本是说，不仅仅是那些关于价格的数字，而且所有的非数字化的公开信息，包括政府文件、公司年报、新闻、公告甚至是揣测，都被人们消化了，你不用再去研究了。此时此刻，资产的价格已经充分地反映了所有这些信息了。</li>
<li>而有效市场假说的最强的一个版本是说，不仅仅是那些关于价格的数字，也不仅仅是那些公开的信息，就连那些秘密，包括私人手上不为人知的消息，以及政府的机密，其实都已经走漏消息了。这些消息也被人们理解、消化，并体现在具体资产的价格上了，你都不需要做研究了。</li>
</ol>


<p>当然，也有经济学家不同意这种看法。事实上存在着另外一派的经济学家，他们认为市场其实是存在泡沫的，他们认为人往往是非理性的，资产的定价有时候过高，有时候过低，人的反应有时候不足，有时候又过激，所以价格在传递信息方面并不完全有效，市场是存在泡沫的。</p>

<p>上面的人的非理性的说法也可以归纳进有效市场假说的范畴：有效市场假说说的是，知识和规律一旦被人们掌握，就会融入到人们对新消息的理解过程当中去，所以哪怕是希勒教授所讲的泡沫理论是对的，也就是说哪怕很多人会有不理性的行为，但这些不理性的行为一旦形成规律，一旦能够被人们所掌握，那么这种不理性的行为也就变得可以预测了。这时候影响股票价格的因素也仍然是那些不能确定的新的消息。</p>

<h1>产权</h1>

<h3>37 为什么不能以大欺小？（权力与能力）</h3>

<p>动物的竞争靠能力，人类的竞争靠权力。</p>

<p>人类社会和动物界都有竞争，但是动物界靠的是身体的能力，而人类社会靠的是迂回的竞争和权利的保护这个道理。能力和权利之间是有根本的区别的，能力取决于凭一己之力你能够占有多少，而权利取决于别人，社会的其他人愿意给你多少，认可你多少。</p>

<h3>38 你的权利从何而来？（权力来自错误）</h3>

<h4>权力来自哪里</h4>

<p>德肖维茨有本书，叫《你的权利从哪里来》。他认为人的权利不来自于神，不来自于自然，不来自于逻辑，也不来自于法律。他说，权利来自于人类的经验，尤其是那些惨痛的经验和人类所犯下的巨大的错误。</p>

<p>每当我们经历了惨痛的经验，反省自己犯下的巨大的错误以后，我们就会想避免重蹈覆辙。于是，我们就会逐渐建立起对权利的约定、对权利的安排，目的就是要避免错误，减少损失，防止一错再错。</p>

<p>你看，德肖维茨的观点很实际，也符合人类历史发展的事实。很多我们今天认为理所当然的权利，其实就是这么一点一滴，从有人提出，再有人实践，后来越来越多人赞成，最后把它们上升为法律条文，成为人们明文遵守的规则的。</p>

<h4>权力之间的冲突与平衡</h4>

<p>德肖维兹指出，许多我们认为理所当然的权利，这些权利之间，它们本身就是有冲突的。怎么找到这些互相冲突的权利之间的平衡点，才是我们要处理的关键问题。</p>

<p>一个人有言论自由的权利，但它跟另外一个人不受别人冒犯的权利，这两种权利之间就会有冲突；抽烟的人有抽烟的权利，但对于那些拒绝吸二手烟的人来说，他们的健康权和别人抽烟的权利就会产生冲突；人有吸取营养的权利，但有些人认为，动物也应该有不被吃掉的权利，这两种权利也会发生冲突。</p>

<h3>39 什么才叫你拥有一样东西？（产权的三环）</h3>

<p>要判断人们是不是对一件物品拥有完整的产权，你必须关注产权的三个环节，这三个环节分别是使用权、收益权和转让权。在这三者当中，转让权是最重要的，因为转让权意味着永久地占有使用权和收益权。</p>

<h3>40 为什么课堂上不能随便发言？（自由并不免费）</h3>

<p>通过这一节言论自由的故事，你明白了一个道理，那就是人们要行使各种各样不同的权利，行使各种各样不同的自由。</p>

<p>但在这个过程中，都必须动用经济资源，而经济资源并不是免费的，它们是有主人的，每个人在行使政治权利、言论自由的时候，必须尊重别人的经济产权，因为经济资源、经济产权也是人们非常重要的权利，它跟其他的权利是平等的。</p>

<p>现在，你就能够明白，以后应该怎么样去看待那些在公共场合，利用公共资源，看似义正辞严，说是维护自己权利的行为了。</p>

<h3>41 为什么要给知识付费？（知识产权）</h3>

<p>修理摩托车时，检查了两个小时，只换了一个很小的零件，但是收费却不低，因为只是也是需要付费的。</p>

<h3>42 为什么咖啡厅愿意提供wifi？（公共服务的提供）</h3>

<p>航海灯塔的边际成本几乎为零，并不是说灯塔需要免费提供。毕竟，建造灯塔的本身还是需要付出大量的维护成本的。</p>

<h4>公共服务也是可以收费的</h4>

<p>当政府修建了一条隧道，为市民提供交通服务的时候，它当然可以选择免费提供这种服务。但同时，它也可以选择收费。
而如果政府收费的话，它能够同时达到两个效果：</p>

<ul>
<li>第一，就是筛选需求。</li>
<li>第二，进行经济核算。以便作出进一步决策，比如，确定要不要再修一条。</li>
</ul>


<h3>43 解决堵车问题，靠什么？（产权与治堵）</h3>

<p>通过这一节治理拥堵的故事，你明白了收取拥堵费，筛选的不是贫富而是需求的道理。拥堵使得道路变成了停车场，造成的资源的极大损耗。在高峰期有偿使用道路，是解决问题的一个公平合理而且有效的办法。当然，政府收取了拥堵费以后，也应该对这一笔钱进行妥善的管理和使用。</p>

<h3>44 产权冲突时，谁来负责？（产权的冲突）</h3>

<p>谁避免意外的成本更低，谁就应该为避免意外做出相应的牺牲。</p>

<p>回到故事里，铁路公司和农夫都对自己的东西拥有产权，但是双方在行使权利的时候却发生了冲突，看起来最后的结果是铁路公司的火星烧着了农夫的亚麻，但责任并不一定要划到铁路公司头上。避免意外的责任也可以由农夫来承担，因为农夫避免意外所要付出的成本比铁路公司所要付出的成本低得多。谁付出的成本更低，谁就应该担当更大的责任。因为只有这样来分摊避免意外的责任，整个社会为了避免意外所要付出的总成本才会达到最低。</p>

<h1>信任</h1>

<h3>45 为什么人们不能彼此信任？（信息不对称）</h3>

<p>信息不对称。它的意思是，在各种合作和交易的过程当中，每个人所掌握的信息是不一样的。而由于他们掌握的信息不一样，他们因此也就不容易完成交易，达成合作。</p>

<h3>46 麦当劳优质在哪？（优质产品）</h3>

<p>优质产品：
1. 品质稳定
2. 性价比高</p>

<h3>47 申请学校为什么要写推荐信？（第三方背书）</h3>

<p>经济学认为，推荐信是解决信息不对称、增加人与人之间信任的一种重要的方式。花费大量的时间、精力来准备一封好的推荐信，往往是值得的。</p>

<p>实际上，在现实生活当中，要解决人与人之间的信息不对称问题，增加人与人之间的信任，可以采用的方式大概有三种。那就是重复交易、第三方背书和增加附加成本。</p>

<p>我们怎么来理解这三种方式呢？我们一个一个来看吧。</p>

<h4>1.重复交易</h4>

<p>如果人们知道将来会重逢，就会减少欺骗的行为。</p>

<p>你可以设想一下，在过去咱们爷爷奶奶生活的年代里面，他们生活的环境是熟人社会，家家户户住得很近，祖祖辈辈都认识，谁做了不地道的事情，人们总能够找到他，总会记住他，口碑一旦不好了，信任也就不存在了。</p>

<p>所以，重复交易是克服信息不对称问题、增加信任的一个好办法。</p>

<h4>2.第三方背书</h4>

<p>推荐信</p>

<h4>3.增加附加值</h4>

<p>第三个增加人与人之间信任的办法，就是增加附加值。你还记得我们讲的需求第三定律“好东西运到远方去定律”吗？它的意思是说，每当一个产品加上一个更高的附加值，那就只有那些品质更高的产品，才配得上这个更高的附加值了。所以倒过来，人们会根据一件产品所配置的附加值的高低，来判断这件产品质量的高低。如果厂家提供的产品质量是有问题的，那迟早会被人们发现，一旦人们发现了，厂家配置的更高的附加值成本就会给他带来更大的损失。</p>

<p>有些照相机配送的皮套和背带都是真皮做的。如果照相机的质量不行，那这些高价值的配件也就浪费了。有些高级餐厅会用银器餐具，那是为了让用餐的人觉得，这家餐厅请的厨师手艺肯定不会差，不然，不就糟蹋了这么贵的餐具了吗？</p>

<h4>找餐馆</h4>

<p>生活当中其实是有很多类似的情况的。比如说，你在火车站旁边看到很多饭店吧，你觉得这些饭店的开设和小区里的饭店哪个更可信一点呢？那很可能是小区里的饭店更好一点。火车站的人群流动量很大，这些饭店不是通过重复交易获得的，他们服务的往往是一次性的顾客。顾客吃完就走了，他们等下一拨的顾客就行了。但小区里的就不一样了，他们服务的对象基本上是回头客，居民会来来回回在这里吃饭，这就是重复交易。所以小区里的饭店必须把服务做得更好，才能吸引回头客。</p>

<p>而同时，你再想想看，如果非要在火车站旁边找个饭店，你会找连锁店还是私人的小饭馆呢？很可能你会觉得连锁店会好一点，因为有第三方背书。连锁店不完全是属于店主的，它靠的是背后总店的担保和质量监管，万一出了什么问题，总店需要承担责任，你也容易找到投诉的对象，这是为什么在火车站、汽车站和机场，连锁经营的餐厅特别多的缘故。</p>

<p>那如果是同样有好几家连锁店，味道也差不多，你会怎么选呢？你会不会看看里面的装潢和设施，你应该选一个装修更好、光线更明亮、餐具品质更好的吧？这些都是附加成本。这些餐厅的食品质量如果不值得那么好，那么这些附加成本作用就不大了。所以合理的预期是，越是准备长期经营，越是计划长期提供优质服务的商家，越是打算长期提供优质服务的餐厅，就越舍得去投资装潢、餐具和其它固定的设施。</p>

<h3>48 明星天价代言费合理吗？（沉没成本自残）</h3>

<p>商家为什么要请天价明星来做代言人呢？</p>

<p><strong>投入沉没成本取信于人。</strong>在消费者和商家之间存在严重的信息不对称。商家的商品越不容易通过一些明显的指标让消费者信任，就越需要这种“自残”方式来取信于消费者。</p>

<h4>厂家的取信于人</h4>

<p>厂商实际上是在用实际行动告诉消费者，由于我已经把钱花出去了，我投入的成本已经变成沉没成本了，再也收不回来了，我要把这一个亿收回来，办法只有一个，那就是持续地卖出100万台机器，每台机器都多挣顾客100块钱，这样我才能把今天一下子浪费掉的、花出去的一个亿给赚回来。在未来很长的时间里面，在这慢慢销售的100万台机器里面，如果有任何一个时间我被逮住了，我被发现我的机器其实没那么好，顾客停止买我的机器了，那我前面付出的那一个亿的沉没成本就血本无归了。</p>

<p>厂商会说，我只有认认真真地给你提供服务，我才能在未来的一段长时间里面慢慢把成本收回来，这下子你应该放心了吧。这就是为什么很多大的厂商，尽管已经名声在外，他还要不断地做广告。而且他还要不断地翻出以前做广告的历史的原因。他的目的是要向消费者不断地展示，你看，我一直在乱花钱，我一直在投入成本，这成本是拿不回来的沉没成本。我会一以贯之地提供好的服务，才能逐渐把成本收回来。</p>

<h4>银行的取信于人</h4>

<p>又比如银行，银行是一个很难取信于人的行业。因为别人把钱交给银行了，万一哪天银行把钱卷走了，那可是个大事。银行怎么取信于人呢？他们总会把总部设在繁华的地段，他们的总部通常不是租的，是买的，自己建的，这些都能让人相信他们一直打算待在那里，不会搬走，会做50年，做100年、200年甚至更长的时间的生意，这也是一种投入，也是一种取信于顾客的方式。</p>

<h4>饭桌上的取信于人</h4>

<p>在我们中国喝酒的文化当中，自罚喝酒就是一种自残。你平时看电视或者注意生活当中人们的交际场合，就经常会听到类似的一句话，我先干为敬，您随意。敬酒的人自己先喝三杯，这也是一种自残的行为。其实，喝酒的人付出了一定的沉没成本，因为被敬酒的那一方就会想啊，这个人主动地在自残，他将来肯定会好好珍惜我跟他之间的关系，否则他今天付出的代价将来是收不回来的。通过这种喝酒的方式，他获得了信任。所以中国人才会经常说“感情深，一口闷”这种酒桌谚语。</p>

<p>当然，拼命喝酒，自残式的喝酒只是人们增加互信的一种方式。我们可以预测，当人们克服信息不对称，增进信任的方式多起来以后，通过喝酒自残来增加互相信任的情况也会变得越来越少，喝酒将来会越来越以娱乐为目的的。</p>

<h3>49 暴露弱点更能交到好朋友？（人质做抵押）</h3>

<p>在人际交往中如何取信于人？自残。这里说的自残，可以是自曝一些糗事，自我调侃一下，或者做一些不羁的事情。如果别人一直认为你高高在上，就会不信任你。你们之间的关系就不会走的很近。</p>

<h3>50 毒牛奶的“毒”从哪里来？（垂直整合）</h3>

<p>分工合作与垂直整合：</p>

<p>我们什么时候要进行更多的分工合作，什么时候要进行更多的垂直整合呢？这当中有一个规律，那就是那些半成品或者成品，它们的品质检验成本如果是比较低的，它换手的次数就可能比较多。也就是说更多地进行分工。
相反，如果半成品或者成品之间的检验成本比较高，那就要进行更多的垂直整合，减少中间环节，把业务都拢在一个大企业内部完成。</p>

<h3>51 总店管分店，真的很霸道？（特许经营许可）</h3>

<p>通过这一节眼镜店的故事（总店与加盟店的关系），你明白了特许经营合同里面的强者和弱者之间的关系。从条文上看，总店是强者，加盟店是弱者。但仔细分析下来我们发现，在现实生活当中，其实加盟店才是强者，而总店是弱者。</p>

<p>以后，每当我们看见一份合同，里面有不公平的条款，而这种不公平的条款越是普遍存在的时候，我们就先不要抱怨，先不要指责，我们要想想为什么这种不公平的条款会产生，会被执行，会一直延续下来。有时候，合同条款本身看上去是不公平的，但它的目的是要纠正现实社会当中的另外一种不公平。</p>

<h3>52 意外发生，如何划分责任？（汉德公式）</h3>

<p>汉德公式：谁能够以比较低的代价避免比较大的损失，那他就应该担负起一定的责任。而相反，如果一个人必须用很大的代价才能避免比较小的损失的话，他就不应该负责任。</p>

<h3>53 监管为什么不是越严越好？（监管要看边际效应）</h3>

<p>监管本身是没错的，但监管要看边际效应。</p>

<p>任何事情从经济学的角度看，我们永远不会只盯住一个指标，追求一个指标的最大化。我们要追求的是多个指标的综合效益最大化，任何事情都得有一个度，过分昂贵的食品，过分的安全，过好的就餐环境，食堂过大的责任，都会带来事与愿违的结果。</p>

<p>你还记得吗？我们在讲什么叫做优质的时候，就提到了麦当劳。你觉得麦当劳的鸡肉是最好吃的吗？这里面的监管到位吗？要不要追求极致呢？我们当时的回答是否定的，因为在追求极致的过程中，就会有很多附加的成本，这些成本反过来都是需要消费者支付的。如果对麦当劳的汉堡进行了非常非常严格的监管，那它的价格可能就和米其林高级餐厅里的一样了，那就不是人人都吃得起了，也不是想吃就能吃到了。这样的结局就反而会伤害了很多人的利益，因为他们只能退而求其次，选择到一些质量更差的餐厅里面去就餐了。</p>

<p>当然，这也不能说明我们就不要监管了，监管是对的，问题就在于监管应该有一个适当的尺度，监管不是越严格越好的，而是应该考虑边际效益。如果监管过于严格，就会导致追求产品的安全性，或者优质性的成本太高，对大多数的消费者来讲反而是剥夺了他们选择的权利了。</p>

<p>美国FDA药物监管也是相同的道理。在今天，时不时就有一些病人和他们的家属跑到FDA总部的门口去抗议，要求加快新药的审批过程。他们说，我们不需要那么安全的药了，我们的病已经很重了，我们的时间已经不多了，快让我们试试那些新药吧。</p>

<h3>54 说明书那么长，有什么用？（监管引入竞争）</h3>

<p><strong>强制披露</strong>指的，是政府让厂家、让服务提供商把产品或者服务的所有情况都详细地列举出来，告诉消费者，让消费者自己决定的一种监管措施。</p>

<p>学者和政府官员很喜欢这种方式：学者医生不用针对不同喜好的消费者做决定，政府也不需要立法成本和执法成本，只需要一纸命令即可。但是，消费者就麻烦啦：</p>

<ol>
<li>对数字和一些专业信息不理解。</li>
<li>厚厚的说明书看不过来。软件的安装协议，有人看过吗？</li>
<li>决策太多，决策厌恶症，懒得做决策。</li>
</ol>


<p>要同时解决产品质量安全当中存在的两个问题，一是专家必须做出判断，第二，专家的判断也必须符合经济规律。要同时满足这两个条件，最好的办法就是对监管本身也引入竞争的机制，不是垄断性的、独此一家的监管机构提供监管的服务，而是多家互相竞争的监管机构提供互相竞争的监管服务。不同的监管机构，不同的认证机构，根据不同的标准、不同的风格、不同消费者的偏好，给出认证。这样的话，消费者就不需要知道具体的专业知识，而只需要在不同的认证机构的品牌之间做出选择，那就可以了。</p>

<p>比如说买药，你也不知道买哪个好。但是如果你知道某家很有权威的国际认证机构，而你要买的药有这家认证机构的认证，那你就会放心地买这种药了。你选择的不是药品本身，因为你缺乏相应的医药知识，你选择的也不仅仅是药厂的品牌，因为你知道，商人都是唯利是图的，不能完全信得过，你选择的也不是独此一家的监管机构，因为你知道监管机构可能会追求过度的安全，而让你在成本和药物的可得性上吃亏。你实际在选择的是那些互相竞争的认证机构的品牌，简单地说，你选择认证专家，认证专家帮你做其它的选择。这种让监管专家、监管机构之间也形成竞争态势的做法，应该是提高产品的综合质量、解决厂商和消费者之间信息不对称的困难的基本思路。</p>

<h1>组织</h1>

<h3>55 自己足够优秀，还要合作吗？（团队）</h3>

<p>团队就是那些能够带来比每一个成员单独产出之和还要大的产出的组织，而团队当中单个成员的收入应该跟他对团队的边际贡献相等。</p>

<h3>56 家庭里为什么也谈钱？（家庭经济学）</h3>

<p>科恩教授在这篇文章（《I Gave Him the Best Years of My Life》）里面解释说，男性的价值高峰期和女性的不一样。怎么来理解这个价值高峰期呢？你可以把它理解为精力、体力最好的时间，最容易获得成就的时间，或者最吸引异性的时间，无论身体状态还是事业发展都可能会达到最好的那段时间，它就被称为价值的峰值。</p>

<p>男性和女性在生理上有所不同，在社会角色上也有不同。比如在传统观念当中，女性要生儿育女，所以根据过去的医疗条件和当时女性的身体情况，二十多岁最适合生育，正是黄金年龄，那正是她们的价值高峰期。而男性呢，要赚钱养家，在事业上如果要做到独当一面，往往要到40岁左右，他们的成就才会比较明显，那时候才是他们的成熟期，或者说那时候才是他们的价值高峰期。</p>

<p>所以整体上来看，女性的价值高峰期要比男性来得早，也就是说如果同样是25岁，女性已经快到达价值高峰期了，而男性还需要一段时间才能慢慢到达。</p>

<p>所以你可以设想一下，如果一位二十多岁的女性找到了同龄的男孩儿，那会发生什么样的事情呢？这位已经到达价值高峰期的女性，首先就会对家庭做出各种投入，先养育孩子、照顾家庭、扶持丈夫。而在这段时间里面，丈夫并不在他的价值高峰期上，而妻子也不知道丈夫以后能不能达到比较高的价值，也就是说并不知道他以后的事业能不能够有成就。就算一切顺利，随着时间的推移，丈夫走上事业的高峰，到那个时候，他会有更多的选择机会。而女性在生理上的价值就已经开始逐步下降了，这时候，丈夫背叛妻子的机会就会增加。如果年轻的女性在自己的峰值期找一位同样在峰值期的男人呢，也就是年纪比自己大一点的男人呢？他们的事业已经比较有成就了，他们的成就已经比较显著，已经比较清晰了，那么相对来说，这段婚姻的不确定性反而会小一点，女性的风险就会小一点，婚姻可能就会稳固一点。</p>

<p>当然，我要马上补充，这篇文章所谈的只是问题的一个侧面，而且主要是对旧时代情况的描述和解释。</p>

<h3>57 多生还是少生，谁来决定？（家庭经济学）</h3>

<p>为什么旧社会人们养这么多孩子，而现在的人不愿意多生呢？
1. 存活率。
2. 农业社会需要劳动力。
3. 父母的时间成本变高了。
4. 旧社会需要孩子防老，新社会不需要。
5. 孩子的质量比数量更重啊哟。</p>

<h3>58 你出钱我出力，谁该当老板？（资本vs劳动力）</h3>

<p>谁提供的资源更容易被欺负、被滥用、被支配、被牵制，这种资源的所有者就应当充当老板，让他们来发号施令，让他们来做监督管理。而与此相对，那些更容易偷懒、更容易滥用别人的资源的人，更容易虚张声势、假装卖力的人，他们就应该成为被管理者。</p>

<p>而当我们把资本和劳动力做比较的时候，我们就能够发现，资本其实更容易被欺负，更容易被滥用，而劳动力是更容易偷懒、更容易滥用资本的。所以企业管理的核心问题就是如何防止劳动力剥削、滥用、控制资本，而不是相反。</p>

<p>在企业里面谁当老板的一个标准，那就是谁提供的资源更容易被滥用，被支配，被牵制，谁就来当老板，谁就来发号施令，谁就来承担更大的监管责任。而在资本和劳动力的比较当中，我们发现，资本其实是弱者，劳动者其实是强者。所以我们看一个企业的规章制度，看雇佣者和被雇佣者之间签订的劳动合同，我们就能发现，控制权往往落在弱者也就是资本家的手里，而不是在劳动者的手里了。</p>

<h3>59 都是出力的，谁该管理谁？（通用vs专用）</h3>

<p>经济学家把那些自身的价值高度依赖于他所在的平台的劳动力，称为企业的专用资源，比如技术人员，而把那些无论放到哪个企业平台里面都能发挥差不多的功能、获得差不多的收益的资源称为企业的通用资源，比如保洁、保安。而当然，企业的专用资源会更在乎企业的兴衰存亡，让他们来当管理者，让他们来做决策，胜算会更大一点。</p>

<h3>60 怎么给老板发工资？（剩余索取）</h3>

<p>在企业当中，那些容易被观察、被衡量、被评估的工作，他们根据劳动的投入，拿固定的收入。而那些不容易被观察，不容易被衡量、被评估的工作，他们按照企业剩下的利润来分配收入。这种获得收入的权利被称为剩余索取权。</p>

<p>学完了这一节，你就能够明白，挣钱的企业和亏钱的企业相比较，普通员工的收入相差不大，但老板和高级经理的收入相差就很大的缘故了。</p>

<h1>货币</h1>

<h3>61 “钱”有什么用？（货币的作用）</h3>

<h3>62 为什么石头也能当钱用？（货币的诞生）</h3>

<p>货币之所以有用，最重要的原因就在于，人们相信它有用。</p>

<h3>63 东西涨价了，应该去怪谁？（通货膨胀）</h3>

<h3>64 货币像水还是像蜜？（货币扩散）</h3>

<p>通货膨胀国家释放货币，就像释放一堆蜂蜜，蜂蜜渐渐流动，最后摊平。通货膨胀刺激经济增长的过程就是这个流动的过程，当摊平之后，通货膨胀的作用也就消失了。</p>

<h4>通货膨胀导致错误决策的过程</h4>

<p>老板叹了口气说，菜品涨价确实是通货膨胀的结果，而因为通货膨胀，他还曾经做了很多错误的决策，导致严重的亏损，差点关门了。</p>

<p>这是怎么回事呢？老板说：你看一开始，大家手里的钱一下子比原来多了，所以来吃饭的客人也多了，生意越来越好了，饭店从上到下都感到很开心。就想，这是为什么呢？归根到底应该是由于咱们餐厅的菜品做得好，服务做得周到，把顾客从别的店里吸引过来了吧。</p>

<p>既然自己的饭店这么好，就不能埋没了自己的优势啊。渐渐地，老板对自己经营管理的信心就越来越强了，认为自己既然相对优势增加了，竞争力增强了，那就应该扩大生产。于是他多招了服务员，多招了高价的厨师，还在其它地方开了分店。</p>

<p>结果怎么样？晓燕继续问。老板摇了摇头说，慢慢地，他才意识到，这顾客多了，钱赚多了，很可能不是因为自己的优势比别的饭店更明显，功劳不是自己的，而是由于人们口袋里的钱多了，暂时多了起来，所以这些人才更愿意来消费。但是经过一段时间，人们就很快意识到，不是自己的钱变多了，而是因为钱不值钱了，因为其它所有的商品和服务也都变贵了，自己的这点钱还是买不到什么。这样，人们就开始调整自己的行为了，比如减少在外面就餐的次数，或者消费的金额，老板的饭店也就没那么红火了。</p>

<p>可是老板已经雇佣了很多人呢，还开了分店，得给他们发工资。工资在涨，分店的租金也在涨，肉啊，菜啊，这些食材价格也都在涨。这一下子，成本也就“噌噌噌”地往上涨了。</p>

<h4>坎蒂隆效应</h4>

<p>故事讲到这里，我想让你来想想，如果你是那位餐厅的老板，你能不能避免他犯的决策错误呢？</p>

<p>对这个问题，经济学认为，每当发生通货膨胀的时候，尤其是当过多的钞票进入到流通当中，影响我们的生活的时候，这些新增的货币并不是一下子就均匀地影响到每一个人的，这种新增的货币要经过一段时间，才能逐渐在整个经济体里面摊匀，这种现象被称为“坎蒂隆效应”（Cantillon Effect）。</p>

<p>这句话怎么理解呢？你看，如果政府每多印一批钞票，都用直升飞机在整个国家里面平均地撒下去，雨露均沾，每一个人得到的货币量都是一样的，而所有商品和服务的标价也同时灵敏地做出调整，那确实货币增发对我们的决策和行动不会有什么影响。</p>

<p>又再比如，如果银行把每个人的存款数目都多加一个零，然后所有商品的标价也都同时多加一个零的话，那通货膨胀对社会的影响可能也是不大的。</p>

<p>但在现实生活当中，新增的货币其实总是要通过某个出口才逐渐流向社会的。这个流动的过程需要一段时间，货币对整个经济生活的影响其实是不均匀的，这时候它对人们的决策和行动就会产生重大的影响。“坎蒂隆效应”就是这个意思。</p>

<p>经济学家海耶克曾经对这个效应打了个形象的比喻，他说：这种效应就像我们把一种黏性的液体，比如蜂蜜倒入一个容器当中的时候所发生的现象。刚开始，蜂蜜倒下去的时候，在容器的底部会产生一个轻微的隆起，而这个隆起会慢慢地向周围扩散。即使我们不再继续倒蜂蜜，原来的蜂蜜要在容器底部完全摊平，也仍然需要一段时间。
货币增发的过程也是这样，政府多印的钞票并不是一下子平均地分给社会上每一个人的，相反，它是通过拨款、通过贷款等其它的方式，让某些部门、某些企业、某些个人先用这笔钱，这些钱是从某些特定的出口慢慢地流向整个社会的，哪怕政府停止增发货币，原来新增的货币也要经过一段时间才扩散到整个社会，体现在每一种商品和服务的价格上涨上。</p>

<p>所以在通货膨胀开始发生的阶段，当新增的货币没有平摊到每一个人身上的时候，任何一家企业，他们都很难判断自己的生意变好了，究竟是因为自己的相对优势增加了，应该扩张生产，多招人，多开分店，还是因为整个社会正在经历一场通货膨胀，最后所有的物价都会上涨，自己根本不应该过分自信，不应该多招人，不应该扩大生产，不应该去开分店。而一旦做出了错误的判断，将来就会蒙受亏损。</p>

<h3>65 降低失业率，多印钱管用吗？（通货膨胀与失业）</h3>

<p>制造通货膨胀的办法到底能不能够解决失业问题呢？这背后又有什么规律可循呢？</p>

<p>当时很多人都相信，制造通货膨胀是对付失业的一个有效措施。出现了比较严重的失业率以后，政府就可以通过制造一点通货膨胀来解决问题。而且事实上，当人们真的付诸行动，真的制造通货膨胀的时候，他们确实看到失业率下降了。原因是什么呢？原因就是我们之前讲过的，货币像蜂蜜。每当发生通货膨胀的时候，新增货币的扩散是需要时间的，人们对通货膨胀来临的认识并不是瞬间就能完成的。在这个过程中，慢慢扩散的通货膨胀就会迷惑一些人，让他们做出错误的决定。</p>

<p>你记得吗？我们讲过餐厅老板开分店的故事。通货膨胀发生以后，人们的收入增加了，更愿意消费了。这时候，被制造出来的通货膨胀就开始收到所谓的正面效果了。雇主开始招人了，市场上的空缺职位增加了，人们很容易就找到工作了，工作的收入还不错。但是，随着时间的推移，新增的货币会向整个社会、整个经济体扩散出去。这时候，货币就越来越像水了。新增的货币完全扩散开来以后，人们就终于明白了，原来这只不过是一场通货膨胀而已。</p>

<p>就像那位餐厅老板最后意识到的，我的收入在增加的同时，我的人工、我的成本、我的铺租全上去了。我所做的那些新增投资，我所雇佣的新员工，可能都是错误的。</p>

<p>终于有一天，政府不得不采取行动，抑制通货膨胀。到这时候，我需要的资金就接续不上了，我正在进行的计划很可能就会被搁置了。我招来的人可能就被解雇了。换句话说，如果人们对通货膨胀的预测和认识能力在提高，那么通过通货膨胀来减少失业的努力就会越来越失效，这一招就会越来越不灵。</p>

<p>你想啊，如果那位餐厅老板早就意识到这就是通货膨胀，那他可能就不会再开分店了，不会再招那么多人了。这样的话，政府通过制造通货膨胀来降低失业率的效果也就没有了。</p>

<p>有两位经济学家，一位叫弗里德曼（Milton Friedman），另外一位叫费尔普斯（Edmund Phelps），这两位经济学家分别发现了这种现象，他们独立发表了他们的论文。他们认为，在长时间内，制造通货膨胀是不能解决失业问题的，用专业的话来说，通货膨胀率和失业率之间并不存在持久的反向关系。他们预测，如果政府反复地使用通货膨胀来对付失业的话，失业就减不下去了，到时候反而会出现通货膨胀率和失业率同时高涨的现象，这就是所谓的滞胀（stagflation）。</p>

<p>滞就是停滞的滞，胀就是通货膨胀的胀。滞胀就是通货膨胀和经济停滞并存的现象。20世纪70年代，美国就出现过严重的滞胀。</p>

<p>由于提前准确地预见了这种情况的发生，这两位经济学家，弗里德曼和费尔普斯后来都分别获得了诺贝尔经济学奖。</p>

<h3>66 人人都忽然不消费了怎么办？（经济周期）</h3>

<h4>凯恩斯主义</h4>

<p>凯恩斯主义是怎么看经济波动的。简单地说凯恩斯主义认为，出于莫名其妙的原因，人们的消费忽然减缓了，自由市场本身要针对这种变化做出调整，存在着各种各样的障碍。这时候政府就应该承担责任，替人们进行消费，从而抵抗经济的波动。具体的做法，包括修路、修桥、盖房子、修地铁等等。但是凯恩斯主义的观点，也受到了其他经济学家的质疑，所以政府在进行公共工程的时候，就要特别小心谨慎，避免浪费和出错。</p>

<h3>67 变化导致了经济波动该怎么办？（经济周期）</h3>

<p>很多对经济体产生的冲击都是正常的，都是时代发展的结果，额外的干预不但不能起到稳定经济的作用，反而还会造成额外的损失，阻碍了新生事物的发展。</p>

<h4>传真机</h4>

<p>传真机刚刚出现的时候，政府也曾经做过干预，因为邮电局刚刚发展了电报网，这时候如果大家都转用传真机了，那刚刚部署好的电报网该怎么办呢？于是邮电局就打击传真机。他们请人设计了专用的软件，检测那些家里连接了传真机的用户，一旦查到就处以重罚。但即便是这样，传真机还是发展起来了，政府的干预不但救不了老的技术，对新技术的发展也起到了阻碍的作用。</p>

<h4>互联网</h4>

<p>再比如现在的互联网购物，对传统的实体店购物也是一种冲击，大家都不太去商店买东西了。那地租怎么办？售货员怎么办？互联网购物就需要很多的快递员，缺少快递员又怎么办？对于这些新兴的商业模式，我觉得静观其变、顺其自然，还是比较合理的对策。</p>

<h3>68 小想法如何产生大效应？（微观与宏观）</h3>

<p>经济学家谢林（Thomas C. Schelling）出版过一本畅销书，书的名字也刚好就是叫做《微观动机和宏观行为》（Micromotives and Macrobehavior）。他的这本书就分析了很多不经意发生的微观动机，和非常奇特的宏观行为之间的关系。</p>

<h4>补课班</h4>

<p>你参加过一些提前的补课班吗？现在有些地方提前补课的情况越来越多了，甚至学校都没法正常地教课了。因为一个班级里一半的学生都提前学过了，老师就会快速地讲，而那些没有提前补课的同学，学起来就特别困难。这种情况造成了所有的学生、家长和老师都变得很焦虑，课程真的那么难吗？真的需要提前补吗？也不见得。</p>

<h4>座位</h4>

<p>经济学家谢林就发现，每次他走进演讲会场，大部分人都坐到了会场的后半部分，前排基本上没人坐，大家为什么要离他那么远呢？</p>

<p>后来谢林发现，其实大家并不想真的离他那么远，每一个走进会场选择座位的人，他心目中只有一个小小的愿望，那就是我不想坐第一排，我希望我的前面还有人坐。但是当每一个人都这么选择的时候，他就会越来越往后退，大部分人都会聚到会场的后半部分了。我们看到的宏观现象，是所有的人聚到了会场的后半部分，但原因并不是每个人都想这么做，每个人心目中的小心思，其实只不过是希望自己不坐第一排而已。</p>

<h4>找工作时间提前</h4>

<p>在美国许多学校，学生找工作也有越来越提前的倾向，早一点去找工作，找到的工作可能就会好一点。所以很多学生还没有毕业就先找实习了，而他们找实习的时间也不断地提前。最后，在一些商学院，从第一天上课开始，学生们每周都要去学习面试和找工作了。</p>

<h4>唐人街是怎么形成的</h4>

<p>经济学家谢林说，其实人们可能没有意识到这个宏观结果。在开始的时候，每个人并没有那么强的种族意识，只不过每一个人在选择自己邻居的时候，他们可能会想，我前后左右四个方位里面，至少有一位或者两位是我的同胞就好了。其实他们的心态也是很开放的，他们并没有要求周围所有的邻居都是同种族的人。</p>

<p>但是你知道吗？经过多次迭代，当每一家人都要求自己边上至少有一个同种族的邻居以后，很快的，他们就会被自己的同胞所包围。一个大的生活区，唐人街、印度人街、意大利人街，就这么形成了。</p>

<h1>收入</h1>

<h3>69 工资到底怎么发？（工资的决定）</h3>

<h4>爸爸的年薪和表哥的月薪</h4>

<p>爸爸当销售总监的工作是需要更多灵活空间的，他的工作更多的是要耐心地研究市场的行情，市场内在的规律，然后做出一个影响深远的决策。这需要一个比较长的时间跨度，我们不能要求他每天都有工作成果。而同时，他的工作绩效也不是马上就能甄别出来的，得经过一段时间才能见分晓。所以爸爸的工作适用于年薪制。</p>

<p>而表哥呢，只是个初级的销售员，他的工作方向还会有很多的变数，今天可能在这家公司工作，明天就可能换到别的企业去工作了。而且比较初级的工作的业绩也都比较容易评估，所以表哥的工资是以月为计算单位的。</p>

<h3>70 同工同酬法，能帮到弱势群体吗？（同工同酬法）</h3>

<h4>一分恰如其分的工资</h4>

<p>要求一份合理的工资，有时候甚至要求一份稍微比市场价格低那么一点的工资，是那些绝对竞争能力比较低的人，跟绝对竞争能力比较高的人展开竞争的最强有力的武器。</p>

<p>但这个时候，如果一个国家、一个地区，实施了所谓的同工同酬法，那就意味着老板必须付出高额的工资。如果无论雇佣谁，他都必须给100块钱的话，那你猜，他会倾向于请哪一类的员工呢？既然100块钱都出了，他当然只会请他心目中配得起这个工资的人。这时候，对那些竞争实力比较弱一点的人来说，这种逼着老板出高价雇佣工人的法律，实际上它剥夺了弱势群体跟强势群体展开竞争的最强有力的武器。这个武器就叫做只要一份恰如其分的工资。</p>

<p>还是那句话：哪怕是弱者，也能够跟强者展开竞争，而弱者跟强者展开竞争的最强有力的武器之一，就是只索取一个恰如其分的合理的价格。而同工同酬法，很可能是剥夺了弱者手上这把最有的武器。</p>

<h3>71 最低工资为什么不保护残疾人？（最低工资法）</h3>

<h4>最低工资法的后果</h4>

<p>最低工资制度会产生事与愿违的结果。本来这个制度是想要保护那些工资水平比较低的人的，而实际上这些工资水平比较低的人可能连工作都找不到了。而这样，是不利于那些年轻人，那些穷人，走向自食其力，自强不息的道路的。</p>

<h4>最低工资法存在的理由</h4>

<p>问题是，这种事与愿违的最低工资法制度，之所以在世界各地都得到推行，一方面是由于人们善良的愿望，他们没有学会把愿望和结果区分开来看。而另外一方面，更重要的原因是，有一些竞争对手希望抬高其他竞争对手的竞争成本，把他们自己享受的福利加到别人身上去，目的就是想把工作机会从别人手里再抢回来。</p>

<h3>72 什么职业最赚钱？（基尼系数）</h3>

<p>基尼系数是衡量人与人之间流量收入差距的一个指标。而仅仅通过基尼系数的高低来判断一个社会收入分配是否公正，是不合适的。</p>

<h3>73 想当个电工，为什么这么难？（工作权的限制）</h3>

<p>通过这一节找电工的故事，你明白了一个道理，那就是对工作资格实施考核准入制度，确实是能够保障从业人员的服务质量的。但是，如果无条件地提高准入的质量标准，那就会导致从业人员过少，服务价格过高，并且会迫使人们选择其他安全性更差的替代品的结果。同时，你也明白了，那些大力推动就业许可制度的人，<strong>那些大力提高考核标准的人，很可能就是那些已经获得了就业资格的既得利益者，他们过分地提高考核的标准，实际上保护了他们自己的利益。</strong></p>

<h3>74 改变命运，穷人靠什么？（个人的发展）</h3>

<p>穷人要找到出路，基本上就是两个办法。第一，自己要努力，寻求进步；第二是搭社会进步的顺风车。</p>

<h1>竞争</h1>

<h3>75 为什么键盘不按ABCD排序？（市场的选择）</h3>

<h4>网络效应</h4>

<p>生活当中其实是有很多类似的情况的。有很多产品它具有这么一个特点，那就是使用的人越多，它的价值就越高。比如说电话，世界上如果只有一台电话，那电话的价值就是0，它只是一台玩具。但是世界上如果有100台电话呢？拥有一台电话的人就可以和另外拥有电话的99个人通话，电话的价值由于用户数量的增加而增加了。而如果世界上有100万台电话，1000万台电话，那电话的价值就更高了。经济学家把这种效应称之为网络效应，网络效应的意思是，一种产品使用的人数越多，它对任何一位用户的价值就越大。</p>

<h4>路径依赖</h4>

<p>问题是，跟网络效应相关的还有另外一个概念，就是路径依赖。由于一种产品用的人越多，价值就越高，所以用户就会聚在同样一个产品上面，选择同样的产品来使用。因为人聚得越多，产品的价值就越高嘛。但这时候，如果出现了另外一些新的产品，出现了另外一些新的替代方案，这些替代方案哪怕是更有效的，但由于没办法吸引足够的用户使用，它们就会被市场搁置，被市场遗忘，被市场抛弃，而大多数人只会继续使用那种效率比较低下的产品。这种效应叫路径依赖。</p>

<h4>网约车</h4>

<p>我们所讲的键盘布局的故事，告诉我们的一个重要道理就是，市场竞争能够帮助我们尽快地选中那些真正有效的商品、标准或者平台，让大多数人选用这种效率更高的商品、标准或者平台。</p>

<p>比如说网约车吧，提供网约车服务的竞争其实是很激烈的，开发一套网约车服务的软件不是太难。但我们可以预见，最终无论是司机还是用户，都喜欢聚到同一个平台上，因为只有这样，这个平台的价值才是最大的。没有哪位乘客，他要打车的时候，愿意同时使用十几种软件来找车，也没有哪位司机愿意同时使用十几种软件来寻找乘客，他们都希望在同一个平台上被撮合，被进行交易。</p>

<p>那么多的平台互相竞争，怎么才能尽快地决出胜负呢？其中一种有效的办法，就是在一开始，网约车服务商向司机和乘客提供补贴，把他们吸引过来，迅速形成巨大的用户群体，从而增加这个平台的价值。补贴力度越大，花的钱越多的公司，从概率上讲，也是越有实力提高他们服务质量的公司，所以先补贴，然后聚拢用户，然后提供更好的服务，是商业社会里面人们利用网络效应的优势，而同时避免路径依赖的陷阱的一种有效的办法。</p>

<h3>76 公司做大就是错吗？（垄断）</h3>

<h4>技术垄断</h4>

<p>当年的国际商业机器公司IBM、微软公司Microsoft，今天的谷歌公司Google、苹果公司Apple，他们的产品都曾经占据了很高的市场份额。但回过头来看，他们风光的日子并不长，在很短的时间内，他们就遇到了新的对手、新的挑战、新的格局，只要稍不留神，他们原来享有的优势就会丧失，新的知识、新的技术、新的公司就会替代旧的知识、旧的技术、旧的公司，消费者的利益就能够得到长久的保障。</p>

<p>当考虑垄断问题的时候，我们必须先考虑垄断者最初是通过什么样的办法来取得垄断地位的。如果是通过自身的知识、技术和不断的努力来获得这种市场支配地位的话，那么他们的地位就是无可厚非的。而长远地看，动态的竞争很快就会改变市场的格局，垄断者的优势只是暂时的，在整个过程当中，受益的是消费者和整个社会。</p>

<h3>77 石油大王靠什么发家？（掠夺性定价）</h3>

<p>通过掠夺性定价把竞争对手赶出市场，然后再通过提价来攫取垄断利润的做法，在现实当中是很难成功的。商人对他们的产品持续降价的原因，很可能不是为了垄断市场而垄断市场，而是因为他们掌握了更好的技术，提供了更好的产品，采用了更好的管理模式，降低了成本，为消费者带来了真正的实惠。</p>

<blockquote><p>但是互联网行业确确实实存在这种掠夺性定价，并且最终垄断市场。这是因为该行业有网络效应，一家独大，赢者通吃。比如微信，滴滴。</p></blockquote>

<h3>78 为什么不让加盟店打折？（最低零售限制）</h3>

<p>零售商之间为什么需要商定一个最低零售价，而不能自由降价吸引顾客呢？</p>

<p>如果零售商之间不达成最低零售价限制的话，顾客会怎么做呢？顾客就会像小青买鞋那样，先跑到那些服务周到的商店里面，享受各种咨询、试用、试穿的服务，等她确定下来，要买哪件商品以后，她就会跑到那些不提供这些服务的商店里面，以比较低廉的价格购买商品。结果呢？谁也没积极性提供服务了，顾客就不了解，销量就会下跌。这不是厂家所愿意见到的结局。</p>

<h3>79 捆绑销售是为了多赚钱吗？（捆绑的理由）</h3>

<h4>IBM捆绑打孔纸</h4>

<p>IBM公司强迫用户购买和使用他们提供的打孔纸，原因不在于他想要扩充自己的垄断地位，而是因为机器是租用的，他们负责维护，不同的租户所发生的维护费用是很不一样的。而且，很难计算。结果IBM公司就选择了打孔纸作为使用量，用它来衡量提供服务的多少。用纸越多的用户，维护成本自然也比较高，收费也就比较高；用打孔纸比较少的用户，惹的麻烦就比较少，收费就比较低。
所以其实IBM卖的不是打孔纸，它卖的是技术，卖的是服务。IBM公司只是根据打孔纸的使用量来对用户进行区别定价而已。</p>

<h4>相机捆绑打印纸</h4>

<p>听完这个故事，你不妨再想想，生活当中其实是有很多类似的情况的。比如我买过一款相片打印机，它要求用户必须购买同品牌的配套相纸才能使用。这看起来也是捆绑销售啊，那商家为什么要这么做呢？商家的目的是要区分不同的用户对相机的使用量，相纸的价格比较贵，用得多的人多付钱，用得少的人少付钱。这样就能够确保相机的价格做到足够的便宜，把购买的成本降得足够低，让更多的人，哪怕是那些只想打几张照片的人，也能够享受到相应的服务。</p>

<p>捆绑销售不能够帮卖家把他们的垄断地位从一种产品扩充到另外一种产品。他们真要这么做的话，效果只会适得其反。但在现实生活当中，我们经常还会见到卖家进行捆绑销售，那是因为他们要达到其他的目的。</p>

<h3>80 卖家勾结定价，行得通吗？（勾结定价）</h3>

<p>勾结定价面临的种种障碍，自发的勾结定价总是趋于瓦解的。</p>

<h3>81 什么才是竞争的合理状态？（竞争的分类）</h3>

<p>每个厂商为了自己更有竞争力，都想办法挖掘消费者的需求和喜好，不断创造出新的品种，各个厂商之间的竞争不再只围绕着价格进行，生产出来的维生素也就多种多样了，可以符合不同消费者的需求，这样不是更好吗？
完全竞争和不完全竞争</p>

<p>仔细看看药店的维生素，就会发现，它们在吃法上有很多的不同。比如含片、咀嚼片、泡腾片等等。口味上也有橘子味儿的、草莓味儿的等等。此外，还分小儿专用的和大人服用的，还分纯天然的和合成的，而价格相差也很大。</p>

<p>其实，互相竞争的厂商之间，他们比拼的不仅仅是价格这么一个维度，他们不断努力，不断创新，就是想要让自己的产品跟别人的产品有那么一点不一样。当每一位厂家在每一天里都以这样的态度来对待他们的每一件产品的时候，市场上的商品就变得多姿多彩了，消费者得到的满足感也就越来越大了。</p>

<h3>82 什么才是企业的合理规模？（企业规模）</h3>

<p>通过这一节，早餐摊的故事，你明白了一个道理，那就是一个市场的竞争程度不取决于这个市场里互相竞争的企业的数目。有时候企业之间进行合并，看上去竞争者的数量减少了，原来的竞争者从竞争关系转变为合作关系了。但整个市场的竞争程度却并没有下降，因为这些合并的企业，他们整合了资源，优化了配置，加强了管理，形成了更强的竞争力，可以在更大范围里面，跟更多的竞争者展开更激烈的竞争。</p>

<h1>协调</h1>

<h3>83 你的信息，为什么必然泄露？（共享经济）</h3>

<p>暴露隐私的最大的一个好处就是人会变得更加可信了。你知道吗？人们是根据一个人的各种状态，各种历史记录，尤其是他的工作、交友、收入、支出等等信息来判断一个人的信用的。</p>

<p>更重要的是，当一个人知道自己的行动受到某种监测，自己的信用会受到评估以后，他也会有积极性，有意识地去矫正自己的行为。</p>

<p>你以前看到，只有公司办的酒店才能给人提供住宿。可现在不一样了，今天有了大数据，有了个人隐私信息的共享，陌生人不再真的是陌生人了。你可能并不直接掌握他的个人信息，但是交易平台掌握了他的交易信息，你并不了解他，但你知道有人或者有机构了解他，你知道出了事能够把他找回来。如果他也知道这一点的话，那他也会对自己的行为负责，这时候你就愿意把房子借给他了。这就是民宿可以发展起来的信任基础。</p>

<h3>84 投票选举，谁的意见最重要？（中位数原理）</h3>

<p>选举的中位数原理。它是说，在有若干候选人竞选，而只有一位候选人获胜的选举当中，那位能够讨好中间选民的选举人，他获胜的机会最大。而如果一个选区有多位候选人获胜，那他就应该尽量去讨好那些还没有人去讨好的选民。这样的话，他获胜的机会就比较大。</p>

<h3>85 少数服从多数，真的可行吗？（阿罗不可能定律）</h3>

<h4>阿罗不可能定律</h4>

<p>这个定律告诉我们的是，在有些情况下，哪怕每个选举人都如实地汇报自己的偏好，选举的过程中没有人作弊，但一人一票的选择方法仍然没有办法体现出大多数人的意愿，选举的结果有可能是循环不已的。</p>

<p>而现实生活当中，之所以没有见到这种情况发生，那是因为我们大多数的选举投票都是在有会议召集人或者议程确定人的情况下发生的，是他们暗中把一些选项给剔除掉了，从而阻止了选举的结果会循环不已的可能性。</p>

<p>比如大家商议，该去看哪部电影。如果只是通过排序选择的话，那就有可能出现阿罗不可能定律所预言的循环的情况，大家投了半天票，也得不出什么结论。但是如果换个角度，就能解决问题了。比如，大家推举一位主持人，他可能会有自己的倾向，他就带着自己的倾向为大家提供一定的选项，他自己先在众多电影当中挑出两部他自己最喜欢的，让大家投票，投完以后，选举结果就确定了。其他的电影根本没有机会被大家投票选择，事情很快就有结果了。</p>

<h3>86 不负责的言论会有什么后果？（理性胡闹的代价）</h3>

<p>言论自由的相对性，你知道言论本身也会带来负的外部性，造谣和传谣的成本很低，但社会辟谣的成本可能会很高，我们应该特别小心那些不负责任的言论。</p>

<h3>87 做决策时，你该考虑什么？（看得见与看不见）</h3>

<p>19世纪的法国经济学家巴斯夏的《看得见和看不见的》，阐述了看得见和看不见的现象。比如他说黑暗能够增加蜡烛工人工作的机会，太阳出来了工作机会就少了，这是看得见的。但看不见的是太阳如果出来了，人们如果能够充分地利用太阳，那就至少有一部分蜡烛工人可以去从事其他的工作，为人们创造更多其他的财富。这种其他的工作虽然说不定是什么，但一定是存在的，我们就要善于看得见这些还没有出现，所以还看不见的工作。</p>

<p>通过关灯节能的这个故事，学到了一个经济学的基本原理，那就是我们不仅要看见那些看得见的因素，我们还要特别重视那些不容易看见的却真实存在的因素。只有这样，我们才能够避免在做选择、在做决策的时候犯错误。</p>

<h3>88 遇到事与愿违，你该怎么看？（愿望与结果）</h3>

<p>回顾一下前面讲过的一些事与愿违的事情。
1. 需求第一定律：人们对代价是很敏感的，在需求不变的情况下，代价越高需求量就越低，代价越低需求量就越大。
2. 需求第二定律：交易税法律确定不了，确定了也没有用，最后是由更迫切需要交易的一方承担的。承担的比例取决于迫切程度。
3. 监管机制：监管越严，供给越少，价格越高。比如，FDA。
4. 最低工资：弱势群体找不到工作。
5. 基尼系数和贫富政策。</p>

<h3>89 如何分清因果关系？（个体与全体）</h3>

<p>分清相关性和因果性。对于相关的两件事情，不一定是因果关系，可能存在着隐藏的第三个因素，同时决定了这两件事情。</p>

<h4>喝红酒与健康。</h4>

<p>有一些大数据统计表明，爱喝红酒的人，他们确实比较健康。这时候我们就说，喝红酒和健康之间就有相关性。但相关性并不意味着因果性，因为在喝红酒和健康之间，还可能存在着第三个隐形的因素，那就是收入。收入更高的人，通常喜欢喝红酒，而不是啤酒。而收入高，生活环境和医疗条件也比较好，所以也比较健康，是收入高影响了健康，而不是喝红酒影响了健康。</p>

<h4>艺术家与长头发</h4>

<p>我们研究很多男艺术家的长相，我们发现，他们很多人都留着长头发，这时候长头发和艺术气质之间就存在着相关性。但这种相关性并不意味着因果性。如果你今天忽然想当艺术家了，就把头发留长，这并不会增加你的艺术细胞，使你成为艺术家。</p>

<p>当然，长头发和艺术性之间可能还存在着第三个隐形的因素，那就是在一个比较保守的社会里面，只有那些非常喜欢特立独行的人，他们才会留长头发。而特立独行又是艺术家的特征之一。所以，并不是留长头发导致了艺术性，而是那个隐形的，不可见的因素，特立独行导致了艺术性。</p>

<h3>90 最重要的四个经济学基本规律（因果的理顺）</h3>

<ol>
<li>需求定律</li>
<li>边际收益递减定律</li>
<li>比较优势定律</li>
<li>资产现值的决定因素</li>
</ol>


<p>关于资产现值的决定因素，多说一些。资产现值的决定因素是所有资产的总价值，等于它期望当中的未来收入流的折现和。
任何一种产品，它之所以有价值，是人们预期它将来能够提供服务，它能够为人所用。而这种预期，构成了任何资源当前的价值。这时候，我们就能够看到一个非常有趣的逻辑，那就是资源的价值取决于，而且只取决于人们对它未来收益的预期。如果预期发生了改变，资源的价值也就会当场做出改变。</p>

<p>掌握了需求定律，你就了解了人性；掌握了边际的概念，你就掌握了合理配置有限资源的基本方法；而掌握了比较优势原理，你就学会了永远要和别人分工合作，永远要取长补短的道理；而掌握了资产现值的决定因素的原理，你就能够了解时间的意义，你就永远不会固步自封，你就会学会以开放的心态拥抱未来。</p>

<h1>课外阅读</h1>

<h3>阿尔钦 为什么说存活才是经济学研究的重点？</h3>

<h3>奥斯特罗姆 没有主人的资源会被完全损耗掉吗？</h3>

<h3>巴斯夏 把铺好的路铲掉重铺，能刺激经济发展吗？</h3>

<h3>德姆赛茨 为什么说交易成本在现实生活中无处不在？</h3>

<h3>法玛 为什么说人类历史是不可预测的？</h3>

<h3>弗里德曼 如果让家长和学生投票选择学校</h3>

<h3>海耶克 为什么说商人运用信息牟利是合理的？</h3>

<h3>加里·贝克 为什么说竞争越激烈歧视就越少？</h3>

<h3>卡普兰 为什么人们会理性地选择胡闹？</h3>

<h3>开课前，我有话想对你说</h3>

<h3>凯恩斯 为什么说仅仅用数学语言来讲经济学，会造成重大缺失？</h3>

<h3>科斯 该不该让牛吃小麦？</h3>

<h3>麦科洛斯基 为什么现代人那么富裕？</h3>

<h3>曼尼 为什么说恶意收购并不恶意？</h3>

<h3>欧文·费雪 为什么收取利息天经地义？</h3>

<h3>图洛克 地铁票价取消打折，谁损失更大？</h3>

<h3>威廉斯 为什么说最低工资法会剥夺穷人的工作？</h3>

<h1>问答</h1>

<h3>问答 第1期 经济学最基础的概念</h3>

<h3>问答 解决资源分配问题，“认人”好还是“认钱”好？</h3>

<h3>问答 企业越多竞争就越激烈吗？</h3>

<h3>问答 人类社会为什么需要货币？</h3>

<h3>问答 为什么实施同工同酬法往往会事与愿违？</h3>

<h3>问答 为什么说方言会逐渐消失？</h3>

<h3>问答 为什么说监管不是越严格越好？</h3>

<h3>问答 为什么说权利是人赋的，而不是天赋的？</h3>

<h3>问答 为什么学区房让上学变更难？</h3>

<h3>问答 为什么有人拿固定工资，有人却能赚很多钱？</h3>

<h3>问答 为什么有人拿月薪，有人拿年薪？</h3>

<h3>问答 为什么有些知识收费，有些知识免费？</h3>

<h3>问答 为什么主动暴露弱点可以取信于人？</h3>

<h3>问答 家里做饭的口味，迁就爸爸还是妈妈？</h3>

<h3>问答 没有中间商，药价就会便宜吗？</h3>

<h3>问答 赢得别人尊重主要靠自己的比较优势</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[董悠悠-不可不知的50位艺术大师]]></title>
    <link href="http://hongchaozhang.github.io/blog/2020/10/15/50yishudashi/"/>
    <updated>2020-10-15T17:55:01+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2020/10/15/50yishudashi</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>00丨发刊词：学艺术，还得跟着大师学</h2>

<h2>01丨乔托：相信老师还是相信自己</h2>

<ul>
<li>西方绘画之父</li>
<li>代表作：斯科维尼小教堂壁画《最后的审判》</li>
</ul>


<p>乔托之前的画家都是画家跟画家和之前的作品学画画，而不管自己眼睛看到的是什么样子。这种方式持续了一千年，到乔托这儿才开始了改变。乔托选择“相信自己的眼睛“。</p>

<p>虽然按照我们现在的眼光来看，乔托只是把普通的动画，画出了3D动画的感觉。但是，这在700年前已经是非常前卫、非常厉害的了。他的这种做法彻底改变了西方艺术史，在他之后的六七百年里，西方的画家们都是朝着这个方向越走越远。</p>

<h3>艺术风格公式</h3>

<p>西方绘画之父：3D动画感+蓝色褪色+用背景衬托人物</p>

<h2>02丨达芬奇：“强迫症”科学家怎么画画</h2>

<h3>磨皮效果</h3>

<p>在达芬奇的画里，人脸的边缘都是没有明显的一条分界线的，就像是用我们现在的P图软件磨过皮一样。达芬奇就是用这种方式实现从亮到暗的过度的。比如《蒙娜丽莎》的脸：</p>

<p><img src="http://hongchaozhang.github.io/images/%E8%BE%BE%E8%8A%AC%E5%A5%87%E6%9C%80%E5%90%8E%E7%9A%84%E6%99%9A%E9%A4%90.jpg" alt="达芬奇最后的晚餐" /></p>

<h3>空间透视</h3>

<p>《最后的晚餐》通过线性透视实现立体感。线性透视在室内容易实现，在室外没有直线就难以利用。达芬奇发明了自己的空气透视法：越近的东西，细节就越清楚；越远的东西，轮廓就越模糊，而且颜色也更加的不真实，甚至远到一定程度的时候，最远处的东西会变成蓝色的。比如《岩间圣母》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E8%BE%BE%E8%8A%AC%E5%A5%87%E5%B2%A9%E9%97%B4%E5%9C%A3%E6%AF%8D.jpg" alt="达芬奇岩间圣母" /></p>

<h3>艺术风格公式</h3>

<p>科技美学第一人：半成品+磨皮效果+空气透视</p>

<h2>03丨波提切利：“非主流”画家</h2>

<h3>代表作</h3>

<ul>
<li>维纳斯的诞生</li>
<li>春</li>
</ul>


<h3>艺术风格公式</h3>

<p>文艺复兴非主流：歪头忧伤少女+清新的配色</p>

<h2>04丨米开朗基罗：迷恋肌肉的雕塑家</h2>

<h3>代表作</h3>

<ul>
<li>大卫</li>
<li>西斯廷穹顶壁画</li>
</ul>


<h3>艺术风格公式</h3>

<p>文艺复兴雕塑天才：发达的肌肉+高密度的人</p>

<h2>05丨拉斐尔：完美主义的巅峰</h2>

<h3>代表作</h3>

<ul>
<li>圣母的婚礼</li>
<li>各种圣母像</li>
<li>雅典学院</li>
</ul>


<p><img src="http://hongchaozhang.github.io/images/%E6%8B%89%E6%96%90%E5%B0%94%E9%9B%85%E5%85%B8%E5%AD%A6%E9%99%A2.jpg" alt="拉斐尔雅典学院" /></p>

<h3>艺术风格公式</h3>

<p>“完美”的代表，文艺复兴的巅峰：风狂画圣母+红蓝配色+磨皮+尖下巴</p>

<h2>06丨卡拉瓦乔：天才还是犯罪</h2>

<h3>作品特点</h3>

<p>第一，红与黑的配色，一般他的作品背景都是黑色的，而人往往穿着红色的衣服，或者人会流点血。
第二，他的作品里一般都有强光，而且这道光都是对角线打的。</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%8D%A1%E6%8B%89%E7%93%A6%E4%B9%94%E5%9C%A3%E6%AF%8D%E4%B9%8B%E6%AD%BB.jpg" alt="卡拉瓦乔圣母之死" /></p>

<p>第三，他画里的人都有瑕疵，看起来脏脏的。</p>

<h3>艺术风格公式</h3>

<p>17世纪绘画天才：红黑配色+对角线强光+脏脏的人</p>

<h2>07丨贝尼尼：17世纪“最佳导演”</h2>

<h3>大理石不像大理石</h3>

<p>《掳走珀耳塞福涅》讲的是冥王哈迪斯把女神珀耳塞福涅掳走，想让她回家当老婆的情景。你看哈迪斯抓住珀耳塞福涅的地方，是不是很像人的皮肤？</p>

<h3>选择夸张的瞬间</h3>

<p>贝尼尼有一件代表作叫《阿波罗和达芙妮》，讲的是太阳神阿波罗追求精灵达芙妮的故事。这个故事是这样的，太阳神爱上了达芙妮，但是，达芙妮是一个不想谈恋爱，也不想结婚的女孩子。她觉得阿波罗很烦，就向她的父亲求助。他的父亲河神，就把达芙妮变成了一棵月桂树。从此，达芙妮就变成了月桂女神。</p>

<p>他选了故事最具戏剧性的时刻，也就是达芙妮变身的时刻。你可以看一下，达芙妮手是不是已经变成了树枝？上边全部是叶子，她的腿已经变成了树皮。正是因为贝尼尼选的都是戏剧性的时刻，所以他作品里的人，表情和肢体语言都比较浮夸。</p>

<p>所以，虽然《阿波罗和达芙妮》是一尊静止的雕像，但是，我们却可以感受到动感，我们能感觉到：阿波罗和达芙妮是在奔跑着，达芙尼就快被阿波罗追上了，这时她开始变身了。你还可以注意下阿芙尼的表情，也非常生动。好像她发现自己正在变身，感到非常惊讶，我们甚至可以听到她的尖叫。</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%98%BF%E6%B3%A2%E7%BD%97%E5%92%8C%E8%BE%BE%E8%8A%99%E5%A6%AE.jpg" alt="阿波罗和达芙妮" /></p>

<h3>艺术风格公式</h3>

<p>巴洛克最佳导演：表情浮夸+“有颜色”的雕塑</p>

<h2>08丨鲁本斯：胖子美在哪里</h2>

<p>之前两期，我分别给你讲了巴洛克艺术的开端：卡拉瓦乔，和巴洛克的雕塑巅峰：贝尼尼。那谁是巴洛克的绘画巅峰呢？就是我们今天要讲的鲁本斯。</p>

<h3>什么是巴洛克</h3>

<p>巴洛克这个词，其实是来自葡萄牙语的“barroco”，意思是不规则的珍珠。珍珠一般都是越圆，越完美的越值钱。不规则的，坑坑洼洼的珍珠就不怎么值钱。所以开始的时候“巴洛克”艺术，是贬义词，为了讽刺那些奇奇怪怪的，不规则的艺术。意思就是，你们这些歪瓜裂枣，跟文艺复兴时期的那种稳定、典雅之美很不一样。当然，我们现在再说巴洛克的时候，是一个中性词，没有任何贬义的意思。</p>

<h3>不稳定带来动感</h3>

<p>文艺复兴时期的画比较“稳定”，比如《最后的晚餐》。再看看鲁本斯的《耶稣上十字架》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%B2%81%E6%9C%AC%E6%96%AF%E8%80%B6%E7%A8%A3%E4%B8%8A%E5%8D%81%E5%AD%97%E6%9E%B6.png" alt="鲁本斯耶稣上十字架" /></p>

<p>你看看鲁本斯的画里，人都是怎么排列的。是不是都排在了对角线上？你有没有发现，我们在看一条水平线，或者是一条竖线的时候，往往会觉得很稳。就比如一根笔直的电线杆，你会觉得它很稳定；但是如果一根倾斜的电线杆放在那里，你就会觉得很危险，随时都要倒下了，因为倾斜会给我们一种不稳定感，好像它的状态会随时发生变化。鲁本斯正是利用了这一点，让画面动了起来。</p>

<p>再比如《法厄同得坠落》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%B2%81%E6%9C%AC%E6%96%AF%E6%B3%95%E5%8E%84%E5%90%8C%E7%9A%84%E5%9D%A0%E8%90%BD.png" alt="鲁本斯法厄同的坠落" /></p>

<p>法厄同是太阳神的儿子，他驾驶着太阳马车运太阳，结果失控了，人仰马翻。太阳要掉到地上，那地面不就生灵涂炭了吗？这时候宙斯为了保护地面的生命，就打了一个闪电，把马车和法厄同一起击毁了，这幅画描绘的就是这么一个瞬间。你是不是能感受到这种千钧一发的时刻？感受到对角线构图带来的不稳定，和动感呢？</p>

<h3>X构图和螺旋构图</h3>

<p>《掳走留西帕斯的女儿》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%B2%81%E6%9C%AC%E6%96%AF%E6%8E%B3%E8%B5%B0%E7%95%99%E8%A5%BF%E5%B8%95%E6%96%AF%E7%9A%84%E5%A5%B3%E5%84%BF.png" alt="鲁本斯掳走留西帕斯的女儿" /></p>

<p>这幅画就同时具有X构图和螺旋构图：</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%B2%81%E6%9C%AC%E6%96%AF%E6%8E%B3%E8%B5%B0%E7%95%99%E8%A5%BF%E5%B8%95%E6%96%AF%E7%9A%84%E5%A5%B3%E5%84%BFX%E6%9E%84%E5%9B%BE.jpg" alt="鲁本斯掳走留西帕斯的女儿X构图" /></p>

<p><img src="http://hongchaozhang.github.io/images/%E9%B2%81%E6%9C%AC%E6%96%AF%E6%8E%B3%E8%B5%B0%E7%95%99%E8%A5%BF%E5%B8%95%E6%96%AF%E7%9A%84%E5%A5%B3%E5%84%BF%E8%9E%BA%E6%97%8B%E6%9E%84%E5%9B%BE.jpg" alt="鲁本斯掳走留西帕斯的女儿螺旋构图" /></p>

<h3>理性美和感性美</h3>

<p>下面依次可以看到三幅《美惠三女神》，她们分别是拉斐尔的，波提切利的和鲁本斯画的美惠三女神：</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%8B%89%E6%96%90%E5%B0%94%E7%BE%8E%E6%83%A0%E4%B8%89%E5%A5%B3%E7%A5%9E.png" alt="拉斐尔美惠三女神" />
<img src="http://hongchaozhang.github.io/images/%E6%B3%A2%E6%8F%90%E5%88%87%E5%88%A9%E7%BE%8E%E6%83%A0%E4%B8%89%E5%A5%B3%E7%A5%9E.png" alt="波提切利美惠三女神" />
<img src="%E9%B2%81%E6%9C%AC%E6%96%AF%E7%BE%8E%E6%83%A0%E4%B8%89%E5%A5%B3%E7%A5%9E.png" alt="鲁本斯美惠三女神" /></p>

<p>美惠三女神是神话里代表着美丽、魅力和创造力的三位女神，她们经常会出现在维纳斯的身边，是西方艺术里很经典的题材，很多画家都曾经画过。你可以注意一下，在这三幅画里是不是鲁本斯画的要胖得多？那相比之下，拉斐尔和波提切利画的美惠三女神是不是就瘦多了？</p>

<p>其实，拉斐尔和波提切利画的是体现了文艺复兴时期的审美，因为文艺复兴时期崇尚的是理性美。理性是什么意思呢？理性代表着节制、稳定、有秩序，所以你可以看到文艺复兴的作品往往构图都很稳定，就像《最后的晚餐》一样，人也都是瘦瘦的。</p>

<p>但是巴洛克时期欧洲爆发了各种战争，宗教战争、独立战争等等，人们生活很不安定。你想想在战乱时期，人们衣不暖食不饱，所以会崇尚一种今朝有酒今朝醉的感性美。这种丰满的人体恰恰符合了当时人们的审美。</p>

<p><strong>其实这也给了你一个，判断某个时代审美偏好的指标，如果一个时代以瘦为美，那么这个时代很有可能就是崇尚理性美；如果一个时代以胖为美，那么这个时代就崇尚感性美。</strong></p>

<h3>艺术风格公式</h3>

<p>巴洛克绘画巅峰：对角线构图+X型构图+螺旋构图+胖胖胖</p>

<h2>09丨伦勃朗：最会“自拍”的画家</h2>

<h3>伦勃朗光</h3>

<p>在大多数伦勃朗的画里，人都在半明半暗的里，就是一边脸是亮的，一边脸是暗的。而且在比较暗的那面脸颊上，会形成一个倒着的三角形。</p>

<p><img src="http://hongchaozhang.github.io/images/%E4%BC%A6%E5%8B%83%E6%9C%97%E5%85%89.png" alt="伦勃朗光" /></p>

<p>在大多数伦勃朗的画里，人都在半明半暗的里，就是一边脸是亮的，一边脸是暗的。而且在比较暗的那面脸颊上，会形成一个倒着的三角形。</p>

<p><img src="http://hongchaozhang.github.io/images/%E4%BC%A6%E5%8B%83%E6%9C%97%E5%85%89%E7%8E%B0%E4%BB%A3%E4%BA%BA%E7%89%A9%E6%91%84%E5%83%8F.png" alt="伦勃朗光现代人物摄像" /></p>

<h3>艺术风格公式</h3>

<p>自拍狂人：肖像画+伦勃朗光+黑衣服白领子</p>

<h2>10丨维米尔：被画画耽误的侦探小说家</h2>

<h3>用光线制造神秘氛围</h3>

<p>你有没有发现，维米尔的绝大多数的作品里，左边都有一扇窗。就像我们刚看到的《拿天平的女子》和《倒牛奶的女仆》。即使没有窗，我们也能从画面中的光线感觉到，好像画的左边有扇窗，比如你现在在屏幕上看到的《情书》这幅画，就能给人这样的感觉。</p>

<p><img src="http://hongchaozhang.github.io/images/%E7%BB%B4%E7%B1%B3%E5%B0%94%E6%83%85%E4%B9%A6.jpg" alt="维米尔情书.jpg" /></p>

<p><img src="http://hongchaozhang.github.io/images/%E7%BB%B4%E7%B1%B3%E5%B0%94%E6%88%B4%E7%8F%8D%E7%8F%A0%E8%80%B3%E7%8E%AF%E7%9A%84%E5%B0%91%E5%A5%B3.jpg" alt="维米尔戴珍珠耳环的少女.jpg" /></p>

<h3>艺术风格公式</h3>

<p>不知名的天才：蓝黄搭配+左边有窗+有阻挡物</p>

<h2>11丨委拉斯凯兹：“魔镜”中的秘密</h2>

<h3>魔镜</h3>

<p>《镜中的维纳斯》是西班牙历史上第一幅裸体画， 因为西班牙当时非常保守，裸体画是不被允许的，而这幅就是第一幅。</p>

<blockquote><p>在这幅画里，我们可以看到一位裸体的女子，侧卧在床上，她旁边有一位带着翅膀的小天使，举着一面镜子，在给这位女子照镜子。这个女子是谁呢？你要记住，你后你只要看到裸女和小天使加上一面镜子一同出现，就说明这个女子是爱与美的女神维纳斯。因为比较美，所以爱照镜子，你可以这么理解。</p></blockquote>

<p><img src="http://hongchaozhang.github.io/images/%E9%95%9C%E4%B8%AD%E7%9A%84%E7%BB%B4%E7%BA%B3%E6%96%AF.png" alt="镜中的维纳斯.png" /></p>

<p>你有没有发现镜子中的女神面孔非常模糊，几乎看不清这个女孩子的五官。通过这个作品，委拉斯凯兹给我们提出了一个非常创新的做法：镜子中反射出的影像不一定是真实的。可以说委拉斯凯兹对后来艺术家最大的启发就是，之前的艺术家都在追求画的像，但是委拉斯凯兹告诉我们，<strong>画画可以不追求真实</strong>。</p>

<h3>艺术风格公式</h3>

<ol>
<li>他的画里都是贵族，所以他们衣服的面料都很贵，都是反光的。</li>
<li>因为他画的都是西班牙贵族，所以很多都长着大下巴。</li>
<li>就是他最著名的两幅画中都有镜子，他把镜子这个道具运用到了炉火纯青的地步。</li>
</ol>


<p>镜子魔术师：贵族反光面料+大下巴——经典作有镜子</p>

<h2>12丨夏尔丹：画家的厨房</h2>

<h3>静止的生命</h3>

<p>有一位评论家对夏尔丹的描述非常准确，他说在夏尔丹之前，静物画是Nature morte，这是一个法语，意思是“死去的自然”；但在夏尔丹之后，静物画就是still-life，也就是英文里的“静止的生命”。</p>

<h3>艺术风格公式</h3>

<p>市民艺术家：平凡的事物+背后的思考+咖啡色墨绿色桔红色</p>

<h2>13丨布歇：法国人眼里的中国人</h2>

<h3>洛可可</h3>

<p>在法语里，洛可可叫“Rococo”，这个词来自法语的“rocaille” 小石头和“coquille“贝壳，有两个特点：
1. 奢华贵气和小清新的色调，最常用的就是粉蓝，粉红和粉绿。
2. 大量的运用自然元素，比如小石头、贝壳，花花草草。</p>

<p>洛可可时期的作品没有什么欣赏门槛，它不像之前我们说的巴洛克时期，艺术作品，总要表现一些宏大、深刻的主题。洛可可时期的作品，更注重单纯的视觉享乐，说白了就是看起来很好看，给人一种很轻松欢快的感觉就够了。</p>

<h3>西方作品中的中国元素</h3>

<p>布歇的梳妆室画的是两个贵族女孩子在化妆间的情景。如果仔细看的话，你会发现在画面左下角放着一柄团扇；在茶几上摆放着一套瓷器；最明显的是，背景中的一扇装饰着花鸟图案的屏风。这些，都是非常具有咱们中国特色的物件。</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%B8%83%E6%AD%87%E6%A2%B3%E5%A6%86%E5%AE%A4.png" alt="布歇梳妆室.png" /></p>

<p>类似的作品还有很多，比如《早餐》，还有专门描写中国的《中国花园》、《中国婚礼》、《中国皇帝上朝》。</p>

<p>布歇并没有真正到过中国，他画的中国景象是通过工艺品上的图案，是根据传教士编的图册来画的，当中还有很多想象的成分。所以，布歇的中国画都是中西合璧的。</p>

<p>其实，18世纪的时候在法国宫廷，刮起了一股“中国风”。在法语里有个专有名词，叫“chinoiserie”，也就是中国风。后来这股潮流蔓延到了整个欧洲，那为什么那个时候的欧洲这么迷恋“中国风”呢？</p>

<p>其实18世纪的时候，西方人通过贸易往来，传教等等途径，突然发现：在遥远的东方，有一个国家的人们，好像过着一种无忧无虑地、 “田园牧歌”式的生活。在欧洲人看来，中国简直就是一个世外桃源、乌托邦，他们对中国充满了无限的向往和遐想。</p>

<p>所以，欧洲人对来自咱们中国的商品非常着迷。对他们来说，中国的丝绸，瓷器，各种工艺品都是奢侈品，是摆在宫廷和家里用来显示自己的身份的。是不是觉得很穿越？我们现在很多人去法国买奢侈品，但几百年前，法国人喜欢买中国奢侈品。</p>

<p>他们不仅喜欢用咱们中国的物件和工艺品，而且这些工艺品中的艺术风格，也大大地影响了当时的审美。所以说，洛可可风很有可能就是受了咱们中国审美的影响。</p>

<p>洛可可作品中，常用的粉色系，粉红、粉绿、粉黄，很有可能就是从咱们中国出口过去的布料、瓷器上得到的灵感。
除此之外，我们都是知道咱们中国瓷器很喜欢用植物装饰。而洛可可的其中一个特点，就是大量用大自然元素做装饰。而且，在洛可可之前法国人崇尚的是对称。最典型的就是，路易十四的凡尔赛花园，每一颗植物都被修剪得整整齐齐的，都很对称。</p>

<p>但是，跟他们相反的，咱们中国的园林，讲究道法自然，好想都是看起来非常的随意。中国这种对待自然的态度，在洛可可时期很受那个时候的欧洲人推崇，你看刚才布歇画里的植物、布景都很随意。</p>

<h3>艺术风格公式</h3>

<p>法国典型洛可可风代表：衣着华丽+小清新粉色+中国元素</p>

<h2>14丨大卫：如何用艺术“掌权”</h2>

<h3>代表作</h3>

<p>《拿破仑过阿尔卑斯》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%8B%BF%E7%A0%B4%E4%BB%91%E8%BF%87%E9%98%BF%E5%B0%94%E5%8D%91%E6%96%AF%E5%B1%B1.png" alt="拿破仑过阿尔卑斯山.png" /></p>

<h3>新古典主义风格</h3>

<p><img src="http://hongchaozhang.github.io/images/%E5%A4%A7%E5%8D%AB%E8%B4%BA%E6%8B%89%E6%96%AF%E5%85%84%E5%BC%9F%E4%B9%8B%E8%AA%93%E8%A8%80.png" alt="大卫贺拉斯兄弟之誓言.png" /></p>

<p>大卫的《贺拉斯兄弟之誓言》。这个故事是这样的。古罗马的时候，贺拉斯三兄弟马上就要去战场了，正在跟他们的老父亲发誓表决心，大概就是：我们一定会努力上场杀敌不怕牺牲的！但是，贺拉斯三兄弟的姐妹跟他们敌人有婚约。所以在大卫的画里，左边三兄弟正在跟站在他们对面的老父亲发誓，而画面的另一边，他们的姐妹已经哭倒在椅子上了。
在你看来，大卫用这个故事，想要讲一个什么道理呢？</p>

<p>其实大卫想要用这个故事告诉人们：要爱国，为了国家利益，可以放弃私人感情，舍小家，为大家。</p>

<p>你可以特别注意下，在这幅画里大卫用来画男人和女人的线条有什么不一样？你会发现，他用来画男人用的线条都是直线，他用来画女人的线条都是曲线。这两种线条给人的感觉是不一样的，直线可以提现出男性的坚决和果断，曲线可以提现出女性的柔弱。</p>

<p>这幅画让大卫的名声大震，一下改变了法国当时绘画的流行趋势。原来，流行的是看起来非常复杂奢华的洛可可风。就像我们之前说的布歇那种风格。而大卫的画看起来就比较朴素。他用的颜色也比较少，除了红色，其他都比较暗。他的线条也比较简洁。</p>

<p>这种简洁的颜色和线条，加上他喜欢用古希腊古罗马故事来讲道理的特点，形成了一种新的风格，叫<strong>新古典主义风格</strong>。请记住这个风格的名字，因为这个风格称霸法国画坛很多年。在之后的很长一段时间里，法国画坛上最有名的画家，要么是大卫自己，要么就是大卫的学生们。</p>

<h3>化腐朽为神奇</h3>

<p>大卫简直是一个塑造光辉形象的高手，他善于通过细节塑造一个人的形象，让他想要说的事情更有说服力。比如，在法国大革命期间，他成功地把一个杀人恶魔，塑造成了一个圣人。这幅画叫《马拉之死》。</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%A4%A7%E5%8D%AB%E9%A9%AC%E6%8B%89%E4%B9%8B%E6%AD%BB.png" alt="大卫马拉之死.png" /></p>

<p>马拉本来是一个病入膏肓50多岁的中年男子，但大卫在画他的时候，先把他外形上的瑕疵修掉，让他成了一个体型完美、身体健壮的青年男子，看起来好像只有30几岁；再为他设计一个姿势，画中马拉的姿势，用的是耶稣下十字架的姿势。耶稣是谁？是神，是圣人。大卫通过一个简单的姿势，就把马拉神圣化了。</p>

<h3>艺术风格公式</h3>

<p>拿破仑的宣传委员：酱油色红色+罗马故事+拿破仑+讲道理</p>

<h2>15丨安格尔：为什么要把美女画畸形？</h2>

<p>下面是安格尔的代表作，挂在卢浮宫的《大宫女》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%AE%89%E6%A0%BC%E5%B0%94%E5%A4%A7%E5%AE%AB%E5%A5%B3.png" alt="安格尔大宫女.png" /></p>

<p>看到这幅画以后， 你能猜到为什么这幅画不受欢迎了吗？你有没有发现，画里的女孩子身体不成比例？有种我们现在说的，P图P到地板都歪了感觉。只要稍微留意下，你就会发现人类身体是没有办法这样长得这样长的，画里的这个女孩子的手臂，腿和背都被画家特意地给拉长了。当时，最著名的对这幅画的吐槽就是：“她的脊柱多了三块骨头。”</p>

<p>如果我们再看看他其他的作品的画，你会发现，他不是只这幅画这样，在他很多幅著名作品里，女孩子都有或多或少的畸形。比如，在他画的另一幅《浴女》中，也就在洗澡的女孩子里，你会发现，他把人女孩子的下颌骨去掉了，也就是说，他没有画人家的下巴。</p>

<p>安格尔为什么要这么做呢？安格尔曾经说过，画画的时候如果太注重科学或者是细节，就会看起来不真诚，有碍于画家表达中心思想。所以，他画画的时候，往往更注重画面给人的整体感觉，注重画有没有表达出他的思想，而不是某个细节真不真实，符不符合客观规律。
所以，他把《大宫女》后背、手臂，腿拉长，那是为了让画面整体的线条看起来修长，更好看，也是为了突出画里这个女子那种懒洋洋的感觉。</p>

<p>当然，他的这种为了整体感觉，不惜把人画畸形的想法，在当时是非常先进的思想，甚至有些过于先进了。所以当时的很多人，对他都有很深的误解；包括到了今天，也还有很多人，并不能认同他的风格，不觉得他有多伟大。</p>

<p>但是，很多我们熟悉的大画家们，都意识到了安格尔的伟大。我们可以看到像毕加索、马蒂斯、高更，都在安格尔作品的上得到了灵感。所以，安格尔并不是一个只知道复制黏贴的传统画家，他画的畸形少女恰恰体现了他的伟大和创新。</p>

<h3>艺术风格公式</h3>

<p>喜欢画畸形少女的画家：露背+红白头巾+畸形</p>

<h2>16丨透纳：大自然也有情感？</h2>

<h3>浪漫主义风景画</h3>

<p>透纳不追求写实，不追求画的像，而是将自己的情感融入画中，通过画来表现自己的情感。这叫做<strong>浪漫主义风景画</strong>。</p>

<p>比如他的《暴风雪》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%80%8F%E7%BA%B3%E6%9A%B4%E9%A3%8E%E9%9B%AA.png" alt="透纳暴风雪.png" /></p>

<p>他的《奴隶船》描绘的是奴隶被抛进大海淹死的情景：</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%80%8F%E7%BA%B3%E5%A5%B4%E9%9A%B6%E8%88%B9.png" alt="透纳奴隶船.png" /></p>

<p>再比如《汉尼拔和他的军队越过阿尔卑斯山》名为画人，实际上大部分篇幅是自然，不仔细看都看不到人在哪里：</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%80%8F%E7%BA%B3%E6%B1%89%E5%B0%BC%E6%8B%94%E5%92%8C%E4%BB%96%E7%9A%84%E5%86%9B%E9%98%9F%E8%B6%8A%E8%BF%87%E9%98%BF%E5%B0%94%E5%8D%91%E6%96%AF%E5%B1%B1.png" alt="透纳汉尼拔和他的军队越过阿尔卑斯山.png" /></p>

<p>那为什么透纳这么迷恋灾难呢？有人推测，这很有可能是因为他20多岁时，第一次离开英国，坐船去法国旅行的时候，遇上了特别大的风浪，自己坐的船差一点就要翻了。这次经历让他对自然的力量，产生了敬畏。</p>

<h3>一团颜色，自成风格</h3>

<p>透纳的作品还有另外一个很特别的点，那就是颜色。在透纳前期的作品里，我们还能看到人物、风景的轮廓；但到了后期，不要说人了，连风景也看不清楚了，只有一团颜色。比如《国会大厦火灾》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%80%8F%E7%BA%B3%E5%9B%BD%E4%BC%9A%E5%A4%A7%E5%8E%A6%E7%81%AB%E7%81%BE.png" alt="透纳国会大厦火灾.png" /></p>

<p>这幅画就很好地体现了这一点。在这幅画里，除了右边的大桥我们基本看不到什么，但是，过了几百年，站在这幅面前，我们还是能强烈地感觉到当时那场大火，仿佛要吞没整个城市的感觉。</p>

<p>他这种对光的迷恋，对颜色的迷恋，启发了很多之后的大师。几十年以后，来到英国的印象派大画家莫奈，就从他的画里吸取了灵感；还有他这种经常被吐槽的，“看起来什么都没画，只有颜料”的风格，对之后的抽象表现主义，也有着深远的意义。</p>

<h3>艺术风格公式</h3>

<p>灾难片画家：灾难+漩涡+红黄配色</p>

<h2>17丨德拉克洛瓦：画怎么煽情</h2>

<h3>招黑体质</h3>

<p>他跟别的艺术家，不一样。他的作品，跟那个时候人们印象里的好作品，相差甚远。</p>

<p>那个时候的主流，是新古典主义，也就安格尔那一派的风格：线条干净利落，画面简洁庄严，传达一种正能量。</p>

<p>再来看看德拉克洛瓦的，你会发现它整体会给人一种混乱的感觉，颜色乱七八糟，主题都是屠杀、地狱、战争等等，简直就是满满的负能量。</p>

<p>但是，引起大众的反感，受到了很多批评，并不意味着德拉克洛瓦的作品不好，只不过意味着，他的作品，跟传统不一样罢了。他的作品，被很多人骂完之后，又被识货的政府给买了、收藏了。</p>

<p>让我们看看他的《萨尔达那巴勒之死》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%BE%B7%E6%8B%89%E5%85%8B%E6%B4%9B%E7%93%A6%E8%90%A8%E5%B0%94%E8%BE%BE%E9%82%A3%E5%B7%B4%E5%8B%92%E4%B9%8B%E6%AD%BB.jpg" alt="德拉克洛瓦萨尔达那巴勒之死.jpg" /></p>

<p>再来，就是我们最熟悉的《自由引导人民》。德拉克洛瓦在画里，描绘的是法国的七月革命，中间是自由的化身——自由女神带着人民去战斗。这幅画，也没有逃过被批评的命运。甚至有人说，女神就像卖鱼的大婶。</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%BE%B7%E6%8B%89%E5%85%8B%E6%B4%9B%E7%93%A6%E8%87%AA%E7%94%B1%E5%BC%95%E5%AF%BC%E4%BA%BA%E6%B0%91.jpg" alt="德拉克洛瓦自由引导人民.jpg" /></p>

<h3>线条和颜色哪个更重要？</h3>

<p>很多人说，19世纪上半页，法国的艺术史就是安格尔和德拉克洛瓦的打架史。而且，他们产生分歧的点，就是画画的时候，到底是线条重要，还是颜色重要？</p>

<p>安格尔、大卫的作品，看起来非常干净利落，感觉画家的每一笔，都是经过仔细思考之后才画的。对于这一派画家来说，线条就更加重要。德拉克洛瓦的作品呢，第一眼就有种非常混乱的感觉，感觉画家画画的时候，非常激动。对于他来说，颜色是他最强大的武器。</p>

<p>德拉克洛瓦对颜色的研究与痴迷，影响了他之后很多的艺术家。比如，印象派最看重的也是颜色，很大一部分就是对德拉克洛瓦的影响；再比如，梵高、修拉，也是受到他的影响。</p>

<p>线条和颜色，还代表了不同的思维方式。<strong>线条，偏向理性，而颜色，则是偏向感性</strong>。德拉克洛瓦也说，自己画画的时候，是跟着感觉走的。他想要表现的，不是冷冰冰的事实或者道理，而是主观的感觉。</p>

<p>德拉克洛瓦也是浪漫主义，只是透纳是画风景的浪漫主义，而德拉克洛瓦是画人的浪漫主义。他们画的都是暴力、激烈的场景。</p>

<h3>艺术风格公式</h3>

<p>浪漫主义招黑画家：小说题材+暴力场景+红绿对比色</p>

<h2>18丨米勒：画农民出名的画家</h2>

<h3>擅长画农民</h3>

<p>下面的《拾穗者》和《晚祷》是米勒的代表作，从中可以看出米勒最擅长画农民。在米勒之前，大家画的都是深化、历史、宗教、伟人等各种高大上的题材，而米勒的农民之所以能被人们接受，和当时的历史背景是有关系的。</p>

<p>在历史上，1848年可不是平凡的一年。1848年，《共产主义宣言》发表了，意味着无产阶级革命开始了。说得简单点，就是在社会上，大家对于农民的看法改变了，开始尊重劳动者了。米勒正是赶上了那年最大的热点。</p>

<p><img src="http://hongchaozhang.github.io/images/%E7%B1%B3%E5%8B%92%E6%8B%BE%E7%A9%97%E8%80%85.png" alt="米勒拾穗者.png" /></p>

<p><img src="http://hongchaozhang.github.io/images/%E7%B1%B3%E5%8B%92%E6%99%9A%E7%A5%B7.png" alt="米勒晚祷.png" /></p>

<p>米勒因为画农民很成功，收获了一批迷弟。梵高、莫奈、达利、比萨罗，都多多少少受到了他的影响。你现在在屏幕上看到的，分别是梵高的《播种者》和米勒的《播种者》，无论是题材，还是构图，甚至是画中人的姿势，都有很多相似的地方。</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%A2%B5%E9%AB%98%E6%92%AD%E7%A7%8D%E8%80%85.png" alt="梵高播种者.png" /></p>

<p><img src="http://hongchaozhang.github.io/images/%E7%B1%B3%E5%8B%92%E6%92%AD%E7%A7%8D%E8%80%85.png" alt="米勒播种者.png" /></p>

<h3>画出农民的庄重</h3>

<p>米勒之前也有人画农民，但是画中的农民都是一副滑稽愚昧的样子，而米勒一改传统，画出来农民的庄重、坚毅、宁静。</p>

<h3>逆光不清晰</h3>

<p>米勒用了哪些方法，来画出农民的宁静和庄重呢？</p>

<ol>
<li>逆光。逆光会让人物形成一个概括的剪影，会带来一种永恒感，仿佛时间都停止住了。正是因为逆光，在米勒的画里，你基本是看不到人物的脸的。那是因为米勒画的不是具体的某个人，不是某一天、某一个时刻。米勒画的是农民的一个常态，是几百年来，农民都重复着这个动作的时刻。这也表达了一种永恒的感觉。</li>
<li>高级灰。米勒觉得，人物才是画面的主体，而颜色很容易诱惑人的眼睛，而让人忽略了主体。所以，你在米勒的画里看不到特别鲜艳的颜色。但也正是因为这样，米勒的画给人一种安静、平静感觉。</li>
</ol>


<p>下图是布鲁盖尔另一幅表现农民的画：《农民的婚礼》，你可以看到他用的颜色就很鲜艳，让人感觉很活泼。相比之下，米勒这种偏灰偏冷的颜色，更适合用来表现农民庄重的美。</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%B8%83%E9%B2%81%E7%9B%96%E5%B0%94%E5%86%9C%E6%B0%91%E7%9A%84%E5%A9%9A%E7%A4%BC.png" alt="布鲁盖尔农民的婚礼.png" /></p>

<h3>艺术风格公式</h3>

<p>农民画家：农民+逆光+冷灰色调</p>

<h2>19丨库尔贝：没见过的东西画得出来吗</h2>

<h3>代表作《采石工》</h3>

<p>下面是库尔贝的采石工，它和《播种者》同时展出，但是它尺寸2.4米宽，1.7米高，其中的人物是1:1的高度，而播种者是0.8米宽，1米高，只是半个人的高度，给人的视觉冲击力肯定是不一样的。这也是《采石工》引起更大反响的原因之一。</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%BA%93%E5%B0%94%E8%B4%9D%E9%87%87%E7%9F%B3%E5%B7%A5.png" alt="库尔贝采石工.png" /></p>

<h3>现实主义</h3>

<p>当然，上面的原因不足以让这幅画引起那么大的轰动。这幅画之所以出名，还有一个更加深层的原因。</p>

<p>之前我们讲到，米勒画的农民，你看不出来画的是哪位具体农民，哪个具体的时代，感觉生活在世外桃源，有一种永恒感。</p>

<p>但是库尔贝的《采石者》就不一样了。他画的就是当时的现状。19世纪，工业革命开始了，土地都被圈走养羊、盖工厂了，失去土地的农民，只能打零工、采石头来赚钱。社会矛盾也变得非常剧烈。库尔贝就通过这个画，把这个现象反映出来了，具有很强的批判性。也就是说，库尔贝想用画，更直观的告诉人们农民的现状有多惨。</p>

<p>这就是<strong>现实主义</strong>。说到现实主义，很多人误以为画得像、画得逼真，就是现实主义，其实不是的，现实主义的核心是反映和批判现实生活。</p>

<h3>艺术风格公式</h3>

<p>现实主义之父：尺寸巨大+主题写实+天气阴沉</p>

<h2>20丨马奈：被骂成名的“印象派之父”</h2>

<p>马奈的作品和当时学院派的作品风格格格不入。</p>

<p>什么是学院派的风格呢？就是新古典主义那一套，也就是大卫、安格尔那一套：主题要高大上，比如神话、宗教，要有道德寓意，要有完美的笔触、构图。我找了一张最符合当时学院派标准的作品，就是现在屏幕上的这幅《维纳斯的诞生》。</p>

<p><img src="http://hongchaozhang.github.io/images/%E7%BB%B4%E7%BA%B3%E6%96%AF%E7%9A%84%E8%AF%9E%E7%94%9F.jpg" alt="维纳斯的诞生" /></p>

<h3>题材创新：从神到人</h3>

<p>下面这幅《草地上的野餐》，是马奈的代表作，就是马奈想拿去参加展览的作品。但是这幅作品就被评审委员会拒绝了，理由就是“伤风败俗”。</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%A9%AC%E5%A5%88%E8%8D%89%E5%9C%B0%E4%B8%8A%E7%9A%84%E9%87%8E%E9%A4%90.png" alt="马奈草地上的野餐.png" /></p>

<p>你能不能看出来这幅画哪里伤风败俗呢？有人可能会觉得，是不是因为最前面的女人没穿衣服？
然而，《维纳斯的诞生》也没有穿衣服啊。但是《维纳斯的诞生》中没穿衣服的是维纳斯，是女神，周围飘着的没穿衣服的都是小天使，也是神。但是你看马奈这幅《草地上的野餐》，没穿衣服的不是神，而是一个普通人。实际上，这个女人画的是当时巴黎郊区的妓女。同样是没穿衣服，画神可以，画人就反映了当时的社会阴暗面。代表统治阶级的沙龙评委会，当然不认可这样的作品。</p>

<blockquote><p>这里顺便帮你总结一个小技巧：在印象派之前，如果你看到有裸体的人物，多半都是神。</p></blockquote>

<p>所以，马奈和之前我们讲到的米勒很像，就是在题材上，做到了创新：之前，主流绘画都是画神话、宗教、历史。我们说过的农民画家米勒，开创了新题材，开始画农村生活了；相对应的，就是生活在大城市巴黎的马奈，也开始创新，开始画城市生活了。比如《女神游乐厅的吧台》也是反应城市生活的作品：</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%A9%AC%E5%A5%88%E5%A5%B3%E7%A5%9E%E6%B8%B8%E4%B9%90%E5%8E%85%E7%9A%84%E5%90%A7%E5%8F%B0.png" alt="女神游乐厅的吧台" /></p>

<p>可以说<strong>马奈第一个大贡献，就是解放了绘画题材</strong>。之后的印象派就是学他，不再画宗教神话历史那些经典题材了，而是关注当下的现实生活，游玩、风景等等，总之就是画的内容更接地气了。</p>

<h3>回归平面</h3>

<p>从文艺复兴以来，绘画界一直都在追求，在二维的画纸上呈现三维的立体世界。然而马奈却放弃了这个标准。那沙龙委员会肯定不干了。当时有人就批评马奈说：“你看这个小男孩的裤子没有布料的质地。”但是，马奈的回答很妙，他说：“对啊，这就是一幅画啊，画就是用颜料画的啊。”</p>

<p>你可不要小看这句话，马奈的这个绘画理念，影响了几乎所有艺术家。在这之前，艺术家都在追求以假乱真，让别人看不出来这是一幅画，是最好的。但是，马奈不这么觉得，他觉得“画”就应该让人感觉到“这是画的”才是好的。</p>

<p>马奈之所以会这样想，也跟当时的技术发展有很大关系。马奈生活的年代，照相机已经被发明出来了。马奈就想，如果还追求“画得像”，照相机比人做得好多了，为什么还要画画呢？艺术家不就都要失业了吗？所以，马奈产生了这样的创新思想：让绘画回归绘画。</p>

<h3>恶搞经典</h3>

<h4>恶搞1</h4>

<p>当然，马奈坚持不懈地投稿，也不是全军覆没，有几幅还是入选过沙龙展的。当中最经典的一幅是《奥林匹亚》。不过这幅画虽然入选了，但马奈还是被观众骂得狗血淋头。除了上面说的伤风败俗、画面扁平之外，这回他又多了一个罪名：“恶搞”经典。</p>

<p>下面是马奈的《奥林匹亚》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%A9%AC%E5%A5%88%E5%A5%A5%E6%9E%97%E5%8C%B9%E4%BA%9A.png" alt="马奈奥林匹亚.png" /></p>

<p>马奈的《奥林匹亚》，其实是在模仿经典的画维纳斯的构图。但这回，马奈又把神圣的女神画成了轻浮的妓女。</p>

<p><img src="http://hongchaozhang.github.io/images/%E7%BB%8F%E5%85%B8%E5%A5%A5%E6%9E%97%E5%8C%B9%E4%BA%9A.png" alt="经典奥林匹亚.png" /></p>

<h4>恶搞2</h4>

<p>其实开头讲的那幅《草地上的野餐》，马奈也模仿了一幅经典作品的构图，那就是《帕里斯的审判》。在《帕里斯的审判》这幅画的右下角有三个人，这三个人的姿势，和马奈这幅《草地上的野餐》里的人，姿势是一样的。</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%A9%AC%E5%A5%88%E8%8D%89%E5%9C%B0%E4%B8%8A%E7%9A%84%E9%87%8E%E9%A4%90.png" alt="马奈草地上的野餐.png" /></p>

<p><img src="http://hongchaozhang.github.io/images/%E7%BB%8F%E5%85%B8%E5%B8%95%E9%87%8C%E6%96%AF%E7%9A%84%E5%AE%A1%E5%88%A4.png" alt="经典帕里斯的审判.png" /></p>

<p>那么马奈为什么要借鉴这个构图呢？其实《帕里斯的审判》讲的是一个经典神话故事，法语叫做Le Jugement de Pâris。帕里斯这个名字，和“巴黎”的法语Paris，写法是一样的。其实，马奈是想用这个双关语讽刺巴黎的现状，让巴黎当时那些伪善的人，接受道德的审判。马奈这样恶搞经典题材，当时巴黎人和当局者当然不喜欢。</p>

<h3>一个矛盾的人</h3>

<p>说到这里，你可能发现了，可以说马奈是个有点矛盾的人。一方面，他做了很多挑战传统的创新，并且用作品来批判社会；另一方面，他又很守旧，一心想在代表传统的沙龙展取得成功，也因此他从来不承认自己是印象派，也从来没参加过印象派的画展。</p>

<p>不过，虽然马奈不承认自己是印象派，但他的作品和画风，确确实实启发了很多印象派的大画家，比如莫奈、雷诺阿、塞尚、高更等等。可以说，马奈是一位连接传统与现代的桥梁，是一个承前启后的大师。</p>

<h3>艺术风格公式</h3>

<p>印象派之父：城市生活+追求平面+恶搞经典</p>

<h2>21丨罗丹：雕塑界的“救世主”</h2>

<h3>雕塑已死</h3>

<p>罗丹伟大在哪里呢？罗丹生活在19世纪末20世纪初，他凭借一个人的力量，改变了当时雕塑的走向，拯救了当时的雕塑艺术。</p>

<p>说拯救并不是我夸张。在罗丹生活的年代，雕塑艺术已经不行了。你还记不记得我们之前说过，在米开朗基罗和达芬奇的时代，有雕塑和绘画之争，大家会讨论雕塑比较厉害，还是绘画比较厉害？</p>

<p>但是，罗丹生活的时代已经不用讨论了。因为雕塑已经快“死”了，快沦落成装饰品，基本算不上艺术了。罗丹在跟他爸爸说“爸爸，我想要成为一个雕塑家”的时候，他爸的评价是：“可笑的职业，是个脏活啊！”从这里你就可以知道，当时的人们对于雕塑的普遍看法了。</p>

<h3>从”像“到”不像“</h3>

<p>那罗丹是怎么拯救雕塑艺术的呢？其实，说的简单点，罗丹的雕塑之路，就是一个从“像到不像”的过程。对，你没有听错，就是从”像“到”不像“。</p>

<h4>“像”</h4>

<p>我们先来说说，一开始的时候，为什么他要把雕塑雕得像。</p>

<p>其实很简单。那是因为，在他那个时候，雕塑都雕得不像真的。注意，我这里说的不像真的，意思是修饰过度，就像我们现在手机上看到的图片，PS过度了，就会变得很假。那个时候的雕塑，就有点这种感觉。下面这个雕塑，就是当时非常流行的雕塑的样子，是不是有种磨皮磨过了、有点呆呆的感觉？</p>

<p><img src="http://hongchaozhang.github.io/images/%E4%BF%AE%E9%A5%B0%E8%BF%87%E5%BA%A6%E5%88%B0%E9%9B%95%E5%A1%91.png" alt="修饰过度到雕塑.png" /></p>

<p>那罗丹是怎么改变的呢？其实，他跟乔托做的事情是一样的，就是回归大自然，直接通过观察模特来做雕塑。</p>

<p><img src="http://hongchaozhang.github.io/images/%E7%BD%97%E4%B8%B9%E9%9D%92%E9%93%9C%E6%97%B6%E4%BB%A3.png" alt="罗丹青铜时代.png" /></p>

<p>这件作品第一次公开展出的时候，很多人不接受。你可以再看一下这件作品，是不是看起来就是一个平凡男子好像在洗澡洗头发的样子。之所以大家不接受，是因为觉得雕得太像了。</p>

<h4>“不像”</h4>

<p>罗丹不但追求表面的逼真，他更喜欢通过雕塑来表现那些不可见的情感。他说：雕塑家必须学会复制，包括人类的外表、灵魂、爱情、激情和生命。所以，我们在看罗丹作品的时候，就觉得特别富有情感。</p>

<p>为了表现情感，他甚至会把人的动作和表情夸大。下面这幅图是罗丹非常著名的一件作品，叫做《浪子回头》。说的是浪子回头恳求老父亲原谅的情景。这个雕像后仰的幅度很夸张，其实罗丹是为了体现浪子那种恳切的心情。</p>

<p><img src="http://hongchaozhang.github.io/images/%E7%BD%97%E4%B8%B9%E6%B5%AA%E5%AD%90%E5%9B%9E%E5%A4%B4.png" alt="罗丹浪子回头.png" /></p>

<p>再来看一下他最著名的作品《思想者》。你可以特别观察下，这个思想者的表情和肌肉，是不是可以感受到他思考时的那种痛苦？这个就是刚我们说的，罗丹可以把那些无形的东西，通过雕塑给表现出来。</p>

<p><img src="http://hongchaozhang.github.io/images/%E7%BD%97%E4%B8%B9%E6%80%9D%E6%83%B3%E8%80%85.png" alt="罗丹思想者.png" /></p>

<p>其实，这两件作品还有一个秘密，那就是它们都来自罗丹的另一个作品——著名的《地狱之门》。</p>

<p><img src="http://hongchaozhang.github.io/images/%E7%BD%97%E4%B8%B9%E5%9C%B0%E7%8B%B1%E4%B9%8B%E9%97%A8.png" alt="罗丹地狱之门.png" /></p>

<p>《地狱之门》是罗丹给当时一个装饰博物馆做的大门，他从但丁的《神曲》里得到灵感，在这扇门上，用雕塑描绘出了地狱的情景。罗丹之后的很多作品，都是对这扇门上的各种细节，进行复制和再造。</p>

<h3>艺术风格公式</h3>

<p>雕塑界救世主：地狱主题+碎片雕塑+表面不平整</p>

<h2>22丨宫崎骏：“动画之神”怎么创作？</h2>

<h3>大主题</h3>

<p>宫崎骏的作品不只是给小孩子看的。实际上宫崎骏的动画，讨论的都是大问题，即使对大人来说，也是很需要思考的。</p>

<p>他有几个特别喜欢的主题，比如寻找自我、人与大自然、战争与和平等等。</p>

<p>《千与千寻》就是典型地以“寻找自我”为主题的故事。千寻跟着自己的爸爸妈妈穿过了隧道，来到了一个神奇的世界。她在旅途中遇到了各种各样的人，这些人都因为自己的欲望而迷失了自我。一路上千寻也遇到了各种各样的诱惑，甚至忘记了自己的名字。但还好她每次遇到诱惑的时候，只要想一想自己真正要的是什么，她就知道自己应该怎么选了。在这个旅途中，千寻学会了要忠于自己，学会了永远不舍弃对自己来说最重要的东西。</p>

<p>他的作品里还有很大一部分是人与自然的主题，比如《天空之城》《悬崖上的金鱼姬》《风之谷》《幽灵公主》等等。有人说，喜欢看宫崎骏的电影，是因为我们现在大多生活在钢筋混凝土环绕的大都市里。但是在他的电影里，我们能看到大自然、森林、树木、草地、花花草草。宫崎骏想要表现出这个世界的美丽，并唤起人们对它的尊重，告诉大家万物都有灵性。</p>

<h3>从艺术作品中获取灵感</h3>

<p>宫崎骏的作品之所以那么特别、那么有力量，还有一个原因：他经常从很多其他艺术家的作品中获得灵感。
下面是《起风了》这部动画里女主角在野外画画的场景：</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%AE%AB%E5%B4%8E%E9%AA%8F%E8%B5%B7%E9%A3%8E%E4%BA%86.jpg" alt="宫崎骏起风了.jpg" /></p>

<p>你看看是不是特别熟悉？是不是就是莫奈《撑阳伞的女子》这幅画的翻版？</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%92%91%E9%98%B3%E4%BC%9E%E7%9A%84%E5%A5%B3%E5%AD%90.jpg" alt="撑阳伞的女子.jpg" /></p>

<p>下图是《天空之城》的一个的镜头，就是有座城飘在空中的画面：</p>

<p><img src="http://hongchaozhang.github.io/images/%E5%AE%AB%E5%B4%8E%E9%AA%8F%E5%A4%A9%E7%A9%BA%E4%B9%8B%E5%9F%8E.jpg" alt="宫崎骏天空之城" /></p>

<p>这个画面跟玛格丽特的作品——《比利牛斯山的城堡》简直一摸一样:</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%AF%94%E5%88%A9%E7%89%9B%E6%96%AF%E5%B1%B1%E7%9A%84%E5%9F%8E%E5%A0%A1.png" alt="比利牛斯山的城堡" /></p>

<ol>
<li>宫崎骏的动画讨论的都是大问题，比如战争与和平（哈尔的移动城堡）、寻找自我（千与千寻）、人与自然关系（风之谷、幽灵公主、天空之城、悬崖上的金鱼姬）等等；</li>
<li>宫崎骏坚持手绘，总能用温和的方式，把这些严肃的大道理表达出来；</li>
<li>我们能从他的画面中，发现熟悉的生活，熟悉的场景，不管你来自什么国家、什么样的文化背景，都能在宫崎骏的动画里，找到共识。</li>
</ol>


<h3>艺术风格公式</h3>

<p>动画之神：线条流畅+人脸圆嘟嘟+大主题</p>

<h2>23丨罗塞蒂：“拉斐尔画得没我好”</h2>

<h3>回归自然</h3>

<p>拉斐尔是文艺复兴艺术的顶点，在拉斐尔之后的几个世纪，他一直被认为是绘画界“完美”的代表，是教科书一样的存在。</p>

<p><img src="http://hongchaozhang.github.io/images/%E7%BD%97%E5%A1%9E%E8%92%82-%E5%9C%A3%E6%AF%8D%E9%A2%86%E6%8A%B1.png" alt="罗塞蒂-圣母领抱.png" /></p>

<p>这幅画更像乔托时期的作品。</p>

<p>最明显的一点就是，这幅画里的两个人头上都有个金盘子。其实这是圣人的标志，说明他们都是被神的光保佑的人。在中世纪的绘画作品里，圣人头上都有个金盘子，乔托的画里也有。</p>

<p>但是，后来慢慢的圣人头上的光环越变越细，慢慢就没有了。但是到了罗塞蒂这里，他又把这个金盘子画回去了，给人一种复古的感觉。</p>

<p>而且你有没有发现，在罗塞蒂的这件作品里，玛丽亚长得有点普通、不怎么完美。是不是额头短短的，轮廓还有点男性化，感觉没那么好看？不是我们印象中完美、优雅的玛丽亚。</p>

<p>他们提倡忠于自然，不对自然中的人物或事物进行美化。他们认为拉斐尔的作品就是美化过了头、完美过了头，显得做作，套路太多，不太真诚。</p>

<h3>象征主义</h3>

<p>罗塞蒂和他朋友们的这个拉斐尔前派并没有持续很久，短短几年之后，这个团体就解散了。</p>

<p>在这之后，罗塞蒂的艺术探索之路并没有停止。不过他的画，不再像拉斐尔前派主张的那样忠于自然。他的作品渐渐充满了象征意义，他作品里的事物、道具和颜色，往往有很多内涵。</p>

<p><img src="http://hongchaozhang.github.io/images/%E7%BD%97%E5%A1%9E%E8%92%82%E8%B4%9D%E5%A8%85%E7%89%B9%E4%B8%BD%E6%96%AF.png" alt="罗塞蒂贝娅特丽斯.png" /></p>

<p>比如，上面的这幅《贝娅特丽斯》，描绘的是贝娅特丽斯去世的情景。画里的女模特是罗塞蒂刚去世的夫人，罗塞蒂是用但丁的故事来寄托自己的情感。</p>

<p>这幅画里几乎所有的道具都有象征意义，比如红色的鸽子代表着死亡的信息；白色的罂粟花，代表的则是罗塞蒂夫人死亡的原因——吸食鸦片过量而死；画中人物衣服的灰色与绿色，分别代表哀伤和希望。所以，这幅画并不是我们看到的那么简单的，它背后充满了象征意义。</p>

<h3>唯美主义</h3>

<p>罗塞蒂后期的画还有一个很明显的特点，就是他的画里，渐渐就只剩下一个人了，而且是一个穿着长裙、留着长发、周围围绕着花花草草的女人。</p>

<p>我们之前说过，文艺复兴时期的作品有一个很重要的特点，就是有景深、有空间感；但在罗塞蒂的画里，这些完全消失了。他也不在乎用画来讲故事，只在意颜色的搭配，说白了就是只要这幅画看起来好看就可以了。</p>

<p>这正是唯美主义所主张的。</p>

<h3>艺术风格公式</h3>

<p>“拉斐尔前派”：红发女子+轮廓深邃+花花草草</p>

<h2>24丨葛饰北斋：西方人喜欢的日本画家</h2>

<p><img src="http://hongchaozhang.github.io/images/%E8%91%9B%E9%A5%B0%E5%8C%97%E6%96%8B%E7%A5%9E%E5%A5%88%E5%B7%9D%E6%B2%96%E6%B5%AA%E9%87%8C.jpg" alt="葛饰北斋神奈川沖浪里.jpg" /></p>

<p>这幅画画的是神奈川这条河入海口的波浪。只要是跟日本沾边的地方，比如日式餐厅、日式商店，十有八九都会有这幅画。</p>

<p>对很多人来说，这件作品意味着日本艺术的精髓，是日本的标志。葛饰北斋，则可以说是西方人最喜欢日本艺术家。</p>

<p>其实，《神奈川冲浪里》不是严格意义上的艺术品，它本来是用来宣传旅游景点的。你再回过头去看看这件作品，你能看出来他画的是哪个热门景点吗？在大浪的后边，跟浪花一样，也是蓝色和白色的，是日本最高的山——富士山。</p>

<p>其实这个主题的版画，葛饰北斋一共做了36幅，称为《富岳三十六景》。富岳就是富士山；富岳三十六景，就是在36个不同角度、不同天气情况下，富士山的风景。下面是另外一副：</p>

<p><img src="http://hongchaozhang.github.io/images/%E8%91%9B%E9%A5%B0%E5%8C%97%E6%96%8B%E5%AF%8C%E5%B2%B3%E4%B8%89%E5%8D%81%E5%85%AD%E6%99%AF.jpg" alt="葛饰北斋富岳三十六景.jpg" /></p>

<h3>19世界欧洲刮起“日本风”</h3>

<p>梵高《星月夜》里天空中旋转的星云，跟北斋这件作品里的巨浪，是不是很相似？</p>

<p>除了梵高，还有很多大艺术家，比如莫奈、惠斯勒，都对日本文化非常痴迷。惠斯勒画过很多外国女孩子穿和服扮演成日本人的肖像画；莫奈则在自己家的花园里，修了一座日本画里出现的日本桥。</p>

<p>日本的艺术作品究竟新奇在哪里呢？</p>

<ol>
<li>以前的西方艺术家，喜欢画传说，比如古希腊神话里的那些神；而日本版画不一样，画的都是身边的生活，比如下雪、下雨、稻子成熟等等。</li>
<li>除此之外，西方传统绘画喜欢用酱油色，什么都看起来暗暗的；但是日本的版画，颜色都非常鲜艳。</li>
<li>还有，按照西方的传统，喜欢把人和景画得越真越好，越像越好；但是日本的版画把人和景，都尽量简化。</li>
<li>日本风在19世纪的欧洲流行起来，还有一个很重要的原因：日本画很便宜、很容易买到。因为是版画，葛饰北斋的这幅《神奈川沖浪里》，少说也印了五六千幅，价格很便宜、很容易买到。像梵高这样很穷的画家，家里都挂着几幅。</li>
</ol>


<p>当时欧洲画家喜欢这类日本画，有一个专业词汇——浮世绘，画的就是人们的日常生活、风景、戏剧场景。在之后的课程中你也会发现，无论是绘画的主题、用色、还是追求的效果，西方艺术家都从日本浮世绘版画里得到了启发。</p>

<p>所以，印象派画家开始画城市生活；梵高、高更、马蒂斯这些画家，开始用鲜艳的颜色。这些都是受到了日本的影响。</p>

<h3>艺术风格公式</h3>

<p>浮世绘画家：版画+富士山——普鲁士蓝</p>

<h2>25丨莫奈：如何欣赏雾霾？</h2>

<h3>雾霾下的《国会大厦》</h3>

<p>19世纪的时候，有些欧洲人特别喜欢雾霾，哪有霾他们就去哪观霾，甚至还有专门去伦敦看霾的旅行项目。这群人迷恋雾霾的人里，就有我们今天要说的大画家——莫奈。</p>

<p>下面是他的几幅《国会大厦》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E8%8E%AB%E5%A5%88%E5%9B%BD%E4%BC%9A%E5%A4%A7%E5%8E%A6.jpg" alt="莫奈国会大厦.jpg" /></p>

<p>英国国会大厦这个主题，莫奈画了80多幅。但是他画的，要么是一天中不同时刻的国会大厦，要么是不同天气条件下的国会大厦，这些画呈现出来的效果，都非常不一样。</p>

<p>就像我们刚刚说的，他是想要再现某个瞬间。对他来讲，每个瞬间都是不一样的，尤其是每一个时刻的光线都是不一样的。所以严格来说，莫奈不是对英国国会大厦感兴趣，而是对大厦周围千变万化的光线感兴趣。</p>

<p>这也就解释了为什么莫奈这么喜欢画雾霾中的国会大厦了。就是因为有了雾霾，光线变化会更加地多端。今天的霾有可能是蓝色的，明天的霾有可能是红色的。</p>

<p>莫奈曾经说过：“夏天的伦敦很美，但怎么也比不上冬天那个雾气氤氲的伦敦。大雾让伦敦变得更美，充满神秘感。”</p>

<p>莫奈这么频繁地去伦敦观霾、画霾的结果，毫无疑问就是得了呼吸道疾病，在医院住了很久。
当然，他也为我们留下了很多美丽的雾霾下的伦敦。甚至现在的一些气象学家和历史学家，想要研究伦敦当时的天气情况，都要观察莫奈的这些作品作为参考资料。</p>

<h3>开创新的绘画方式：写生</h3>

<p>写生。也就是到户外，对着风景直接画画。在今天看来，写生是一件特别平常的事情；但在过去，写生是非常不容易实现的，到了莫奈这个时代才成为了可能（铁路、管装颜料、便携式画架）。</p>

<h3>用绘画抓住动态瞬间</h3>

<p>那么在室外直接对着风景画，画出来的作品有什么不一样的呢？</p>

<ol>
<li>首先就是自然光和人造光的区别。</li>
<li>第二个不同，就是印象派画家的作品往往很模糊很潦草，看起来好像没有画完。那是因为他们想要抓住风景在某一个瞬间的样子，画得比较快，甚至连颜料都来不及调好就往画布上画了。所以很奇妙的是，印象派的画有一个最大的特点：<strong>站得越远，看得越清楚。</strong>如果站得很近，你就只能看到一团乱七八糟的颜料；但<strong>当你慢慢退后，离画越来越远，就会发现颜料会逐渐在你的眼睛里融合；画里的风景不仅越来越清楚，而且还会呈现出一种动态效果。</strong></li>
<li>印象派画家追求的是“画得像”，他们追求的“像”，不是静态的“像”，而是动态的“像”，是为了让动态的某一刻，凝固在画布上，真实地再现他们眼睛看到的风景。</li>
</ol>


<p><img src="http://hongchaozhang.github.io/images/%E8%8E%AB%E5%A5%88%E5%8D%B0%E8%B1%A1%E6%97%A5%E5%87%BA.png" alt="莫奈印象日出.png" /></p>

<p>上面是莫奈的《印象日出》。当你慢慢远离这幅画的时候，那些模糊的颜料就会变成水面、渔船、人……不仅画面逐渐变得清晰了，甚至还能感觉到水面在晃动。</p>

<h3>同一个东西重复画</h3>

<p>看上去是同一个东西，其实每一个瞬间都有不一样动态。</p>

<h3>艺术风格公式</h3>

<p>印象派灵魂人物：主题重复+颜色明亮+越远越动态</p>

<h2>26丨惠斯勒：“泼桶油漆”卖出一百万？</h2>

<h3>艺术史上的第一场诉讼案</h3>

<p><img src="http://hongchaozhang.github.io/images/%E6%83%A0%E6%96%AF%E5%8B%92%E9%BB%91%E8%89%B2%E4%B8%8E%E9%87%91%E8%89%B2%E7%9A%84%E5%A4%9C%E6%9B%B2.png" alt="惠斯勒黑色与金色的夜曲.png" /></p>

<p>上面是惠斯勒的《黑色与金色的夜曲》，A4幅面，要价200金币（100万人民币）。当时的评论家罗斯金说：“从没有听说过，向公众泼桶油漆，还要200个金币的。”惠斯勒就将罗斯金告上了法庭。</p>

<p>在法庭上，罗斯金的律师质问惠斯勒：“你画这幅画用了多久？”惠斯勒说：“一两天吧。”</p>

<p>罗斯金的律师听到答案后，发出了鄙视的笑声，说：“只用了一两天，你也好意思要200个金币？”</p>

<p>要知道，当时的人都喜欢“画得像”的作品，画的价格是按照劳动时间确定的，一幅画画的时间越长，可能就越贵。</p>

<p>但是惠斯勒不认同这种看法。在庭审中，他开始发挥他的演讲口才，说：“我并不是为我两天劳动时间要的价，而是我一生的学识。”</p>

<h3>抽象画先驱</h3>

<p><img src="http://hongchaozhang.github.io/images/%E6%83%A0%E6%96%AF%E5%8B%92%E6%97%A9%E6%9C%9F%E4%BD%9C%E5%93%81.png" alt="惠斯勒早期作品.png" /></p>

<p>上面是惠斯勒24岁时画的作品。你可以去看看，是不是能够感受到库尔贝那种苦大仇深的气息？</p>

<p>不过慢慢地，惠斯勒在跟其他艺术家接触的过程中，渐渐找到了自己的方向。<strong>他慢慢觉得，一幅画并不只是用来讲故事、反映现实的，颜色好看，才是最重要的。</strong></p>

<p>你可以回忆一下我们过去说的那些艺术品，除了美以外，或多或少都有一些其他的功能。比如，宗教作品是用来讲宗教故事的；大卫那样的新古典主义画家，是靠艺术来告诉别人大道理的；而库尔贝的现实主义，是靠艺术来批判现实的。</p>

<p>但是惠斯勒认为，艺术只要看就好了，艺术品只要美就好了，跟其他一切无关。就像一首歌，歌词唱什么并不重要，旋律好听才是关键。</p>

<p>为了体现“绘画和音乐是一样的”这个观点，惠斯勒很喜欢用古典乐曲名来给他的画命名，所以他的很多画都叫“交响曲”“小夜曲”等等。</p>

<h3>唯美主义</h3>

<p><img src="http://hongchaozhang.github.io/images/%E6%83%A0%E6%96%AF%E5%8B%92%E7%99%BD%E8%89%B2%E4%BA%A4%E5%93%8D%E6%9B%B2%E4%B8%80%E5%8F%B7.png" alt="惠斯勒白色交响曲一号.png" /></p>

<p>到了他27岁的时候，他终于画了人生中的第一幅大作。这幅画画的是个女人，但是画的名字叫做《白色交响曲一号》。他觉得你在看这幅作品的时候，只要觉得白色用得舒服，就够了，其他的都不重要。</p>

<p>可以说，惠斯勒用一生的学识悟出来的道理就是：艺术品只要美就够了。这就是我们常说的“唯美”。</p>

<h3>艺术风格公式</h3>

<p>抽象画先驱：黑白灰蓝+乐曲命名+唯美主义</p>

<h2>27丨雷诺阿：如何画出幸福？</h2>

<h3>印象派</h3>

<p>雷诺阿跟莫奈一样，被认为是典型的印象派。但是你会发现，他们的画完全不一样。如果粗略地做个区分，那就是：莫奈喜欢画风景；而雷诺阿喜欢画人，而且都是让人感到很开心、很幸福的人。看下面两幅作品：《小艾琳》《船宴》</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%9B%B7%E8%AF%BA%E9%98%BF%E5%B0%8F%E8%89%BE%E7%90%B3.png" alt="雷诺阿小艾琳.png" /></p>

<p><img src="http://hongchaozhang.github.io/images/%E9%9B%B7%E8%AF%BA%E9%98%BF%E8%88%B9%E5%AE%B4.png" alt="雷诺阿船宴.png" /></p>

<p>印象派的其中一个特点就是在室外写生。雷诺阿也是在露天的自然光下创作的，也正因为如此，他画的光斑更符合现实中我们眼睛看到的样子。
雷诺阿的成名作是一张群像，叫做《煎饼磨坊的舞会》。</p>

<p>在这幅画中，每个人都带着笑脸，而且画面有一种跳动的感觉，仿佛你能感受到灿烂的阳光透过树梢，在每个人的脸上闪动。</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%9B%B7%E8%AF%BA%E9%98%BF%E7%85%8E%E9%A5%BC%E7%A3%A8%E5%9D%8A%E7%9A%84%E8%88%9E%E4%BC%9A.png" alt="雷诺阿煎饼磨坊的舞会.png" /></p>

<h3>印象派+新古典主义</h3>

<p>雷诺阿非常勤奋，卖出了一些画、攒够钱就去意大利旅行了。意大利是西方古典绘画的发源地，几乎每个艺术家都想去意大利学习。</p>

<p>这时候，雷诺阿逐渐发现了印象派的缺点。他忽然觉得印象派一直以来追求瞬间的光影，虽然看起来很美，但是构图缺少永恒感。相比之下，古典主义的作品似乎更经典。</p>

<p>所以特别有意思的是，41岁的雷诺阿从意大利旅游回来，之后的10年，他的作品风格大变，他甚至把自己之前很多印象派风格的作品都撕掉了，开始创作像大卫、安格尔那样的新古典主义作品。下面这幅，就是他风格变化最大的一张画——《沐浴图》。</p>

<p><img src="http://hongchaozhang.github.io/images/%E9%9B%B7%E8%AF%BA%E9%98%BF%E6%B2%90%E6%B5%B4%E5%9B%BE.png" alt="雷诺阿沐浴图" /></p>

<p>前景是典型的新古典主义技法，人物的皮肤完美无瑕疵，轮廓线清晰，造型优雅舒展。背景仍然采用印象派的那种粗糙的笔触。这很像我们现在拍摄的背景虚化的照片。</p>

<h3>被贫穷限制了发展</h3>

<p>他这幅结合了印象派和新古典主义的《沐浴图》，当时的人并不看好，因为那时候新古典主义已经过时了。更重要的是，他原来的买家也不开心了。买家一般都倾向收藏艺术家成熟时期的经典作品，如果一个艺术家老换风格，就是不自信不成熟，买家怎么会信任你呢？</p>

<p>所以雷诺阿的风格一换，画的销量就不好了。于是他只好又继续回到老套路了。</p>

<p>所以很可惜，雷诺阿本来有机会开创一个全新的艺术风格，但是迫于生计，只好牺牲了自己的艺术主张。</p>

<p>后来真正完成“印象派+新古典主义”的艺术家，是被称“现代绘画之父”的塞尚。塞尚是个富二代，他不像雷诺阿，不需要为了生计，去迎合市场和买家。</p>

<p>雷诺阿曾经说过这么一句话：“世界上丑恶的事已经够多了，为什么艺术还不能是美的呢？”这句话，可以说是他毕生的宗旨，意思就是：要画美的艺术，给这个世界带来更多的美丽。
雷诺阿用乐观的态度，改变了自己的生存状况，为自己带来了快乐，也为世界带来了快乐。我想对他来说就足够了。</p>

<h3>艺术风格公式</h3>

<p>幸福画家：皮肤粉嫩+光线明亮+充满幸福感</p>

<h2>28丨德加：巴黎富二代的日常</h2>

<h3>记忆力+想象力</h3>

<p><img src="http://hongchaozhang.github.io/images/%E5%BE%97%E5%8A%A0%E6%AD%8C%E5%89%A7%E9%99%A2%E7%9A%84%E8%8A%AD%E8%95%BE%E8%88%9E%E5%AE%A4.png" alt="得加歌剧院的芭蕾舞室.png" /></p>

<p>德加喜欢画芭蕾舞演员。当然，他在出入这些场所的时候，不会像他的印象派朋友们那样当场画画；在这些场合他还是优雅的富二代德加先生；回到画室之后，他又变身成画家，凭着记忆、经过深思熟虑再画画。</p>

<p>虽然德加经常跟他的印象派朋友们一起办画展，但他从来不认为自己是印象派。因为印象派画家，喜欢在现场捕捉某一个瞬间；但德加的作品，跟意外和偶然没有关系。避免即兴创作，是他时刻要提醒自己的。</p>

<p>他曾经说过：“<strong>画出眼睛看到的东西固然好，但是画出脑海里的样子，就更好了。</strong>”</p>

<p>因为大脑会对眼睛看到的东西做加工，想象力和记忆力会同时发生作用。你不需要画出所有眼睛看到的东西，只要画出给你留下深刻印象的东西就好了。</p>

<h3>艺术风格公式</h3>

<p>富二代画家：芭蕾舞女+轻盈灵动+喜欢粉绿色</p>

<h2>29丨修拉：画点点点也能出名？</h2>

<h3>印象派终结者</h3>

<p>修拉究竟做了什么，把纵横画坛十多年的印象派终结了呢？其实很简单，他用自己的一幅画，参加了1886年的第八届印象派画展。</p>

<p>当时他只有20多岁，印象派已经流行了10多年了。最初印象派的光线和颜色让人们眼前一亮，但是它的魅力消失得也很快，很快人们就厌倦了。很多艺术家也意识到了印象派的硬伤，比如没有内涵，不考虑画面结构等等。</p>

<p><img src="http://hongchaozhang.github.io/images/%E4%BF%AE%E6%8B%89%E5%A4%A7%E7%A2%97%E5%B2%9B%E7%9A%84%E6%98%9F%E6%9C%9F%E5%A4%A9%E4%B8%8B%E5%8D%88.png" alt="修拉大碗岛的星期天下午.png" /></p>

<p>如果把这幅画放大一些，你就会发现，这幅画完全是由一个个点组成的。</p>

<p>所以严格来说，修拉这幅画不是画出来的，而是点出来的。这幅画非常大，大概有2米高3米宽，有一面墙那么大。修拉就这么点点点、点点点，点了两年才画完。</p>

<p><img src="http://hongchaozhang.github.io/images/%E4%BF%AE%E6%8B%89%E5%A4%A7%E7%A2%97%E5%B2%9B%E7%9A%84%E6%98%9F%E6%9C%9F%E5%A4%A9%E4%B8%8B%E5%8D%88%E5%9C%A8%E5%8D%9A%E7%89%A9%E9%A6%86.png" alt="修拉大碗岛的星期天下午在博物馆.png" /></p>

<h3>艺术界的科学家</h3>

<p>我们在讲莫奈的时候说过，为了迅速把自己看到的景象画下来，印象派画家不会在调色盘里调颜色，而是直接把颜色往画布上画。但这样画画会出现一个问题，就是很多颜色叠在一起后，会让画面出现一种灰色。</p>

<p>但是，修拉不一样。他看过很多有关颜色和光学的理论，他很清楚怎么样让颜色更鲜艳，更有阳光下那种闪烁的感觉。经过研究，他得出的结论就是：既不在画板上调色，也不在画布上调色；而是在画布上画一个个的小点，用这些小点组成画面。这个小点不是叠加的，而是并列的。通过点的不同比例，达到混色的效果。</p>

<h3>修拉的影响</h3>

<p>我们之前讲，画家要处理的问题分为两大类：一是“画什么”，二是“怎么画”。米勒、库尔贝、马奈，是让大家知道除了神话、历史、宗教外，还可以画劳动题材、都市题材，研究的是“画什么”的问题；但是修拉的创新，是在探索“怎么画”的问题。</p>

<p>我们刚说了，莫奈、雷诺阿不喜欢修拉的这种画法，但是有一个人非常喜欢。他这一年正好在巴黎，看到修拉的《大碗岛》，非常喜欢，就把修拉的这种分色点彩画法发扬光大了。是谁呢？就是家喻户晓的梵高。</p>

<p>除了梵高，修拉的风格还影响了很多后来的画家。你会发现，只要把他的点变大一些，就成了后来的野兽派；把他的点变方一些，就是蒙德里安；把他的点变成色块，那就成了康定斯基。</p>

<h3>不识货的法国博物馆</h3>

<p>更可惜的是，修拉虽然是一个法国画家，但是他的作品几乎都不在法国了。因为修拉死后，他母亲把他的作品都交给法国的博物馆，但是法国的博物馆不要，说看不懂这画的是什么。所以修拉的重要作品几乎都被美国人很廉价地收藏了。</p>

<p>直到后来，修拉的作品才受到重视。现在他的作品都是“镇馆”级别的，我们之前说的《大碗岛》就是美国芝加哥美术馆博物馆的镇馆之宝。</p>

<h3>艺术风格公式</h3>

<p>印象派终结者：近看都是点点点+画中人肢体僵硬+用点点点画画框</p>

<h2>30丨毕加索：卖出天价的“儿童画”</h2>

<p>毕加索是20世纪最伟大的艺术家之一。但大部分人在看到他作品的时候，都有一个共同的疑惑：毕加索到底会不会画画？毕加索的画到底好在哪里？</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%AF%95%E5%8A%A0%E7%B4%A2%E6%A2%A6.png" alt="毕加索梦.png" /></p>

<p><img src="http://hongchaozhang.github.io/images/%E6%AF%95%E5%8A%A0%E7%B4%A2%E9%95%9C%E5%89%8D%E5%B0%91%E5%A5%B3.png" alt="毕加索镜前少女.png" /></p>

<h3>勇于自我突破的天才</h3>

<p>毕加索自己就说过：“当我还是个孩子的时候，就能画得跟拉斐尔一样了。之后的一生，我都在学习怎么样画得跟孩子一样。“</p>

<p>毕加索没有说大话，下面是他15岁时的作品《第一次圣餐》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%AF%95%E5%8A%A0%E7%B4%A2%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9C%A3%E9%A4%90.png" alt="毕加索第一次圣餐.png" /></p>

<h3>原始主义</h3>

<p><img src="http://hongchaozhang.github.io/images/%E6%AF%95%E5%8A%A0%E7%B4%A2%E9%98%BF%E7%BB%B4%E5%86%9C%E5%B0%91%E5%A5%B3.png" alt="毕加索阿维农少女.png" /></p>

<p>上面这幅作品是他这个时期的代表作——《阿维农少女》，画的是西班牙巴塞罗“阿维农街”这条街上的5个女孩子。你可以看看，这幅画里女孩子是不是很像原始部落的雕塑？特别是右边那两个女孩子的脸，简直跟原始面具一模一样！
为什么原始人的艺术对毕加索这么有吸引力呢？那是因为毕加索发现，原始艺术非常简单，而且往往能用最简单的手法表现出最想要的结果，更有利于表达情感，更有视觉冲击力。</p>

<p>也正是从《阿维农少女》这幅作品开始，毕加索有了一套独特的体系，无论是画人还是画物体，都开始慢慢简化，最后变成了细细的一条线。比如他画的和平鸽就是这个样子。</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%AF%95%E5%8A%A0%E7%B4%A2%E5%92%8C%E5%B9%B3%E9%B8%BD.png" alt="毕加索和平鸽.png" /></p>

<h3>立体主义</h3>

<p>你可不要小看立体主义画法！他的这种做法从此改变了艺术史。按照西方传统的画法，画家都是站在某一个固定的点来画画的，呈现出来的画面也就是事物的某一个面。画家们按照这种方式已经画了几百年了。</p>

<p>但是，毕加索打破了这种传统，他把事物的不同面拼在了一起。这种“碎玻璃”的画法，之后影响了很多人，后来被专家们称为“立体主义”。比如《拿曼陀林的少女》：</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%AF%95%E5%8A%A0%E7%B4%A2%E6%8B%BF%E6%9B%BC%E9%99%80%E6%9E%97%E7%9A%84%E5%B0%91%E5%A5%B3.png" alt="毕加索拿曼陀林的少女.png" /></p>

<h3>艺术风格公式</h3>

<p>立体主义大师：面具人脸+线条简单+碎玻璃画法</p>

<h2>31丨塞尚：改变艺术史的苹果</h2>

<p>其实塞尚有点嫌弃印象派，他觉得印象派不讲究构图、没有立体感，看起来不像古典主义的画那样有永恒感，坚定感。而塞尚要做的，就是用印象派的颜色，加上古典主义的构图，画出全新的作品。</p>

<p>到了塞尚艺术生涯的最后几十年，他也跟莫奈一样，几乎只固定地画某几样东西了。比如，苹果，他家乡的圣维克多山
。
他为什么要一直画相同的东西呢？就像我们刚刚说的，塞尚感兴趣的是立体感、空间感以及画面的构图。所以，具体画什么不重要，重要的是，用同一个东西，不停地进行研究和练习。</p>

<p>其实塞尚最最伟大的地方，就在这里，<strong>他改变了艺术家看待世界以及呈现世界的方式。</strong></p>

<p>过去的艺术家，呈现的都是站在一个不动的点上看到的世界。但在日常生活中，我们并不是这样看人看事物的，你可以回忆看看，你在看某个事物的时候，是不是一般都是左看看右看看的？塞尚用他的画布，还原了我们这种看待世界的方式；说得夸张点，他用画布，为我们再创造了一个世界。</p>

<h3>艺术风格公式</h3>

<p>现代艺术之父：苹果圣维可多山+马赛克+蓝橘红绿赭石</p>

<h2>32丨梵高：大师的画为什么卖不出去？</h2>

<h3>职业发展三个阶段</h3>

<p>一般来说，我们可以根据梵高生活地点的变化，把他的作品分为荷兰、巴黎和普罗旺斯三个时期。而且这三个时期非常容易分辨。那就是，随着梵高居住的地方越来越靠近赤道，阳光越来越充足，他画里的颜色也会越来越明亮。</p>

<h4>荷兰</h4>

<p>荷兰很难碰到太阳，天气总是阴沉沉的，所以梵高的画也是阴沉沉的。</p>

<h4>巴黎</h4>

<p><img src="http://hongchaozhang.github.io/images/%E6%A2%B5%E9%AB%98%E5%94%90%E5%90%89%E8%80%81%E7%88%B7.jpg" alt="梵高唐吉老爷.jpg" /></p>

<p>上面的画是梵高的《唐吉老爷》，很明显受当时盛行的印象派的影响，同时也受日本浮世绘版画的影响。</p>

<h4>普罗旺斯</h4>

<p>普罗旺斯是一个阳光明媚的地方，有大片的薰衣草花田和向日葵田。我在普罗旺斯住了很多年，那里有三百天的太阳。梵高就是为了普罗旺斯的光线，才决定搬到那里去的。</p>

<p>代表作都是在这个时期创作的，包括“向日葵”、“星空”和“自画像”。</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%A2%B5%E9%AB%98%E5%90%91%E6%97%A5%E8%91%B5.jpg" alt="梵高向日葵.jpg" /></p>

<p><img src="http://hongchaozhang.github.io/images/%E6%A2%B5%E9%AB%98%E6%98%9F%E7%A9%BA.jpg" alt="梵高星空.jpg" /></p>

<p><img src="http://hongchaozhang.github.io/images/%E6%A2%B5%E9%AB%98%E5%89%B2%E6%8E%89%E8%80%B3%E6%9C%B5%E7%9A%84%E8%87%AA%E7%94%BB%E5%83%8F.jpg" alt="梵高割掉耳朵的自画像.jpg" /></p>

<h3></h3>

<h3>艺术风格公式</h3>

<p>后印象派大师：农村风光+黄蓝+蜡笔</p>

<h2>33丨高更：梵高的“最差室友”</h2>

<h3>艺术风格公式</h3>

<p>现代艺术奠基者之一：热带配色黄红蓝绿紫+大溪地土著+平面感</p>

<p>高更的作品有以下几个特点：</p>

<ol>
<li>他画了很多大溪地的原始人；</li>
<li>他的画不太讲究立体感，大部分作品都有一种平面感；</li>
<li>他的画颜色很鲜艳，有大片的色块拼接，他特别喜欢黄色、紫色、蓝色、绿色拼在一起的、感觉很热带的配色。</li>
<li>不像梵高那样依赖大自然，而是依赖想象力，依赖颜色和线条的和谐。</li>
</ol>


<h2>34丨克利姆特：用金子画画的浮夸画家</h2>

<h3>艺术风格公式</h3>

<p>浮夸画家：用黄金作画+讨论大问题+人物很颓废</p>

<h2>35丨卢梭：让天才羡慕的业余选手</h2>

<h3>艺术风格公式</h3>

<h2>36丨夏加尔：用绘画逃离地心引力</h2>

<h3>艺术风格公式</h3>

<h2>37丨达利：西班牙版周公解梦</h2>

<h3>艺术风格公式</h3>

<h2>38丨玛格丽特：艺术界的哲学家</h2>

<h3>艺术风格公式</h3>

<h2>39丨弗里达：“拯救世界”的女画家</h2>

<h3>艺术风格公式</h3>

<h2>40丨马蒂斯：红配绿土不土？</h2>

<h3>艺术风格公式</h3>

<h2>41丨康定斯基：没有内容能叫画吗？</h2>

<h3>艺术风格公式</h3>

<h2>42丨蒙德里安：如何靠画表格出名？</h2>

<h3>艺术风格公式</h3>

<h2>43丨波洛克：乱涂乱画也能出名？</h2>

<h3>艺术风格公式</h3>

<h2>44丨罗斯科：颜色背后的哲学思考</h2>

<h3>艺术风格公式</h3>

<h2>45丨杜尚：艺术的终结者</h2>

<p><img src="http://hongchaozhang.github.io/images/%E6%9D%9C%E5%B0%9A%E8%87%AA%E8%A1%8C%E8%BD%A6%E8%BD%A6%E8%BD%AE.jpg" alt="杜尚自行车车轮.jpg" /></p>

<p>从25岁开始，杜尚基本上放弃了绘画。放弃绘画一年后，杜尚做出了他的改变艺术史的第一件作品《自行车车轮》。这件作品，就是一个自行车前车架倒插在一个厨房凳子上，而且车轮是没有固定住的，可以旋转。可以说，这件作品的标题非常简单、直白、准确。</p>

<p>你有没有发现，这件作品有两个很大的特点。
* 第一个，就是这件作品是能动的。
* 第二个，杜尚这件作品的素材并不是创作出来的，而是现成的。</p>

<p><img src="http://hongchaozhang.github.io/images/%E6%9D%9C%E5%B0%9A%E6%B3%89.jpg" alt="杜尚泉.jpg" /></p>

<p>艺术史上最著名的现成品，也出自杜尚之手，就是就是杜尚1917年创作的作品《泉》了。他在超市买了个小便池，把小便池翻了个方向，签上了个假名字和日期，就把它带去参加展览了。</p>

<h3>杜尚的贡献</h3>

<p>杜尚对于艺术史的贡献就是把原来被认为根本不是艺术品的东西变成了艺术品。说得大点，<strong>杜尚重新定义了艺术。</strong></p>

<p>杜尚可以说是通过一己之力，改变了现代艺术。他的作品给之后的艺术家带来了无穷的灵感。现在很多艺术家的想法看起来很新奇，其实都是对杜尚思想的再加工。我们现在能看到的装置艺术、文献艺术、动感艺术、身体艺术、行为艺术等等，都受到了杜尚的启发。</p>

<h3>艺术风格公式</h3>

<p>观念艺术大师：不像艺术品+最著名的作品《泉》</p>

<h2>46丨安迪·沃霍尔：喜欢蹭热点的艺术家</h2>

<h3>艺术风格公式</h3>

<h2>47丨霍普：孤独美在哪里？</h2>

<h3>艺术风格公式</h3>

<h2>48丨班克西：为何毁坏自己的作品？</h2>

<h3>艺术风格公式</h3>

<h2>49丨柯布西耶：房子是用来住的还是看的？</h2>

<h3>艺术风格公式</h3>

<h2>50丨贾科梅蒂：最贵的火柴人</h2>

<h3>艺术风格公式</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSS中的white-space，word-break和word-wrap]]></title>
    <link href="http://hongchaozhang.github.io/blog/2020/07/02/css-white-space-word-break-and-word-wrap/"/>
    <updated>2020-07-02T10:27:04+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2020/07/02/css-white-space-word-break-and-word-wrap</id>
    <content type="html"><![CDATA[<!-- more -->


<p><code>white-space</code>、<code>word-break</code>、<code>word-wrap</code>（<code>overflow-wrap</code>）估计是css里最基本却又容易让人迷惑的三个属性了。</p>

<h2><code>white-space</code></h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space"><code>white-space</code></a>：正如它的名字，这个属性是用来<strong>控制空白字符的显示的，同时还能控制是否自动换行</strong>。它有6个值：</p>

<ol>
<li>normal：默认值。空格被合并，自动换行。</li>
<li>nowrap：不仅空格被合并，换行符无效，连原本的自动换行都没了！只有\&lt;/br>才能导致换行！所以这个值的表现还是挺简单的，我们可以理解为"永不换行"。</li>
<li>pre：下面四个用来保留空格，不常用。详情参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space">MDN介绍</a>。</li>
<li>pre-wrap</li>
<li>pre-line</li>
<li>break-space</li>
</ol>


<p>下面的表格记录的很详细：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 属性值 </th>
<th style="text-align:center;"> 换行符 </th>
<th style="text-align:center;"> 空格和制表符 </th>
<th style="text-align:center;"> 文字换行 </th>
<th style="text-align:center;"> 行尾空格 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;">normal </td>
<td style="text-align:center;"> 合并    </td>
<td style="text-align:center;"> 合并    </td>
<td style="text-align:center;"> 换行    </td>
<td style="text-align:center;"> 删除 </td>
</tr>
<tr>
<td style="text-align:center;">nowrap </td>
<td style="text-align:center;"> 合并    </td>
<td style="text-align:center;"> 合并    </td>
<td style="text-align:center;"> 不换行 </td>
<td style="text-align:center;"> 删除 </td>
</tr>
<tr>
<td style="text-align:center;">pre    </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 不换行 </td>
<td style="text-align:center;"> 保留 </td>
</tr>
<tr>
<td style="text-align:center;">pre-wrap   </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 换行    </td>
<td style="text-align:center;"> 挂起 </td>
</tr>
<tr>
<td style="text-align:center;">pre-line   </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 合并    </td>
<td style="text-align:center;"> 换行    </td>
<td style="text-align:center;"> 删除 </td>
</tr>
<tr>
<td style="text-align:center;">break-spaces   </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 保留    </td>
<td style="text-align:center;"> 换行    </td>
<td style="text-align:center;"> 换行 </td>
</tr>
</tbody>
</table>


<h2><code>word-break</code></h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a>指定了怎样在单词内断行。这里说的单词在英文中很明显，但是，对于中文、日文和韩文（合称CJK文本）整段话都是一个单词。</p>

<p><code>word-break</code>共有三个选项：</p>

<ol>
<li>normal：使用默认的断行规则。</li>
<li>break-all：对于non-CJK文本，可在任意字符间断行。</li>
<li>keep-all：CJK文本不断行。 Non-CJK文本表现同normal。</li>
</ol>


<h2><code>word-wrap</code> (<code>overflow-wrap</code>)</h2>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-wrap"><code>word-wrap</code>(<code>overflow-wrap</code>)</a>控制长度超过一行的单词是否被拆分换行。有两个值：</p>

<ol>
<li>normal：长度超过一行的单词也不允许拆成两行显示。</li>
<li>break-word：长度超过一行的单词允许被拆分成两行显示。</li>
</ol>


<h2>总结</h2>

<ul>
<li><code>white-space</code>，<strong>控制空白字符的显示，同时还能控制是否自动换行</strong>。</li>
<li><code>word-break</code>，<strong>控制单词如何被拆分换行</strong>。</li>
<li><code>word-wrap</code>（<code>overflow-wrap</code>）<strong>控制长度超过一行的单词是否被拆分换行</strong>，是<code>word-break</code>的补充。</li>
</ul>


<h2>参考</h2>

<p>实际效果可以参考<a href="https://juejin.im/post/5b8905456fb9a01a105966b4">彻底搞懂word-break、word-wrap、white-space</a>及其其提供的一个<a href="https://codepen.io/YGYOOO/pen/jvyrWK">测试页面</a>。</p>

<p>MDN的官方文档当然是不得不看的：</p>

<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space"><code>white-space</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break"><code>word-break</code></a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-wrap"><code>word-wrap</code>(<code>overflow-wrap</code>)</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Python解析Excel文件]]></title>
    <link href="http://hongchaozhang.github.io/blog/2020/06/23/parse-excel-using-python/"/>
    <updated>2020-06-23T19:17:45+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2020/06/23/parse-excel-using-python</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Python基础教程</h2>

<p><a href="https://www.runoob.com/python/python-tutorial.html">python基础教程</a></p>

<h2>xlrd和xlwt</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/env python</span>
</span><span class='line'><span class="c"># -*- coding: utf-8 -*-</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">xlrd</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">xlwt</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">read_excel</span><span class="p">():</span>
</span><span class='line'>    <span class="n">file_name</span> <span class="o">=</span> <span class="s">&#39;demo.xlsx&#39;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># 打开excel文件</span>
</span><span class='line'>    <span class="n">wb</span> <span class="o">=</span> <span class="n">xlrd</span><span class="o">.</span><span class="n">open_workbook</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># 获取所有表格名字</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="n">wb</span><span class="o">.</span><span class="n">sheet_names</span><span class="p">())</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># 通过索引获取表格</span>
</span><span class='line'>    <span class="n">sheet1</span> <span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="n">sheet_by_index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="n">sheet1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">sheet1</span><span class="o">.</span><span class="n">nrows</span><span class="p">,</span> <span class="n">sheet1</span><span class="o">.</span><span class="n">ncols</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># 获取行内容</span>
</span><span class='line'>    <span class="n">rows</span> <span class="o">=</span> <span class="n">sheet1</span><span class="o">.</span><span class="n">row_values</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># 获取列内容</span>
</span><span class='line'>    <span class="n">cols</span> <span class="o">=</span> <span class="n">sheet1</span><span class="o">.</span><span class="n">col_values</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># 获取表格里的内容，三种方式</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="n">sheet1</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="n">sheet1</span><span class="o">.</span><span class="n">cell_value</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</span><span class='line'>    <span class="k">print</span><span class="p">(</span><span class="n">sheet1</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">write_excel</span><span class="p">():</span>
</span><span class='line'>    <span class="n">f</span> <span class="o">=</span> <span class="n">xlwt</span><span class="o">.</span><span class="n">Workbook</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># 添加sheet</span>
</span><span class='line'>    <span class="n">sheet1</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">add_sheet</span><span class="p">(</span><span class="s">&#39;Students&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># 创建杭数据和列数据</span>
</span><span class='line'>    <span class="n">row0</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;qq&quot;</span><span class="p">,</span> <span class="s">&quot;ddd&quot;</span><span class="p">,</span> <span class="s">&quot;fgg&quot;</span><span class="p">,</span> <span class="s">&quot;hjj&quot;</span><span class="p">]</span>
</span><span class='line'>    <span class="n">column0</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;zsfsd&quot;</span><span class="p">,</span> <span class="s">&quot;ghg&quot;</span><span class="p">,</span> <span class="s">&quot;Python&quot;</span><span class="p">,</span> <span class="s">&quot;fs&quot;</span><span class="p">,</span> <span class="s">&quot;fgsf&quot;</span><span class="p">,</span> <span class="s">&quot;zbg&quot;</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># 写第一行</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">row0</span><span class="p">)):</span>
</span><span class='line'>        <span class="n">sheet1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">row0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># 写第一列</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">column0</span><span class="p">)):</span>
</span><span class='line'>        <span class="n">sheet1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">column0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># 保存文件为xls格式，xlsx格式不能打开</span>
</span><span class='line'>    <span class="n">f</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;test.xls&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>openpyxl</h2>

<p>xlwt的局限性是不能写入超过65535行、256列的数据（因为它只支持Excel 2003及之前的版本，在这些版本的Excel中行数和列数有此限制）。openpyxl支持07/10/13版本Excel，功能很强大，但是操作起来感觉没有xlwt方便。</p>

<h2>总结</h2>

<ol>
<li>读取Excel时，选择openpyxl和xlrd差别不大，都能满足要求</li>
<li>写入少量数据且存为xls格式文件时，用xlwt更方便</li>
<li>写入大量数据（超过xls格式限制）或者必须存为xlsx格式文件时，就要用openpyxl了。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Python解析XML格式文件]]></title>
    <link href="http://hongchaozhang.github.io/blog/2020/06/22/parse-xml-using-python/"/>
    <updated>2020-06-22T18:34:32+08:00</updated>
    <id>http://hongchaozhang.github.io/blog/2020/06/22/parse-xml-using-python</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>Python基础教程</h2>

<p><a href="https://www.runoob.com/python/python-tutorial.html">python基础教程</a></p>

<h2>ElementTree</h2>

<p>ELementTree官方文档参考：<a href="https://docs.python.org/2/library/xml.etree.elementtree.html#xml.etree.ElementTree.Element">The ElementTree XML API</a></p>

<p>下面是一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">xml.etree</span> <span class="kn">import</span> <span class="n">ElementTree</span> <span class="k">as</span> <span class="n">ET</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 读取xml文件</span>
</span><span class='line'><span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&#39;gadm36_CHN_2.kml&#39;</span><span class="p">)</span>
</span><span class='line'><span class="c">## 获取root节点</span>
</span><span class='line'><span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 打印root节点的tag名称和所有的attribute</span>
</span><span class='line'><span class="k">print</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">attrib</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 正常的xml文件的tag可能只是Placemark，这里是因为读进来的是一个kml文件</span>
</span><span class='line'><span class="k">for</span> <span class="n">placemark</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s">&#39;{http://www.opengis.net/kml/2.2}Placemark&#39;</span><span class="p">):</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">simpleData</span> <span class="ow">in</span> <span class="n">placemark</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="s">&#39;{http://www.opengis.net/kml/2.2}SimpleData&#39;</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># 获取某一个attribute的值也可以可以使用simpleData.get(&#39;attribute name&#39;)</span>
</span><span class='line'>        <span class="k">print</span> <span class="n">simpleData</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">simpleData</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;NAME_2&#39;</span><span class="p">:</span>
</span><span class='line'>            <span class="n">cityName</span> <span class="o">=</span> <span class="n">simpleData</span><span class="o">.</span><span class="n">text</span>
</span><span class='line'>            <span class="c"># 创建一个tag为name的节点作为placemark的子节点</span>
</span><span class='line'>            <span class="n">nameEle</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">placemark</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">)</span>
</span><span class='line'>            <span class="c"># 给新创建的节点的text属性赋值</span>
</span><span class='line'>            <span class="n">nameEle</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">cityName</span>
</span><span class='line'>            <span class="c"># 给placemark节点增加一个名为updated的attribute，其值为&#39;yes&#39;</span>
</span><span class='line'>            <span class="n">placemark</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;updated&#39;</span><span class="p">,</span> <span class="s">&#39;yes&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># 将新修改的xml文件写入新的文件</span>
</span><span class='line'><span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;modifyChinaCity.kml&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
