---
layout: post
title: "程序员的数学基础课（黄申）"
date: 2022-05-31 15:48:14 +0800
comments: true
categories: [algorithm, machine learning, python]
---

<!-- more -->


## 01-开篇词 (1讲)
### 00丨开篇词丨作为程序员，为什么你应该学好数学？
## 02-导读 (1讲)
### 00丨导读：程序员应该怎么学数学？
## 03-基础思想篇 (18讲)
### 01丨二进制：不了解计算机的源头，你学什么编程
### 02丨余数：原来取余操作本身就是个哈希函数
### 03丨迭代法：不用编程语言的自带函数，你会如何计算平方根？
### 04丨数学归纳法：如何用数学归纳提升代码的运行效率？
### 05丨递归（上）：泛化数学归纳，如何将复杂问题简单化？
### 06丨递归（下）：分而治之，从归并排序到MapReduce
### 07丨排列：如何让计算机学会“田忌赛马”？
### 08丨组合：如何让计算机安排世界杯的赛程？
### 09丨动态规划（上）：如何实现基于编辑距离的查询推荐？
### 10丨动态规划（下）：如何求得状态转移方程并进行编程实现？
### 11丨树的深度优先搜索（上）：如何才能高效率地查字典？
### 12丨树的深度优先搜索（下）：如何才能高效率地查字典？
### 13丨树的广度优先搜索（上）：人际关系的六度理论是真的吗？
### 14丨树的广度优先搜索（下）：为什么双向广度优先搜索的效率更高？
### 15丨从树到图：如何让计算机学会看地图？
### 16丨时间和空间复杂度（上）：优化性能是否只是“纸上谈兵”？
### 17丨时间和空间复杂度（下）：如何使用六个法则进行复杂度分析？
### 18丨总结课：数据结构、编程语句和基础算法体现了哪些数学思想？
## 04-概率统计篇 (14讲)
### 19丨概率和统计：编程为什么需要概率和统计？
### 20丨概率基础（上）：一篇文章帮你理解随机变量、概率分布和期望值
#### 随机变量
#### 概率分布
1. 离散概率分布：伯努利分布、分类分布、二项分布、泊松分布
    1. 伯努利分布：二分类分布
    2. 分类分布：随机变量的取值空间为`n`个离散的值，`n=2`时就是伯努利分布。
2. 连续概率分布：正态分布、均匀分布、指数分布、拉普拉斯分布
    1. 正态分布：也叫高斯分布，有两个关键参数：均值和方差。

#### 期望值
均值是期望值的特例，即各个取值的概率相同。

### 21丨概率基础（下）：联合概率、条件概率和贝叶斯法则，这些概率公式究竟能做什么？
#### 联合概率
由多个随机变量决定的概率我们就叫联合概率，使用`P(x, y)`表示。
#### 边缘概率
联合概率和单个随机变量的概率之间有什么关联呢？对于离散型随机变量，我们可以通过通过联合概率`P(x, y)`在`y`上求和，就可以得到`P(x)`。对于连续型随机变量，我们可以通过联合概率`P(x, y)`在`y`上的积分，推导出概率`P(x)`。这个时候，我们称`P(x)`为**边缘概率**。
#### 条件概率
条件概率也是由多个随机变量决定，但是和联合概率不同的是，它计算了给定某个（或多个）随机变量的情况下，另一个（或多个）随机变量出现的概率，其概率分布叫做条件概率分布。给定随机变量`x`，随机变量`y`的条件概率使用`P(y|x)`表示。

#### 贝叶斯法则
条件概率、联合概率之间的关系如下：
`P(x,y) = P(x|y) * P(y)`

根据上面的关系，可以得到贝叶斯定理如下：

![20220531贝叶斯定理.png](/images/20220531贝叶斯定理.png)

1. 先验概率： 我们把`P(x)`称为先验概率。之所以称为“先验”，是因为它是从数据资料统计得到的，不需要经过贝叶斯定理的推算。
2. 条件概率（似然函数）：`P(y|x)`是给定`x`之后`y`出现的条件概率。在统计学中，我们也把`P(y|x)`写作似然函数`L(x|y)`。在数学里，似然函数和概率是有区别的。概率是指已经知道模型的参数来预测结果，而似然函数是根据观测到的结果数据，来预估模型的参数。不过，当`y`值给定的时候，两者在数值上是相等的，在应用中我们可以不用细究。
3. 边缘概率：我们没有必要事先知道`P(y)`。`P(y)`可以通过联合概率`P(x,y)`计算边缘概率得来，而联合概率`P(x,y)`可以由`P(y|x)`*`P(x)`推出。
4. 后验概率：`P(x|y)`是根据贝叶斯定理，通过先验概率`P(x)`、似然函数`P(y|x)`和边缘概率`P(y)`推算而来，因此我们把它称作后验概率。

如果有一定数量的标注数据，那么通过统计的方法，我们可以很方便地得到先验概率和似然函数，然后推算出后验概率，最后依据后验概率来做预测。这整个过程符合监督式机器学习的模型训练和新数据预测这两个阶段，因此朴素贝叶斯算法被广泛运用在机器学习的分类问题中。

#### 随机变量之间的独立性
如果随机变量`x`和`y`之间不相互影响，那么我们就说`x`和`y`相互独立。此时，有`P(x|y)=P(x)`，所以`P(x,y)=P(x)*P(y)`。

变量之间的独立性，可以帮我们简化计算。

举个例子，假设有6个随机变量，而每个变量有10种可能的取值，那么计算它们的联合概率`p(x1,x2,x3,x4,x5,x6)`，在实际中是非常困难的一件事情。

根据排列，可能的联合取值，会达到10的6次方，也就是100万这么多。那么使用实际的数据进行统计时，我们也至少需要这个数量级的样本，否则的话很多联合概率分布的值就是0，产生了数据稀疏的问题。但是，如果假设这些随机变量都是相互独立的，那么我们就可以将联合概率`p(x1,x2,x3,x4,x5,x6)`转换为`p(x1)*p(x2)*p(x3)*p(x4)*p(x5)*p(x6)`。如此一来，我们只需要计算`p(x1)`到`p(x6)`就行了。

### 22丨朴素贝叶斯：如何让计算机学会自动分类？
#### 训练样本
贝叶斯分类需要的训练样本如下：
![20220531训练样本](/images/20220531训练样本.png)

#### 训练
贝叶斯定理的核心思想：**用先验概率和条件概率估计后验概率**。

具体到这里的分类问题，贝叶斯公式可以写成这样：

![20220531贝叶斯分类公式.png](/images/20220531贝叶斯分类公式.png)

其中`c`表示一个分类（class）, `f`表示属性对应的数据字段（field）。如此一来，等号左边的`P(c|f)`就是待分类样本中，出现属性值`f`时，样本属于类别`c`的概率。而等号右边的`P(f|c)`是根据训练数据统计，得到分类`c`中出现属性`f`的概率。`P(c)`是分类`c`在训练数据中出现的概率，`P(f)`是属性`f`在训练样本中出现的概率。

这里的贝叶斯公式只描述了单个属性值属于某个分类的概率，可是我们要分析的水果每个都有很多属性，**朴素贝叶斯**在这里就要发挥作用了。这是基于一个简单假设建立的一种贝叶斯方法，并**假定数据对象的不同属性对其归类影响时是相互独立的**。此时若数据对象`o`中同时出现属性`fi`与`fj`，则对象`o`属于类别`c`的概率就是这样：

![20220531朴素贝叶斯分类公式.png](/images/20220531朴素贝叶斯分类公式.png)

现在，我们应该已经可以用10个水果的数据，来建立朴素贝叶斯模型了。

比如，苹果的分类中共包含3个数据实例，对于形状而言，出现2次不规则圆、1次圆形和0次椭圆形，因此各自的统计概率为0.67、0.33和0.00。我们将这些值称为，给定一个水果分类时，出现某个属性值的**条件概率**。以此类推，所有的统计结果就是下面这个表格中这样：

![20220531贝叶斯训练样本条件概率.png](/images/20220531贝叶斯训练样本条件概率.png)

> 对于上表中出现的0.00概率，在做贝叶斯公式中的乘积计算时，会出现结果为0的情况，因此我们通常取一个比这个数据集里最小统计概率还要小的极小值，来代替“零概率”。比如，我们这里取0.01。在填充训练数据中从来没有出现过的属性值的时候，我们就会使用这种技巧，我们给这种技巧起个名字就叫作**平滑**（Smoothing）。

#### 预测
有了这些条件概率，以及各类水果和各个属性出现的先验概率，我们已经建立起了朴素贝叶斯模型。现在，我们就可以用它进行朴素贝叶斯分类了。

假设我们有一个新的水果，它的形状是圆形，口感是甜的，那么根据朴素贝叶斯，它属于苹果、甜橙和西瓜的概率分别是多少呢？

我们先来计算一下，它属于苹果的概率有多大:

![20220531贝叶斯分类预测苹果概率.png](/images/20220531贝叶斯分类预测苹果概率.png)

其中，`apple`表示分类为苹果，`shape-2`表示形状属性的值为`2`（也就是圆形），`taste-2`表示口感属性的值为`2`。以此类推，我们还可计算该水果属于甜橙和西瓜的概率:

![20220531贝叶斯分类预测橙子西瓜概率.png](/images/20220531贝叶斯分类预测橙子西瓜概率.png)

比较这三个数值，`0.00198<0.00798<0.26934`，所以计算机可以得出的结论，该水果属于甜橙的可能性是最大的，或者说，这个水果最有可能是甜橙。

> 这几个公式里的概率乘积通常都非常小，在物品的属性非常多的时候，这个乘积可能就小到计算机无法处理的地步。因此，在实际运用中，我们还会采用一些数学手法进行转换（比如取`log`将小数转换为绝对值大于`1`的负数），原理都是一样的。

#### 总结
总结一次朴素贝叶斯分类的主要步骤：

1. 准备数据：针对水果分类这个案例，我们收集了若干水果的实例，并从水果的常见属性入手，将其转化为计算机所能理解的数据。这种数据也被称为**训练样本**。
2. 建立模型：通过手头上水果的实例，我们让计算机统计每种水果、属性出现的先验概率，以及在某个水果分类下某种属性出现的条件概率。这个过程也被称为基于样本的**训练**。
3. 分类新数据：对于一颗新水果的属性数据，计算机根据已经建立的模型进行推导计算，得到该水果属于每个分类的概率，实现了分类的目的。这个过程也被称为**预测**。

### 23丨文本分类：如何区分特定类型的新闻？
运用朴素贝叶斯原理，根据词频特征，对文章进行分类。清晰明了，值得一看。

### 24丨语言模型：如何使用链式法则和马尔科夫假设简化概率模型？
#### 语言模型
这里说的语言模型指的是基于概率和统计的语言模型。
##### 链式法则

![20220531链式法则.png](/images/20220531链式法则.png)

##### 马尔可夫假设

理解了链式法则，我们再来看看马尔可夫假设。这个假设的内容是：任何一个词`wi`出现的概率只和它前面的1个或若干个词有关。基于这个假设，我们可以提出多元文法（Ngram）模型。Ngram中的`N`很重要，它表示任何一个词出现的概率，只和它前面的`N-1`个词有关。

以二元文法模型为例，按照刚才的说法，二元文法表示，某个单词出现的概率只和它前面的1个单词有关。也就是说，即使某个单词出现在一个很长的句子中，我们也只需要看前面那1个单词。用公式来表示出来就是这样：

![20220531二元文法模型.png](/images/20220531二元文法模型.png)

假设我们有一个统计样本文本`d`，`s`表示某个有意义的句子，由一连串按照特定顺序排列的词`w1，w2,…,wn`组成，这里`n`是句子里单词的数量。现在，我们想知道根据文档`d`的统计数据，`s`在文本中出现的可能性，即`P(s|d)`，那么我们可以把它表示为`P(s|d)=P(w1,w2,…,wn|d)`。假设我们这里考虑的都是在集合`d`的情况下发生的概率，所以可以忽略`d`，写为`P(s)=P(w1,w2,…,wn)`。

`P(w1,w2,…,wn)`可以通过上面说的链式法则计算，通过文档集合`C`，你可以知道`P(w1)`，`P(w2|w1)`这种概率。但是，这会带来两个问题：

1. 概率为0的问题
    `P(w1)`大小还好，`P(w2|w1)`会小一些，再往后看，`P(w3|w1,w2)`出现概率更低，`P(w4|w1,w2,w3)`出现的概率就更低了。一直到`P(wn|w1,w2,…,wn−1)`，基本上又为0了。我们可以使用上一节提到的平滑技巧，减少0概率的出现。不过，如果太多的概率都是通过平滑的方式而得到的，那么模型和真实的数据分布之间的差距就会加大，最终预测的效果也会很差，所以平滑也不是解决0概率的最终办法。
2. 存储空间的问题
    为了统计现有文档集合中`P(w1,w2,…,wn)`这类值，我们就需要生成很多的计数器。我们假设文档集合中有`m`个不同的单词，那么从中挑出`n`个单词的可重复排列，数量就是`m^n`。此外，还有`m^(n−1)`,`m^(n−2)`等等。这也意味着，如果要统计并存储的所有`P(w1,w2,…,wn)`或`P(wn|w1,w2,…,wn−1)`这类概率，就需要大量的内存和磁盘空间。当然，你可以做一些简化，不考虑单词出现的顺序，那么问题就变成了可重复组合，但是数量仍然非常巨大。

在这两个问题上，马尔科夫假设和多元文法模型就能帮上大忙了。如果我们使用三元文法模型，上述公式可以改写为：

![20220531三元文法模型.png](/images/20220531三元文法模型.png)

这样，系统的复杂度大致在`(C(m,1)+C(m,2)+C(m,3))`这个数量级，而且`P(wn|wn−2,wn−1)`为0的概率也会大大低于`P(wn|w1,w2,…,wn−1)`为0的概率。

#### 语言模型的应用
基于概率的语言模型，本身不是新兴的技术。它已经在机器翻译、语音识别和中文分词中得到了成功应用。近几年来，人们也开始在信息检索领域中尝试语言模型。下面我就来讲讲语言模型在信息检索和中文分词这两个方面里是如何发挥作用的。

##### 信息检索
信息检索很关心的一个问题就是相关性，也就是说，给定一个查询，哪篇文档是更相关的呢？一种常见的做法是计算`P(d|q)`，其中`q`表示一个查询，`d`表示一篇文档。`P(d|q)`表示用户输入查询`q`的情况下，文档`d`出现的概率是多少？如果这个概率越高，我们就认为`q`和`d`之间的相关性越高。

通过我们手头的文档集合，并不能直接获得`P(d|q)`。好在我们已经学习过了贝叶斯定理，通过这个定理，我们可以将`P(d|q)`重写如下：

![20220531信息检索贝叶斯公式.png](/images/20220531信息检索贝叶斯公式.png)

让`k1,k2,…,kn`表示查询`q`里包含的`n`个关键词，就可以根据链式法则求解出`P(q|d)`，我们也使用马尔科夫假设和多元文法来提高算法效率。

最终，当用户输入一个查询`q`之后，对于每一篇文档`d`，我们都能获得`P(d|q)`的值。根据每篇文档所获得的`P(d|q)`这个值，由高到低对所有的文档进行排序。这就是语言模型在信息检索中的常见用法。

##### 中文分词
和拉丁语系不同，中文存在分词的问题。比如原句是“兵乓球拍卖完了”，分词结果可能是：

```
1. 兵乓球|拍卖|完了
2. 兵乓|球拍|卖完|了
3. ...
```

上面分词的例子，从字面来看都是合理的，所以这种歧义无法通过这句话本身来解决。那么这种情况下，语言模型能为我们做什么呢？我们知道，语言模型是基于大量的语料来统计的，所以我们可以使用这个模型来估算，哪种情况更合理。

假设整个文档集合是`D`，要分词的句子是`s`，分词结果为`w1,…wn`，如果使用三元文法模型，

![20220531中文分词三元文法模型.png](/images/20220531中文分词三元文法模型.png)

> 请注意，在信息检索中，我们关心的是每篇文章产生一个句子（也就是查询）的概率，而这里可以是整个文档集合`D`产生一个句子的概率。

语言模型可以帮我们估计某种分词结果，在文档集合中出现的概率。由于不同的分词方法，会导致`w1`到`wn`的不同，因此就会产生不同的`P(s)`。接下来，我们只要取最大的`P(s)`，并假设这种分词方式是最合理的，就可以在一定程度上解决歧义。

回到“兵乓球拍卖完了”这句话，如果文档集合都是讲述的有关体育用品的销售，而不是拍卖行，那么“兵乓|球拍|卖完|了”这种分词的可能性应该更高。

### 25丨马尔科夫模型：从PageRank到语音识别，背后是什么模型在支撑？
#### 马尔可夫模型
在介绍语言模型的时候，我们提到了马尔科夫假设，这个假设是说，每个词出现的概率和之前的一个或若干个词有关。我们换个角度思考就是，**每个词按照一定的概率转移到下一个词**。

如果把词抽象为一个状态，那么我们就可以认为，状态到状态之间是有关联的。前一个状态有一定的概率可以转移到到下一个状态。如果多个状态之间的随机转移满足马尔科夫假设，那么这类随机过程就是一个马尔科夫随机过程。而刻画这类随机过程的统计模型，就是**马尔科夫模型**（Markov Model）。

前面讲多元文法的时候，我提到了二元文法、三元文法。对于二元文法来说，某个词出现的概率只和前一个词有关。对应的，在马尔科夫模型中，如果一个状态出现的概率只和前一个状态有关，那么我们称它为**一阶马尔科夫模型**或者**马尔科夫链**。对应于三元、四元甚至更多元的文法，我们也有二阶、三阶等马尔科夫模型。

##### PageRank和马尔可夫链
Google公司最引以为傲的PageRank链接分析算法，它的核心思想就是基于马尔科夫链。这个算法假设了一个“随机冲浪者”模型，冲浪者从某张网页出发，根据Web图中的链接关系随机访问。在每个步骤中，冲浪者都会从当前网页的链出网页中随机选取一张作为下一步访问的目标。在整个Web图中，绝大部分网页节点都会有链入和链出。那么冲浪者就可以永不停歇地冲浪，持续在图中走下去。我们可以假设每张网页就是一个状态，而网页之间的链接表明了状态转移的方向。这样，我们很自然地就可以使用马尔科夫链来刻画“随机冲浪者”。

> 1. PageRank值：在随机访问的过程中，越是被频繁访问的链接，越是重要。可以看出，每个节点的PageRank值取决于Web图的链接结构。**假如一个页面节点有很多的链入链接，或者是链入的网页有较高的被访问率，那么它也将会有更高的被访问概率**。
> 2. PageRank在标准的马尔科夫链上，引入了随机的跳转操作，也就是假设冲浪者不按照Web图的拓扑结构走下去，只是随机挑选了一张网页进行跳转。这样的处理是类比人们打开一张新网页的行为，也是符合实际情况的，避免了信息孤岛的形成。
#### 隐马尔可夫模型
马尔可夫模型都是假设每个状态对我们都是已知的，比如在概率语言模型中，一个状态对应了单词“上学”，另一个状态对应了单词“书包”。可是，有没有可能某些状态我们是未知的呢？

在某些现实的应用场景中，我们是无法确定马尔科夫过程中某个状态的取值的。这种情况下，最经典的案例就是**语音识别**。使用概率对语音进行识别的过程，和语言模型类似，因此我们可以把每个等待识别的词对应为马尔科夫过程中的一个状态。

计算机只知道某个词的发音，而不知道它具体怎么写，对于这种情况，我们就认为计算机只能观测到每个状态的部分信息，而另外一些信息被“隐藏”了起来。这个时候，我们就需要用隐马尔科夫模型来解决这种问题。隐马尔科夫模型有两层，一层是我们可以观测到的数据，称为“输出层”，另一层则是我们无法直接观测到的状态，称为“隐藏状态层”。如下图：

![20220531隐马尔可夫模型图.jpeg](/images/20220531隐马尔可夫模型图.jpeg)

那么在这个两层模型示例中，“隐藏状态层”(x1，x2，x3)产生“输出层”(y1，y2，y3)的概率是:

![20220531隐马尔可夫模型输出层概率.png](/images/20220531隐马尔可夫模型输出层概率.png)

语音识别要做的，就是遍历所有可能的状态层，找出最可能产生已知“输出层”的状态层，即为语音识别结果。

### 26丨信息熵：如何通过几个问题，测出你对应的武侠人物？
现在有个小游戏，“测测你是哪个武侠人物”：通过连续的几个问题，确定答题者是武侠人物中的哪一位？

那么，问卷设计者应该如何选择合适的题目，才能在读者回答尽量少的问题的同时，相对准确地测出自己对应于武侠中的哪个人物呢？为了实现这一目的，系统背后需要有这样的一张表格：

![20220531信息熵游戏表格.png](/images/20220531信息熵游戏表格.png)

在题目的设计上，我们可能要考虑下面两个问题：
1. 每个问题在人物划分上，是否有着不同的区分能力？
2. 题目的先后顺序会不会直接影响要回答问题的数量？

#### 问题的区分能力
每一个问题都会将被测试者划分为不同的人物分组。如果某个问题将属于不同人物分组的被测者，尽可能地划分到了相应的分组，那么我们认为这个问题的区分能力较强。相反，如果某个问题无法将属于不同人物分组的被测者划分开来，那么我们认为这个问题的区分能力较弱。

举个例子，我们先来比较一下“性别”和“智商”这两个属性。

首先，性别属性将武侠人物平均地划分为一半一半，也就是说“男”和“女”出现的先验概率是各 50%。如果我们假设被测试的人群，其男女性别的概率分布也是50%和50%，那么关于性别的测试题，就能将被测者的群体大致等分。

我们再来看智商属性。我们也将武侠人物划分为2个小集合，不过“智商高”的先验概率是 80%，而“智商中等”的先验概率只有 20%。同样，我们假设被测试的人群，其智商的概率分布也是类似地，那么经过关于智商的测试题之后，仍然有 80% 左右的不同人物还是属于同一个集合，并没有被区分开来。因此，我们可以认为关于“智商”的测试题，在对人物进行分组这个问题上，其能力要弱于“性别”的测试题。

这只是对区分能力的一个感性认识，如何对其进行量化呢？这就需要引入**信息量，信息熵，信息增益**等概念。

#### 信息量
任何能够减少不确定性的消息，都叫做信息。定性地看，事件的概率越小，不确定性越大，一旦发生带来的信息量也就越大。信息量公式如下：

![20220531信息量公式.svg](/images/20220531信息量公式.svg)

#### 信息熵
一个系统的信息熵是其各种状态的信息量的期望：

![20220531信息熵公示.svg](/images/20220531信息熵公示.svg)

这个公式和热力学的熵的本质一样，故也称为熵。从公式可知，当各个符号出现的几率相等，即“不确定性”最高时，信息熵最大。故信息可以视为“不确定性”、“不纯净度”或“选择的自由度”的度量。

从集合和分组的角度来说，如果一个集合里的元素趋向于落在同一分组里，那么告诉你某个元素属于哪个分组的信息量就越小，整个集合的熵也越小，换句话说，整个集合就越“纯净”。相反，如果一个集合里的元素趋向于分散在不同分组里，那么告诉你某个元素属于哪个分组的信息量就越大，整个集合的熵也越大，换句话说，整个集合就越“混乱”。


已经知道单个集合的熵是如何计算的了。那么，如果将一个集合划分成多个更小的集合之后，又该如何根据这些小集合，来计算整体的熵呢？之前我们提到了信息量和熵具有加和的性质，所以对于包含多个集合的更大集合，它的信息量期望值是可以通过每个小集合的信息量期望值来推算的。具体来说，我们可以使用如下公式：

![20220531集合划分信息熵公式.png](/images/20220531集合划分信息熵公式.png)

其中，`T`表示一种划分，`Pv`表示划分后其中某个小集合，`Entropy(Pv)`表示某个小集合的熵， 而`|Pv|/|P|`表示某个小集合出现的概率。

#### 信息增益
一个系统的信息增益是指，由于信息量大增加带来的其信息熵的减少:

![20220531信息增益公式.png](/images/20220531信息增益公式.png)

其中`T`表示当前选择的特征，`Entropy(P)`表示选择特征`T`之前的熵，`Entropy(Pv)`表示特征`T`取值为`v`分组的熵。减号后面的部分表示选择`T`做决策之后，各种取值子集合的熵的加权平均（期望）后整体的熵。

#### 再次回到“武侠人物分类”的小游戏
我们把这个信息增益的概念放到咱们的小游戏里就是，如果一个测试问题能够将来自不同分组的人物尽量的分开，也就是该划分对应的信息增益越高，那么我们就认为其区分能力越高，提供的信息含量也越多。

我们还是以“性别”和“智商”的两个测试题为例。

在提出任何问题之前，我们无法知道被测者属于哪位武侠人物，因此所有被测者属于同一个集合。假设被测者的概率分布和这10位武侠人物的先验概率分布相同，那么被测者集合的熵为3.32(`10*(-1 * 0.1 * log(0.1, 2))`)。

通过性别的测试问题对人物进行划分后，我们得到了两个更小的集合，每个小集合都包含5种不同的人物分组，因此每个小集合的熵是2.32(`(-1 * 5 * 0.2 * log(0.2, 2))`)，两个小集合的整体熵是2.32(`0.5 * 2.32 + 0.5 * 2.32`)。因此使用性格的测试题后，信息增益是1(`3.32 - 2.32`)。

而通过智商的测试问题对人物分组后，我们也得到了两个小集合，一个包含了8种人物，另一个包含了2种人物。包含8种人物的小集合其熵是3(`(-1* 8 * 0.125 * log(0.125, 2))`)，包含`2`种人物的小集合其熵是1(`(-1* 2 * 0.5 * log(0.5, 2))`)。两个小集合的整体熵是2.6(`0.8 * 3 + 0.2 * 1`)。因此使用智商的测试题后，信息增益是0.72(`3.32 - 2.6`)，低于基于性别的测试。所以，我们可以得出结论，有关性别的测试题比有关智商的测试题更具有区分能力。

### 27丨决策树：信息增益、增益比率和基尼指数的运用

#### 继续“武侠人物分类”游戏
还说上面的“武侠人物分类”游戏，被测者们每次回答一道问题，就会被细分到不同的集合，每个细分的集合纯净度就会提高，而熵就会下降。在测试结束的时候，如果所有被测者都被分配到了相应的武侠人物名下，那么每个人物分组都是最纯净的，熵值都为0。于是，测试问卷的过程就转化为“如何将熵从3.32下降到0”的过程。

首先计算各个特征的信息增益：

![20220531武侠人物游戏各个特征信息增益.png](/images/20220531武侠人物游戏各个特征信息增益.png)

按照信息增益从高到低的顺序选择特征问题：

![20220531武侠人物分类图.png](/images/20220531武侠人物分类图.png)

从这个图可以看出来，对于每种人物的判断，我们至多需要问3个问题，没有必要问全5个问题。比如，对于人物J和C，我们只需要问2个问题。假设读者属于10种武侠人物的概率是均等的，那么我们就可以利用之前介绍的知识，来计算读者需要回答的问题数量之期望值。每种人物出现的概率是0.1，8种人物需要问3个问题，2种人物需要问2个问题，那么回答问题数的期望值是2.8(`0.8 * 3 + 0.2 * 2`)。

如果我们每次不选熵值最高的问题，而选择熵值最低的问题，那么需要回答的问题的数量期望值为4到5之间。

#### 决策树
上述这个过程就体现了训练决策树（Decision Tree）的基本思想。决策树学习属于归纳推理算法之一，适用于分类问题。决定问卷题出现顺序的这个过程，其实就是建立决策树模型的过程，即**训练**过程。

整个构建出来的图就是一个树状结构，这也是“决策树”这个名字的由来。而根据用户对每个问题的答案，从决策树的根节点走到叶子节点，最后来判断其属于何种人物类型，这个过程就是分类新数据的过程，即**预测**过程。

> 有点需要注意的是，问卷案例中的每类武侠人物。都只有一个样本，而在泛化的机器学习问题中，每个类型对应了多个样本。也就是说，我们可以有很多个郭靖，而且每个人的属性并不完全一致，但是它们的分类都是“郭靖”。正是因为这个原因，决策树通常都只能把整体的熵降低到一个比较低的值，而无法完全降到0。这也意味着，训练得到的决策树模型，常常无法完全准确地划分训练样本，只能求到一个近似的解。

#### 几种常见的决策树算法
采用信息增益来构建决策树的算法被称为[ID3](https://zh.wikipedia.org/wiki/ID3%E7%AE%97%E6%B3%95)（Iterative Dichotomiser 3，迭代二叉树3代）。但是这个算法有一个缺点，它一般会优先考虑具有较多取值的特征，因为取值多的特征会有相对较大的信息增益。这是为什么呢？

仔细观察一下信息熵的定义，就能发现背后的原因。更多的取值会把数据样本划分为更多更小的分组，这样熵就会大幅降低，信息增益就会大幅上升。但是这样构建出来的树，很容易导致机器学习中的过拟合现象，不利于决策树对新数据的预测。为了克服这个问题，人们又提出了一个改进版，[C4.5算法](https://zh.wikipedia.org/wiki/C4.5%E7%AE%97%E6%B3%95)。

决策树也有不足。这类算法受训练样本的影响很大，比较容易过拟合。在预测阶段，如果新的数据和原来的训练样本差异较大，那么分类效果就会比较差。为此人们也提出了一些优化方案，比如剪枝和随机森林。

### 28丨熵、信息增益和卡方：如何寻找关键特征？
#### 通过信息增益进行特征选择
类似于决策树算法。
#### 通过卡方检验进行特征选择
在统计学中，我们使用卡方检验来检验两个变量是否相互独立。把它运用到特征选择，我们就可以检验特征与分类这两个变量是否独立。如果两者独立，证明特征和分类没有明显的相关性，特征对于分类来说没有提供足够的信息量。反之，如果两者有较强的相关性，那么特征对于分类来说就是有信息量的，是个好的特征。

为了检验独立性，卡方检验考虑了四种情况的概率：P(fi,cj)、P(fi¯,cj¯)、P(fi,cj¯)和P(fi¯,cj)。

在这四种概率中，P(fi,cj)和P(fi¯,cj¯)表示特征fi和分类cj是正相关的。如果P(fi,cj)很高，表示特征fi的出现意味着属于分类cj的概率更高；如果P(fi¯,cj¯)很高，表示特征fi不出现意味着不属于分类cj的概率更高。

类似地，P(fi,cj¯)和P(fi¯,cj)表示特征fi和分类cj是负相关的。如果P(fi,cj¯)很高，表示特征fi的出现意味着不属于分类cj的概率更高；如果P(fi¯,cj)很高，表示特征fi不出现意味着属于分类cj的概率更高。

如果特征和分类的相关性很高，要么是正向相关值远远大于负向相关值，要么是负向相关值远远大于正向相关值。如果特征和分类相关性很低，那么正向相关值和负向相关的值就会很接近。卡方检验就是利用了正向相关和负向相关的特性。

![20220531卡方检验进行特征选择.png](/images/20220531卡方检验进行特征选择.png)

其中，N表示数据的总个数。通过这个公式，你可以看到，如果一个特征和分类的相关性很高，无论是正向相关还是负向相关，那么正向相关和负向相关的差值就很大，最终计算的值就很高。最后，我们就可以按照卡方检验的值由高到低对特征进行排序，挑选出排列靠前的特征。
### 29丨归一化和标准化：各种特征如何综合才是最合理的？
第一点，为什么有时候需要转换特征值？因为不同类型的特征取值范围不同，分布也不同，相互之间没有可比性。因此在线性回归中，通过这些原始值分析得到的权重，并不能代表每个特征实际的重要性。

我们用Boston Housing 数据集对房价数据进行回归分析，这个数据来自 70 年代美国波斯顿周边地区的房价，是用于机器学习的经典数据集，你可以在[Kaggle的网站](https://www.kaggle.com/c/boston-housing#description)下载到它，并查看表格中各列的含义：

1. CRIM：per capita crime rate by town.
2. ZN：proportion of residential land zoned for lots over 25,000 sq.ft.
3. INDUS：proportion of non-retail business acres per town.
4. CHAS：Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).
5. NOX：nitrogen oxides concentration (parts per 10 million).
6. RM：average number of rooms per dwelling.
7. AGE：proportion of owner-occupied units built prior to 1940.
8. DIS：weighted mean of distances to five Boston employment centres.
9. RAD：index of accessibility to radial highways.
10. TAX：full-value property-tax rate per \$10,000.
11. PTRATIO：pupil-teacher ratio by town.
12. B：1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town.
13. LSTAT：lower status of the population (percent).
14. MEDV：median value of owner-occupied homes in \$1000s.

> Kaggle上面好像不能直接下载啦，可以点击[这里](/assets/resources/boston_house_price.csv)下载。

使用下面的python代码实现线性回归分析：

```python
import pandas as pd
from sklearn.linear_model import LinearRegression

df = pd.read_csv("demo/datasets/boston_house_price.csv")  # 读取 Boston Housing 中的 csv数据
df_features = df.drop(['MEDV'], axis=1)  # Dataframe 中除了最后一列，其余列都是特征，或者说自变量
df_targets = df['MEDV']  # Dataframe 最后一列是目标变量，或者说因变量
#
regression = LinearRegression().fit(df_features, df_targets)  # 使用特征和目标数据，拟合线性回归模型
print(regression.score(df_features, df_targets))  # 拟合程度的好坏
print(regression.coef_)  # 各个特征所对应的系
```

输出结果：
```
0.7406426641094095
[-1.08011358e-01  4.64204584e-02  2.05586264e-02  2.68673382e+00
 -1.77666112e+01  3.80986521e+00  6.92224640e-04 -1.47556685e+00
  3.06049479e-01 -1.23345939e-02 -9.52747232e-01  9.31168327e-03
 -5.24758378e-01]
```

因为不是所有的数据都是可以使用线性回归模型来表示，所以我们需要使用 regression.score 函数，来看拟合的程度。如果完美拟合，这个函数就会输出 1；如果拟合效果很差，这个函数的输出可能就是一个负数。

这里 regression.score 函数的输出大约为 0.74，接近于 1.0。它表示这个数据集使用线性模型拟合的效果还是不错的。

> 注意：下面是原文章中的解释，但是和我下载到的数据跑出的结果匹配不上，但是有关归一化和标准化的作用还是能够看出来的。
原文章中的输出：
```
0.735578647853312
[-4.54789253e-03 -5.17062363e-02  4.93344687e-02  5.34084254e-02
  3.78011391e+00 -1.54106687e+01  3.87910457e+00 -9.51042267e-03
 -1.60411361e+00  3.61780090e-01 -1.14966409e-02 -8.48538613e-01
  1.18853164e-02 -6.01842329e-01]
```

权重可以帮助我们解释哪个特征对最终房价的中位值有更大的影响。参看 csv 中的数据，你会发现最主要的两个正相关特征是 nox（系数为 3.78011391e+00）和 age（系数为 3.87910457e+00）。其中 nox 表示空气污染浓度，age 表示老房子占比，也就是说空气污染越多、房龄越高，房价中位数越高，这好像不太合乎常理。我们再来看看最主要的负相关特征 rm（系数为 -1.54106687e+01），也就是房间数量。房间数量越多，房价中位数越低，也不合理。

造成这些现象最重要的原因是，不同类型的特征值没有转换到同一个可比较的范围内，所以线性回归后所得到的系数不具有可比性，因此我们无法直接对这些权重加以解释。


#### 归一化（Normalization）
简单起见，这里的归一化是指使用特征取值范围中的最大值和最小值，把原始值转换为0到1之间的值。这样处理的好处在于简单易行，便于理解。不过，它的缺点也很明显，由于只考虑了最大最小值，因此很容易受到异常数据点的干扰。

```python
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import MinMaxScaler

minMaxScaler = MinMaxScaler()  # 基于 min 和 max 值的归一化

df = pd.read_csv("demo/datasets/boston_house_price.csv")  # 读取 Boston Housing 中的 csv的数据
df_normalized = minMaxScaler.fit_transform(df)  # 对原始数据进行归一化，包括特征值和目标变量
df_features_normalized = df_normalized[:, 0:-1]  # 获取归一化之后的特征值
df_targets_normalized = df_normalized[:, -1]  # 获取归一化之后的目标值

# 再次进行线性回归
regression_normalized = LinearRegression().fit(df_features_normalized, df_targets_normalized)
print(regression_normalized.score(df_features_normalized, df_targets_normalized))
print(regression_normalized.coef_)
```

输出：

```
0.7406426641094094
[-0.21355017  0.10315657  0.0124631   0.0597052  -0.1918794   0.4418597
  0.00149367 -0.36059247  0.15642529 -0.14362949 -0.19901831  0.08206283
 -0.42260541]
```

> 注意：下面是原文章中的解释，但是和我下载到的数据跑出的结果匹配不上，但是有关归一化和标准化的作用还是能够看出来的。
原文章中的输出：
```
0.7355786478533118
[-0.05103746 -0.08448544  0.10963215  0.03204506  0.08400253 -0.16643522
  0.4451488  -0.01986622 -0.34152292  0.18490982 -0.13361651 -0.16216516
  0.10390408 -0.48468369]
```

你可以看到，表示拟合程度的分数没有变，但是每个特征对应的系数或者说权重，发生了比较大的变化。仔细观察一下，你会发现，这次最主要的正相关特征是 age（0.4451488）和 tax（0.18490982），也就是老房子占比和房产税的税率，其中至少房产税的税率是比较合理的，因为高房价的地区普遍税率也比较高。而最主要的负相关特征是 rad（-0.34152292）和 lstat（-0.48468369），rad 表示高速交通的便利程度，它的值越大表示离高速越远，房价中位数越低。而 lstat 表示低收入人群的占比，这个值越大房价中位数越低，这两点都是合理的。

#### 标准化（Standardizaiton）
另一种常见的方法是基于正态分布的 z 分数（z-score）标准化（Standardization）。该方法假设数据呈现标准正态分布。

经过标准化处理之后，每种特征的取值都会变成一个标准正态分布，以0为均值，1为标准差。和归一化相比，标准化使用了数据是正态分布的假设，不容易受到过大或过小值的干扰。

```python
standardScaler = StandardScaler()  # 基于 Z 分数的标准化

df = pd.read_csv("demo/datasets/boston_house_price.csv")  # 读取 Boston Housing 中的 csv的数据
print(df)
standardScaler.fit(df)
df_standardized = standardScaler.transform(df)  # 对原始数据进行标准化，包括特征值和目标变量
print(df_standardized)

df_features_standardized = df_standardized[:, 0:-1]  # 获取标准化之后的特征值
df_targets_standardized = df_standardized[:, -1]  # 获取标准化之后的特征值

# 再次进行线性回归
regression_standardized = LinearRegression().fit(df_features_standardized, df_targets_standardized)
print(regression_standardized.score(df_features_standardized, df_targets_standardized))
print(regression_standardized.coef_)
```

输出：

```
0.7406426641094093
[-0.10101708  0.1177152   0.0153352   0.07419883 -0.22384803  0.29105647
  0.00211864 -0.33783635  0.28974905 -0.22603168 -0.22427123  0.09243223
 -0.40744693]
```

> 注意：下面是原文章中的解释，但是和我下载到的数据跑出的结果匹配不上，但是有关归一化和标准化的作用还是能够看出来的。
原文章中的输出：
```
0.7355786478533118
[-0.07330367 -0.04144107  0.12194378  0.04074345  0.09805446 -0.19311408
  0.29767387 -0.02916672 -0.34642803  0.34477088 -0.21410757 -0.19904179
  0.11218058 -0.46369483]
```

表示拟合程度的分数任然没有变。再次对比不同特征所对应的系数，你会发现这次最主要的正相关特征还是 age（0.29767387）和 tax（0.34477088），但是相比之前，明显房产税的税率占了更高的权重，更加合理。而最主要的负相关特征还是 rad（-0.34152292）和 lstat（-0.48468369），这两点都是合理的。

### 30丨统计意义（上）：如何通过显著性检验，判断你的A-B测试结果是不是巧合？
### 31丨统计意义（下）：如何通过显著性检验，判断你的A-B测试结果是不是巧合？
### 32丨概率统计篇答疑和总结为什么会有欠拟合和过拟合？
## 05-线性代数篇 (13讲)
### 33丨线性代数：线性代数到底都讲了些什么？
### 34丨向量空间模型：如何让计算机理解现实事物之间的关系？
### 35丨文本检索：如何让计算机处理自然语言？
### 36丨文本聚类：如何过滤冗余的新闻？
### 37丨矩阵（上）：如何使用矩阵操作进行PageRank计算？
### 38丨矩阵（下）：如何使用矩阵操作进行协同过滤推荐？
### 39丨线性回归（上）：如何使用高斯消元求解线性方程组？
### 40丨线性回归（中）：如何使用最小二乘法进行直线拟合？
### 41丨线性回归（下）：如何使用最小二乘法进行效果验证？
### 42丨PCA主成分分析（上）：如何利用协方差矩阵来降维？
### 43丨PCA主成分分析（下）：为什么要计算协方差矩阵的特征值和特征向量？
### 44丨奇异值分解：如何挖掘潜在的语义关系？
### 45丨线性代数篇答疑和总结：矩阵乘法的几何意义是什么？
## 06-综合应用篇 (6讲)
### 46丨缓存系统：如何通过哈希表和队列实现高效访问？
### 47丨搜索引擎（上）：如何通过倒排索引和向量空间模型，打造一个简单的搜索引擎？
### 48丨搜索引擎（下）：如何通过查询的分类，让电商平台的搜索结果更相关？
### 49丨推荐系统（上）：如何实现基于相似度的协同过滤？
### 50丨推荐系统（下）：如何通过SVD分析用户和物品的矩阵？
### 51丨综合应用篇答疑和总结：如何进行个性化用户画像的设计？
## 07-加餐 (3讲)
### 数学专栏课外加餐（一）丨我们为什么需要反码和补码？
### 数学专栏课外加餐（三）：程序员需要读哪些数学书？
### 数学专栏课外加餐（二）丨位操作的三个应用实例
## 08-结束语 (1讲)
### 结束语丨从数学到编程，本身就是一个很长的链条

